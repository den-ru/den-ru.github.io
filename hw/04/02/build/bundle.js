/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = __webpack_require__(16);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/MWEyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcz83YmFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar contentBlocks = exports.contentBlocks = ['operations', 'add', 'chart'];\n\nvar operationDirection = exports.operationDirection = {\n    'incomes': 'Пополнение',\n    'expenses': 'Списание'\n};\n\nvar sortVariants = exports.sortVariants = {\n    'date-desc': 'По дате сначала новые',\n    'date-asc': 'По дате сначала старые',\n    'summ-desc': 'По сумме по убыванию',\n    'summ-asc': 'По сумме по возростанию'\n};\n\nvar expensesTypes = exports.expensesTypes = {\n    'food': 'еда',\n    'fun': 'развлечения',\n    'shop': 'покупки',\n    'other': 'другое'\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9VdGlscy5qcz85NTliIl0sIm5hbWVzIjpbImNvbnRlbnRCbG9ja3MiLCJvcGVyYXRpb25EaXJlY3Rpb24iLCJzb3J0VmFyaWFudHMiLCJleHBlbnNlc1R5cGVzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUNPLElBQU1BLHdDQUFnQixDQUFDLFlBQUQsRUFBZSxLQUFmLEVBQXNCLE9BQXRCLENBQXRCOztBQUVBLElBQU1DLGtEQUFxQjtBQUM5QixlQUFXLFlBRG1CO0FBRTlCLGdCQUFZO0FBRmtCLENBQTNCOztBQUtBLElBQU1DLHNDQUFlO0FBQ3hCLGlCQUFhLHVCQURXO0FBRXhCLGdCQUFZLHdCQUZZO0FBR3hCLGlCQUFhLHNCQUhXO0FBSXhCLGdCQUFZO0FBSlksQ0FBckI7O0FBT0EsSUFBTUMsd0NBQWdCO0FBQ3pCLFlBQVEsS0FEaUI7QUFFekIsV0FBTyxhQUZrQjtBQUd6QixZQUFRLFNBSGlCO0FBSXpCLGFBQVM7QUFKZ0IsQ0FBdEIiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGNvbnN0IGNvbnRlbnRCbG9ja3MgPSBbJ29wZXJhdGlvbnMnLCAnYWRkJywgJ2NoYXJ0J107XG5cbmV4cG9ydCBjb25zdCBvcGVyYXRpb25EaXJlY3Rpb24gPSB7XG4gICAgJ2luY29tZXMnOiAn0J/QvtC/0L7Qu9C90LXQvdC40LUnLFxuICAgICdleHBlbnNlcyc6ICfQodC/0LjRgdCw0L3QuNC1Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBzb3J0VmFyaWFudHMgPSB7XG4gICAgJ2RhdGUtZGVzYyc6ICfQn9C+INC00LDRgtC1INGB0L3QsNGH0LDQu9CwINC90L7QstGL0LUnLFxuICAgICdkYXRlLWFzYyc6ICfQn9C+INC00LDRgtC1INGB0L3QsNGH0LDQu9CwINGB0YLQsNGA0YvQtScsXG4gICAgJ3N1bW0tZGVzYyc6ICfQn9C+INGB0YPQvNC80LUg0L/QviDRg9Cx0YvQstCw0L3QuNGOJyxcbiAgICAnc3VtbS1hc2MnOiAn0J/QviDRgdGD0LzQvNC1INC/0L4g0LLQvtC30YDQvtGB0YLQsNC90LjRjidcbn07XG5cbmV4cG9ydCBjb25zdCBleHBlbnNlc1R5cGVzID0ge1xuICAgICdmb29kJzogJ9C10LTQsCcsXG4gICAgJ2Z1bic6ICfRgNCw0LfQstC70LXRh9C10L3QuNGPJyxcbiAgICAnc2hvcCc6ICfQv9C+0LrRg9C/0LrQuCcsXG4gICAgJ290aGVyJzogJ9C00YDRg9Cz0L7QtSdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9VdGlscy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(1);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcz82MzI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzPzczMTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8wNDQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  var invariant = __webpack_require__(4);\n  var warning = __webpack_require__(3);\n  var ReactPropTypesSecret = __webpack_require__(8);\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz8yMWVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (true) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanM/NGM5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/ODJkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanM/NzMzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(11);\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(17);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _MoneyPalApp = __webpack_require__(34);\n\nvar _MoneyPalApp2 = _interopRequireDefault(_MoneyPalApp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_reactDom2.default.render(_react2.default.createElement(_MoneyPalApp2.default, null), document.getElementById('root'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbInJlbmRlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFFQSxtQkFBU0EsTUFBVCxDQUNJLDBEQURKLEVBRUlDLFNBQVNDLGNBQVQsQ0FBd0IsTUFBeEIsQ0FGSiIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxuaW1wb3J0IE1vbmV5UGFsQXBwIGZyb20gJy4vY29tcG9uZW50cy9Nb25leVBhbEFwcC5qc3gnO1xyXG5cclxuUmVhY3RET00ucmVuZGVyKFxyXG4gICAgPE1vbmV5UGFsQXBwIC8+LFxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKVxyXG4pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(12);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {\"hmr\":true}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(14)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./styles.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./styles.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLnNjc3M/NWNlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZXMuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZXMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZXMuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3R5bGVzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(13)(undefined);\n// imports\nexports.push([module.i, \"@import url(https://fonts.googleapis.com/css?family=Galada);\", \"\"]);\n\n// module\nexports.push([module.i, \".app {\\n  margin-top: 20px; }\\n  .app .material-icons {\\n    font-size: 36px; }\\n    .app .material-icons:hover {\\n      cursor: pointer;\\n      color: magenta; }\\n  .app .app__header {\\n    font-family: 'Galada', cursive;\\n    font-size: 30px;\\n    text-align: center;\\n    font-weight: 500;\\n    color: black;\\n    text-shadow: 0px 2px 3px rgba(255, 255, 255, 0.5);\\n    margin: 5px 0 0; }\\n  .app .app_amount {\\n    height: 57px; }\\n    .app .app_amount .amount-container {\\n      height: 40px;\\n      line-height: 47px; }\\n      .app .app_amount .amount-container .amount {\\n        font-family: 'Galada';\\n        font-size: 26px; }\\n  .app .app_operationListMenu {\\n    overflow: hidden;\\n    margin-bottom: 10px; }\\n    .app .app_operationListMenu .material-icons {\\n      margin-left: 15px; }\\n  .app .app_add_operation .summ {\\n    text-align: right; }\\n  .app .app_operation {\\n    text-align: left;\\n    font-size: 20px;\\n    position: relative; }\\n    .app .app_operation .summ {\\n      margin-right: 15px; }\\n    .app .app_operation.operation-expenses .summ {\\n      color: crimson; }\\n    .app .app_operation.operation-incomes .summ {\\n      color: darkgreen; }\\n    .app .app_operation .material-icons {\\n      font-size: 20px;\\n      position: relative;\\n      top: 3px; }\\n    .app .app_operation .operation-footer {\\n      font-size: 12px;\\n      color: #888; }\\n    .app .app_operation .close {\\n      position: absolute;\\n      top: 13px;\\n      right: 5px; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLnNjc3M/MTdlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EscUZBQXNGOztBQUV0RjtBQUNBLCtCQUFnQyxxQkFBcUIsRUFBRSwwQkFBMEIsc0JBQXNCLEVBQUUsa0NBQWtDLHdCQUF3Qix1QkFBdUIsRUFBRSx1QkFBdUIscUNBQXFDLHNCQUFzQix5QkFBeUIsdUJBQXVCLG1CQUFtQix3REFBd0Qsc0JBQXNCLEVBQUUsc0JBQXNCLG1CQUFtQixFQUFFLDBDQUEwQyxxQkFBcUIsMEJBQTBCLEVBQUUsb0RBQW9ELGdDQUFnQywwQkFBMEIsRUFBRSxpQ0FBaUMsdUJBQXVCLDBCQUEwQixFQUFFLG1EQUFtRCwwQkFBMEIsRUFBRSxtQ0FBbUMsd0JBQXdCLEVBQUUseUJBQXlCLHVCQUF1QixzQkFBc0IseUJBQXlCLEVBQUUsaUNBQWlDLDJCQUEyQixFQUFFLG9EQUFvRCx1QkFBdUIsRUFBRSxtREFBbUQseUJBQXlCLEVBQUUsMkNBQTJDLHdCQUF3QiwyQkFBMkIsaUJBQWlCLEVBQUUsNkNBQTZDLHdCQUF3QixvQkFBb0IsRUFBRSxrQ0FBa0MsMkJBQTJCLGtCQUFrQixtQkFBbUIsRUFBRTs7QUFFaitDIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PUdhbGFkYSk7XCIsIFwiXCJdKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYXBwIHtcXG4gIG1hcmdpbi10b3A6IDIwcHg7IH1cXG4gIC5hcHAgLm1hdGVyaWFsLWljb25zIHtcXG4gICAgZm9udC1zaXplOiAzNnB4OyB9XFxuICAgIC5hcHAgLm1hdGVyaWFsLWljb25zOmhvdmVyIHtcXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgY29sb3I6IG1hZ2VudGE7IH1cXG4gIC5hcHAgLmFwcF9faGVhZGVyIHtcXG4gICAgZm9udC1mYW1pbHk6ICdHYWxhZGEnLCBjdXJzaXZlO1xcbiAgICBmb250LXNpemU6IDMwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IGJsYWNrO1xcbiAgICB0ZXh0LXNoYWRvdzogMHB4IDJweCAzcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbiAgICBtYXJnaW46IDVweCAwIDA7IH1cXG4gIC5hcHAgLmFwcF9hbW91bnQge1xcbiAgICBoZWlnaHQ6IDU3cHg7IH1cXG4gICAgLmFwcCAuYXBwX2Ftb3VudCAuYW1vdW50LWNvbnRhaW5lciB7XFxuICAgICAgaGVpZ2h0OiA0MHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiA0N3B4OyB9XFxuICAgICAgLmFwcCAuYXBwX2Ftb3VudCAuYW1vdW50LWNvbnRhaW5lciAuYW1vdW50IHtcXG4gICAgICAgIGZvbnQtZmFtaWx5OiAnR2FsYWRhJztcXG4gICAgICAgIGZvbnQtc2l6ZTogMjZweDsgfVxcbiAgLmFwcCAuYXBwX29wZXJhdGlvbkxpc3RNZW51IHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTBweDsgfVxcbiAgICAuYXBwIC5hcHBfb3BlcmF0aW9uTGlzdE1lbnUgLm1hdGVyaWFsLWljb25zIHtcXG4gICAgICBtYXJnaW4tbGVmdDogMTVweDsgfVxcbiAgLmFwcCAuYXBwX2FkZF9vcGVyYXRpb24gLnN1bW0ge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgfVxcbiAgLmFwcCAuYXBwX29wZXJhdGlvbiB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAgIC5hcHAgLmFwcF9vcGVyYXRpb24gLnN1bW0ge1xcbiAgICAgIG1hcmdpbi1yaWdodDogMTVweDsgfVxcbiAgICAuYXBwIC5hcHBfb3BlcmF0aW9uLm9wZXJhdGlvbi1leHBlbnNlcyAuc3VtbSB7XFxuICAgICAgY29sb3I6IGNyaW1zb247IH1cXG4gICAgLmFwcCAuYXBwX29wZXJhdGlvbi5vcGVyYXRpb24taW5jb21lcyAuc3VtbSB7XFxuICAgICAgY29sb3I6IGRhcmtncmVlbjsgfVxcbiAgICAuYXBwIC5hcHBfb3BlcmF0aW9uIC5tYXRlcmlhbC1pY29ucyB7XFxuICAgICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICB0b3A6IDNweDsgfVxcbiAgICAuYXBwIC5hcHBfb3BlcmF0aW9uIC5vcGVyYXRpb24tZm9vdGVyIHtcXG4gICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgY29sb3I6ICM4ODg7IH1cXG4gICAgLmFwcCAuYXBwX29wZXJhdGlvbiAuY2xvc2Uge1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICB0b3A6IDEzcHg7XFxuICAgICAgcmlnaHQ6IDVweDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3NyYy9zdHlsZXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tvar styleTarget = fn.call(this, selector);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[selector] = styleTarget;\n\t\t}\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(15);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/MzEzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAoc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzk4OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.0.0\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n(function() {\n\n'use strict';\n\nvar objectAssign$1 = __webpack_require__(5);\nvar require$$0 = __webpack_require__(3);\nvar emptyObject = __webpack_require__(7);\nvar invariant = __webpack_require__(4);\nvar emptyFunction = __webpack_require__(1);\nvar checkPropTypes = __webpack_require__(6);\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule reactProdInvariant\n * \n */\n\n{\n  var warning = require$$0;\n}\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var constructor = publicInstance.constructor;\n    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\\n\\nPlease check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass');\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar ReactNoopUpdateQueue_1 = ReactNoopUpdateQueue;\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule lowPriorityWarning\n */\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning_1 = lowPriorityWarning;\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction ReactComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue_1;\n}\n\nReactComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nReactComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nReactComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(ReactComponent.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning_1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction ReactPureComponent(props, context, updater) {\n  // Duplicated from ReactComponent.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue_1;\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = ReactComponent.prototype;\nvar pureComponentPrototype = ReactPureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = ReactPureComponent;\n// Avoid an extra prototype jump for these methods.\nobjectAssign$1(pureComponentPrototype, ReactComponent.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\nfunction ReactAsyncComponent(props, context, updater) {\n  // Duplicated from ReactComponent.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue_1;\n}\n\nvar asyncComponentPrototype = ReactAsyncComponent.prototype = new ComponentDummy();\nasyncComponentPrototype.constructor = ReactAsyncComponent;\n// Avoid an extra prototype jump for these methods.\nobjectAssign$1(asyncComponentPrototype, ReactComponent.prototype);\nasyncComponentPrototype.unstable_isAsyncReactComponent = true;\nasyncComponentPrototype.render = function () {\n  return this.props.children;\n};\n\nvar ReactBaseClasses = {\n  Component: ReactComponent,\n  PureComponent: ReactPureComponent,\n  AsyncComponent: ReactAsyncComponent\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactCurrentOwner\n * \n */\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar ReactCurrentOwner_1 = ReactCurrentOwner;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n{\n  var warning$2 = require$$0;\n}\n\n// The Symbol used to tag the ReactElement type. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warning$2(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warning$2(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allow us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE$1,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://facebook.github.io/react/docs/react-api.html#createelement\n */\nReactElement.createElement = function (type, config, children) {\n  var propName;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE$1) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner_1.current, props);\n};\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://facebook.github.io/react/docs/react-api.html#createfactory\n */\nReactElement.createFactory = function (type) {\n  var factory = ReactElement.createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook TODO: Warn if this is accessed\n  factory.type = type;\n  return factory;\n};\n\nReactElement.cloneAndReplaceKey = function (oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n};\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://facebook.github.io/react/docs/react-api.html#cloneelement\n */\nReactElement.cloneElement = function (element, config, children) {\n  var propName;\n\n  // Original props are copied\n  var props = objectAssign$1({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner_1.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n};\n\n/**\n * Verifies the object is a ReactElement.\n * See https://facebook.github.io/react/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nReactElement.isValidElement = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE$1;\n};\n\nvar ReactElement_1 = ReactElement;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactDebugCurrentFrame\n * \n */\n\nvar ReactDebugCurrentFrame = {};\n\n{\n  // Component that is being worked on\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      return impl();\n    }\n    return null;\n  };\n}\n\nvar ReactDebugCurrentFrame_1 = ReactDebugCurrentFrame;\n\n{\n  var warning$1 = require$$0;\n\n  var _require = ReactDebugCurrentFrame_1,\n      getStackAddendum = _require.getStackAddendum;\n}\n\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n// The Symbol used to tag the ReactElement type. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null || type === 'string' || type === 'number' ||\n  // The following is inlined from ReactElement. This means we can optimize\n  // some checks. React Fiber also inlines this logic for similar purposes.\n  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          warning$1(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getStackAddendum());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://facebook.github.io/react/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (ReactElement_1.isValidElement(mappedChild)) {\n      mappedChild = ReactElement_1.cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://facebook.github.io/react/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://facebook.github.io/react/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://facebook.github.io/react/docs/react-api.html#react.children.toarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\nvar ReactChildren = {\n  forEach: forEachChildren,\n  map: mapChildren,\n  count: countChildren,\n  toArray: toArray\n};\n\nvar ReactChildren_1 = ReactChildren;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactVersion\n */\n\nvar ReactVersion = '16.0.0';\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://facebook.github.io/react/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !ReactElement_1.isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nvar onlyChild_1 = onlyChild;\n\n/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @providesModule describeComponentFrame\n */\n\nvar describeComponentFrame$1 = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule getComponentName\n * \n */\n\nfunction getComponentName$1(instanceOrFiber) {\n  if (typeof instanceOrFiber.getName === 'function') {\n    // Stack reconciler\n    var instance = instanceOrFiber;\n    return instance.getName();\n  }\n  if (typeof instanceOrFiber.tag === 'number') {\n    // Fiber reconciler\n    var fiber = instanceOrFiber;\n    var type = fiber.type;\n\n    if (typeof type === 'string') {\n      return type;\n    }\n    if (typeof type === 'function') {\n      return type.displayName || type.name;\n    }\n  }\n  return null;\n}\n\nvar getComponentName_1 = getComponentName$1;\n\n{\n  var checkPropTypes$1 = checkPropTypes;\n  var lowPriorityWarning$1 = lowPriorityWarning_1;\n  var ReactDebugCurrentFrame$1 = ReactDebugCurrentFrame_1;\n  var warning$3 = require$$0;\n  var describeComponentFrame = describeComponentFrame$1;\n  var getComponentName = getComponentName_1;\n\n  var currentlyValidatingElement = null;\n\n  var getDisplayName = function (element) {\n    if (element == null) {\n      return '#empty';\n    } else if (typeof element === 'string' || typeof element === 'number') {\n      return '#text';\n    } else if (typeof element.type === 'string') {\n      return element.type;\n    } else {\n      return element.type.displayName || element.type.name || 'Unknown';\n    }\n  };\n\n  var getStackAddendum$1 = function () {\n    var stack = '';\n    if (currentlyValidatingElement) {\n      var name = getDisplayName(currentlyValidatingElement);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n    }\n    stack += ReactDebugCurrentFrame$1.getStackAddendum() || '';\n    return stack;\n  };\n}\n\nvar ITERATOR_SYMBOL$1 = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL$1 = '@@iterator'; // Before Symbol spec.\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner_1.current) {\n    var name = getComponentName(ReactCurrentOwner_1.current);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner_1.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n  }\n\n  currentlyValidatingElement = element;\n  {\n    warning$3(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum$1());\n  }\n  currentlyValidatingElement = null;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (ReactElement_1.isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (ReactElement_1.isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = ITERATOR_SYMBOL$1 && node[ITERATOR_SYMBOL$1] || node[FAUX_ITERATOR_SYMBOL$1];\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (ReactElement_1.isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var componentClass = element.type;\n  if (typeof componentClass !== 'function') {\n    return;\n  }\n  var name = componentClass.displayName || componentClass.name;\n  var propTypes = componentClass.propTypes;\n\n  if (propTypes) {\n    currentlyValidatingElement = element;\n    checkPropTypes$1(propTypes, element.props, 'prop', name, getStackAddendum$1);\n    currentlyValidatingElement = null;\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    warning$3(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n  }\n}\n\nvar ReactElementValidator$1 = {\n  createElement: function (type, props, children) {\n    var validType = typeof type === 'string' || typeof type === 'function';\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    if (!validType) {\n      var info = '';\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(props);\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      info += ReactDebugCurrentFrame$1.getStackAddendum() || '';\n\n      warning$3(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);\n    }\n\n    var element = ReactElement_1.createElement.apply(this, arguments);\n\n    // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n    if (element == null) {\n      return element;\n    }\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n    if (validType) {\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], type);\n      }\n    }\n\n    validatePropTypes(element);\n\n    return element;\n  },\n\n  createFactory: function (type) {\n    var validatedFactory = ReactElementValidator$1.createElement.bind(null, type);\n    // Legacy hook TODO: Warn if this is accessed\n    validatedFactory.type = type;\n\n    {\n      Object.defineProperty(validatedFactory, 'type', {\n        enumerable: false,\n        get: function () {\n          lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n          Object.defineProperty(this, 'type', {\n            value: type\n          });\n          return type;\n        }\n      });\n    }\n\n    return validatedFactory;\n  },\n\n  cloneElement: function (element, props, children) {\n    var newElement = ReactElement_1.cloneElement.apply(this, arguments);\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], newElement.type);\n    }\n    validatePropTypes(newElement);\n    return newElement;\n  }\n};\n\nvar ReactElementValidator_1 = ReactElementValidator$1;\n\n{\n  var warning$4 = require$$0;\n}\n\nfunction isNative(fn) {\n  // Based on isNative() from Lodash\n  var funcToString = Function.prototype.toString;\n  var reIsNative = RegExp('^' + funcToString\n  // Take an example native function source for comparison\n  .call(Object.prototype.hasOwnProperty)\n  // Strip regex characters so we can use it for regex\n  .replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  // Remove hasOwnProperty from the template to make it generic\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  try {\n    var source = funcToString.call(fn);\n    return reIsNative.test(source);\n  } catch (err) {\n    return false;\n  }\n}\n\nvar canUseCollections =\n// Array.from\ntypeof Array.from === 'function' &&\n// Map\ntypeof Map === 'function' && isNative(Map) &&\n// Map.prototype.keys\nMap.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&\n// Set\ntypeof Set === 'function' && isNative(Set) &&\n// Set.prototype.keys\nSet.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);\n\nvar setItem;\nvar getItem;\nvar removeItem;\nvar getItemIDs;\nvar addRoot;\nvar removeRoot;\nvar getRootIDs;\n\nif (canUseCollections) {\n  var itemMap = new Map();\n  var rootIDSet = new Set();\n\n  setItem = function (id, item) {\n    itemMap.set(id, item);\n  };\n  getItem = function (id) {\n    return itemMap.get(id);\n  };\n  removeItem = function (id) {\n    itemMap['delete'](id);\n  };\n  getItemIDs = function () {\n    return Array.from(itemMap.keys());\n  };\n\n  addRoot = function (id) {\n    rootIDSet.add(id);\n  };\n  removeRoot = function (id) {\n    rootIDSet['delete'](id);\n  };\n  getRootIDs = function () {\n    return Array.from(rootIDSet.keys());\n  };\n} else {\n  var itemByKey = {};\n  var rootByKey = {};\n\n  // Use non-numeric keys to prevent V8 performance issues:\n  // https://github.com/facebook/react/pull/7232\n  var getKeyFromID = function (id) {\n    return '.' + id;\n  };\n  var getIDFromKey = function (key) {\n    return parseInt(key.substr(1), 10);\n  };\n\n  setItem = function (id, item) {\n    var key = getKeyFromID(id);\n    itemByKey[key] = item;\n  };\n  getItem = function (id) {\n    var key = getKeyFromID(id);\n    return itemByKey[key];\n  };\n  removeItem = function (id) {\n    var key = getKeyFromID(id);\n    delete itemByKey[key];\n  };\n  getItemIDs = function () {\n    return Object.keys(itemByKey).map(getIDFromKey);\n  };\n\n  addRoot = function (id) {\n    var key = getKeyFromID(id);\n    rootByKey[key] = true;\n  };\n  removeRoot = function (id) {\n    var key = getKeyFromID(id);\n    delete rootByKey[key];\n  };\n  getRootIDs = function () {\n    return Object.keys(rootByKey).map(getIDFromKey);\n  };\n}\n\nvar unmountedIDs = [];\n\nfunction purgeDeep(id) {\n  var item = getItem(id);\n  if (item) {\n    var childIDs = item.childIDs;\n\n    removeItem(id);\n    childIDs.forEach(purgeDeep);\n  }\n}\n\nfunction getDisplayName$1(element) {\n  if (element == null) {\n    return '#empty';\n  } else if (typeof element === 'string' || typeof element === 'number') {\n    return '#text';\n  } else if (typeof element.type === 'string') {\n    return element.type;\n  } else {\n    return element.type.displayName || element.type.name || 'Unknown';\n  }\n}\n\nfunction describeID(id) {\n  var name = ReactComponentTreeHook.getDisplayName(id);\n  var element = ReactComponentTreeHook.getElement(id);\n  var ownerID = ReactComponentTreeHook.getOwnerID(id);\n  var ownerName = void 0;\n\n  if (ownerID) {\n    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);\n  }\n  warning$4(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id);\n  return describeComponentFrame$1(name || '', element && element._source, ownerName || '');\n}\n\nvar ReactComponentTreeHook = {\n  onSetChildren: function (id, nextChildIDs) {\n    var item = getItem(id);\n    !item ? invariant(false, 'Item must have been set') : void 0;\n    item.childIDs = nextChildIDs;\n\n    for (var i = 0; i < nextChildIDs.length; i++) {\n      var nextChildID = nextChildIDs[i];\n      var nextChild = getItem(nextChildID);\n      !nextChild ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : void 0;\n      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : void 0;\n      !nextChild.isMounted ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : void 0;\n      if (nextChild.parentID == null) {\n        nextChild.parentID = id;\n        // TODO: This shouldn't be necessary but mounting a new root during in\n        // componentWillMount currently causes not-yet-mounted components to\n        // be purged from our tree data so their parent id is missing.\n      }\n      !(nextChild.parentID === id) ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : void 0;\n    }\n  },\n  onBeforeMountComponent: function (id, element, parentID) {\n    var item = {\n      element: element,\n      parentID: parentID,\n      text: null,\n      childIDs: [],\n      isMounted: false,\n      updateCount: 0\n    };\n    setItem(id, item);\n  },\n  onBeforeUpdateComponent: function (id, element) {\n    var item = getItem(id);\n    if (!item || !item.isMounted) {\n      // We may end up here as a result of setState() in componentWillUnmount().\n      // In this case, ignore the element.\n      return;\n    }\n    item.element = element;\n  },\n  onMountComponent: function (id) {\n    var item = getItem(id);\n    !item ? invariant(false, 'Item must have been set') : void 0;\n    item.isMounted = true;\n    var isRoot = item.parentID === 0;\n    if (isRoot) {\n      addRoot(id);\n    }\n  },\n  onUpdateComponent: function (id) {\n    var item = getItem(id);\n    if (!item || !item.isMounted) {\n      // We may end up here as a result of setState() in componentWillUnmount().\n      // In this case, ignore the element.\n      return;\n    }\n    item.updateCount++;\n  },\n  onUnmountComponent: function (id) {\n    var item = getItem(id);\n    if (item) {\n      // We need to check if it exists.\n      // `item` might not exist if it is inside an error boundary, and a sibling\n      // error boundary child threw while mounting. Then this instance never\n      // got a chance to mount, but it still gets an unmounting event during\n      // the error boundary cleanup.\n      item.isMounted = false;\n      var isRoot = item.parentID === 0;\n      if (isRoot) {\n        removeRoot(id);\n      }\n    }\n    unmountedIDs.push(id);\n  },\n  purgeUnmountedComponents: function () {\n    if (ReactComponentTreeHook._preventPurging) {\n      // Should only be used for testing.\n      return;\n    }\n\n    for (var i = 0; i < unmountedIDs.length; i++) {\n      var id = unmountedIDs[i];\n      purgeDeep(id);\n    }\n    unmountedIDs.length = 0;\n  },\n  isMounted: function (id) {\n    var item = getItem(id);\n    return item ? item.isMounted : false;\n  },\n  getCurrentStackAddendum: function () {\n    var info = '';\n    var currentOwner = ReactCurrentOwner_1.current;\n    if (currentOwner) {\n      !(typeof currentOwner.tag !== 'number') ? invariant(false, 'Fiber owners should not show up in Stack stack traces.') : void 0;\n      if (typeof currentOwner._debugID === 'number') {\n        info += ReactComponentTreeHook.getStackAddendumByID(currentOwner._debugID);\n      }\n    }\n    return info;\n  },\n  getStackAddendumByID: function (id) {\n    var info = '';\n    while (id) {\n      info += describeID(id);\n      id = ReactComponentTreeHook.getParentID(id);\n    }\n    return info;\n  },\n  getChildIDs: function (id) {\n    var item = getItem(id);\n    return item ? item.childIDs : [];\n  },\n  getDisplayName: function (id) {\n    var element = ReactComponentTreeHook.getElement(id);\n    if (!element) {\n      return null;\n    }\n    return getDisplayName$1(element);\n  },\n  getElement: function (id) {\n    var item = getItem(id);\n    return item ? item.element : null;\n  },\n  getOwnerID: function (id) {\n    var element = ReactComponentTreeHook.getElement(id);\n    if (!element || !element._owner) {\n      return null;\n    }\n    return element._owner._debugID;\n  },\n  getParentID: function (id) {\n    var item = getItem(id);\n    return item ? item.parentID : null;\n  },\n  getSource: function (id) {\n    var item = getItem(id);\n    var element = item ? item.element : null;\n    var source = element != null ? element._source : null;\n    return source;\n  },\n  getText: function (id) {\n    var element = ReactComponentTreeHook.getElement(id);\n    if (typeof element === 'string') {\n      return element;\n    } else if (typeof element === 'number') {\n      return '' + element;\n    } else {\n      return null;\n    }\n  },\n  getUpdateCount: function (id) {\n    var item = getItem(id);\n    return item ? item.updateCount : 0;\n  },\n\n\n  getRootIDs: getRootIDs,\n  getRegisteredIDs: getItemIDs\n};\n\nvar ReactComponentTreeHook_1 = ReactComponentTreeHook;\n\nvar createElement = ReactElement_1.createElement;\nvar createFactory = ReactElement_1.createFactory;\nvar cloneElement = ReactElement_1.cloneElement;\n\n{\n  var ReactElementValidator = ReactElementValidator_1;\n  createElement = ReactElementValidator.createElement;\n  createFactory = ReactElementValidator.createFactory;\n  cloneElement = ReactElementValidator.cloneElement;\n}\n\nvar React = {\n  Children: {\n    map: ReactChildren_1.map,\n    forEach: ReactChildren_1.forEach,\n    count: ReactChildren_1.count,\n    toArray: ReactChildren_1.toArray,\n    only: onlyChild_1\n  },\n\n  Component: ReactBaseClasses.Component,\n  PureComponent: ReactBaseClasses.PureComponent,\n  unstable_AsyncComponent: ReactBaseClasses.AsyncComponent,\n\n  createElement: createElement,\n  cloneElement: cloneElement,\n  isValidElement: ReactElement_1.isValidElement,\n\n  createFactory: createFactory,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: ReactCurrentOwner_1,\n    // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n    assign: objectAssign$1\n  }\n};\n\n{\n  objectAssign$1(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n    // These should not be included in production.\n    ReactComponentTreeHook: ReactComponentTreeHook_1,\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame_1\n  });\n}\n\nvar ReactEntry = React;\n\nmodule.exports = ReactEntry;\n\n})();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzPzk5ZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZDtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSSx5Q0FBeUM7QUFDbkw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4wLjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4oZnVuY3Rpb24oKSB7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdEFzc2lnbiQxID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIHJlcXVpcmUkJDAgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHJlYWN0UHJvZEludmFyaWFudFxuICogXG4gKi9cblxue1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUkJDA7XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZV8xID0gUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGxvd1ByaW9yaXR5V2FybmluZ1xuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nXzEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXzE7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nXzEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXzE7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZTtcbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWN0UHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxub2JqZWN0QXNzaWduJDEocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBSZWFjdEFzeW5jQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWVfMTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gUmVhY3RBc3luY0NvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RBc3luY0NvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxub2JqZWN0QXNzaWduJDEoYXN5bmNDb21wb25lbnRQcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbn07XG5cbnZhciBSZWFjdEJhc2VDbGFzc2VzID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdFB1cmVDb21wb25lbnQsXG4gIEFzeW5jQ29tcG9uZW50OiBSZWFjdEFzeW5jQ29tcG9uZW50XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICogXG4gKi9cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXJfMSA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG57XG4gIHZhciB3YXJuaW5nJDIgPSByZXF1aXJlJCQwO1xufVxuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSQxID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmckMihmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmckMihmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSQxLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSQxKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lcl8xLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IG9iamVjdEFzc2lnbiQxKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXJfMS5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5SZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUkMTtcbn07XG5cbnZhciBSZWFjdEVsZW1lbnRfMSA9IFJlYWN0RWxlbWVudDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZVxuICogXG4gKi9cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWVfMSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbntcbiAgdmFyIHdhcm5pbmckMSA9IHJlcXVpcmUkJDA7XG5cbiAgdmFyIF9yZXF1aXJlID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZV8xLFxuICAgICAgZ2V0U3RhY2tBZGRlbmR1bSA9IF9yZXF1aXJlLmdldFN0YWNrQWRkZW5kdW07XG59XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gSVRFUkFUT1JfU1lNQk9MICYmIGNoaWxkcmVuW0lURVJBVE9SX1NZTUJPTF0gfHwgY2hpbGRyZW5bRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIGdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudF8xLmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnRfMS5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbnZhciBSZWFjdENoaWxkcmVuXzEgPSBSZWFjdENoaWxkcmVuO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjAuMCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50XzEuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIG9ubHlDaGlsZF8xID0gb25seUNoaWxkO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQHByb3ZpZGVzTW9kdWxlIGRlc2NyaWJlQ29tcG9uZW50RnJhbWVcbiAqL1xuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSQxID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRDb21wb25lbnROYW1lXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lJDEoaW5zdGFuY2VPckZpYmVyKSB7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2VPckZpYmVyLmdldE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBTdGFjayByZWNvbmNpbGVyXG4gICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VPckZpYmVyO1xuICAgIHJldHVybiBpbnN0YW5jZS5nZXROYW1lKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZU9yRmliZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEZpYmVyIHJlY29uY2lsZXJcbiAgICB2YXIgZmliZXIgPSBpbnN0YW5jZU9yRmliZXI7XG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGdldENvbXBvbmVudE5hbWVfMSA9IGdldENvbXBvbmVudE5hbWUkMTtcblxue1xuICB2YXIgY2hlY2tQcm9wVHlwZXMkMSA9IGNoZWNrUHJvcFR5cGVzO1xuICB2YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmdfMTtcbiAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWVfMTtcbiAgdmFyIHdhcm5pbmckMyA9IHJlcXVpcmUkJDA7XG4gIHZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZGVzY3JpYmVDb21wb25lbnRGcmFtZSQxO1xuICB2YXIgZ2V0Q29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVfMTtcblxuICB2YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gIHZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIElURVJBVE9SX1NZTUJPTCQxID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wkMSA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lcl8xLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXJfMS5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lcl8xLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nJDMoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnRfMS5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudF8xLmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IElURVJBVE9SX1NZTUJPTCQxICYmIG5vZGVbSVRFUkFUT1JfU1lNQk9MJDFdIHx8IG5vZGVbRkFVWF9JVEVSQVRPUl9TWU1CT0wkMV07XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnRfMS5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICB2YXIgcHJvcFR5cGVzID0gY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzO1xuXG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMkMShwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nJDMoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IkMSA9IHtcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbi5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICBpbmZvICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICAgIHdhcm5pbmckMyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudF8xLmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvciQxLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnRfMS5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxufTtcblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvcl8xID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yJDE7XG5cbntcbiAgdmFyIHdhcm5pbmckNCA9IHJlcXVpcmUkJDA7XG59XG5cbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcbiAgdmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXG4gIC8vIFRha2UgYW4gZXhhbXBsZSBuYXRpdmUgZnVuY3Rpb24gc291cmNlIGZvciBjb21wYXJpc29uXG4gIC5jYWxsKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG52YXIgc2V0SXRlbTtcbnZhciBnZXRJdGVtO1xudmFyIHJlbW92ZUl0ZW07XG52YXIgZ2V0SXRlbUlEcztcbnZhciBhZGRSb290O1xudmFyIHJlbW92ZVJvb3Q7XG52YXIgZ2V0Um9vdElEcztcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIHZhciBpdGVtTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfTtcblxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXRbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBpdGVtQnlLZXkgPSB7fTtcbiAgdmFyIHJvb3RCeUtleSA9IHt9O1xuXG4gIC8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHZhciBnZXRLZXlGcm9tSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gJy4nICsgaWQ7XG4gIH07XG4gIHZhciBnZXRJREZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbiAgfTtcblxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9O1xuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcmV0dXJuIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByb290QnlLZXlba2V5XSA9IHRydWU7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH07XG4gIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZUl0ZW0oaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZSQxKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWUgPSB2b2lkIDA7XG5cbiAgaWYgKG93bmVySUQpIHtcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xuICB9XG4gIHdhcm5pbmckNChlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKTtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUkMShuYW1lIHx8ICcnLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lIHx8ICcnKTtcbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XG4gICAgICB2YXIgbmV4dENoaWxkID0gZ2V0SXRlbShuZXh0Q2hpbGRJRCk7XG4gICAgICAhbmV4dENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uTW91bnRDb21wb25lbnQoKSB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IGlkIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIHZhciBpdGVtID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICAgIHRleHQ6IG51bGwsXG4gICAgICBjaGlsZElEczogW10sXG4gICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlQ291bnQ6IDBcbiAgICB9O1xuICAgIHNldEl0ZW0oaWQsIGl0ZW0pO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBhZGRSb290KGlkKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xuICB9LFxuICBnZXRDdXJyZW50U3RhY2tBZGRlbmR1bTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyXzEuY3VycmVudDtcbiAgICBpZiAoY3VycmVudE93bmVyKSB7XG4gICAgICAhKHR5cGVvZiBjdXJyZW50T3duZXIudGFnICE9PSAnbnVtYmVyJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBvd25lcnMgc2hvdWxkIG5vdCBzaG93IHVwIGluIFN0YWNrIHN0YWNrIHRyYWNlcy4nKSA6IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudE93bmVyLl9kZWJ1Z0lEID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoY3VycmVudE93bmVyLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcbiAgfSxcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUkMShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHMsXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldEl0ZW1JRHNcbn07XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rXzEgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudF8xLmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudF8xLmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50XzEuY2xvbmVFbGVtZW50O1xuXG57XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JfMTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW5fMS5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbl8xLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW5fMS5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuXzEudG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRfMVxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RCYXNlQ2xhc3Nlcy5Db21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0QmFzZUNsYXNzZXMuUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IFJlYWN0QmFzZUNsYXNzZXMuQXN5bmNDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnRfMS5pc1ZhbGlkRWxlbWVudCxcblxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcl8xLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBvYmplY3RBc3NpZ24kMVxuICB9XG59O1xuXG57XG4gIG9iamVjdEFzc2lnbiQxKFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2tfMSxcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lXzFcbiAgfSk7XG59XG5cbnZhciBSZWFjdEVudHJ5ID0gUmVhY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbnRyeTtcblxufSkoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.min.js');\n} else {\n  module.exports = __webpack_require__(18);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzPzNiNmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.0.0\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n(function() {\n\n'use strict';\n\nvar react = __webpack_require__(0);\nvar invariant = __webpack_require__(4);\nvar ExecutionEnvironment = __webpack_require__(9);\nvar _assign = __webpack_require__(5);\nvar EventListener = __webpack_require__(19);\nvar require$$0 = __webpack_require__(3);\nvar hyphenateStyleName = __webpack_require__(20);\nvar emptyFunction = __webpack_require__(1);\nvar camelizeStyleName = __webpack_require__(22);\nvar performanceNow = __webpack_require__(24);\nvar propTypes = __webpack_require__(26);\nvar emptyObject = __webpack_require__(7);\nvar checkPropTypes = __webpack_require__(6);\nvar shallowEqual = __webpack_require__(28);\nvar containsNode = __webpack_require__(29);\nvar focusNode = __webpack_require__(32);\nvar getActiveElement = __webpack_require__(33);\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule reactProdInvariant\n * \n */\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule checkReact\n * \n */\n\n\n\n\n!react ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule DOMNamespaces\n */\n\nvar HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE;\n  }\n}\n\nfunction getChildNamespace$1(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\nvar Namespaces_1 = Namespaces;\nvar getIntrinsicNamespace_1 = getIntrinsicNamespace;\nvar getChildNamespace_1 = getChildNamespace$1;\n\nvar DOMNamespaces = {\n\tNamespaces: Namespaces_1,\n\tgetIntrinsicNamespace: getIntrinsicNamespace_1,\n\tgetChildNamespace: getChildNamespace_1\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    EventPluginRegistry.plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Mapping from lowercase registration names to the properly cased version,\n   * used to warn in the case of missing event handlers. Available\n   * only in true.\n   * @type {Object}\n   */\n  possibleRegistrationNames: {},\n  // Trust the developer to only use possibleRegistrationNames in true\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function (injectedEventPluginOrder) {\n    !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n    // Clone the ordering so it cannot be dynamically mutated.\n    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var pluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n        !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n        namesToPlugins[pluginName] = pluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  }\n};\n\nvar EventPluginRegistry_1 = EventPluginRegistry;\n\n// These attributes should be all lowercase to allow for\n// case insensitive checks\nvar RESERVED_PROPS = {\n  children: true,\n  dangerouslySetInnerHTML: true,\n  autoFocus: true,\n  defaultValue: true,\n  defaultChecked: true,\n  innerHTML: true,\n  suppressContentEditableWarning: true,\n  style: true\n};\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_PROPERTY: 0x1,\n  HAS_BOOLEAN_VALUE: 0x4,\n  HAS_NUMERIC_VALUE: 0x8,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,\n  HAS_STRING_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n   * attribute namespace URL. (Attribute names not specified use no namespace.)\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function (domPropertyConfig) {\n    var Injection = DOMPropertyInjection;\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    for (var propName in Properties) {\n      !!DOMProperty.properties.hasOwnProperty(propName) ? invariant(false, 'injectDOMPropertyConfig(...): You\\'re trying to inject DOM property \\'%s\\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : void 0;\n\n      var lowerCased = propName.toLowerCase();\n      var propConfig = Properties[propName];\n\n      var propertyInfo = {\n        attributeName: lowerCased,\n        attributeNamespace: null,\n        propertyName: propName,\n        mutationMethod: null,\n\n        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),\n        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)\n      };\n      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : void 0;\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n\n        propertyInfo.attributeName = attributeName;\n      }\n\n      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n      }\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        propertyInfo.mutationMethod = DOMMutationMethods[propName];\n      }\n\n      // Downcase references to whitelist properties to check for membership\n      // without case-sensitivity. This allows the whitelist to pick up\n      // `allowfullscreen`, which should be written using the property configuration\n      // for `allowFullscreen`\n      DOMProperty.properties[propName] = propertyInfo;\n    }\n  }\n};\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\n\n/**\n * DOMProperty exports lookup objects that can be used like functions:\n *\n *   > DOMProperty.isValid['id']\n *   true\n *   > DOMProperty.isValid['foobar']\n *   undefined\n *\n * Although this may be confusing, it performs better in general.\n *\n * @see http://jsperf.com/key-exists\n * @see http://jsperf.com/key-missing\n */\nvar DOMProperty = {\n  ID_ATTRIBUTE_NAME: 'data-reactid',\n  ROOT_ATTRIBUTE_NAME: 'data-reactroot',\n\n  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,\n  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040',\n\n  /**\n   * Map from property \"standard name\" to an object with info about how to set\n   * the property in the DOM. Each object contains:\n   *\n   * attributeName:\n   *   Used when rendering markup or with `*Attribute()`.\n   * attributeNamespace\n   * propertyName:\n   *   Used on DOM node instances. (This includes properties that mutate due to\n   *   external factors.)\n   * mutationMethod:\n   *   If non-null, used instead of the property or `setAttribute()` after\n   *   initial render.\n   * mustUseProperty:\n   *   Whether the property must be accessed and mutated as an object property.\n   * hasBooleanValue:\n   *   Whether the property should be removed when set to a falsey value.\n   * hasNumericValue:\n   *   Whether the property must be numeric or parse as a numeric and should be\n   *   removed when set to a falsey value.\n   * hasPositiveNumericValue:\n   *   Whether the property must be positive numeric or parse as a positive\n   *   numeric and should be removed when set to a falsey value.\n   * hasOverloadedBooleanValue:\n   *   Whether the property can be used as a flag as well as with a value.\n   *   Removed when strictly equal to false; present without a value when\n   *   strictly equal to true; present with a value otherwise.\n   */\n  properties: {},\n\n  /**\n   * Checks whether a property name is a writeable attribute.\n   * @method\n   */\n  shouldSetAttribute: function (name, value) {\n    if (DOMProperty.isReservedProp(name)) {\n      return false;\n    }\n    if ((name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n      return false;\n    }\n    if (value === null) {\n      return true;\n    }\n    switch (typeof value) {\n      case 'boolean':\n        return DOMProperty.shouldAttributeAcceptBooleanValue(name);\n      case 'undefined':\n      case 'number':\n      case 'string':\n      case 'object':\n        return true;\n      default:\n        // function, symbol\n        return false;\n    }\n  },\n\n  getPropertyInfo: function (name) {\n    return DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;\n  },\n  shouldAttributeAcceptBooleanValue: function (name) {\n    if (DOMProperty.isReservedProp(name)) {\n      return true;\n    }\n    var propertyInfo = DOMProperty.getPropertyInfo(name);\n    if (propertyInfo) {\n      return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;\n    }\n    var prefix = name.toLowerCase().slice(0, 5);\n    return prefix === 'data-' || prefix === 'aria-';\n  },\n\n\n  /**\n   * Checks to see if a property name is within the list of properties\n   * reserved for internal React operations. These properties should\n   * not be set on an HTML element.\n   *\n   * @private\n   * @param {string} name\n   * @return {boolean} If the name is within reserved props\n   */\n  isReservedProp: function (name) {\n    return RESERVED_PROPS.hasOwnProperty(name);\n  },\n\n\n  injection: DOMPropertyInjection\n};\n\nvar DOMProperty_1 = DOMProperty;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactDOMComponentFlags\n */\n\nvar ReactDOMComponentFlags = {\n  hasCachedChildNodes: 1 << 0\n};\n\nvar ReactDOMComponentFlags_1 = ReactDOMComponentFlags;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactTypeOfWork\n * \n */\n\nvar ReactTypeOfWork = {\n  IndeterminateComponent: 0, // Before we know whether it is functional or class\n  FunctionalComponent: 1,\n  ClassComponent: 2,\n  HostRoot: 3, // Root of a host tree. Could be nested inside another node.\n  HostPortal: 4, // A subtree. Could be an entry point to a different renderer.\n  HostComponent: 5,\n  HostText: 6,\n  CoroutineComponent: 7,\n  CoroutineHandlerPhase: 8,\n  YieldComponent: 9,\n  Fragment: 10\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule HTMLNodeType\n */\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar HTMLNodeType = {\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_FRAGMENT_NODE: 11\n};\n\nvar HTMLNodeType_1 = HTMLNodeType;\n\nvar HostComponent = ReactTypeOfWork.HostComponent;\nvar HostText = ReactTypeOfWork.HostText;\n\nvar ELEMENT_NODE$1 = HTMLNodeType_1.ELEMENT_NODE;\nvar COMMENT_NODE$1 = HTMLNodeType_1.COMMENT_NODE;\n\n\n\nvar ATTR_NAME = DOMProperty_1.ID_ATTRIBUTE_NAME;\nvar Flags = ReactDOMComponentFlags_1;\n\nvar randomKey = Math.random().toString(36).slice(2);\n\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\n\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\n/**\n * Check if a given node should be cached.\n */\nfunction shouldPrecacheNode(node, nodeID) {\n  return node.nodeType === ELEMENT_NODE$1 && node.getAttribute(ATTR_NAME) === '' + nodeID || node.nodeType === COMMENT_NODE$1 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === COMMENT_NODE$1 && node.nodeValue === ' react-empty: ' + nodeID + ' ';\n}\n\n/**\n * Drill down (through composites and empty components) until we get a host or\n * host text component.\n *\n * This is pretty polymorphic but unavoidable with the current structure we have\n * for `_renderedChildren`.\n */\nfunction getRenderedHostOrTextFromComponent(component) {\n  var rendered;\n  while (rendered = component._renderedComponent) {\n    component = rendered;\n  }\n  return component;\n}\n\n/**\n * Populate `_hostNode` on the rendered host/text component with the given\n * DOM node. The passed `inst` can be a composite.\n */\nfunction precacheNode(inst, node) {\n  var hostInst = getRenderedHostOrTextFromComponent(inst);\n  hostInst._hostNode = node;\n  node[internalInstanceKey] = hostInst;\n}\n\nfunction precacheFiberNode$1(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\nfunction uncacheNode(inst) {\n  var node = inst._hostNode;\n  if (node) {\n    delete node[internalInstanceKey];\n    inst._hostNode = null;\n  }\n}\n\n/**\n * Populate `_hostNode` on each child of `inst`, assuming that the children\n * match up with the DOM (element) children of `node`.\n *\n * We cache entire levels at once to avoid an n^2 problem where we access the\n * children of a node sequentially and have to walk from the start to our target\n * node every time.\n *\n * Since we update `_renderedChildren` and the actual DOM at (slightly)\n * different times, we could race here and see a newer `_renderedChildren` than\n * the DOM nodes we see. To avoid this, ReactMultiChild calls\n * `prepareToManageChildren` before we change `_renderedChildren`, at which\n * time the container's child nodes are always cached (until it unmounts).\n */\nfunction precacheChildNodes(inst, node) {\n  if (inst._flags & Flags.hasCachedChildNodes) {\n    return;\n  }\n  var children = inst._renderedChildren;\n  var childNode = node.firstChild;\n  outer: for (var name in children) {\n    if (!children.hasOwnProperty(name)) {\n      continue;\n    }\n    var childInst = children[name];\n    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;\n    if (childID === 0) {\n      // We're currently unmounting this child in ReactMultiChild; skip it.\n      continue;\n    }\n    // We assume the child nodes are in the same order as the child instances.\n    for (; childNode !== null; childNode = childNode.nextSibling) {\n      if (shouldPrecacheNode(childNode, childID)) {\n        precacheNode(childInst, childNode);\n        continue outer;\n      }\n    }\n    // We reached the end of the DOM children without finding an ID match.\n    invariant(false, 'Unable to find element with ID %s.', childID);\n  }\n  inst._flags |= Flags.hasCachedChildNodes;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  // Walk up the tree until we find an ancestor whose instance we have cached.\n  var parents = [];\n  while (!node[internalInstanceKey]) {\n    parents.push(node);\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var closest;\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {\n    closest = inst;\n    if (parents.length) {\n      precacheChildNodes(inst, node);\n    }\n  }\n\n  return closest;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else if (inst._hostNode === node) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  inst = getClosestInstanceFromNode(node);\n  if (inst != null && inst._hostNode === node) {\n    return inst;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  !(inst._hostNode !== undefined) ? invariant(false, 'getNodeFromInstance: Invalid argument.') : void 0;\n\n  if (inst._hostNode) {\n    return inst._hostNode;\n  }\n\n  // Walk up the tree until we find an ancestor whose DOM node we have cached.\n  var parents = [];\n  while (!inst._hostNode) {\n    parents.push(inst);\n    !inst._hostParent ? invariant(false, 'React DOM tree root should always have a node reference.') : void 0;\n    inst = inst._hostParent;\n  }\n\n  // Now parents contains each ancestor that does *not* have a cached native\n  // node, and `inst` is the deepest ancestor that does.\n  for (; parents.length; inst = parents.pop()) {\n    precacheChildNodes(inst, inst._hostNode);\n  }\n\n  return inst._hostNode;\n}\n\nfunction getFiberCurrentPropsFromNode(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps$1(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = {\n  getClosestInstanceFromNode: getClosestInstanceFromNode,\n  getInstanceFromNode: getInstanceFromNode,\n  getNodeFromInstance: getNodeFromInstance,\n  precacheChildNodes: precacheChildNodes,\n  precacheNode: precacheNode,\n  uncacheNode: uncacheNode,\n  precacheFiberNode: precacheFiberNode$1,\n  getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode,\n  updateFiberProps: updateFiberProps$1\n};\n\nvar ReactDOMComponentTree_1 = ReactDOMComponentTree;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactInstanceMap\n */\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n */\n\n// TODO: Replace this with ES6: var ReactInstanceMap = new Map();\n\nvar ReactInstanceMap = {\n  /**\n   * This API should be called `delete` but we'd have to make sure to always\n   * transform these to strings for IE support. When this transform is fully\n   * supported we can rename it.\n   */\n  remove: function (key) {\n    key._reactInternalFiber = undefined;\n  },\n\n  get: function (key) {\n    return key._reactInternalFiber;\n  },\n\n  has: function (key) {\n    return key._reactInternalFiber !== undefined;\n  },\n\n  set: function (key, value) {\n    key._reactInternalFiber = value;\n  }\n};\n\nvar ReactInstanceMap_1 = ReactInstanceMap;\n\nvar ReactInternals = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactGlobalSharedState = {\n  ReactCurrentOwner: ReactInternals.ReactCurrentOwner\n};\n\n{\n  _assign(ReactGlobalSharedState, {\n    ReactComponentTreeHook: ReactInternals.ReactComponentTreeHook,\n    ReactDebugCurrentFrame: ReactInternals.ReactDebugCurrentFrame\n  });\n}\n\nvar ReactGlobalSharedState_1 = ReactGlobalSharedState;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule getComponentName\n * \n */\n\nfunction getComponentName(instanceOrFiber) {\n  if (typeof instanceOrFiber.getName === 'function') {\n    // Stack reconciler\n    var instance = instanceOrFiber;\n    return instance.getName();\n  }\n  if (typeof instanceOrFiber.tag === 'number') {\n    // Fiber reconciler\n    var fiber = instanceOrFiber;\n    var type = fiber.type;\n\n    if (typeof type === 'string') {\n      return type;\n    }\n    if (typeof type === 'function') {\n      return type.displayName || type.name;\n    }\n  }\n  return null;\n}\n\nvar getComponentName_1 = getComponentName;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactTypeOfSideEffect\n * \n */\n\nvar ReactTypeOfSideEffect = {\n  // Don't change these two values:\n  NoEffect: 0, //           0b00000000\n  PerformedWork: 1, //      0b00000001\n  // You can change the rest (and add more).\n  Placement: 2, //          0b00000010\n  Update: 4, //             0b00000100\n  PlacementAndUpdate: 6, // 0b00000110\n  Deletion: 8, //           0b00001000\n  ContentReset: 16, //      0b00010000\n  Callback: 32, //          0b00100000\n  Err: 64, //               0b01000000\n  Ref: 128 };\n\nvar ReactCurrentOwner = ReactGlobalSharedState_1.ReactCurrentOwner;\n\n\n\n\n{\n  var warning$1 = require$$0;\n}\n\nvar ClassComponent = ReactTypeOfWork.ClassComponent;\nvar HostComponent$1 = ReactTypeOfWork.HostComponent;\nvar HostRoot$1 = ReactTypeOfWork.HostRoot;\nvar HostPortal = ReactTypeOfWork.HostPortal;\nvar HostText$1 = ReactTypeOfWork.HostText;\n\nvar NoEffect = ReactTypeOfSideEffect.NoEffect;\nvar Placement = ReactTypeOfSideEffect.Placement;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot$1) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\nvar isFiberMounted = function (fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n};\n\nvar isMounted = function (component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning$1(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName_1(ownerFiber) || 'A component');\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = ReactInstanceMap_1.get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n};\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot$1) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\nvar findCurrentFiberUsingSlowPath_1 = findCurrentFiberUsingSlowPath;\n\nvar findCurrentHostFiber = function (parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent$1 || node.tag === HostText$1) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n};\n\nvar findCurrentHostFiberWithNoPortals = function (parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent$1 || node.tag === HostText$1) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n};\n\nvar ReactFiberTreeReflection = {\n\tisFiberMounted: isFiberMounted,\n\tisMounted: isMounted,\n\tfindCurrentFiberUsingSlowPath: findCurrentFiberUsingSlowPath_1,\n\tfindCurrentHostFiber: findCurrentHostFiber,\n\tfindCurrentHostFiberWithNoPortals: findCurrentHostFiberWithNoPortals\n};\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function (injectedErrorUtils) {\n      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\nvar ReactErrorUtils_1 = ReactErrorUtils;\n\n{\n  var warning$2 = require$$0;\n}\n\n/**\n * Injected dependencies:\n */\n\n/**\n * - `ComponentTree`: [required] Module that can convert between React instances\n *   and actual node references.\n */\nvar ComponentTree;\nvar injection = {\n  injectComponentTree: function (Injected) {\n    ComponentTree = Injected;\n    {\n      warning$2(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n    }\n  }\n};\n\nfunction isEndish(topLevelType) {\n  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';\n}\n\nvar validateEventDispatches;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    warning$2(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);\n  ReactErrorUtils_1.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  !!Array.isArray(dispatchListener) ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : void 0;\n  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * General utilities that are useful in creating custom Event Plugins.\n */\nvar EventPluginUtils = {\n  isEndish: isEndish,\n  isMoveish: isMoveish,\n  isStartish: isStartish,\n\n  executeDirectDispatch: executeDirectDispatch,\n  executeDispatchesInOrder: executeDispatchesInOrder,\n  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n  hasDispatches: hasDispatches,\n\n  getFiberCurrentPropsFromNode: function (node) {\n    return ComponentTree.getFiberCurrentPropsFromNode(node);\n  },\n  getInstanceFromNode: function (node) {\n    return ComponentTree.getInstanceFromNode(node);\n  },\n  getNodeFromInstance: function (node) {\n    return ComponentTree.getNodeFromInstance(node);\n  },\n\n  injection: injection\n};\n\nvar EventPluginUtils_1 = EventPluginUtils;\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = EventPluginUtils_1.getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  if (typeof internalInstance.tag === 'number') {\n    !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var props = EventPluginUtils_1.getFiberCurrentPropsFromNode(internalInstance.stateNode);\n    fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n    return;\n  }\n  !(typeof internalInstance.restoreControlledState === 'function') ? invariant(false, 'The internal instance must be a React host component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  // If it is not a Fiber, we can just use dynamic dispatch.\n  internalInstance.restoreControlledState();\n}\n\nvar ReactControlledComponent = {\n  injection: ReactControlledComponentInjection,\n\n  enqueueStateRestore: function (target) {\n    if (restoreTarget) {\n      if (restoreQueue) {\n        restoreQueue.push(target);\n      } else {\n        restoreQueue = [target];\n      }\n    } else {\n      restoreTarget = target;\n    }\n  },\n  restoreStateIfNeeded: function () {\n    if (!restoreTarget) {\n      return;\n    }\n    var target = restoreTarget;\n    var queuedTargets = restoreQueue;\n    restoreTarget = null;\n    restoreQueue = null;\n\n    restoreStateOfTarget(target);\n    if (queuedTargets) {\n      for (var i = 0; i < queuedTargets.length; i++) {\n        restoreStateOfTarget(queuedTargets[i]);\n      }\n    }\n  }\n};\n\nvar ReactControlledComponent_1 = ReactControlledComponent;\n\n// Used as a way to call batchedUpdates when we don't know if we're in a Fiber\n// or Stack context. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar stackBatchedUpdates = function (fn, a, b, c, d, e) {\n  return fn(a, b, c, d, e);\n};\nvar fiberBatchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nfunction performFiberBatchedUpdates(fn, bookkeeping) {\n  // If we have Fiber loaded, we need to wrap this in a batching call so that\n  // Fiber can apply its default priority for this call.\n  return fiberBatchedUpdates(fn, bookkeeping);\n}\nfunction batchedUpdates(fn, bookkeeping) {\n  // We first perform work with the stack batching strategy, by passing our\n  // indirection to it.\n  return stackBatchedUpdates(performFiberBatchedUpdates, fn, bookkeeping);\n}\n\nvar isNestingBatched = false;\nfunction batchedUpdatesWithControlledComponents(fn, bookkeeping) {\n  if (isNestingBatched) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state. Therefore, we add the target to\n    // a queue of work.\n    return batchedUpdates(fn, bookkeeping);\n  }\n  isNestingBatched = true;\n  try {\n    return batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isNestingBatched = false;\n    ReactControlledComponent_1.restoreStateIfNeeded();\n  }\n}\n\nvar ReactGenericBatchingInjection = {\n  injectStackBatchedUpdates: function (_batchedUpdates) {\n    stackBatchedUpdates = _batchedUpdates;\n  },\n  injectFiberBatchedUpdates: function (_batchedUpdates) {\n    fiberBatchedUpdates = _batchedUpdates;\n  }\n};\n\nvar ReactGenericBatching = {\n  batchedUpdates: batchedUpdatesWithControlledComponents,\n  injection: ReactGenericBatchingInjection\n};\n\nvar ReactGenericBatching_1 = ReactGenericBatching;\n\nvar TEXT_NODE$1 = HTMLNodeType_1.TEXT_NODE;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\n\n\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE$1 ? target.parentNode : target;\n}\n\nvar getEventTarget_1 = getEventTarget;\n\nvar HostRoot = ReactTypeOfWork.HostRoot;\n\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  if (typeof inst.tag === 'number') {\n    while (inst['return']) {\n      inst = inst['return'];\n    }\n    if (inst.tag !== HostRoot) {\n      // This can happen if we're in a detached tree.\n      return null;\n    }\n    return inst.stateNode.containerInfo;\n  } else {\n    while (inst._hostParent) {\n      inst = inst._hostParent;\n    }\n    var rootNode = ReactDOMComponentTree_1.getNodeFromInstance(inst);\n    return rootNode.parentNode;\n  }\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = ReactDOMComponentTree_1.getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    ReactDOMEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget_1(bookKeeping.nativeEvent));\n  }\n}\n\nvar ReactDOMEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  setHandleTopLevel: function (handleTopLevel) {\n    ReactDOMEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function (enabled) {\n    ReactDOMEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function () {\n    return ReactDOMEventListener._enabled;\n  },\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `BrowserEventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} element Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(element, handlerBaseName, ReactDOMEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `BrowserEventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} element Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(element, handlerBaseName, ReactDOMEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  dispatchEvent: function (topLevelType, nativeEvent) {\n    if (!ReactDOMEventListener._enabled) {\n      return;\n    }\n\n    var nativeEventTarget = getEventTarget_1(nativeEvent);\n    var targetInst = ReactDOMComponentTree_1.getClosestInstanceFromNode(nativeEventTarget);\n    if (targetInst !== null && typeof targetInst.tag === 'number' && !ReactFiberTreeReflection.isFiberMounted(targetInst)) {\n      // If we get an event (ex: img onload) before committing that\n      // component's mount, ignore it for now (that is, treat it as if it was an\n      // event on a non-React tree). We might also consider queueing events and\n      // dispatching them after the mount.\n      targetInst = null;\n    }\n\n    var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactGenericBatching_1.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      releaseTopLevelCallbackBookKeeping(bookKeeping);\n    }\n  }\n};\n\nvar ReactDOMEventListener_1 = ReactDOMEventListener;\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\nvar accumulateInto_1 = accumulateInto;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule forEachAccumulated\n * \n */\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\n\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\nvar forEachAccumulated_1 = forEachAccumulated;\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    EventPluginUtils_1.executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\nvar EventPluginHub = {\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry_1.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry_1.injectEventPluginsByName\n  },\n\n  /**\n   * @param {object} inst The instance, which is the source of events.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n  getListener: function (inst, registrationName) {\n    var listener;\n\n    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n    // live here; needs to be moved to a better place soon\n    if (typeof inst.tag === 'number') {\n      var stateNode = inst.stateNode;\n      if (!stateNode) {\n        // Work in progress (ex: onload events in incremental mode).\n        return null;\n      }\n      var props = EventPluginUtils_1.getFiberCurrentPropsFromNode(stateNode);\n      if (!props) {\n        // Work in progress.\n        return null;\n      }\n      listener = props[registrationName];\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n    } else {\n      var currentElement = inst._currentElement;\n      if (typeof currentElement === 'string' || typeof currentElement === 'number') {\n        // Text node, let it bubble through.\n        return null;\n      }\n      if (!inst._rootNodeID) {\n        // If the instance is already unmounted, we have no listeners.\n        return null;\n      }\n      var _props = currentElement.props;\n      listener = _props[registrationName];\n      if (shouldPreventMouseEvent(registrationName, currentElement.type, _props)) {\n        return null;\n      }\n    }\n\n    !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n    return listener;\n  },\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var events;\n    var plugins = EventPluginRegistry_1.plugins;\n    for (var i = 0; i < plugins.length; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n        if (extractedEvents) {\n          events = accumulateInto_1(events, extractedEvents);\n        }\n      }\n    }\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function (events) {\n    if (events) {\n      eventQueue = accumulateInto_1(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function (simulated) {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    if (simulated) {\n      forEachAccumulated_1(processingEventQueue, executeDispatchesAndReleaseSimulated);\n    } else {\n      forEachAccumulated_1(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n    }\n    !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n    // This would be a good time to rethrow if any of the event handlers threw.\n    ReactErrorUtils_1.rethrowCaughtError();\n  }\n};\n\nvar EventPluginHub_1 = EventPluginHub;\n\nfunction runEventQueueInBatch(events) {\n  EventPluginHub_1.enqueueEvents(events);\n  EventPluginHub_1.processEventQueue(false);\n}\n\nvar ReactEventEmitterMixin = {\n  /**\n   * Streams a fired top-level event to `EventPluginHub` where plugins have the\n   * opportunity to create `ReactEvent`s to be dispatched.\n   */\n  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var events = EventPluginHub_1.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n    runEventQueueInBatch(events);\n  }\n};\n\nvar ReactEventEmitterMixin_1 = ReactEventEmitterMixin;\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature = document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nvar isEventSupported_1 = isEventSupported;\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return '';\n}\n\nvar getVendorPrefixedEventName_1 = getVendorPrefixedEventName;\n\n/**\n * Types of raw signals from the browser caught at the top level.\n *\n * For events like 'submit' which don't consistently bubble (which we\n * trap at a lower node than `document`), binding at `document` would\n * cause duplicate events so we don't include them here.\n */\nvar topLevelTypes$1 = {\n  topAbort: 'abort',\n  topAnimationEnd: getVendorPrefixedEventName_1('animationend') || 'animationend',\n  topAnimationIteration: getVendorPrefixedEventName_1('animationiteration') || 'animationiteration',\n  topAnimationStart: getVendorPrefixedEventName_1('animationstart') || 'animationstart',\n  topBlur: 'blur',\n  topCancel: 'cancel',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topChange: 'change',\n  topClick: 'click',\n  topClose: 'close',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoadedData: 'loadeddata',\n  topLoad: 'load',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topScroll: 'scroll',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topSelectionChange: 'selectionchange',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTextInput: 'textInput',\n  topTimeUpdate: 'timeupdate',\n  topToggle: 'toggle',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topTransitionEnd: getVendorPrefixedEventName_1('transitionend') || 'transitionend',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting',\n  topWheel: 'wheel'\n};\n\nvar BrowserEventConstants = {\n  topLevelTypes: topLevelTypes$1\n};\n\nvar BrowserEventConstants_1 = BrowserEventConstants;\n\nvar topLevelTypes = BrowserEventConstants_1.topLevelTypes;\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\nvar ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin_1, {\n  /**\n   * Sets whether or not any created callbacks should be enabled.\n   *\n   * @param {boolean} enabled True if callbacks should be enabled.\n   */\n  setEnabled: function (enabled) {\n    if (ReactDOMEventListener_1) {\n      ReactDOMEventListener_1.setEnabled(enabled);\n    }\n  },\n\n  /**\n   * @return {boolean} True if callbacks are enabled.\n   */\n  isEnabled: function () {\n    return !!(ReactDOMEventListener_1 && ReactDOMEventListener_1.isEnabled());\n  },\n\n  /**\n   * We listen for bubbled touch events on the document object.\n   *\n   * Firefox v8.01 (and possibly others) exhibited strange behavior when\n   * mounting `onmousemove` events at some node that was not the document\n   * element. The symptoms were that if your mouse is not moving over something\n   * contained within that mount point (for example on the background) the\n   * top-level listeners for `onmousemove` won't be called. However, if you\n   * register the `mousemove` on the document object, then it will of course\n   * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n   * top-level listeners to the document object only, at least for these\n   * movement types of events and possibly all events.\n   *\n   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n   *\n   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n   * they bubble to document.\n   *\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {object} contentDocumentHandle Document which owns the container\n   */\n  listenTo: function (registrationName, contentDocumentHandle) {\n    var mountAt = contentDocumentHandle;\n    var isListening = getListeningForDocument(mountAt);\n    var dependencies = EventPluginRegistry_1.registrationNameDependencies[registrationName];\n\n    for (var i = 0; i < dependencies.length; i++) {\n      var dependency = dependencies[i];\n      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n        if (dependency === 'topWheel') {\n          if (isEventSupported_1('wheel')) {\n            ReactDOMEventListener_1.trapBubbledEvent('topWheel', 'wheel', mountAt);\n          } else if (isEventSupported_1('mousewheel')) {\n            ReactDOMEventListener_1.trapBubbledEvent('topWheel', 'mousewheel', mountAt);\n          } else {\n            // Firefox needs to capture a different mouse scroll event.\n            // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n            ReactDOMEventListener_1.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);\n          }\n        } else if (dependency === 'topScroll') {\n          ReactDOMEventListener_1.trapCapturedEvent('topScroll', 'scroll', mountAt);\n        } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n          ReactDOMEventListener_1.trapCapturedEvent('topFocus', 'focus', mountAt);\n          ReactDOMEventListener_1.trapCapturedEvent('topBlur', 'blur', mountAt);\n\n          // to make sure blur and focus event listeners are only attached once\n          isListening.topBlur = true;\n          isListening.topFocus = true;\n        } else if (dependency === 'topCancel') {\n          if (isEventSupported_1('cancel', true)) {\n            ReactDOMEventListener_1.trapCapturedEvent('topCancel', 'cancel', mountAt);\n          }\n          isListening.topCancel = true;\n        } else if (dependency === 'topClose') {\n          if (isEventSupported_1('close', true)) {\n            ReactDOMEventListener_1.trapCapturedEvent('topClose', 'close', mountAt);\n          }\n          isListening.topClose = true;\n        } else if (topLevelTypes.hasOwnProperty(dependency)) {\n          ReactDOMEventListener_1.trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n        }\n\n        isListening[dependency] = true;\n      }\n    }\n  },\n\n  isListeningToAllDependencies: function (registrationName, mountAt) {\n    var isListening = getListeningForDocument(mountAt);\n    var dependencies = EventPluginRegistry_1.registrationNameDependencies[registrationName];\n    for (var i = 0; i < dependencies.length; i++) {\n      var dependency = dependencies[i];\n      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {\n    return ReactDOMEventListener_1.trapBubbledEvent(topLevelType, handlerBaseName, handle);\n  },\n\n  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {\n    return ReactDOMEventListener_1.trapCapturedEvent(topLevelType, handlerBaseName, handle);\n  }\n});\n\nvar ReactBrowserEventEmitter_1 = ReactBrowserEventEmitter;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactDOMFeatureFlags\n */\n\nvar ReactDOMFeatureFlags = {\n  fiberAsyncScheduling: false,\n  useFiber: true\n};\n\nvar ReactDOMFeatureFlags_1 = ReactDOMFeatureFlags;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule CSSProperty\n */\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\n\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Most style properties can be unset by doing .style[prop] = '' but IE8\n * doesn't like doing that with shorthand properties so for the properties that\n * IE8 breaks on, which are listed here, we instead unset each of the\n * individual properties. See http://bugs.jquery.com/ticket/12385.\n * The 4-value 'clock' properties like margin, padding, border-width seem to\n * behave without any problems. Curiously, list-style works too without any\n * special prodding.\n */\nvar shorthandPropertyExpansions = {\n  background: {\n    backgroundAttachment: true,\n    backgroundColor: true,\n    backgroundImage: true,\n    backgroundPositionX: true,\n    backgroundPositionY: true,\n    backgroundRepeat: true\n  },\n  backgroundPosition: {\n    backgroundPositionX: true,\n    backgroundPositionY: true\n  },\n  border: {\n    borderWidth: true,\n    borderStyle: true,\n    borderColor: true\n  },\n  borderBottom: {\n    borderBottomWidth: true,\n    borderBottomStyle: true,\n    borderBottomColor: true\n  },\n  borderLeft: {\n    borderLeftWidth: true,\n    borderLeftStyle: true,\n    borderLeftColor: true\n  },\n  borderRight: {\n    borderRightWidth: true,\n    borderRightStyle: true,\n    borderRightColor: true\n  },\n  borderTop: {\n    borderTopWidth: true,\n    borderTopStyle: true,\n    borderTopColor: true\n  },\n  font: {\n    fontStyle: true,\n    fontVariant: true,\n    fontWeight: true,\n    fontSize: true,\n    lineHeight: true,\n    fontFamily: true\n  },\n  outline: {\n    outlineWidth: true,\n    outlineStyle: true,\n    outlineColor: true\n  }\n};\n\nvar CSSProperty = {\n  isUnitlessNumber: isUnitlessNumber,\n  shorthandPropertyExpansions: shorthandPropertyExpansions\n};\n\nvar CSSProperty_1 = CSSProperty;\n\nvar isUnitlessNumber$1 = CSSProperty_1.isUnitlessNumber;\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber$1.hasOwnProperty(name) && isUnitlessNumber$1[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar dangerousStyleValue_1 = dangerousStyleValue;\n\n/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @providesModule describeComponentFrame\n */\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nvar IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent;\nvar FunctionalComponent = ReactTypeOfWork.FunctionalComponent;\nvar ClassComponent$1 = ReactTypeOfWork.ClassComponent;\nvar HostComponent$2 = ReactTypeOfWork.HostComponent;\n\n\n\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent$1:\n    case HostComponent$2:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName_1(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName_1(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber$1(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nvar ReactFiberComponentTreeHook = {\n  getStackAddendumByWorkInProgressFiber: getStackAddendumByWorkInProgressFiber$1\n};\n\nvar ReactDebugCurrentFrame = ReactGlobalSharedState_1.ReactDebugCurrentFrame;\n\n{\n  var getComponentName$3 = getComponentName_1;\n\n  var _require2$2 = ReactFiberComponentTreeHook,\n      getStackAddendumByWorkInProgressFiber = _require2$2.getStackAddendumByWorkInProgressFiber;\n}\n\nfunction getCurrentFiberOwnerName$2() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    if (fiber._debugOwner != null) {\n      return getComponentName$3(fiber._debugOwner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber, phase) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum$1;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName$2,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum$1\n};\n\nvar ReactDebugCurrentFiber_1 = ReactDebugCurrentFiber;\n\nvar warnValidStyle$1 = emptyFunction;\n\n{\n  var camelizeStyleName$1 = camelizeStyleName;\n  var getComponentName$2 = getComponentName_1;\n  var warning$4 = require$$0;\n\n  var _require$3 = ReactDebugCurrentFiber_1,\n      getCurrentFiberOwnerName$1 = _require$3.getCurrentFiberOwnerName;\n\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n\n\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, owner) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning$4(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName$1(name), checkRenderMessage(owner));\n  };\n\n  var warnBadVendoredStyleName = function (name, owner) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning$4(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner));\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, owner) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning$4(false, \"Style property values shouldn't contain a semicolon.%s \" + 'Try \"%s: %s\" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, ''));\n  };\n\n  var warnStyleValueIsNaN = function (name, value, owner) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning$4(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner));\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, owner) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning$4(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner));\n  };\n\n  var checkRenderMessage = function (owner) {\n    var ownerName;\n    if (owner != null) {\n      // Stack passes the owner manually all the way to CSSPropertyOperations.\n      ownerName = getComponentName$2(owner);\n    } else {\n      // Fiber doesn't pass it but uses ReactDebugCurrentFiber to track it.\n      // It is only enabled in development and tracks host components too.\n      ownerName = getCurrentFiberOwnerName$1();\n      // TODO: also report the stack.\n    }\n    if (ownerName) {\n      return '\\n\\nCheck the render method of `' + ownerName + '`.';\n    }\n    return '';\n  };\n\n  warnValidStyle$1 = function (name, value, component) {\n    var owner;\n    if (component) {\n      // TODO: this only works with Stack. Seems like we need to add unit tests?\n      owner = component._currentElement._owner;\n    }\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, owner);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, owner);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, owner);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, owner);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, owner);\n      }\n    }\n  };\n}\n\nvar warnValidStyle_1 = warnValidStyle$1;\n\n{\n  var hyphenateStyleName$1 = hyphenateStyleName;\n  var warnValidStyle = warnValidStyle_1;\n}\n\nvar hasShorthandPropertyBug = false;\nif (ExecutionEnvironment.canUseDOM) {\n  var tempStyle = document.createElement('div').style;\n  try {\n    // IE8 throws \"Invalid argument.\" if resetting shorthand style properties.\n    tempStyle.font = '';\n  } catch (e) {\n    hasShorthandPropertyBug = true;\n  }\n}\n\n/**\n * Operations for dealing with CSS properties.\n */\nvar CSSPropertyOperations = {\n  /**\n   * This creates a string that is expected to be equivalent to the style\n   * attribute generated by server-side rendering. It by-passes warnings and\n   * security checks so it's not safe to use this value for anything other than\n   * comparison. It is only used in DEV for SSR validation.\n   */\n  createDangerousStringForStyles: function (styles) {\n    {\n      var serialized = '';\n      var delimiter = '';\n      for (var styleName in styles) {\n        if (!styles.hasOwnProperty(styleName)) {\n          continue;\n        }\n        var styleValue = styles[styleName];\n        if (styleValue != null) {\n          var isCustomProperty = styleName.indexOf('--') === 0;\n          serialized += delimiter + hyphenateStyleName$1(styleName) + ':';\n          serialized += dangerousStyleValue_1(styleName, styleValue, isCustomProperty);\n\n          delimiter = ';';\n        }\n      }\n      return serialized || null;\n    }\n  },\n\n  /**\n   * Sets the value for multiple styles on a node.  If a value is specified as\n   * '' (empty string), the corresponding style property will be unset.\n   *\n   * @param {DOMElement} node\n   * @param {object} styles\n   * @param {ReactDOMComponent} component\n   */\n  setValueForStyles: function (node, styles, component) {\n    var style = node.style;\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var isCustomProperty = styleName.indexOf('--') === 0;\n      {\n        if (!isCustomProperty) {\n          warnValidStyle(styleName, styles[styleName], component);\n        }\n      }\n      var styleValue = dangerousStyleValue_1(styleName, styles[styleName], isCustomProperty);\n      if (styleName === 'float') {\n        styleName = 'cssFloat';\n      }\n      if (isCustomProperty) {\n        style.setProperty(styleName, styleValue);\n      } else if (styleValue) {\n        style[styleName] = styleValue;\n      } else {\n        var expansion = hasShorthandPropertyBug && CSSProperty_1.shorthandPropertyExpansions[styleName];\n        if (expansion) {\n          // Shorthand property that IE8 won't like unsetting, so unset each\n          // component to placate it\n          for (var individualStyleName in expansion) {\n            style[individualStyleName] = '';\n          }\n        } else {\n          style[styleName] = '';\n        }\n      }\n    }\n  }\n};\n\nvar CSSPropertyOperations_1 = CSSPropertyOperations;\n\nvar ReactInvalidSetStateWarningHook = {};\n\n{\n  var warning$7 = require$$0;\n  var processingChildContext = false;\n\n  var warnInvalidSetState = function () {\n    warning$7(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()');\n  };\n\n  ReactInvalidSetStateWarningHook = {\n    onBeginProcessingChildContext: function () {\n      processingChildContext = true;\n    },\n    onEndProcessingChildContext: function () {\n      processingChildContext = false;\n    },\n    onSetState: function () {\n      warnInvalidSetState();\n    }\n  };\n}\n\nvar ReactInvalidSetStateWarningHook_1 = ReactInvalidSetStateWarningHook;\n\n/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactHostOperationHistoryHook\n * \n */\n\n// Trust the developer to only use this with a true check\nvar ReactHostOperationHistoryHook = null;\n\n{\n  var history = [];\n\n  ReactHostOperationHistoryHook = {\n    onHostOperation: function (operation) {\n      history.push(operation);\n    },\n    clearHistory: function () {\n      if (ReactHostOperationHistoryHook._preventClearing) {\n        // Should only be used for tests.\n        return;\n      }\n\n      history = [];\n    },\n    getHistory: function () {\n      return history;\n    }\n  };\n}\n\nvar ReactHostOperationHistoryHook_1 = ReactHostOperationHistoryHook;\n\nvar ReactComponentTreeHook = ReactGlobalSharedState_1.ReactComponentTreeHook;\n\n\n\n{\n  var warning$6 = require$$0;\n}\n\n// Trust the developer to only use this with a true check\nvar ReactDebugTool$1 = null;\n\n{\n  var hooks = [];\n  var didHookThrowForEvent = {};\n\n  var callHook = function (event, fn, context, arg1, arg2, arg3, arg4, arg5) {\n    try {\n      fn.call(context, arg1, arg2, arg3, arg4, arg5);\n    } catch (e) {\n      warning$6(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\\n' + e.stack);\n      didHookThrowForEvent[event] = true;\n    }\n  };\n\n  var emitEvent = function (event, arg1, arg2, arg3, arg4, arg5) {\n    for (var i = 0; i < hooks.length; i++) {\n      var hook = hooks[i];\n      var fn = hook[event];\n      if (fn) {\n        callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);\n      }\n    }\n  };\n\n  var isProfiling = false;\n  var flushHistory = [];\n  var lifeCycleTimerStack = [];\n  var currentFlushNesting = 0;\n  var currentFlushMeasurements = [];\n  var currentFlushStartTime = 0;\n  var currentTimerDebugID = null;\n  var currentTimerStartTime = 0;\n  var currentTimerNestedFlushDuration = 0;\n  var currentTimerType = null;\n\n  var lifeCycleTimerHasWarned = false;\n\n  var clearHistory = function () {\n    ReactComponentTreeHook.purgeUnmountedComponents();\n    ReactHostOperationHistoryHook_1.clearHistory();\n  };\n\n  var getTreeSnapshot = function (registeredIDs) {\n    return registeredIDs.reduce(function (tree, id) {\n      var ownerID = ReactComponentTreeHook.getOwnerID(id);\n      var parentID = ReactComponentTreeHook.getParentID(id);\n      tree[id] = {\n        displayName: ReactComponentTreeHook.getDisplayName(id),\n        text: ReactComponentTreeHook.getText(id),\n        updateCount: ReactComponentTreeHook.getUpdateCount(id),\n        childIDs: ReactComponentTreeHook.getChildIDs(id),\n        // Text nodes don't have owners but this is close enough.\n        ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,\n        parentID: parentID\n      };\n      return tree;\n    }, {});\n  };\n\n  var resetMeasurements = function () {\n    var previousStartTime = currentFlushStartTime;\n    var previousMeasurements = currentFlushMeasurements;\n    var previousOperations = ReactHostOperationHistoryHook_1.getHistory();\n\n    if (currentFlushNesting === 0) {\n      currentFlushStartTime = 0;\n      currentFlushMeasurements = [];\n      clearHistory();\n      return;\n    }\n\n    if (previousMeasurements.length || previousOperations.length) {\n      var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();\n      flushHistory.push({\n        duration: performanceNow() - previousStartTime,\n        measurements: previousMeasurements || [],\n        operations: previousOperations || [],\n        treeSnapshot: getTreeSnapshot(registeredIDs)\n      });\n    }\n\n    clearHistory();\n    currentFlushStartTime = performanceNow();\n    currentFlushMeasurements = [];\n  };\n\n  var checkDebugID = function (debugID) {\n    var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (allowRoot && debugID === 0) {\n      return;\n    }\n    if (!debugID) {\n      warning$6(false, 'ReactDebugTool: debugID may not be empty.');\n    }\n  };\n\n  var beginLifeCycleTimer = function (debugID, timerType) {\n    if (currentFlushNesting === 0) {\n      return;\n    }\n    if (currentTimerType && !lifeCycleTimerHasWarned) {\n      warning$6(false, 'There is an internal error in the React performance measurement code.' + '\\n\\nDid not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another');\n      lifeCycleTimerHasWarned = true;\n    }\n    currentTimerStartTime = performanceNow();\n    currentTimerNestedFlushDuration = 0;\n    currentTimerDebugID = debugID;\n    currentTimerType = timerType;\n  };\n\n  var endLifeCycleTimer = function (debugID, timerType) {\n    if (currentFlushNesting === 0) {\n      return;\n    }\n    if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {\n      warning$6(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another');\n      lifeCycleTimerHasWarned = true;\n    }\n    if (isProfiling) {\n      currentFlushMeasurements.push({\n        timerType: timerType,\n        instanceID: debugID,\n        duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration\n      });\n    }\n    currentTimerStartTime = 0;\n    currentTimerNestedFlushDuration = 0;\n    currentTimerDebugID = null;\n    currentTimerType = null;\n  };\n\n  var pauseCurrentLifeCycleTimer = function () {\n    var currentTimer = {\n      startTime: currentTimerStartTime,\n      nestedFlushStartTime: performanceNow(),\n      debugID: currentTimerDebugID,\n      timerType: currentTimerType\n    };\n    lifeCycleTimerStack.push(currentTimer);\n    currentTimerStartTime = 0;\n    currentTimerNestedFlushDuration = 0;\n    currentTimerDebugID = null;\n    currentTimerType = null;\n  };\n\n  var resumeCurrentLifeCycleTimer = function () {\n    var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),\n        startTime = _lifeCycleTimerStack$.startTime,\n        nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,\n        debugID = _lifeCycleTimerStack$.debugID,\n        timerType = _lifeCycleTimerStack$.timerType;\n\n    var nestedFlushDuration = performanceNow() - nestedFlushStartTime;\n    currentTimerStartTime = startTime;\n    currentTimerNestedFlushDuration += nestedFlushDuration;\n    currentTimerDebugID = debugID;\n    currentTimerType = timerType;\n  };\n\n  var lastMarkTimeStamp = 0;\n  var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n  var shouldMark = function (debugID) {\n    if (!isProfiling || !canUsePerformanceMeasure) {\n      return false;\n    }\n    var element = ReactComponentTreeHook.getElement(debugID);\n    if (element == null || typeof element !== 'object') {\n      return false;\n    }\n    var isHostElement = typeof element.type === 'string';\n    if (isHostElement) {\n      return false;\n    }\n    return true;\n  };\n\n  var markBegin = function (debugID, markType) {\n    if (!shouldMark(debugID)) {\n      return;\n    }\n\n    var markName = debugID + '::' + markType;\n    lastMarkTimeStamp = performanceNow();\n    performance.mark(markName);\n  };\n\n  var markEnd = function (debugID, markType) {\n    if (!shouldMark(debugID)) {\n      return;\n    }\n\n    var markName = debugID + '::' + markType;\n    var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';\n\n    // Chrome has an issue of dropping markers recorded too fast:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=640652\n    // To work around this, we will not report very small measurements.\n    // I determined the magic number by tweaking it back and forth.\n    // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.\n    // When the bug is fixed, we can `measure()` unconditionally if we want to.\n    var timeStamp = performanceNow();\n    if (timeStamp - lastMarkTimeStamp > 0.1) {\n      var measurementName = displayName + ' [' + markType + ']';\n      performance.measure(measurementName, markName);\n    }\n\n    performance.clearMarks(markName);\n    if (measurementName) {\n      performance.clearMeasures(measurementName);\n    }\n  };\n\n  ReactDebugTool$1 = {\n    addHook: function (hook) {\n      hooks.push(hook);\n    },\n    removeHook: function (hook) {\n      for (var i = 0; i < hooks.length; i++) {\n        if (hooks[i] === hook) {\n          hooks.splice(i, 1);\n          i--;\n        }\n      }\n    },\n    isProfiling: function () {\n      return isProfiling;\n    },\n    beginProfiling: function () {\n      if (isProfiling) {\n        return;\n      }\n\n      isProfiling = true;\n      flushHistory.length = 0;\n      resetMeasurements();\n      ReactDebugTool$1.addHook(ReactHostOperationHistoryHook_1);\n    },\n    endProfiling: function () {\n      if (!isProfiling) {\n        return;\n      }\n\n      isProfiling = false;\n      resetMeasurements();\n      ReactDebugTool$1.removeHook(ReactHostOperationHistoryHook_1);\n    },\n    getFlushHistory: function () {\n      return flushHistory;\n    },\n    onBeginFlush: function () {\n      currentFlushNesting++;\n      resetMeasurements();\n      pauseCurrentLifeCycleTimer();\n      emitEvent('onBeginFlush');\n    },\n    onEndFlush: function () {\n      resetMeasurements();\n      currentFlushNesting--;\n      resumeCurrentLifeCycleTimer();\n      emitEvent('onEndFlush');\n    },\n    onBeginLifeCycleTimer: function (debugID, timerType) {\n      checkDebugID(debugID);\n      emitEvent('onBeginLifeCycleTimer', debugID, timerType);\n      markBegin(debugID, timerType);\n      beginLifeCycleTimer(debugID, timerType);\n    },\n    onEndLifeCycleTimer: function (debugID, timerType) {\n      checkDebugID(debugID);\n      endLifeCycleTimer(debugID, timerType);\n      markEnd(debugID, timerType);\n      emitEvent('onEndLifeCycleTimer', debugID, timerType);\n    },\n    onBeginProcessingChildContext: function () {\n      emitEvent('onBeginProcessingChildContext');\n    },\n    onEndProcessingChildContext: function () {\n      emitEvent('onEndProcessingChildContext');\n    },\n    onHostOperation: function (operation) {\n      checkDebugID(operation.instanceID);\n      emitEvent('onHostOperation', operation);\n    },\n    onSetState: function () {\n      emitEvent('onSetState');\n    },\n    onSetChildren: function (debugID, childDebugIDs) {\n      checkDebugID(debugID);\n      childDebugIDs.forEach(checkDebugID);\n      emitEvent('onSetChildren', debugID, childDebugIDs);\n    },\n    onBeforeMountComponent: function (debugID, element, parentDebugID) {\n      checkDebugID(debugID);\n      checkDebugID(parentDebugID, true);\n      emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);\n      markBegin(debugID, 'mount');\n    },\n    onMountComponent: function (debugID) {\n      checkDebugID(debugID);\n      markEnd(debugID, 'mount');\n      emitEvent('onMountComponent', debugID);\n    },\n    onBeforeUpdateComponent: function (debugID, element) {\n      checkDebugID(debugID);\n      emitEvent('onBeforeUpdateComponent', debugID, element);\n      markBegin(debugID, 'update');\n    },\n    onUpdateComponent: function (debugID) {\n      checkDebugID(debugID);\n      markEnd(debugID, 'update');\n      emitEvent('onUpdateComponent', debugID);\n    },\n    onBeforeUnmountComponent: function (debugID) {\n      checkDebugID(debugID);\n      emitEvent('onBeforeUnmountComponent', debugID);\n      markBegin(debugID, 'unmount');\n    },\n    onUnmountComponent: function (debugID) {\n      checkDebugID(debugID);\n      markEnd(debugID, 'unmount');\n      emitEvent('onUnmountComponent', debugID);\n    },\n    onTestEvent: function () {\n      emitEvent('onTestEvent');\n    }\n  };\n\n  ReactDebugTool$1.addHook(ReactInvalidSetStateWarningHook_1);\n  ReactDebugTool$1.addHook(ReactComponentTreeHook);\n  var url = ExecutionEnvironment.canUseDOM && window.location.href || '';\n  if (/[?&]react_perf\\b/.test(url)) {\n    ReactDebugTool$1.beginProfiling();\n  }\n}\n\nvar ReactDebugTool_1 = ReactDebugTool$1;\n\n// Trust the developer to only use ReactInstrumentation with a true check\n\nvar debugTool = null;\n\n{\n  var ReactDebugTool = ReactDebugTool_1;\n  debugTool = ReactDebugTool;\n}\n\nvar ReactInstrumentation = { debugTool: debugTool };\n\n{\n  var warning$5 = require$$0;\n}\n\n// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty_1.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning$5(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\n// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nfunction shouldIgnoreValue(propertyInfo, value) {\n  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\nvar DOMPropertyOperations = {\n  setAttributeForID: function (node, id) {\n    node.setAttribute(DOMProperty_1.ID_ATTRIBUTE_NAME, id);\n  },\n\n  setAttributeForRoot: function (node) {\n    node.setAttribute(DOMProperty_1.ROOT_ATTRIBUTE_NAME, '');\n  },\n\n  /**\n   * Get the value for a property on a node. Only used in DEV for SSR validation.\n   * The \"expected\" argument is used as a hint of what the expected value is.\n   * Some properties have multiple equivalent values.\n   */\n  getValueForProperty: function (node, name, expected) {\n    {\n      var propertyInfo = DOMProperty_1.getPropertyInfo(name);\n      if (propertyInfo) {\n        var mutationMethod = propertyInfo.mutationMethod;\n        if (mutationMethod || propertyInfo.mustUseProperty) {\n          return node[propertyInfo.propertyName];\n        } else {\n          var attributeName = propertyInfo.attributeName;\n\n          var stringValue = null;\n\n          if (propertyInfo.hasOverloadedBooleanValue) {\n            if (node.hasAttribute(attributeName)) {\n              var value = node.getAttribute(attributeName);\n              if (value === '') {\n                return true;\n              }\n              if (shouldIgnoreValue(propertyInfo, expected)) {\n                return value;\n              }\n              if (value === '' + expected) {\n                return expected;\n              }\n              return value;\n            }\n          } else if (node.hasAttribute(attributeName)) {\n            if (shouldIgnoreValue(propertyInfo, expected)) {\n              // We had an attribute but shouldn't have had one, so read it\n              // for the error message.\n              return node.getAttribute(attributeName);\n            }\n            if (propertyInfo.hasBooleanValue) {\n              // If this was a boolean, it doesn't matter what the value is\n              // the fact that we have it is the same as the expected.\n              return expected;\n            }\n            // Even if this property uses a namespace we use getAttribute\n            // because we assume its namespaced name is the same as our config.\n            // To use getAttributeNS we need the local name which we don't have\n            // in our config atm.\n            stringValue = node.getAttribute(attributeName);\n          }\n\n          if (shouldIgnoreValue(propertyInfo, expected)) {\n            return stringValue === null ? expected : stringValue;\n          } else if (stringValue === '' + expected) {\n            return expected;\n          } else {\n            return stringValue;\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n   * The third argument is used as a hint of what the expected value is. Some\n   * attributes have multiple equivalent values.\n   */\n  getValueForAttribute: function (node, name, expected) {\n    {\n      if (!isAttributeNameSafe(name)) {\n        return;\n      }\n      if (!node.hasAttribute(name)) {\n        return expected === undefined ? undefined : null;\n      }\n      var value = node.getAttribute(name);\n      if (value === '' + expected) {\n        return expected;\n      }\n      return value;\n    }\n  },\n\n  /**\n   * Sets the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   * @param {*} value\n   */\n  setValueForProperty: function (node, name, value) {\n    var propertyInfo = DOMProperty_1.getPropertyInfo(name);\n\n    if (propertyInfo && DOMProperty_1.shouldSetAttribute(name, value)) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod) {\n        mutationMethod(node, value);\n      } else if (shouldIgnoreValue(propertyInfo, value)) {\n        DOMPropertyOperations.deleteValueForProperty(node, name);\n        return;\n      } else if (propertyInfo.mustUseProperty) {\n        // Contrary to `setAttribute`, object properties are properly\n        // `toString`ed by IE8/9.\n        node[propertyInfo.propertyName] = value;\n      } else {\n        var attributeName = propertyInfo.attributeName;\n        var namespace = propertyInfo.attributeNamespace;\n        // `setAttribute` with objects becomes only `[object]` in IE8/9,\n        // ('' + value) makes it output the correct toString()-value.\n        if (namespace) {\n          node.setAttributeNS(namespace, attributeName, '' + value);\n        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n          node.setAttribute(attributeName, '');\n        } else {\n          node.setAttribute(attributeName, '' + value);\n        }\n      }\n    } else {\n      DOMPropertyOperations.setValueForAttribute(node, name, DOMProperty_1.shouldSetAttribute(name, value) ? value : null);\n      return;\n    }\n\n    {\n      var payload = {};\n      payload[name] = value;\n      ReactInstrumentation.debugTool.onHostOperation({\n        instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n        type: 'update attribute',\n        payload: payload\n      });\n    }\n  },\n\n  setValueForAttribute: function (node, name, value) {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (value == null) {\n      node.removeAttribute(name);\n    } else {\n      node.setAttribute(name, '' + value);\n    }\n\n    {\n      var payload = {};\n      payload[name] = value;\n      ReactInstrumentation.debugTool.onHostOperation({\n        instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n        type: 'update attribute',\n        payload: payload\n      });\n    }\n  },\n\n  /**\n   * Deletes an attributes from a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   */\n  deleteValueForAttribute: function (node, name) {\n    node.removeAttribute(name);\n    {\n      ReactInstrumentation.debugTool.onHostOperation({\n        instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n        type: 'remove attribute',\n        payload: name\n      });\n    }\n  },\n\n  /**\n   * Deletes the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   */\n  deleteValueForProperty: function (node, name) {\n    var propertyInfo = DOMProperty_1.getPropertyInfo(name);\n    if (propertyInfo) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod) {\n        mutationMethod(node, undefined);\n      } else if (propertyInfo.mustUseProperty) {\n        var propName = propertyInfo.propertyName;\n        if (propertyInfo.hasBooleanValue) {\n          node[propName] = false;\n        } else {\n          node[propName] = '';\n        }\n      } else {\n        node.removeAttribute(propertyInfo.attributeName);\n      }\n    } else {\n      node.removeAttribute(name);\n    }\n\n    {\n      ReactInstrumentation.debugTool.onHostOperation({\n        instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n        type: 'remove attribute',\n        payload: name\n      });\n    }\n  }\n};\n\nvar DOMPropertyOperations_1 = DOMPropertyOperations;\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var warning$9 = require$$0;\n  var emptyFunction$2 = emptyFunction;\n  var PropTypes = propTypes;\n  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\n  ReactControlledValuePropTypes.checkPropTypes = emptyFunction$2;\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes$1 = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    onChange: PropTypes.func\n  };\n\n  var loggedTypeFailures = {};\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    for (var propName in propTypes$1) {\n      if (propTypes$1.hasOwnProperty(propName)) {\n        var error = propTypes$1[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);\n      }\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true;\n\n        warning$9(false, 'Failed form propType: %s%s', error.message, getStack());\n      }\n    }\n  };\n}\n\nvar ReactControlledValuePropTypes_1 = ReactControlledValuePropTypes;\n\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber_1.getCurrentFiberOwnerName;\n\n{\n  var _require2$3 = ReactDebugCurrentFiber_1,\n      getCurrentFiberStackAddendum$2 = _require2$3.getCurrentFiberStackAddendum;\n\n  var warning$8 = require$$0;\n}\n\n\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\nvar ReactDOMInput = {\n  getHostProps: function (element, props) {\n    var node = element;\n    var value = props.value;\n    var checked = props.checked;\n\n    var hostProps = _assign({\n      // Make sure we set .type before any other properties (setting .value\n      // before .type means .value is lost in IE11 and below)\n      type: undefined,\n      // Make sure we set .step before .value (setting .value before .step\n      // means .value is rounded on mount, based upon step precision)\n      step: undefined,\n      // Make sure we set .min & .max before .value (to ensure proper order\n      // in corner cases such as min or max deriving from value, e.g. Issue #7170)\n      min: undefined,\n      max: undefined\n    }, props, {\n      defaultChecked: undefined,\n      defaultValue: undefined,\n      value: value != null ? value : node._wrapperState.initialValue,\n      checked: checked != null ? checked : node._wrapperState.initialChecked\n    });\n\n    return hostProps;\n  },\n\n  initWrapperState: function (element, props) {\n    {\n      ReactControlledValuePropTypes_1.checkPropTypes('input', props, getCurrentFiberStackAddendum$2);\n\n      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n        warning$8(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$3() || 'A component', props.type);\n        didWarnCheckedDefaultChecked = true;\n      }\n      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n        warning$8(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$3() || 'A component', props.type);\n        didWarnValueDefaultValue = true;\n      }\n    }\n\n    var defaultValue = props.defaultValue;\n    var node = element;\n    node._wrapperState = {\n      initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n      initialValue: props.value != null ? props.value : defaultValue,\n      controlled: isControlled(props)\n    };\n  },\n\n  updateWrapper: function (element, props) {\n    var node = element;\n    {\n      var controlled = isControlled(props);\n\n      if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n        warning$8(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$2());\n        didWarnUncontrolledToControlled = true;\n      }\n      if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n        warning$8(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$2());\n        didWarnControlledToUncontrolled = true;\n      }\n    }\n\n    var checked = props.checked;\n    if (checked != null) {\n      DOMPropertyOperations_1.setValueForProperty(node, 'checked', checked || false);\n    }\n\n    var value = props.value;\n    if (value != null) {\n      if (value === 0 && node.value === '') {\n        node.value = '0';\n        // Note: IE9 reports a number inputs as 'text', so check props instead.\n      } else if (props.type === 'number') {\n        // Simulate `input.valueAsNumber`. IE9 does not support it\n        var valueAsNumber = parseFloat(node.value) || 0;\n\n        if (\n        // eslint-disable-next-line\n        value != valueAsNumber ||\n        // eslint-disable-next-line\n        value == valueAsNumber && node.value != value) {\n          // Cast `value` to a string to ensure the value is set correctly. While\n          // browsers typically do this as necessary, jsdom doesn't.\n          node.value = '' + value;\n        }\n      } else if (node.value !== '' + value) {\n        // Cast `value` to a string to ensure the value is set correctly. While\n        // browsers typically do this as necessary, jsdom doesn't.\n        node.value = '' + value;\n      }\n    } else {\n      if (props.value == null && props.defaultValue != null) {\n        // In Chrome, assigning defaultValue to certain input types triggers input validation.\n        // For number inputs, the display value loses trailing decimal points. For email inputs,\n        // Chrome raises \"The specified value <x> is not a valid email address\".\n        //\n        // Here we check to see if the defaultValue has actually changed, avoiding these problems\n        // when the user is inputting text\n        //\n        // https://github.com/facebook/react/issues/7253\n        if (node.defaultValue !== '' + props.defaultValue) {\n          node.defaultValue = '' + props.defaultValue;\n        }\n      }\n      if (props.checked == null && props.defaultChecked != null) {\n        node.defaultChecked = !!props.defaultChecked;\n      }\n    }\n  },\n\n  postMountWrapper: function (element, props) {\n    var node = element;\n\n    // Detach value from defaultValue. We won't do anything if we're working on\n    // submit or reset inputs as those values & defaultValues are linked. They\n    // are not resetable nodes so this operation doesn't matter and actually\n    // removes browser-default values (eg \"Submit Query\") when no value is\n    // provided.\n\n    switch (props.type) {\n      case 'submit':\n      case 'reset':\n        break;\n      case 'color':\n      case 'date':\n      case 'datetime':\n      case 'datetime-local':\n      case 'month':\n      case 'time':\n      case 'week':\n        // This fixes the no-show issue on iOS Safari and Android Chrome:\n        // https://github.com/facebook/react/issues/7233\n        node.value = '';\n        node.value = node.defaultValue;\n        break;\n      default:\n        node.value = node.value;\n        break;\n    }\n\n    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n    // this is needed to work around a chrome bug where setting defaultChecked\n    // will sometimes influence the value of checked (even after detachment).\n    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n    // We need to temporarily unset name to avoid disrupting radio button groups.\n    var name = node.name;\n    if (name !== '') {\n      node.name = '';\n    }\n    node.defaultChecked = !node.defaultChecked;\n    node.defaultChecked = !node.defaultChecked;\n    if (name !== '') {\n      node.name = name;\n    }\n  },\n\n  restoreControlledState: function (element, props) {\n    var node = element;\n    ReactDOMInput.updateWrapper(node, props);\n    updateNamedCousins(node, props);\n  }\n};\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = ReactDOMComponentTree_1.getFiberCurrentPropsFromNode(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      ReactDOMInput.updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\nvar ReactDOMFiberInput = ReactDOMInput;\n\n{\n  var warning$10 = require$$0;\n}\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  react.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\nvar ReactDOMOption = {\n  validateProps: function (element, props) {\n    // TODO (yungsters): Remove support for `selected` in <option>.\n    {\n      warning$10(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n    }\n  },\n\n  postMountWrapper: function (element, props) {\n    // value=\"\" should make a value attribute (#6219)\n    if (props.value != null) {\n      element.setAttribute('value', props.value);\n    }\n  },\n\n  getHostProps: function (element, props) {\n    var hostProps = _assign({ children: undefined }, props);\n\n    var content = flattenChildren(props.children);\n\n    if (content) {\n      hostProps.children = content;\n    }\n\n    return hostProps;\n  }\n};\n\nvar ReactDOMFiberOption = ReactDOMOption;\n\nvar getCurrentFiberOwnerName$4 = ReactDebugCurrentFiber_1.getCurrentFiberOwnerName;\n\n{\n  var didWarnValueDefaultValue$1 = false;\n  var warning$11 = require$$0;\n\n  var _require2$4 = ReactDebugCurrentFiber_1,\n      getCurrentFiberStackAddendum$3 = _require2$4.getCurrentFiberStackAddendum;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$4();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes_1.checkPropTypes('select', props, getCurrentFiberStackAddendum$3);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning$11(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning$11(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\nvar ReactDOMSelect = {\n  getHostProps: function (element, props) {\n    return _assign({}, props, {\n      value: undefined\n    });\n  },\n\n  initWrapperState: function (element, props) {\n    var node = element;\n    {\n      checkSelectPropTypes(props);\n    }\n\n    var value = props.value;\n    node._wrapperState = {\n      initialValue: value != null ? value : props.defaultValue,\n      wasMultiple: !!props.multiple\n    };\n\n    {\n      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n        warning$11(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n        didWarnValueDefaultValue$1 = true;\n      }\n    }\n  },\n\n  postMountWrapper: function (element, props) {\n    var node = element;\n    node.multiple = !!props.multiple;\n    var value = props.value;\n    if (value != null) {\n      updateOptions(node, !!props.multiple, value);\n    } else if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue);\n    }\n  },\n\n  postUpdateWrapper: function (element, props) {\n    var node = element;\n    // After the initial mount, we control selected-ness manually so don't pass\n    // this value down\n    node._wrapperState.initialValue = undefined;\n\n    var wasMultiple = node._wrapperState.wasMultiple;\n    node._wrapperState.wasMultiple = !!props.multiple;\n\n    var value = props.value;\n    if (value != null) {\n      updateOptions(node, !!props.multiple, value);\n    } else if (wasMultiple !== !!props.multiple) {\n      // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n      if (props.defaultValue != null) {\n        updateOptions(node, !!props.multiple, props.defaultValue);\n      } else {\n        // Revert the select back to its default unselected state.\n        updateOptions(node, !!props.multiple, props.multiple ? [] : '');\n      }\n    }\n  },\n\n  restoreControlledState: function (element, props) {\n    var node = element;\n    var value = props.value;\n\n    if (value != null) {\n      updateOptions(node, !!props.multiple, value);\n    }\n  }\n};\n\nvar ReactDOMFiberSelect = ReactDOMSelect;\n\n{\n  var warning$12 = require$$0;\n\n  var _require$4 = ReactDebugCurrentFiber_1,\n      getCurrentFiberStackAddendum$4 = _require$4.getCurrentFiberStackAddendum;\n}\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\nvar ReactDOMTextarea = {\n  getHostProps: function (element, props) {\n    var node = element;\n    !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n    // Always set children to the same thing. In IE9, the selection range will\n    // get reset if `textContent` is mutated.  We could add a check in setTextContent\n    // to only set the value if/when the value differs from the node value (which would\n    // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n    // solution. The value can be a boolean or object so that's why it's forced\n    // to be a string.\n    var hostProps = _assign({}, props, {\n      value: undefined,\n      defaultValue: undefined,\n      children: '' + node._wrapperState.initialValue\n    });\n\n    return hostProps;\n  },\n\n  initWrapperState: function (element, props) {\n    var node = element;\n    {\n      ReactControlledValuePropTypes_1.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$4);\n      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n        warning$12(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n        didWarnValDefaultVal = true;\n      }\n    }\n\n    var value = props.value;\n    var initialValue = value;\n\n    // Only bother fetching default value if we're going to use it\n    if (value == null) {\n      var defaultValue = props.defaultValue;\n      // TODO (yungsters): Remove support for children content in <textarea>.\n      var children = props.children;\n      if (children != null) {\n        {\n          warning$12(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n        }\n        !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n        if (Array.isArray(children)) {\n          !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n          children = children[0];\n        }\n\n        defaultValue = '' + children;\n      }\n      if (defaultValue == null) {\n        defaultValue = '';\n      }\n      initialValue = defaultValue;\n    }\n\n    node._wrapperState = {\n      initialValue: '' + initialValue\n    };\n  },\n\n  updateWrapper: function (element, props) {\n    var node = element;\n    var value = props.value;\n    if (value != null) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      var newValue = '' + value;\n\n      // To avoid side effects (such as losing text selection), only set value if changed\n      if (newValue !== node.value) {\n        node.value = newValue;\n      }\n      if (props.defaultValue == null) {\n        node.defaultValue = newValue;\n      }\n    }\n    if (props.defaultValue != null) {\n      node.defaultValue = props.defaultValue;\n    }\n  },\n\n  postMountWrapper: function (element, props) {\n    var node = element;\n    // This is in postMount because we need access to the DOM node, which is not\n    // available until after the component has mounted.\n    var textContent = node.textContent;\n\n    // Only set node.value if textContent is equal to the expected\n    // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n    // will populate textContent as well.\n    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n    if (textContent === node._wrapperState.initialValue) {\n      node.value = textContent;\n    }\n  },\n\n  restoreControlledState: function (element, props) {\n    // DOM component is still mounted; update\n    ReactDOMTextarea.updateWrapper(element, props);\n  }\n};\n\nvar ReactDOMFiberTextarea = ReactDOMTextarea;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule omittedCloseTags\n */\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nvar omittedCloseTags_1 = omittedCloseTags;\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags_1);\n\nvar voidElementTags_1 = voidElementTags;\n\n{\n  var warning$13 = require$$0;\n}\n\nvar HTML$1 = '__html';\n\nfunction getDeclarationErrorAddendum$1(getCurrentOwnerName) {\n  {\n    var ownerName = getCurrentOwnerName();\n    if (ownerName) {\n      // TODO: also report the stack.\n      return '\\n\\nThis DOM node was rendered by `' + ownerName + '`.';\n    }\n  }\n  return '';\n}\n\nfunction assertValidProps(tag, props, getCurrentOwnerName) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags_1[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getDeclarationErrorAddendum$1(getCurrentOwnerName)) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    warning$13(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getDeclarationErrorAddendum$1(getCurrentOwnerName)) : void 0;\n}\n\nvar assertValidProps_1 = assertValidProps;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule inputValueTracking\n * \n */\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable,\n    configurable: true,\n    get: function () {\n      return descriptor.get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      descriptor.set.call(this, value);\n    }\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nvar inputValueTracking = {\n  // exposed for testing\n  _getTrackerFromNode: getTracker,\n\n  track: function (node) {\n    if (getTracker(node)) {\n      return;\n    }\n\n    // TODO: Once it's just Fiber we can move this to node._wrapperState\n    node._valueTracker = trackValueOnNode(node);\n  },\n  updateValueIfChanged: function (node) {\n    if (!node) {\n      return false;\n    }\n\n    var tracker = getTracker(node);\n    // if there is no tracker at this point it's unlikely\n    // that trying again will succeed\n    if (!tracker) {\n      return true;\n    }\n\n    var lastValue = tracker.getValue();\n    var nextValue = getValueFromNode(node);\n    if (nextValue !== lastValue) {\n      tracker.setValue(nextValue);\n      return true;\n    }\n    return false;\n  },\n  stopTracking: function (node) {\n    var tracker = getTracker(node);\n    if (tracker) {\n      tracker.stopTracking();\n    }\n  }\n};\n\nvar inputValueTracking_1 = inputValueTracking;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule isCustomComponent\n * \n */\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\nvar isCustomComponent_1 = isCustomComponent;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule createMicrosoftUnsafeLocalFunction\n */\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\n\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\nvar createMicrosoftUnsafeLocalFunction_1 = createMicrosoftUnsafeLocalFunction;\n\nvar Namespaces$1 = DOMNamespaces.Namespaces;\n\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction_1(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n  if (node.namespaceURI === Namespaces$1.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\nvar setInnerHTML_1 = setInnerHTML;\n\n/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Based on the escape-html library, which is used under the MIT License below:\n *\n * Copyright (c) 2012-2013 TJ Holowaychuk\n * Copyright (c) 2015 Andreas Lubbe\n * Copyright (c) 2015 Tiancheng \"Timothy\" Gu\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * @providesModule escapeTextContentForBrowser\n */\n\n// code copied and modified from escape-html\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        // \"\n        escape = '&quot;';\n        break;\n      case 38:\n        // &\n        escape = '&amp;';\n        break;\n      case 39:\n        // '\n        escape = '&#x27;'; // modified from escape-html; used to be '&#39'\n        break;\n      case 60:\n        // <\n        escape = '&lt;';\n        break;\n      case 62:\n        // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n}\n// end code copied and modified from escape-html\n\n/**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */\nfunction escapeTextContentForBrowser(text) {\n  if (typeof text === 'boolean' || typeof text === 'number') {\n    // this shortcircuit helps perf for types that we know will never have\n    // special characters, especially given that this function is used often\n    // for numeric dom ids.\n    return '' + text;\n  }\n  return escapeHtml(text);\n}\n\nvar escapeTextContentForBrowser_1 = escapeTextContentForBrowser;\n\nvar TEXT_NODE$2 = HTMLNodeType_1.TEXT_NODE;\n\n/**\n * Set the textContent property of a node, ensuring that whitespace is preserved\n * even in IE8. innerText is a poor substitute for textContent and, among many\n * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n * as it should.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\n\n\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE$2) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  if (!('textContent' in document.documentElement)) {\n    setTextContent = function (node, text) {\n      if (node.nodeType === TEXT_NODE$2) {\n        node.nodeValue = text;\n        return;\n      }\n      setInnerHTML_1(node, escapeTextContentForBrowser_1(text));\n    };\n  }\n}\n\nvar setTextContent_1 = setTextContent;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule validAriaProperties\n */\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar validAriaProperties$1 = ariaProperties;\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n{\n  var warning$14 = require$$0;\n\n  var _require$5 = ReactGlobalSharedState_1,\n      ReactComponentTreeHook$1 = _require$5.ReactComponentTreeHook,\n      ReactDebugCurrentFrame$1 = _require$5.ReactDebugCurrentFrame;\n\n  var getStackAddendumByID = ReactComponentTreeHook$1.getStackAddendumByID;\n\n\n  var validAriaProperties = validAriaProperties$1;\n}\n\nfunction getStackAddendum(debugID) {\n  if (debugID != null) {\n    // This can only happen on Stack\n    return getStackAddendumByID(debugID);\n  } else {\n    // This can only happen on Fiber / Server\n    var stack = ReactDebugCurrentFrame$1.getStackAddendum();\n    return stack != null ? stack : '';\n  }\n}\n\nfunction validateProperty(tagName, name, debugID) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = validAriaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning$14(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum(debugID));\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning$14(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum(debugID));\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = validAriaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning$14(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum(debugID));\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props, debugID) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key, debugID);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning$14(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum(debugID));\n  } else if (invalidProps.length > 1) {\n    warning$14(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum(debugID));\n  }\n}\n\nfunction validateProperties(type, props, debugID /* Stack only */) {\n  if (isCustomComponent_1(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props, debugID);\n}\n\nvar ReactDOMInvalidARIAHook$1 = {\n  // Fiber\n  validateProperties: validateProperties,\n  // Stack\n  onBeforeMountComponent: function (debugID, element) {\n    if (true && element != null && typeof element.type === 'string') {\n      validateProperties(element.type, element.props, debugID);\n    }\n  },\n  onBeforeUpdateComponent: function (debugID, element) {\n    if (true && element != null && typeof element.type === 'string') {\n      validateProperties(element.type, element.props, debugID);\n    }\n  }\n};\n\nvar ReactDOMInvalidARIAHook_1 = ReactDOMInvalidARIAHook$1;\n\n{\n  var warning$15 = require$$0;\n\n  var _require$6 = ReactGlobalSharedState_1,\n      ReactComponentTreeHook$2 = _require$6.ReactComponentTreeHook,\n      ReactDebugCurrentFrame$2 = _require$6.ReactDebugCurrentFrame;\n\n  var getStackAddendumByID$1 = ReactComponentTreeHook$2.getStackAddendumByID;\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1(debugID) {\n  if (debugID != null) {\n    // This can only happen on Stack\n    return getStackAddendumByID$1(debugID);\n  } else {\n    // This can only happen on Fiber / Server\n    var stack = ReactDebugCurrentFrame$2.getStackAddendum();\n    return stack != null ? stack : '';\n  }\n}\n\nfunction validateProperties$1(type, props, debugID /* Stack only */) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n  if (props != null && props.value === null && !didWarnValueNull) {\n    warning$15(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1(debugID));\n\n    didWarnValueNull = true;\n  }\n}\n\nvar ReactDOMNullInputValuePropHook$1 = {\n  // Fiber\n  validateProperties: validateProperties$1,\n  // Stack\n  onBeforeMountComponent: function (debugID, element) {\n    if (true && element != null && typeof element.type === 'string') {\n      validateProperties$1(element.type, element.props, debugID);\n    }\n  },\n  onBeforeUpdateComponent: function (debugID, element) {\n    if (true && element != null && typeof element.type === 'string') {\n      validateProperties$1(element.type, element.props, debugID);\n    }\n  }\n};\n\nvar ReactDOMNullInputValuePropHook_1 = ReactDOMNullInputValuePropHook$1;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule possibleStandardNames\n */\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames$1 = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  'class': 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  'default': 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  'for': 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  'in': 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  'typeof': 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nvar possibleStandardNames_1 = possibleStandardNames$1;\n\n{\n  var warning$16 = require$$0;\n\n  var _require$7 = ReactGlobalSharedState_1,\n      ReactComponentTreeHook$3 = _require$7.ReactComponentTreeHook,\n      ReactDebugCurrentFrame$3 = _require$7.ReactDebugCurrentFrame;\n\n  var getStackAddendumByID$2 = ReactComponentTreeHook$3.getStackAddendumByID;\n}\n\nfunction getStackAddendum$2(debugID) {\n  if (debugID != null) {\n    // This can only happen on Stack\n    return getStackAddendumByID$2(debugID);\n  } else {\n    // This can only happen on Fiber / Server\n    var stack = ReactDebugCurrentFrame$3.getStackAddendum();\n    return stack != null ? stack : '';\n  }\n}\n\n{\n  var warnedProperties$1 = {};\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on[A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n  var possibleStandardNames = possibleStandardNames_1;\n\n  var validateProperty$1 = function (tagName, name, value, debugID) {\n    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    if (EventPluginRegistry_1.registrationNameModules.hasOwnProperty(name)) {\n      return true;\n    }\n\n    if (EventPluginRegistry_1.plugins.length === 0 && EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we might be in a server environment.\n      // Don't check events in this case.\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    var registrationName = EventPluginRegistry_1.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry_1.possibleRegistrationNames[lowerCasedName] : null;\n\n    if (registrationName != null) {\n      warning$16(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2(debugID));\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName.indexOf('on') === 0) {\n      warning$16(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2(debugID));\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning$16(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning$16(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning$16(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning$16(false, 'Received a `%s` for string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2(debugID));\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning$16(false, 'Received NaN for numeric attribute `%s`. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2(debugID));\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var isReserved = DOMProperty_1.isReservedProp(name);\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning$16(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2(debugID));\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning$16(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2(debugID));\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean') {\n      warning$16(DOMProperty_1.shouldAttributeAcceptBooleanValue(name), 'Received `%s` for non-boolean attribute `%s`. If this is expected, cast ' + 'the value to a string.%s', value, name, getStackAddendum$2(debugID));\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (!DOMProperty_1.shouldSetAttribute(name, value)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, debugID) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], debugID);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning$16(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2(debugID));\n  } else if (unknownProps.length > 1) {\n    warning$16(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2(debugID));\n  }\n};\n\nfunction validateProperties$2(type, props, debugID /* Stack only */) {\n  if (isCustomComponent_1(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, debugID);\n}\n\nvar ReactDOMUnknownPropertyHook$1 = {\n  // Fiber\n  validateProperties: validateProperties$2,\n  // Stack\n  onBeforeMountComponent: function (debugID, element) {\n    if (true && element != null && typeof element.type === 'string') {\n      validateProperties$2(element.type, element.props, debugID);\n    }\n  },\n  onBeforeUpdateComponent: function (debugID, element) {\n    if (true && element != null && typeof element.type === 'string') {\n      validateProperties$2(element.type, element.props, debugID);\n    }\n  }\n};\n\nvar ReactDOMUnknownPropertyHook_1 = ReactDOMUnknownPropertyHook$1;\n\nvar getCurrentFiberOwnerName = ReactDebugCurrentFiber_1.getCurrentFiberOwnerName;\n\nvar DOCUMENT_NODE$1 = HTMLNodeType_1.DOCUMENT_NODE;\nvar DOCUMENT_FRAGMENT_NODE$1 = HTMLNodeType_1.DOCUMENT_FRAGMENT_NODE;\n\n\n\n\n\n\n\n\n{\n  var warning$3 = require$$0;\n\n  var _require3$1 = ReactDebugCurrentFiber_1,\n      getCurrentFiberStackAddendum = _require3$1.getCurrentFiberStackAddendum;\n\n  var ReactDOMInvalidARIAHook = ReactDOMInvalidARIAHook_1;\n  var ReactDOMNullInputValuePropHook = ReactDOMNullInputValuePropHook_1;\n  var ReactDOMUnknownPropertyHook = ReactDOMUnknownPropertyHook_1;\n  var validateARIAProperties = ReactDOMInvalidARIAHook.validateProperties;\n  var validateInputProperties = ReactDOMNullInputValuePropHook.validateProperties;\n  var validateUnknownProperties = ReactDOMUnknownPropertyHook.validateProperties;\n}\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar listenTo = ReactBrowserEventEmitter_1.listenTo;\nvar registrationNameModules = EventPluginRegistry_1.registrationNameModules;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE$1 = DOMNamespaces.Namespaces.html;\nvar getIntrinsicNamespace$1 = DOMNamespaces.getIntrinsicNamespace;\n\n\n{\n  var warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true\n  };\n\n  var validatePropertiesInDevelopment = function (type, props) {\n    validateARIAProperties(type, props);\n    validateInputProperties(type, props);\n    validateUnknownProperties(type, props);\n  };\n\n  var warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning$3(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', serverText, clientText);\n  };\n\n  var warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning$3(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(serverValue), JSON.stringify(clientValue));\n  };\n\n  var warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning$3(false, 'Extra attributes from the server: %s', names);\n  };\n\n  var warnForInvalidEventListener = function (registrationName, listener) {\n    warning$3(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum());\n  };\n\n  var testDocument;\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  var normalizeHTML = function (parent, html) {\n    if (!testDocument) {\n      testDocument = document.implementation.createHTMLDocument();\n    }\n    var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? testDocument.createElement(parent.tagName) : testDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE$1 || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE$1;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE$1 ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\n// There are so many media events, it makes sense to just\n// maintain a list rather than create a `trapBubbledEvent` for each\nvar mediaEvents = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction;\n}\n\nfunction setInitialDOMProperties(domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      CSSPropertyOperations_1.setValueForStyles(domElement, nextProp);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML_1(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        setTextContent_1(domElement, nextProp);\n      } else if (typeof nextProp === 'number') {\n        setTextContent_1(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (isCustomComponentTag) {\n      DOMPropertyOperations_1.setValueForAttribute(domElement, propKey, nextProp);\n    } else if (nextProp != null) {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      DOMPropertyOperations_1.setValueForProperty(domElement, propKey, nextProp);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      CSSPropertyOperations_1.setValueForStyles(domElement, propValue);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML_1(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent_1(domElement, propValue);\n    } else if (isCustomComponentTag) {\n      if (propValue != null) {\n        DOMPropertyOperations_1.setValueForAttribute(domElement, propKey, propValue);\n      } else {\n        DOMPropertyOperations_1.deleteValueForAttribute(domElement, propKey);\n      }\n    } else if (propValue != null) {\n      DOMPropertyOperations_1.setValueForProperty(domElement, propKey, propValue);\n    } else {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      DOMPropertyOperations_1.deleteValueForProperty(domElement, propKey);\n    }\n  }\n}\n\nvar ReactDOMFiberComponent = {\n  createElement: function (type, props, rootContainerElement, parentNamespace) {\n    // We create tags in the namespace of their parent container, except HTML\n    var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n    var domElement;\n    var namespaceURI = parentNamespace;\n    if (namespaceURI === HTML_NAMESPACE$1) {\n      namespaceURI = getIntrinsicNamespace$1(type);\n    }\n    if (namespaceURI === HTML_NAMESPACE$1) {\n      {\n        var isCustomComponentTag = isCustomComponent_1(type, props);\n        // Should this check be gated by parent namespace? Not sure we want to\n        // allow <SVG> or <mATH>.\n        warning$3(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);\n      }\n\n      if (type === 'script') {\n        // Create the script via .innerHTML so its \"parser-inserted\" flag is\n        // set to true and it does not execute\n        var div = ownerDocument.createElement('div');\n        div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n        // This is guaranteed to yield a script element.\n        var firstChild = div.firstChild;\n        domElement = div.removeChild(firstChild);\n      } else if (typeof props.is === 'string') {\n        // $FlowIssue `createElement` should be updated for Web Components\n        domElement = ownerDocument.createElement(type, { is: props.is });\n      } else {\n        // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n        // See discussion in https://github.com/facebook/react/pull/6896\n        // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n        domElement = ownerDocument.createElement(type);\n      }\n    } else {\n      domElement = ownerDocument.createElementNS(namespaceURI, type);\n    }\n\n    {\n      if (namespaceURI === HTML_NAMESPACE$1) {\n        if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n          warnedUnknownTags[type] = true;\n          warning$3(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n        }\n      }\n    }\n\n    return domElement;\n  },\n  createTextNode: function (text, rootContainerElement) {\n    return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n  },\n  setInitialProperties: function (domElement, tag, rawProps, rootContainerElement) {\n    var isCustomComponentTag = isCustomComponent_1(tag, rawProps);\n    {\n      validatePropertiesInDevelopment(tag, rawProps);\n      if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n        warning$3(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName() || 'A component');\n        didWarnShadyDOM = true;\n      }\n    }\n\n    // TODO: Make sure that we check isMounted before firing any of these events.\n    var props;\n    switch (tag) {\n      case 'iframe':\n      case 'object':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n        props = rawProps;\n        break;\n      case 'video':\n      case 'audio':\n        // Create listener for each media event\n        for (var event in mediaEvents) {\n          if (mediaEvents.hasOwnProperty(event)) {\n            ReactBrowserEventEmitter_1.trapBubbledEvent(event, mediaEvents[event], domElement);\n          }\n        }\n        props = rawProps;\n        break;\n      case 'source':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n        props = rawProps;\n        break;\n      case 'img':\n      case 'image':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n        props = rawProps;\n        break;\n      case 'form':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topReset', 'reset', domElement);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topSubmit', 'submit', domElement);\n        props = rawProps;\n        break;\n      case 'details':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topToggle', 'toggle', domElement);\n        props = rawProps;\n        break;\n      case 'input':\n        ReactDOMFiberInput.initWrapperState(domElement, rawProps);\n        props = ReactDOMFiberInput.getHostProps(domElement, rawProps);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement);\n        // For controlled components we always need to ensure we're listening\n        // to onChange. Even if there is no listener.\n        ensureListeningTo(rootContainerElement, 'onChange');\n        break;\n      case 'option':\n        ReactDOMFiberOption.validateProps(domElement, rawProps);\n        props = ReactDOMFiberOption.getHostProps(domElement, rawProps);\n        break;\n      case 'select':\n        ReactDOMFiberSelect.initWrapperState(domElement, rawProps);\n        props = ReactDOMFiberSelect.getHostProps(domElement, rawProps);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement);\n        // For controlled components we always need to ensure we're listening\n        // to onChange. Even if there is no listener.\n        ensureListeningTo(rootContainerElement, 'onChange');\n        break;\n      case 'textarea':\n        ReactDOMFiberTextarea.initWrapperState(domElement, rawProps);\n        props = ReactDOMFiberTextarea.getHostProps(domElement, rawProps);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement);\n        // For controlled components we always need to ensure we're listening\n        // to onChange. Even if there is no listener.\n        ensureListeningTo(rootContainerElement, 'onChange');\n        break;\n      default:\n        props = rawProps;\n    }\n\n    assertValidProps_1(tag, props, getCurrentFiberOwnerName);\n\n    setInitialDOMProperties(domElement, rootContainerElement, props, isCustomComponentTag);\n\n    switch (tag) {\n      case 'input':\n        // TODO: Make sure we check if this is still unmounted or do any clean\n        // up necessary since we never stop tracking anymore.\n        inputValueTracking_1.track(domElement);\n        ReactDOMFiberInput.postMountWrapper(domElement, rawProps);\n        break;\n      case 'textarea':\n        // TODO: Make sure we check if this is still unmounted or do any clean\n        // up necessary since we never stop tracking anymore.\n        inputValueTracking_1.track(domElement);\n        ReactDOMFiberTextarea.postMountWrapper(domElement, rawProps);\n        break;\n      case 'option':\n        ReactDOMFiberOption.postMountWrapper(domElement, rawProps);\n        break;\n      case 'select':\n        ReactDOMFiberSelect.postMountWrapper(domElement, rawProps);\n        break;\n      default:\n        if (typeof props.onClick === 'function') {\n          // TODO: This cast may not be sound for SVG, MathML or custom elements.\n          trapClickOnNonInteractiveElement(domElement);\n        }\n        break;\n    }\n  },\n\n\n  // Calculate the diff between the two objects.\n  diffProperties: function (domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n    {\n      validatePropertiesInDevelopment(tag, nextRawProps);\n    }\n\n    var updatePayload = null;\n\n    var lastProps;\n    var nextProps;\n    switch (tag) {\n      case 'input':\n        lastProps = ReactDOMFiberInput.getHostProps(domElement, lastRawProps);\n        nextProps = ReactDOMFiberInput.getHostProps(domElement, nextRawProps);\n        updatePayload = [];\n        break;\n      case 'option':\n        lastProps = ReactDOMFiberOption.getHostProps(domElement, lastRawProps);\n        nextProps = ReactDOMFiberOption.getHostProps(domElement, nextRawProps);\n        updatePayload = [];\n        break;\n      case 'select':\n        lastProps = ReactDOMFiberSelect.getHostProps(domElement, lastRawProps);\n        nextProps = ReactDOMFiberSelect.getHostProps(domElement, nextRawProps);\n        updatePayload = [];\n        break;\n      case 'textarea':\n        lastProps = ReactDOMFiberTextarea.getHostProps(domElement, lastRawProps);\n        nextProps = ReactDOMFiberTextarea.getHostProps(domElement, nextRawProps);\n        updatePayload = [];\n        break;\n      default:\n        lastProps = lastRawProps;\n        nextProps = nextRawProps;\n        if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n          // TODO: This cast may not be sound for SVG, MathML or custom elements.\n          trapClickOnNonInteractiveElement(domElement);\n        }\n        break;\n    }\n\n    assertValidProps_1(tag, nextProps, getCurrentFiberOwnerName);\n\n    var propKey;\n    var styleName;\n    var styleUpdates = null;\n    for (propKey in lastProps) {\n      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        var lastStyle = lastProps[propKey];\n        for (styleName in lastStyle) {\n          if (lastStyle.hasOwnProperty(styleName)) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n        // Noop. This is handled by the clear text mechanism.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING) {\n        // Noop\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" fiber pointer gets updated so we need a commit\n        // to update this element.\n        if (!updatePayload) {\n          updatePayload = [];\n        }\n      } else {\n        // For all other deleted properties we add it to the queue. We use\n        // the whitelist in the commit phase instead.\n        (updatePayload = updatePayload || []).push(propKey, null);\n      }\n    }\n    for (propKey in nextProps) {\n      var nextProp = nextProps[propKey];\n      var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        {\n          if (nextProp) {\n            // Freeze the next style object so that we can assume it won't be\n            // mutated. We have already warned for this in the past.\n            Object.freeze(nextProp);\n          }\n        }\n        if (lastProp) {\n          // Unset styles on `lastProp` but not on `nextProp`.\n          for (styleName in lastProp) {\n            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n              if (!styleUpdates) {\n                styleUpdates = {};\n              }\n              styleUpdates[styleName] = '';\n            }\n          }\n          // Update styles that changed since `lastProp`.\n          for (styleName in nextProp) {\n            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n              if (!styleUpdates) {\n                styleUpdates = {};\n              }\n              styleUpdates[styleName] = nextProp[styleName];\n            }\n          }\n        } else {\n          // Relies on `updateStylesByID` not mutating `styleUpdates`.\n          if (!styleUpdates) {\n            if (!updatePayload) {\n              updatePayload = [];\n            }\n            updatePayload.push(propKey, styleUpdates);\n          }\n          styleUpdates = nextProp;\n        }\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var nextHtml = nextProp ? nextProp[HTML] : undefined;\n        var lastHtml = lastProp ? lastProp[HTML] : undefined;\n        if (nextHtml != null) {\n          if (lastHtml !== nextHtml) {\n            (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n          }\n        } else {\n          // TODO: It might be too late to clear this if we have children\n          // inserted already.\n        }\n      } else if (propKey === CHILDREN) {\n        if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n        }\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING) {\n        // Noop\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        if (nextProp != null) {\n          // We eagerly listen to this even though we haven't committed yet.\n          if (true && typeof nextProp !== 'function') {\n            warnForInvalidEventListener(propKey, nextProp);\n          }\n          ensureListeningTo(rootContainerElement, propKey);\n        }\n        if (!updatePayload && lastProp !== nextProp) {\n          // This is a special case. If any listener updates we need to ensure\n          // that the \"current\" props pointer gets updated so we need a commit\n          // to update this element.\n          updatePayload = [];\n        }\n      } else {\n        // For any other property we always add it to the queue and then we\n        // filter it out using the whitelist during the commit.\n        (updatePayload = updatePayload || []).push(propKey, nextProp);\n      }\n    }\n    if (styleUpdates) {\n      (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n    }\n    return updatePayload;\n  },\n\n\n  // Apply the diff.\n  updateProperties: function (domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n    var wasCustomComponentTag = isCustomComponent_1(tag, lastRawProps);\n    var isCustomComponentTag = isCustomComponent_1(tag, nextRawProps);\n    // Apply the diff.\n    updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n    // TODO: Ensure that an update gets scheduled if any of the special props\n    // changed.\n    switch (tag) {\n      case 'input':\n        // Update the wrapper around inputs *after* updating props. This has to\n        // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n        // raise warnings and prevent the new value from being assigned.\n        ReactDOMFiberInput.updateWrapper(domElement, nextRawProps);\n\n        // We also check that we haven't missed a value update, such as a\n        // Radio group shifting the checked value to another named radio input.\n        inputValueTracking_1.updateValueIfChanged(domElement);\n        break;\n      case 'textarea':\n        ReactDOMFiberTextarea.updateWrapper(domElement, nextRawProps);\n        break;\n      case 'select':\n        // <select> value update needs to occur after <option> children\n        // reconciliation\n        ReactDOMFiberSelect.postUpdateWrapper(domElement, nextRawProps);\n        break;\n    }\n  },\n  diffHydratedProperties: function (domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n    {\n      var isCustomComponentTag = isCustomComponent_1(tag, rawProps);\n      validatePropertiesInDevelopment(tag, rawProps);\n      if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n        warning$3(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName() || 'A component');\n        didWarnShadyDOM = true;\n      }\n    }\n\n    // TODO: Make sure that we check isMounted before firing any of these events.\n    switch (tag) {\n      case 'iframe':\n      case 'object':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n        break;\n      case 'video':\n      case 'audio':\n        // Create listener for each media event\n        for (var event in mediaEvents) {\n          if (mediaEvents.hasOwnProperty(event)) {\n            ReactBrowserEventEmitter_1.trapBubbledEvent(event, mediaEvents[event], domElement);\n          }\n        }\n        break;\n      case 'source':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n        break;\n      case 'img':\n      case 'image':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n        break;\n      case 'form':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topReset', 'reset', domElement);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topSubmit', 'submit', domElement);\n        break;\n      case 'details':\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topToggle', 'toggle', domElement);\n        break;\n      case 'input':\n        ReactDOMFiberInput.initWrapperState(domElement, rawProps);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement);\n        // For controlled components we always need to ensure we're listening\n        // to onChange. Even if there is no listener.\n        ensureListeningTo(rootContainerElement, 'onChange');\n        break;\n      case 'option':\n        ReactDOMFiberOption.validateProps(domElement, rawProps);\n        break;\n      case 'select':\n        ReactDOMFiberSelect.initWrapperState(domElement, rawProps);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement);\n        // For controlled components we always need to ensure we're listening\n        // to onChange. Even if there is no listener.\n        ensureListeningTo(rootContainerElement, 'onChange');\n        break;\n      case 'textarea':\n        ReactDOMFiberTextarea.initWrapperState(domElement, rawProps);\n        ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement);\n        // For controlled components we always need to ensure we're listening\n        // to onChange. Even if there is no listener.\n        ensureListeningTo(rootContainerElement, 'onChange');\n        break;\n    }\n\n    assertValidProps_1(tag, rawProps, getCurrentFiberOwnerName);\n\n    {\n      var extraAttributeNames = new Set();\n      var attributes = domElement.attributes;\n      for (var i = 0; i < attributes.length; i++) {\n        var name = attributes[i].name.toLowerCase();\n        switch (name) {\n          // Built-in SSR attribute is whitelisted\n          case 'data-reactroot':\n            break;\n          // Controlled attributes are not validated\n          // TODO: Only ignore them on controlled tags.\n          case 'value':\n            break;\n          case 'checked':\n            break;\n          case 'selected':\n            break;\n          default:\n            // Intentionally use the original name.\n            // See discussion in https://github.com/facebook/react/pull/10676.\n            extraAttributeNames.add(attributes[i].name);\n        }\n      }\n    }\n\n    var updatePayload = null;\n    for (var propKey in rawProps) {\n      if (!rawProps.hasOwnProperty(propKey)) {\n        continue;\n      }\n      var nextProp = rawProps[propKey];\n      if (propKey === CHILDREN) {\n        // For text content children we compare against textContent. This\n        // might match additional HTML that is hidden when we read it using\n        // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n        // satisfies our requirement. Our requirement is not to produce perfect\n        // HTML and attributes. Ideally we should preserve structure but it's\n        // ok not to if the visible content is still enough to indicate what\n        // even listeners these nodes might be wired up to.\n        // TODO: Warn if there is more than a single textNode as a child.\n        // TODO: Should we use domElement.firstChild.nodeValue to compare?\n        if (typeof nextProp === 'string') {\n          if (domElement.textContent !== nextProp) {\n            {\n              warnForTextDifference(domElement.textContent, nextProp);\n            }\n            updatePayload = [CHILDREN, nextProp];\n          }\n        } else if (typeof nextProp === 'number') {\n          if (domElement.textContent !== '' + nextProp) {\n            {\n              warnForTextDifference(domElement.textContent, nextProp);\n            }\n            updatePayload = [CHILDREN, '' + nextProp];\n          }\n        }\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        if (nextProp != null) {\n          if (true && typeof nextProp !== 'function') {\n            warnForInvalidEventListener(propKey, nextProp);\n          }\n          ensureListeningTo(rootContainerElement, propKey);\n        }\n      } else {\n        // Validate that the properties correspond to their expected values.\n        var serverValue;\n        var propertyInfo;\n        if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n          // Noop\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n          var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n          var serverHTML = domElement.innerHTML;\n          var expectedHTML = normalizeHTML(domElement, rawHtml);\n          if (expectedHTML !== serverHTML) {\n            warnForPropDifference(propKey, serverHTML, expectedHTML);\n          }\n        } else if (propKey === STYLE) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propKey);\n          var expectedStyle = CSSPropertyOperations_1.createDangerousStringForStyles(nextProp);\n          serverValue = domElement.getAttribute('style');\n          if (expectedStyle !== serverValue) {\n            warnForPropDifference(propKey, serverValue, expectedStyle);\n          }\n        } else if (isCustomComponentTag) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propKey.toLowerCase());\n          serverValue = DOMPropertyOperations_1.getValueForAttribute(domElement, propKey, nextProp);\n\n          if (nextProp !== serverValue) {\n            warnForPropDifference(propKey, serverValue, nextProp);\n          }\n        } else if (DOMProperty_1.shouldSetAttribute(propKey, nextProp)) {\n          if (propertyInfo = DOMProperty_1.getPropertyInfo(propKey)) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propertyInfo.attributeName);\n            serverValue = DOMPropertyOperations_1.getValueForProperty(domElement, propKey, nextProp);\n          } else {\n            var ownNamespace = parentNamespace;\n            if (ownNamespace === HTML_NAMESPACE$1) {\n              ownNamespace = getIntrinsicNamespace$1(tag);\n            }\n            if (ownNamespace === HTML_NAMESPACE$1) {\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](propKey.toLowerCase());\n            } else {\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](propKey);\n            }\n            serverValue = DOMPropertyOperations_1.getValueForAttribute(domElement, propKey, nextProp);\n          }\n\n          if (nextProp !== serverValue) {\n            warnForPropDifference(propKey, serverValue, nextProp);\n          }\n        }\n      }\n    }\n\n    {\n      // $FlowFixMe - Should be inferred as not undefined.\n      if (extraAttributeNames.size > 0) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        warnForExtraAttributes(extraAttributeNames);\n      }\n    }\n\n    switch (tag) {\n      case 'input':\n        // TODO: Make sure we check if this is still unmounted or do any clean\n        // up necessary since we never stop tracking anymore.\n        inputValueTracking_1.track(domElement);\n        ReactDOMFiberInput.postMountWrapper(domElement, rawProps);\n        break;\n      case 'textarea':\n        // TODO: Make sure we check if this is still unmounted or do any clean\n        // up necessary since we never stop tracking anymore.\n        inputValueTracking_1.track(domElement);\n        ReactDOMFiberTextarea.postMountWrapper(domElement, rawProps);\n        break;\n      case 'select':\n      case 'option':\n        // For input and textarea we current always set the value property at\n        // post mount to force it to diverge from attributes. However, for\n        // option and select we don't quite do the same thing and select\n        // is not resilient to the DOM state changing so we don't do that here.\n        // TODO: Consider not doing this for input and textarea.\n        break;\n      default:\n        if (typeof rawProps.onClick === 'function') {\n          // TODO: This cast may not be sound for SVG, MathML or custom elements.\n          trapClickOnNonInteractiveElement(domElement);\n        }\n        break;\n    }\n\n    return updatePayload;\n  },\n  diffHydratedText: function (textNode, text) {\n    var isDifferent = textNode.nodeValue !== text;\n    {\n      if (isDifferent) {\n        warnForTextDifference(textNode.nodeValue, text);\n      }\n    }\n    return isDifferent;\n  },\n  warnForDeletedHydratableElement: function (parentNode, child) {\n    {\n      if (didWarnInvalidHydration) {\n        return;\n      }\n      didWarnInvalidHydration = true;\n      warning$3(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n    }\n  },\n  warnForDeletedHydratableText: function (parentNode, child) {\n    {\n      if (didWarnInvalidHydration) {\n        return;\n      }\n      didWarnInvalidHydration = true;\n      warning$3(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n    }\n  },\n  warnForInsertedHydratedElement: function (parentNode, tag, props) {\n    {\n      if (didWarnInvalidHydration) {\n        return;\n      }\n      didWarnInvalidHydration = true;\n      warning$3(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n    }\n  },\n  warnForInsertedHydratedText: function (parentNode, text) {\n    {\n      if (text === '') {\n        // We expect to insert empty text nodes since they're not represented in\n        // the HTML.\n        // TODO: Remove this special case if we can just avoid inserting empty\n        // text nodes.\n        return;\n      }\n      if (didWarnInvalidHydration) {\n        return;\n      }\n      didWarnInvalidHydration = true;\n      warning$3(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n    }\n  },\n  restoreControlledState: function (domElement, tag, props) {\n    switch (tag) {\n      case 'input':\n        ReactDOMFiberInput.restoreControlledState(domElement, props);\n        return;\n      case 'textarea':\n        ReactDOMFiberTextarea.restoreControlledState(domElement, props);\n        return;\n      case 'select':\n        ReactDOMFiberSelect.restoreControlledState(domElement, props);\n        return;\n    }\n  }\n};\n\nvar ReactDOMFiberComponent_1 = ReactDOMFiberComponent;\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n\n\n{\n  var warning$17 = require$$0;\n\n  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n    warning$17(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nvar rIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    setTimeout(function () {\n      frameCallback({\n        timeRemaining: function () {\n          return Infinity;\n        }\n      });\n    });\n    return 0;\n  };\n} else if (typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n\n  var scheduledRAFCallback = null;\n  var scheduledRICCallback = null;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = {\n    timeRemaining: typeof performance === 'object' && typeof performance.now === 'function' ? function () {\n      // We assume that if we have a performance timer that the rAF callback\n      // gets a performance timer value. Not sure if this is always true.\n      return frameDeadline - performance.now();\n    } : function () {\n      // As a fallback we use Date.now.\n      return frameDeadline - Date.now();\n    }\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n    var callback = scheduledRAFCallback;\n    scheduledRAFCallback = null;\n    if (callback !== null) {\n      callback(rafTime);\n    }\n  };\n\n  rIC = function (callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n} else {\n  rIC = requestIdleCallback;\n}\n\nvar rIC_1 = rIC;\n\nvar ReactDOMFrameScheduling = {\n\trIC: rIC_1\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactFeatureFlags\n * \n */\n\nvar ReactFeatureFlags = {\n  enableAsyncSubtreeAPI: true\n};\n\nvar ReactFeatureFlags_1 = ReactFeatureFlags;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactPriorityLevel\n * \n */\n\nvar ReactPriorityLevel = {\n  NoWork: 0, // No work is pending.\n  SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects.\n  TaskPriority: 2, // Completes at the end of the current tick.\n  HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive.\n  LowPriority: 4, // Data fetching, or result from updating stores.\n  OffscreenPriority: 5 };\n\nvar CallbackEffect = ReactTypeOfSideEffect.Callback;\n\nvar NoWork = ReactPriorityLevel.NoWork;\nvar SynchronousPriority = ReactPriorityLevel.SynchronousPriority;\nvar TaskPriority = ReactPriorityLevel.TaskPriority;\n\nvar ClassComponent$2 = ReactTypeOfWork.ClassComponent;\nvar HostRoot$2 = ReactTypeOfWork.HostRoot;\n\n\n{\n  var warning$19 = require$$0;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nvar _queue1 = void 0;\nvar _queue2 = void 0;\n\nfunction comparePriority(a, b) {\n  // When comparing update priorities, treat sync and Task work as equal.\n  // TODO: Could we avoid the need for this by always coercing sync priority\n  // to Task when scheduling an update?\n  if ((a === TaskPriority || a === SynchronousPriority) && (b === TaskPriority || b === SynchronousPriority)) {\n    return 0;\n  }\n  if (a === NoWork && b !== NoWork) {\n    return -255;\n  }\n  if (a !== NoWork && b === NoWork) {\n    return 255;\n  }\n  return a - b;\n}\n\nfunction createUpdateQueue() {\n  var queue = {\n    first: null,\n    last: null,\n    hasForceUpdate: false,\n    callbackList: null\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction cloneUpdate(update) {\n  return {\n    priorityLevel: update.priorityLevel,\n    partialState: update.partialState,\n    callback: update.callback,\n    isReplace: update.isReplace,\n    isForced: update.isForced,\n    isTopLevelUnmount: update.isTopLevelUnmount,\n    next: null\n  };\n}\n\nfunction insertUpdateIntoQueue(queue, update, insertAfter, insertBefore) {\n  if (insertAfter !== null) {\n    insertAfter.next = update;\n  } else {\n    // This is the first item in the queue.\n    update.next = queue.first;\n    queue.first = update;\n  }\n\n  if (insertBefore !== null) {\n    update.next = insertBefore;\n  } else {\n    // This is the last item in the queue.\n    queue.last = update;\n  }\n}\n\n// Returns the update after which the incoming update should be inserted into\n// the queue, or null if it should be inserted at beginning.\nfunction findInsertionPosition(queue, update) {\n  var priorityLevel = update.priorityLevel;\n  var insertAfter = null;\n  var insertBefore = null;\n  if (queue.last !== null && comparePriority(queue.last.priorityLevel, priorityLevel) <= 0) {\n    // Fast path for the common case where the update should be inserted at\n    // the end of the queue.\n    insertAfter = queue.last;\n  } else {\n    insertBefore = queue.first;\n    while (insertBefore !== null && comparePriority(insertBefore.priorityLevel, priorityLevel) <= 0) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore.next;\n    }\n  }\n  return insertAfter;\n}\n\nfunction ensureUpdateQueues(fiber) {\n  var alternateFiber = fiber.alternate;\n\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    queue1 = fiber.updateQueue = createUpdateQueue();\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue();\n    }\n  } else {\n    queue2 = null;\n  }\n\n  _queue1 = queue1;\n  // Return null if there is no alternate queue, or if its queue is the same.\n  _queue2 = queue2 !== queue1 ? queue2 : null;\n}\n\n// The work-in-progress queue is a subset of the current queue (if it exists).\n// We need to insert the incoming update into both lists. However, it's possible\n// that the correct position in one list will be different from the position in\n// the other. Consider the following case:\n//\n//     Current:             3-5-6\n//     Work-in-progress:        6\n//\n// Then we receive an update with priority 4 and insert it into each list:\n//\n//     Current:             3-4-5-6\n//     Work-in-progress:        4-6\n//\n// In the current queue, the new update's `next` pointer points to the update\n// with priority 5. But in the work-in-progress queue, the pointer points to the\n// update with priority 6. Because these two queues share the same persistent\n// data structure, this won't do. (This can only happen when the incoming update\n// has higher priority than all the updates in the work-in-progress queue.)\n//\n// To solve this, in the case where the incoming update needs to be inserted\n// into two different positions, we'll make a clone of the update and insert\n// each copy into a separate queue. This forks the list while maintaining a\n// persistent structure, because the update that is added to the work-in-progress\n// is always added to the front of the list.\n//\n// However, if incoming update is inserted into the same position of both lists,\n// we shouldn't make a copy.\n//\n// If the update is cloned, it returns the cloned update.\nfunction insertUpdate(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  ensureUpdateQueues(fiber);\n  var queue1 = _queue1;\n  var queue2 = _queue2;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if (queue1.isProcessing || queue2 !== null && queue2.isProcessing) {\n      warning$19(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n    }\n  }\n\n  // Find the insertion position in the first queue.\n  var insertAfter1 = findInsertionPosition(queue1, update);\n  var insertBefore1 = insertAfter1 !== null ? insertAfter1.next : queue1.first;\n\n  if (queue2 === null) {\n    // If there's no alternate queue, there's nothing else to do but insert.\n    insertUpdateIntoQueue(queue1, update, insertAfter1, insertBefore1);\n    return null;\n  }\n\n  // If there is an alternate queue, find the insertion position.\n  var insertAfter2 = findInsertionPosition(queue2, update);\n  var insertBefore2 = insertAfter2 !== null ? insertAfter2.next : queue2.first;\n\n  // Now we can insert into the first queue. This must come after finding both\n  // insertion positions because it mutates the list.\n  insertUpdateIntoQueue(queue1, update, insertAfter1, insertBefore1);\n\n  // See if the insertion positions are equal. Be careful to only compare\n  // non-null values.\n  if (insertBefore1 === insertBefore2 && insertBefore1 !== null || insertAfter1 === insertAfter2 && insertAfter1 !== null) {\n    // The insertion positions are the same, so when we inserted into the first\n    // queue, it also inserted into the alternate. All we need to do is update\n    // the alternate queue's `first` and `last` pointers, in case they\n    // have changed.\n    if (insertAfter2 === null) {\n      queue2.first = update;\n    }\n    if (insertBefore2 === null) {\n      queue2.last = null;\n    }\n    return null;\n  } else {\n    // The insertion positions are different, so we need to clone the update and\n    // insert the clone into the alternate queue.\n    var update2 = cloneUpdate(update);\n    insertUpdateIntoQueue(queue2, update2, insertAfter2, insertBefore2);\n    return update2;\n  }\n}\n\nfunction addUpdate(fiber, partialState, callback, priorityLevel) {\n  var update = {\n    priorityLevel: priorityLevel,\n    partialState: partialState,\n    callback: callback,\n    isReplace: false,\n    isForced: false,\n    isTopLevelUnmount: false,\n    next: null\n  };\n  insertUpdate(fiber, update);\n}\nvar addUpdate_1 = addUpdate;\n\nfunction addReplaceUpdate(fiber, state, callback, priorityLevel) {\n  var update = {\n    priorityLevel: priorityLevel,\n    partialState: state,\n    callback: callback,\n    isReplace: true,\n    isForced: false,\n    isTopLevelUnmount: false,\n    next: null\n  };\n  insertUpdate(fiber, update);\n}\nvar addReplaceUpdate_1 = addReplaceUpdate;\n\nfunction addForceUpdate(fiber, callback, priorityLevel) {\n  var update = {\n    priorityLevel: priorityLevel,\n    partialState: null,\n    callback: callback,\n    isReplace: false,\n    isForced: true,\n    isTopLevelUnmount: false,\n    next: null\n  };\n  insertUpdate(fiber, update);\n}\nvar addForceUpdate_1 = addForceUpdate;\n\nfunction getUpdatePriority(fiber) {\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  if (fiber.tag !== ClassComponent$2 && fiber.tag !== HostRoot$2) {\n    return NoWork;\n  }\n  return updateQueue.first !== null ? updateQueue.first.priorityLevel : NoWork;\n}\nvar getUpdatePriority_1 = getUpdatePriority;\n\nfunction addTopLevelUpdate$1(fiber, partialState, callback, priorityLevel) {\n  var isTopLevelUnmount = partialState.element === null;\n\n  var update = {\n    priorityLevel: priorityLevel,\n    partialState: partialState,\n    callback: callback,\n    isReplace: false,\n    isForced: false,\n    isTopLevelUnmount: isTopLevelUnmount,\n    next: null\n  };\n  var update2 = insertUpdate(fiber, update);\n\n  if (isTopLevelUnmount) {\n    // TODO: Redesign the top-level mount/update/unmount API to avoid this\n    // special case.\n    var queue1 = _queue1;\n    var queue2 = _queue2;\n\n    // Drop all updates that are lower-priority, so that the tree is not\n    // remounted. We need to do this for both queues.\n    if (queue1 !== null && update.next !== null) {\n      update.next = null;\n      queue1.last = update;\n    }\n    if (queue2 !== null && update2 !== null && update2.next !== null) {\n      update2.next = null;\n      queue2.last = update;\n    }\n  }\n}\nvar addTopLevelUpdate_1 = addTopLevelUpdate$1;\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    var updateFn = partialState;\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction beginUpdateQueue(current, workInProgress, queue, instance, prevState, props, priorityLevel) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      first: currentQueue.first,\n      last: currentQueue.last,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Calculate these using the the existing values as a base.\n  var callbackList = queue.callbackList;\n  var hasForceUpdate = queue.hasForceUpdate;\n\n  // Applies updates with matching priority to the previous state to create\n  // a new state object.\n  var state = prevState;\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  while (update !== null && comparePriority(update.priorityLevel, priorityLevel) <= 0) {\n    // Remove each update from the queue right before it is processed. That way\n    // if setState is called from inside an updater function, the new update\n    // will be inserted in the correct position.\n    queue.first = update.next;\n    if (queue.first === null) {\n      queue.last = null;\n    }\n\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      hasForceUpdate = true;\n    }\n    // Second condition ignores top-level unmount callbacks if they are not the\n    // last update in the queue, since a subsequent update will cause a remount.\n    if (update.callback !== null && !(update.isTopLevelUnmount && update.next !== null)) {\n      callbackList = callbackList !== null ? callbackList : [];\n      callbackList.push(update.callback);\n      workInProgress.effectTag |= CallbackEffect;\n    }\n    update = update.next;\n  }\n\n  queue.callbackList = callbackList;\n  queue.hasForceUpdate = hasForceUpdate;\n\n  if (queue.first === null && callbackList === null && !hasForceUpdate) {\n    // The queue is empty and there are no callbacks. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\nvar beginUpdateQueue_1 = beginUpdateQueue;\n\nfunction commitCallbacks(finishedWork, queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n\n  for (var i = 0; i < callbackList.length; i++) {\n    var _callback = callbackList[i];\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\nvar commitCallbacks_1 = commitCallbacks;\n\nvar ReactFiberUpdateQueue = {\n\taddUpdate: addUpdate_1,\n\taddReplaceUpdate: addReplaceUpdate_1,\n\taddForceUpdate: addForceUpdate_1,\n\tgetUpdatePriority: getUpdatePriority_1,\n\taddTopLevelUpdate: addTopLevelUpdate_1,\n\tbeginUpdateQueue: beginUpdateQueue_1,\n\tcommitCallbacks: commitCallbacks_1\n};\n\n{\n  var warning$21 = require$$0;\n}\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nvar createCursor$1 = function (defaultValue) {\n  return {\n    current: defaultValue\n  };\n};\n\nvar isEmpty = function () {\n  return index === -1;\n};\n\nvar pop$1 = function (cursor, fiber) {\n  if (index < 0) {\n    {\n      warning$21(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning$21(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n};\n\nvar push$1 = function (cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n};\n\nvar reset = function () {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n};\n\nvar ReactFiberStack = {\n\tcreateCursor: createCursor$1,\n\tisEmpty: isEmpty,\n\tpop: pop$1,\n\tpush: push$1,\n\treset: reset\n};\n\n// Trust the developer to only use this with a true check\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactDebugFiberPerf\n * \n */\n\nvar ReactDebugFiberPerf = null;\n\n{\n  var _require$8 = ReactTypeOfWork,\n      HostRoot$4 = _require$8.HostRoot,\n      HostComponent$4 = _require$8.HostComponent,\n      HostText$2 = _require$8.HostText,\n      HostPortal$1 = _require$8.HostPortal,\n      YieldComponent = _require$8.YieldComponent,\n      Fragment = _require$8.Fragment;\n\n  var getComponentName$5 = getComponentName_1;\n\n  // Prefix measurements so that it's possible to filter them.\n  // Longer prefixes are hard to read in DevTools.\n  var reactEmoji = '\\u269B';\n  var warningEmoji = '\\u26D4';\n  var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n  // Keep track of current fiber so that we know the path to unwind on pause.\n  // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n  var currentFiber = null;\n  // If we're in the middle of user code, which fiber and method is it?\n  // Reusing `currentFiber` would be confusing for this because user code fiber\n  // can change during commit phase too, but we don't need to unwind it (since\n  // lifecycles in the commit phase don't resemble a tree).\n  var currentPhase = null;\n  var currentPhaseFiber = null;\n  // Did lifecycle hook schedule an update? This is often a performance problem,\n  // so we will keep track of it, and include it in the report.\n  // Track commits caused by cascading updates.\n  var isCommitting = false;\n  var hasScheduledUpdateInCurrentCommit = false;\n  var hasScheduledUpdateInCurrentPhase = false;\n  var commitCountInCurrentWorkLoop = 0;\n  var effectCountInCurrentCommit = 0;\n  // During commits, we only show a measurement once per method name\n  // to avoid stretch the commit phase with measurement overhead.\n  var labelsInCurrentCommit = new Set();\n\n  var formatMarkName = function (markName) {\n    return reactEmoji + ' ' + markName;\n  };\n\n  var formatLabel = function (label, warning) {\n    var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';\n    var suffix = warning ? ' Warning: ' + warning : '';\n    return '' + prefix + label + suffix;\n  };\n\n  var beginMark = function (markName) {\n    performance.mark(formatMarkName(markName));\n  };\n\n  var clearMark = function (markName) {\n    performance.clearMarks(formatMarkName(markName));\n  };\n\n  var endMark = function (label, markName, warning) {\n    var formattedMarkName = formatMarkName(markName);\n    var formattedLabel = formatLabel(label, warning);\n    try {\n      performance.measure(formattedLabel, formattedMarkName);\n    } catch (err) {}\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if React crashed in an unexpected place earlier.\n    // Don't pile on with more errors.\n\n    // Clear marks immediately to avoid growing buffer.\n    performance.clearMarks(formattedMarkName);\n    performance.clearMeasures(formattedLabel);\n  };\n\n  var getFiberMarkName = function (label, debugID) {\n    return label + ' (#' + debugID + ')';\n  };\n\n  var getFiberLabel = function (componentName, isMounted, phase) {\n    if (phase === null) {\n      // These are composite component total time measurements.\n      return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n    } else {\n      // Composite component methods.\n      return componentName + '.' + phase;\n    }\n  };\n\n  var beginFiberMark = function (fiber, phase) {\n    var componentName = getComponentName$5(fiber) || 'Unknown';\n    var debugID = fiber._debugID;\n    var isMounted = fiber.alternate !== null;\n    var label = getFiberLabel(componentName, isMounted, phase);\n\n    if (isCommitting && labelsInCurrentCommit.has(label)) {\n      // During the commit phase, we don't show duplicate labels because\n      // there is a fixed overhead for every measurement, and we don't\n      // want to stretch the commit phase beyond necessary.\n      return false;\n    }\n    labelsInCurrentCommit.add(label);\n\n    var markName = getFiberMarkName(label, debugID);\n    beginMark(markName);\n    return true;\n  };\n\n  var clearFiberMark = function (fiber, phase) {\n    var componentName = getComponentName$5(fiber) || 'Unknown';\n    var debugID = fiber._debugID;\n    var isMounted = fiber.alternate !== null;\n    var label = getFiberLabel(componentName, isMounted, phase);\n    var markName = getFiberMarkName(label, debugID);\n    clearMark(markName);\n  };\n\n  var endFiberMark = function (fiber, phase, warning) {\n    var componentName = getComponentName$5(fiber) || 'Unknown';\n    var debugID = fiber._debugID;\n    var isMounted = fiber.alternate !== null;\n    var label = getFiberLabel(componentName, isMounted, phase);\n    var markName = getFiberMarkName(label, debugID);\n    endMark(label, markName, warning);\n  };\n\n  var shouldIgnoreFiber = function (fiber) {\n    // Host components should be skipped in the timeline.\n    // We could check typeof fiber.type, but does this work with RN?\n    switch (fiber.tag) {\n      case HostRoot$4:\n      case HostComponent$4:\n      case HostText$2:\n      case HostPortal$1:\n      case YieldComponent:\n      case Fragment:\n        return true;\n      default:\n        return false;\n    }\n  };\n\n  var clearPendingPhaseMeasurement = function () {\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      clearFiberMark(currentPhaseFiber, currentPhase);\n    }\n    currentPhaseFiber = null;\n    currentPhase = null;\n    hasScheduledUpdateInCurrentPhase = false;\n  };\n\n  var pauseTimers = function () {\n    // Stops all currently active measurements so that they can be resumed\n    // if we continue in a later deferred loop from the same unit of work.\n    var fiber = currentFiber;\n    while (fiber) {\n      if (fiber._debugIsCurrentlyTiming) {\n        endFiberMark(fiber, null, null);\n      }\n      fiber = fiber['return'];\n    }\n  };\n\n  var resumeTimersRecursively = function (fiber) {\n    if (fiber['return'] !== null) {\n      resumeTimersRecursively(fiber['return']);\n    }\n    if (fiber._debugIsCurrentlyTiming) {\n      beginFiberMark(fiber, null);\n    }\n  };\n\n  var resumeTimers = function () {\n    // Resumes all measurements that were active during the last deferred loop.\n    if (currentFiber !== null) {\n      resumeTimersRecursively(currentFiber);\n    }\n  };\n\n  ReactDebugFiberPerf = {\n    recordEffect: function () {\n      effectCountInCurrentCommit++;\n    },\n    recordScheduleUpdate: function () {\n      if (isCommitting) {\n        hasScheduledUpdateInCurrentCommit = true;\n      }\n      if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n        hasScheduledUpdateInCurrentPhase = true;\n      }\n    },\n    startWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // If we pause, this is the fiber to unwind from.\n      currentFiber = fiber;\n      if (!beginFiberMark(fiber, null)) {\n        return;\n      }\n      fiber._debugIsCurrentlyTiming = true;\n    },\n    cancelWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // Remember we shouldn't complete measurement for this fiber.\n      // Otherwise flamechart will be deep even for small updates.\n      fiber._debugIsCurrentlyTiming = false;\n      clearFiberMark(fiber, null);\n    },\n    stopWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // If we pause, its parent is the fiber to unwind from.\n      currentFiber = fiber['return'];\n      if (!fiber._debugIsCurrentlyTiming) {\n        return;\n      }\n      fiber._debugIsCurrentlyTiming = false;\n      endFiberMark(fiber, null, null);\n    },\n    stopFailedWorkTimer: function (fiber) {\n      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n        return;\n      }\n      // If we pause, its parent is the fiber to unwind from.\n      currentFiber = fiber['return'];\n      if (!fiber._debugIsCurrentlyTiming) {\n        return;\n      }\n      fiber._debugIsCurrentlyTiming = false;\n      var warning = 'An error was thrown inside this error boundary';\n      endFiberMark(fiber, null, warning);\n    },\n    startPhaseTimer: function (fiber, phase) {\n      if (!supportsUserTiming) {\n        return;\n      }\n      clearPendingPhaseMeasurement();\n      if (!beginFiberMark(fiber, phase)) {\n        return;\n      }\n      currentPhaseFiber = fiber;\n      currentPhase = phase;\n    },\n    stopPhaseTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      if (currentPhase !== null && currentPhaseFiber !== null) {\n        var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n        endFiberMark(currentPhaseFiber, currentPhase, warning);\n      }\n      currentPhase = null;\n      currentPhaseFiber = null;\n    },\n    startWorkLoopTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      commitCountInCurrentWorkLoop = 0;\n      // This is top level call.\n      // Any other measurements are performed within.\n      beginMark('(React Tree Reconciliation)');\n      // Resume any measurements that were in progress during the last loop.\n      resumeTimers();\n    },\n    stopWorkLoopTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      var warning = commitCountInCurrentWorkLoop > 1 ? 'There were cascading updates' : null;\n      commitCountInCurrentWorkLoop = 0;\n      // Pause any measurements until the next loop.\n      pauseTimers();\n      endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning);\n    },\n    startCommitTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      isCommitting = true;\n      hasScheduledUpdateInCurrentCommit = false;\n      labelsInCurrentCommit.clear();\n      beginMark('(Committing Changes)');\n    },\n    stopCommitTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n\n      var warning = null;\n      if (hasScheduledUpdateInCurrentCommit) {\n        warning = 'Lifecycle hook scheduled a cascading update';\n      } else if (commitCountInCurrentWorkLoop > 0) {\n        warning = 'Caused by a cascading update in earlier commit';\n      }\n      hasScheduledUpdateInCurrentCommit = false;\n      commitCountInCurrentWorkLoop++;\n      isCommitting = false;\n      labelsInCurrentCommit.clear();\n\n      endMark('(Committing Changes)', '(Committing Changes)', warning);\n    },\n    startCommitHostEffectsTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      effectCountInCurrentCommit = 0;\n      beginMark('(Committing Host Effects)');\n    },\n    stopCommitHostEffectsTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      var count = effectCountInCurrentCommit;\n      effectCountInCurrentCommit = 0;\n      endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n    },\n    startCommitLifeCyclesTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      effectCountInCurrentCommit = 0;\n      beginMark('(Calling Lifecycle Methods)');\n    },\n    stopCommitLifeCyclesTimer: function () {\n      if (!supportsUserTiming) {\n        return;\n      }\n      var count = effectCountInCurrentCommit;\n      effectCountInCurrentCommit = 0;\n      endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n    }\n  };\n}\n\nvar ReactDebugFiberPerf_1 = ReactDebugFiberPerf;\n\nvar isFiberMounted$1 = ReactFiberTreeReflection.isFiberMounted;\n\nvar ClassComponent$3 = ReactTypeOfWork.ClassComponent;\nvar HostRoot$3 = ReactTypeOfWork.HostRoot;\n\nvar createCursor = ReactFiberStack.createCursor;\nvar pop = ReactFiberStack.pop;\nvar push = ReactFiberStack.push;\n\n{\n  var warning$20 = require$$0;\n  var checkPropTypes$1 = checkPropTypes;\n  var ReactDebugCurrentFiber$2 = ReactDebugCurrentFiber_1;\n\n  var _require4 = ReactDebugFiberPerf_1,\n      startPhaseTimer = _require4.startPhaseTimer,\n      stopPhaseTimer = _require4.stopPhaseTimer;\n\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider$1(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\nvar getUnmaskedContext_1 = getUnmaskedContext;\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\nvar cacheContext_1 = cacheContext;\n\nvar getMaskedContext = function (workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName_1(workInProgress) || 'Unknown';\n    ReactDebugCurrentFiber$2.setCurrentFiber(workInProgress, null);\n    checkPropTypes$1(contextTypes, context, 'context', name, ReactDebugCurrentFiber$2.getCurrentFiberStackAddendum);\n    ReactDebugCurrentFiber$2.resetCurrentFiber();\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n};\n\nvar hasContextChanged = function () {\n  return didPerformWorkStackCursor.current;\n};\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent$3 && fiber.type.contextTypes != null;\n}\nvar isContextConsumer_1 = isContextConsumer;\n\nfunction isContextProvider$1(fiber) {\n  return fiber.tag === ClassComponent$3 && fiber.type.childContextTypes != null;\n}\nvar isContextProvider_1 = isContextProvider$1;\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider$1(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\nvar popContextProvider_1 = popContextProvider;\n\nvar popTopLevelContextObject = function (fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n};\n\nvar pushTopLevelContextObject = function (fiber, context, didChange) {\n  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n};\n\nfunction processChildContext$1(fiber, parentContext, isReconciling) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName_1(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning$20(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber$2.setCurrentFiber(fiber, 'getChildContext');\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    ReactDebugCurrentFiber$2.resetCurrentFiber();\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName_1(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName_1(fiber) || 'Unknown';\n    // We can only provide accurate element stacks if we pass work-in-progress tree\n    // during the begin or complete phase. However currently this function is also\n    // called from unstable_renderSubtree legacy implementation. In this case it unsafe to\n    // assume anything about the given fiber. We won't pass it down if we aren't sure.\n    // TODO: remove this hack when we delete unstable_renderSubtree in Fiber.\n    var workInProgress = isReconciling ? fiber : null;\n    ReactDebugCurrentFiber$2.setCurrentFiber(workInProgress, null);\n    checkPropTypes$1(childContextTypes, childContext, 'child context', name, ReactDebugCurrentFiber$2.getCurrentFiberStackAddendum);\n    ReactDebugCurrentFiber$2.resetCurrentFiber();\n  }\n\n  return _assign({}, parentContext, childContext);\n}\nvar processChildContext_1 = processChildContext$1;\n\nvar pushContextProvider = function (workInProgress) {\n  if (!isContextProvider$1(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertantly blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n};\n\nvar invalidateContextProvider = function (workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext$1(workInProgress, previousContext, true);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n};\n\nvar resetContext = function () {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n};\n\nvar findCurrentUnmaskedContext$1 = function (fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted$1(fiber) && fiber.tag === ClassComponent$3) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot$3) {\n    if (isContextProvider$1(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node['return'];\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n};\n\nvar ReactFiberContext = {\n\tgetUnmaskedContext: getUnmaskedContext_1,\n\tcacheContext: cacheContext_1,\n\tgetMaskedContext: getMaskedContext,\n\thasContextChanged: hasContextChanged,\n\tisContextConsumer: isContextConsumer_1,\n\tisContextProvider: isContextProvider_1,\n\tpopContextProvider: popContextProvider_1,\n\tpopTopLevelContextObject: popTopLevelContextObject,\n\tpushTopLevelContextObject: pushTopLevelContextObject,\n\tprocessChildContext: processChildContext_1,\n\tpushContextProvider: pushContextProvider,\n\tinvalidateContextProvider: invalidateContextProvider,\n\tresetContext: resetContext,\n\tfindCurrentUnmaskedContext: findCurrentUnmaskedContext$1\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactTypeOfInternalContext\n * \n */\n\nvar ReactTypeOfInternalContext = {\n  NoContext: 0,\n  AsyncUpdates: 1\n};\n\nvar IndeterminateComponent$1 = ReactTypeOfWork.IndeterminateComponent;\nvar ClassComponent$4 = ReactTypeOfWork.ClassComponent;\nvar HostRoot$5 = ReactTypeOfWork.HostRoot;\nvar HostComponent$5 = ReactTypeOfWork.HostComponent;\nvar HostText$3 = ReactTypeOfWork.HostText;\nvar HostPortal$2 = ReactTypeOfWork.HostPortal;\nvar CoroutineComponent = ReactTypeOfWork.CoroutineComponent;\nvar YieldComponent$1 = ReactTypeOfWork.YieldComponent;\nvar Fragment$1 = ReactTypeOfWork.Fragment;\n\nvar NoWork$1 = ReactPriorityLevel.NoWork;\n\nvar NoContext = ReactTypeOfInternalContext.NoContext;\n\nvar NoEffect$1 = ReactTypeOfSideEffect.NoEffect;\n\n\n\n{\n  var getComponentName$6 = getComponentName_1;\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect$1;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.pendingWorkPriority = NoWork$1;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nvar createWorkInProgress = function (current, renderPriority) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect$1;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.pendingWorkPriority = renderPriority;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // pendingProps is set by the parent during reconciliation.\n  // TODO: Pass this as an argument.\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n};\n\nvar createHostRootFiber$1 = function () {\n  var fiber = createFiber(HostRoot$5, null, NoContext);\n  return fiber;\n};\n\nvar createFiberFromElement = function (element, internalContextTag, priorityLevel) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = createFiberFromElementType(element.type, element.key, internalContextTag, owner);\n  fiber.pendingProps = element.props;\n  fiber.pendingWorkPriority = priorityLevel;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n};\n\nvar createFiberFromFragment = function (elements, internalContextTag, priorityLevel) {\n  // TODO: Consider supporting keyed fragments. Technically, we accidentally\n  // support that in the existing React.\n  var fiber = createFiber(Fragment$1, null, internalContextTag);\n  fiber.pendingProps = elements;\n  fiber.pendingWorkPriority = priorityLevel;\n  return fiber;\n};\n\nvar createFiberFromText = function (content, internalContextTag, priorityLevel) {\n  var fiber = createFiber(HostText$3, null, internalContextTag);\n  fiber.pendingProps = content;\n  fiber.pendingWorkPriority = priorityLevel;\n  return fiber;\n};\n\nfunction createFiberFromElementType(type, key, internalContextTag, debugOwner) {\n  var fiber = void 0;\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type) ? createFiber(ClassComponent$4, key, internalContextTag) : createFiber(IndeterminateComponent$1, key, internalContextTag);\n    fiber.type = type;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent$5, key, internalContextTag);\n    fiber.type = type;\n  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n  } else {\n    var info = '';\n    {\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in.\";\n      }\n      var ownerName = debugOwner ? getComponentName$6(debugOwner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n  return fiber;\n}\n\nvar createFiberFromElementType_1 = createFiberFromElementType;\n\nvar createFiberFromHostInstanceForDeletion = function () {\n  var fiber = createFiber(HostComponent$5, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n};\n\nvar createFiberFromCoroutine = function (coroutine, internalContextTag, priorityLevel) {\n  var fiber = createFiber(CoroutineComponent, coroutine.key, internalContextTag);\n  fiber.type = coroutine.handler;\n  fiber.pendingProps = coroutine;\n  fiber.pendingWorkPriority = priorityLevel;\n  return fiber;\n};\n\nvar createFiberFromYield = function (yieldNode, internalContextTag, priorityLevel) {\n  var fiber = createFiber(YieldComponent$1, null, internalContextTag);\n  return fiber;\n};\n\nvar createFiberFromPortal = function (portal, internalContextTag, priorityLevel) {\n  var fiber = createFiber(HostPortal$2, portal.key, internalContextTag);\n  fiber.pendingProps = portal.children || [];\n  fiber.pendingWorkPriority = priorityLevel;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    implementation: portal.implementation\n  };\n  return fiber;\n};\n\nvar largerPriority = function (p1, p2) {\n  return p1 !== NoWork$1 && (p2 === NoWork$1 || p2 > p1) ? p1 : p2;\n};\n\nvar ReactFiber = {\n\tcreateWorkInProgress: createWorkInProgress,\n\tcreateHostRootFiber: createHostRootFiber$1,\n\tcreateFiberFromElement: createFiberFromElement,\n\tcreateFiberFromFragment: createFiberFromFragment,\n\tcreateFiberFromText: createFiberFromText,\n\tcreateFiberFromElementType: createFiberFromElementType_1,\n\tcreateFiberFromHostInstanceForDeletion: createFiberFromHostInstanceForDeletion,\n\tcreateFiberFromCoroutine: createFiberFromCoroutine,\n\tcreateFiberFromYield: createFiberFromYield,\n\tcreateFiberFromPortal: createFiberFromPortal,\n\tlargerPriority: largerPriority\n};\n\nvar createHostRootFiber = ReactFiber.createHostRootFiber;\n\nvar createFiberRoot$1 = function (containerInfo) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    isScheduled: false,\n    nextScheduledRoot: null,\n    context: null,\n    pendingContext: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n};\n\nvar ReactFiberRoot = {\n\tcreateFiberRoot: createFiberRoot$1\n};\n\nvar defaultShowDialog = function (capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError$1(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'You can learn more about error boundaries at https://fb.me/react-error-boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar injection$1 = {\n  /**\n   * Display custom dialog for lifecycle errors.\n   * Return false to prevent default behavior of logging to console.error.\n   */\n  injectDialog: function (fn) {\n    !(showDialog === defaultShowDialog) ? invariant(false, 'The custom dialog was already injected.') : void 0;\n    !(typeof fn === 'function') ? invariant(false, 'Injected showDialog() must be a function.') : void 0;\n    showDialog = fn;\n  }\n};\n\nvar logCapturedError_1 = logCapturedError$1;\n\nvar ReactFiberErrorLogger = {\n\tinjection: injection$1,\n\tlogCapturedError: logCapturedError_1\n};\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactCoroutine\n * \n */\n\n// The Symbol used to tag the special React types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_COROUTINE_TYPE$1;\nvar REACT_YIELD_TYPE$1;\nif (typeof Symbol === 'function' && Symbol['for']) {\n  REACT_COROUTINE_TYPE$1 = Symbol['for']('react.coroutine');\n  REACT_YIELD_TYPE$1 = Symbol['for']('react.yield');\n} else {\n  REACT_COROUTINE_TYPE$1 = 0xeac8;\n  REACT_YIELD_TYPE$1 = 0xeac9;\n}\n\nvar createCoroutine = function (children, handler, props) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var coroutine = {\n    // This tag allow us to uniquely identify this as a React Coroutine\n    $$typeof: REACT_COROUTINE_TYPE$1,\n    key: key == null ? null : '' + key,\n    children: children,\n    handler: handler,\n    props: props\n  };\n\n  {\n    // TODO: Add _store property for marking this as validated.\n    if (Object.freeze) {\n      Object.freeze(coroutine.props);\n      Object.freeze(coroutine);\n    }\n  }\n\n  return coroutine;\n};\n\nvar createYield = function (value) {\n  var yieldNode = {\n    // This tag allow us to uniquely identify this as a React Yield\n    $$typeof: REACT_YIELD_TYPE$1,\n    value: value\n  };\n\n  {\n    // TODO: Add _store property for marking this as validated.\n    if (Object.freeze) {\n      Object.freeze(yieldNode);\n    }\n  }\n\n  return yieldNode;\n};\n\n/**\n * Verifies the object is a coroutine object.\n */\nvar isCoroutine = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_COROUTINE_TYPE$1;\n};\n\n/**\n * Verifies the object is a yield object.\n */\nvar isYield = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_YIELD_TYPE$1;\n};\n\nvar REACT_YIELD_TYPE_1 = REACT_YIELD_TYPE$1;\nvar REACT_COROUTINE_TYPE_1 = REACT_COROUTINE_TYPE$1;\n\nvar ReactCoroutine = {\n\tcreateCoroutine: createCoroutine,\n\tcreateYield: createYield,\n\tisCoroutine: isCoroutine,\n\tisYield: isYield,\n\tREACT_YIELD_TYPE: REACT_YIELD_TYPE_1,\n\tREACT_COROUTINE_TYPE: REACT_COROUTINE_TYPE_1\n};\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactPortal\n * \n */\n\n// The Symbol used to tag the special React types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_PORTAL_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;\n\nvar createPortal$1 = function (children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE$1,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n};\n\n/**\n * Verifies the object is a portal object.\n */\nvar isPortal = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_PORTAL_TYPE$1;\n};\n\nvar REACT_PORTAL_TYPE_1 = REACT_PORTAL_TYPE$1;\n\nvar ReactPortal = {\n\tcreatePortal: createPortal$1,\n\tisPortal: isPortal,\n\tREACT_PORTAL_TYPE: REACT_PORTAL_TYPE_1\n};\n\nvar REACT_COROUTINE_TYPE = ReactCoroutine.REACT_COROUTINE_TYPE;\nvar REACT_YIELD_TYPE = ReactCoroutine.REACT_YIELD_TYPE;\n\nvar REACT_PORTAL_TYPE = ReactPortal.REACT_PORTAL_TYPE;\n\n\n\n\n\n\n\n\n{\n  var _require3$4 = ReactDebugCurrentFiber_1,\n      getCurrentFiberStackAddendum$5 = _require3$4.getCurrentFiberStackAddendum;\n\n  var warning$24 = require$$0;\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n\n  var warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$5() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning$24(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$5());\n  };\n}\n\nvar createWorkInProgress$2 = ReactFiber.createWorkInProgress;\nvar createFiberFromElement$1 = ReactFiber.createFiberFromElement;\nvar createFiberFromFragment$1 = ReactFiber.createFiberFromFragment;\nvar createFiberFromText$1 = ReactFiber.createFiberFromText;\nvar createFiberFromCoroutine$1 = ReactFiber.createFiberFromCoroutine;\nvar createFiberFromYield$1 = ReactFiber.createFiberFromYield;\nvar createFiberFromPortal$1 = ReactFiber.createFiberFromPortal;\n\n\nvar isArray = Array.isArray;\n\nvar FunctionalComponent$2 = ReactTypeOfWork.FunctionalComponent;\nvar ClassComponent$7 = ReactTypeOfWork.ClassComponent;\nvar HostText$5 = ReactTypeOfWork.HostText;\nvar HostPortal$5 = ReactTypeOfWork.HostPortal;\nvar CoroutineComponent$2 = ReactTypeOfWork.CoroutineComponent;\nvar YieldComponent$3 = ReactTypeOfWork.YieldComponent;\nvar Fragment$3 = ReactTypeOfWork.Fragment;\nvar NoEffect$2 = ReactTypeOfSideEffect.NoEffect;\nvar Placement$3 = ReactTypeOfSideEffect.Placement;\nvar Deletion$1 = ReactTypeOfSideEffect.Deletion;\n\n\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n// The Symbol used to tag the ReactElement type. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n  return null;\n}\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        if (typeof owner.tag === 'number') {\n          var ownerFiber = owner;\n          !(ownerFiber.tag === ClassComponent$7) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n          inst = ownerFiber.stateNode;\n        } else {\n          // Stack\n          inst = owner.getPublicInstance();\n        }\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$5() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  warning$24(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$5() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldClone, shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    if (!shouldClone) {\n      // When we're reconciling in place we have a work in progress copy. We\n      // actually want the current copy. If there is no current copy, then we\n      // don't need to track deletion side-effects.\n      if (childToDelete.alternate === null) {\n        return;\n      }\n      childToDelete = childToDelete.alternate;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion$1;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, priority) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    if (shouldClone) {\n      var clone = createWorkInProgress$2(fiber, priority);\n      clone.index = 0;\n      clone.sibling = null;\n      return clone;\n    } else {\n      // We override the pending priority even if it is higher, because if\n      // we're reconciling at a lower priority that means that this was\n      // down-prioritized.\n      fiber.pendingWorkPriority = priority;\n      fiber.effectTag = NoEffect$2;\n      fiber.index = 0;\n      fiber.sibling = null;\n      return fiber;\n    }\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement$3;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement$3;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement$3;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, priority) {\n    if (current === null || current.tag !== HostText$5) {\n      // Insert\n      var created = createFiberFromText$1(textContent, returnFiber.internalContextTag, priority);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, priority);\n      existing.pendingProps = textContent;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, priority) {\n    if (current === null || current.type !== element.type) {\n      // Insert\n      var created = createFiberFromElement$1(element, returnFiber.internalContextTag, priority);\n      created.ref = coerceRef(current, element);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, priority);\n      existing.ref = coerceRef(current, element);\n      existing.pendingProps = element.props;\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    }\n  }\n\n  function updateCoroutine(returnFiber, current, coroutine, priority) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CoroutineComponent$2) {\n      // Insert\n      var created = createFiberFromCoroutine$1(coroutine, returnFiber.internalContextTag, priority);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, priority);\n      existing.pendingProps = coroutine;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateYield(returnFiber, current, yieldNode, priority) {\n    if (current === null || current.tag !== YieldComponent$3) {\n      // Insert\n      var created = createFiberFromYield$1(yieldNode, returnFiber.internalContextTag, priority);\n      created.type = yieldNode.value;\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, priority);\n      existing.type = yieldNode.value;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, priority) {\n    if (current === null || current.tag !== HostPortal$5 || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal$1(portal, returnFiber.internalContextTag, priority);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, priority);\n      existing.pendingProps = portal.children || [];\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, priority) {\n    if (current === null || current.tag !== Fragment$3) {\n      // Insert\n      var created = createFiberFromFragment$1(fragment, returnFiber.internalContextTag, priority);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, priority);\n      existing.pendingProps = fragment;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, priority) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes doesn't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText$1('' + newChild, returnFiber.internalContextTag, priority);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement$1(newChild, returnFiber.internalContextTag, priority);\n            _created.ref = coerceRef(null, newChild);\n            _created['return'] = returnFiber;\n            return _created;\n          }\n\n        case REACT_COROUTINE_TYPE:\n          {\n            var _created2 = createFiberFromCoroutine$1(newChild, returnFiber.internalContextTag, priority);\n            _created2['return'] = returnFiber;\n            return _created2;\n          }\n\n        case REACT_YIELD_TYPE:\n          {\n            var _created3 = createFiberFromYield$1(newChild, returnFiber.internalContextTag, priority);\n            _created3.type = newChild.value;\n            _created3['return'] = returnFiber;\n            return _created3;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created4 = createFiberFromPortal$1(newChild, returnFiber.internalContextTag, priority);\n            _created4['return'] = returnFiber;\n            return _created4;\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _created5 = createFiberFromFragment$1(newChild, returnFiber.internalContextTag, priority);\n        _created5['return'] = returnFiber;\n        return _created5;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, priority) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes doesn't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, priority);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, priority);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_COROUTINE_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateCoroutine(returnFiber, oldFiber, newChild, priority);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_YIELD_TYPE:\n          {\n            // Yields doesn't have keys. If the previous node is implicitly keyed\n            // we can continue to replace it without aborting even if it is not a\n            // yield.\n            if (key === null) {\n              return updateYield(returnFiber, oldFiber, newChild, priority);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, priority);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        // Fragments doesn't have keys so if the previous key is implicit we can\n        // update it.\n        if (key !== null) {\n          return null;\n        }\n        return updateFragment(returnFiber, oldFiber, newChild, priority);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, priority) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes doesn't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, priority);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateElement(returnFiber, _matchedFiber, newChild, priority);\n          }\n\n        case REACT_COROUTINE_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateCoroutine(returnFiber, _matchedFiber2, newChild, priority);\n          }\n\n        case REACT_YIELD_TYPE:\n          {\n            // Yields doesn't have keys, so we neither have to check the old nor\n            // new node for the key. If both are yields, they match.\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n            return updateYield(returnFiber, _matchedFiber3, newChild, priority);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber4, newChild, priority);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber5, newChild, priority);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_COROUTINE_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning$24(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$5());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, priority) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], priority);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], priority);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], priority);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, priority) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning$24(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$5());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, priority);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, priority);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, priority);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, priority) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText$5) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, priority);\n      existing.pendingProps = textContent;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText$1(textContent, returnFiber.internalContextTag, priority);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, priority) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, priority);\n          existing.ref = coerceRef(child, element);\n          existing.pendingProps = element.props;\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromElement$1(element, returnFiber.internalContextTag, priority);\n    created.ref = coerceRef(currentFirstChild, element);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleCoroutine(returnFiber, currentFirstChild, coroutine, priority) {\n    var key = coroutine.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CoroutineComponent$2) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, priority);\n          existing.pendingProps = coroutine;\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCoroutine$1(coroutine, returnFiber.internalContextTag, priority);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleYield(returnFiber, currentFirstChild, yieldNode, priority) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === YieldComponent$3) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, priority);\n        existing.type = yieldNode.value;\n        existing['return'] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromYield$1(yieldNode, returnFiber.internalContextTag, priority);\n    created.type = yieldNode.value;\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, priority) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal$5 && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, priority);\n          existing.pendingProps = portal.children || [];\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal$1(portal, returnFiber.internalContextTag, priority);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, priority) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n    if (isObject) {\n      // Support only the subset of return types that Stack supports. Treat\n      // everything else as empty, but log a warning.\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, priority));\n\n        case REACT_COROUTINE_TYPE:\n          return placeSingleChild(reconcileSingleCoroutine(returnFiber, currentFirstChild, newChild, priority));\n\n        case REACT_YIELD_TYPE:\n          return placeSingleChild(reconcileSingleYield(returnFiber, currentFirstChild, newChild, priority));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, priority));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, priority));\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, priority);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, priority);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent$7:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent$2:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers$1 = ChildReconciler(true, true);\n\nvar reconcileChildFibersInPlace$1 = ChildReconciler(false, true);\n\nvar mountChildFibersInPlace$1 = ChildReconciler(false, false);\n\nvar cloneChildFibers$1 = function (current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress$2(currentChild, currentChild.pendingWorkPriority);\n  // TODO: Pass this as an argument, since it's easy to forget.\n  newChild.pendingProps = currentChild.pendingProps;\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress$2(currentChild, currentChild.pendingWorkPriority);\n    newChild.pendingProps = currentChild.pendingProps;\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n};\n\nvar ReactChildFiber = {\n\treconcileChildFibers: reconcileChildFibers$1,\n\treconcileChildFibersInPlace: reconcileChildFibersInPlace$1,\n\tmountChildFibersInPlace: mountChildFibersInPlace$1,\n\tcloneChildFibers: cloneChildFibers$1\n};\n\nvar Update$1 = ReactTypeOfSideEffect.Update;\n\n\n\nvar AsyncUpdates$1 = ReactTypeOfInternalContext.AsyncUpdates;\n\nvar cacheContext$1 = ReactFiberContext.cacheContext;\nvar getMaskedContext$2 = ReactFiberContext.getMaskedContext;\nvar getUnmaskedContext$2 = ReactFiberContext.getUnmaskedContext;\nvar isContextConsumer$1 = ReactFiberContext.isContextConsumer;\n\nvar addUpdate$1 = ReactFiberUpdateQueue.addUpdate;\nvar addReplaceUpdate$1 = ReactFiberUpdateQueue.addReplaceUpdate;\nvar addForceUpdate$1 = ReactFiberUpdateQueue.addForceUpdate;\nvar beginUpdateQueue$2 = ReactFiberUpdateQueue.beginUpdateQueue;\n\nvar _require5 = ReactFiberContext;\nvar hasContextChanged$2 = _require5.hasContextChanged;\n\nvar isMounted$1 = ReactFiberTreeReflection.isMounted;\n\n\n\n\n\n\n\nvar fakeInternalInstance = {};\nvar isArray$1 = Array.isArray;\n\n{\n  var _require7$1 = ReactDebugFiberPerf_1,\n      startPhaseTimer$1 = _require7$1.startPhaseTimer,\n      stopPhaseTimer$1 = _require7$1.stopPhaseTimer;\n\n  var warning$25 = require$$0;\n  var warnOnInvalidCallback = function (callback, callerName) {\n    warning$25(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function (scheduleUpdate, getPriorityContext, memoizeProps, memoizeState) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted$1,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = ReactInstanceMap_1.get(instance);\n      var priorityLevel = getPriorityContext(fiber, false);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      addUpdate$1(fiber, partialState, callback, priorityLevel);\n      scheduleUpdate(fiber, priorityLevel);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = ReactInstanceMap_1.get(instance);\n      var priorityLevel = getPriorityContext(fiber, false);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      addReplaceUpdate$1(fiber, state, callback, priorityLevel);\n      scheduleUpdate(fiber, priorityLevel);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = ReactInstanceMap_1.get(instance);\n      var priorityLevel = getPriorityContext(fiber, false);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      addForceUpdate$1(fiber, callback, priorityLevel);\n      scheduleUpdate(fiber, priorityLevel);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      {\n        startPhaseTimer$1(workInProgress, 'shouldComponentUpdate');\n      }\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      {\n        stopPhaseTimer$1();\n      }\n\n      {\n        warning$25(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName_1(workInProgress) || 'Unknown');\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName_1(workInProgress);\n      var renderPresent = instance.render;\n      warning$25(renderPresent, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      warning$25(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      warning$25(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n      var noInstancePropTypes = !instance.propTypes;\n      warning$25(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning$25(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      warning$25(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning$25(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName_1(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      warning$25(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      warning$25(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning$25(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning$25(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== 'object' || isArray$1(state))) {\n      invariant(false, '%s.state: must be set to an object or null', getComponentName_1(workInProgress));\n    }\n    if (typeof instance.getChildContext === 'function') {\n      !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName_1(workInProgress)) : void 0;\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    ReactInstanceMap_1.set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext$2(workInProgress);\n    var needsContext = isContextConsumer$1(workInProgress);\n    var context = needsContext ? getMaskedContext$2(workInProgress, unmaskedContext) : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext$1(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    {\n      startPhaseTimer$1(workInProgress, 'componentWillMount');\n    }\n    var oldState = instance.state;\n    instance.componentWillMount();\n    {\n      stopPhaseTimer$1();\n    }\n\n    if (oldState !== instance.state) {\n      {\n        warning$25(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName_1(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    {\n      startPhaseTimer$1(workInProgress, 'componentWillReceiveProps');\n    }\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    {\n      stopPhaseTimer$1();\n    }\n\n    if (instance.state !== oldState) {\n      {\n        warning$25(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName_1(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, priorityLevel) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext$2(workInProgress);\n\n    instance.props = props;\n    instance.state = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext$2(workInProgress, unmaskedContext);\n\n    if (ReactFeatureFlags_1.enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates$1;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = beginUpdateQueue$2(current, workInProgress, updateQueue, instance, state, props, priorityLevel);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update$1;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = beginUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = beginUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, priorityLevel) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext$2(workInProgress);\n    var newContext = getMaskedContext$2(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = beginUpdateQueue$2(current, workInProgress, workInProgress.updateQueue, instance, oldState, newProps, priorityLevel);\n    } else {\n      newState = oldState;\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged$2() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update$1;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillUpdate');\n        }\n        instance.componentWillUpdate(newProps, newState, newContext);\n        {\n          stopPhaseTimer$1();\n        }\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update$1;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update$1;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\nvar mountChildFibersInPlace = ReactChildFiber.mountChildFibersInPlace;\nvar reconcileChildFibers = ReactChildFiber.reconcileChildFibers;\nvar reconcileChildFibersInPlace = ReactChildFiber.reconcileChildFibersInPlace;\nvar cloneChildFibers = ReactChildFiber.cloneChildFibers;\n\nvar beginUpdateQueue$1 = ReactFiberUpdateQueue.beginUpdateQueue;\n\n\n\nvar getMaskedContext$1 = ReactFiberContext.getMaskedContext;\nvar getUnmaskedContext$1 = ReactFiberContext.getUnmaskedContext;\nvar hasContextChanged$1 = ReactFiberContext.hasContextChanged;\nvar pushContextProvider$1 = ReactFiberContext.pushContextProvider;\nvar pushTopLevelContextObject$1 = ReactFiberContext.pushTopLevelContextObject;\nvar invalidateContextProvider$1 = ReactFiberContext.invalidateContextProvider;\n\nvar IndeterminateComponent$2 = ReactTypeOfWork.IndeterminateComponent;\nvar FunctionalComponent$1 = ReactTypeOfWork.FunctionalComponent;\nvar ClassComponent$6 = ReactTypeOfWork.ClassComponent;\nvar HostRoot$7 = ReactTypeOfWork.HostRoot;\nvar HostComponent$7 = ReactTypeOfWork.HostComponent;\nvar HostText$4 = ReactTypeOfWork.HostText;\nvar HostPortal$4 = ReactTypeOfWork.HostPortal;\nvar CoroutineComponent$1 = ReactTypeOfWork.CoroutineComponent;\nvar CoroutineHandlerPhase = ReactTypeOfWork.CoroutineHandlerPhase;\nvar YieldComponent$2 = ReactTypeOfWork.YieldComponent;\nvar Fragment$2 = ReactTypeOfWork.Fragment;\n\nvar NoWork$3 = ReactPriorityLevel.NoWork;\nvar OffscreenPriority$1 = ReactPriorityLevel.OffscreenPriority;\n\nvar PerformedWork$1 = ReactTypeOfSideEffect.PerformedWork;\nvar Placement$2 = ReactTypeOfSideEffect.Placement;\nvar ContentReset$1 = ReactTypeOfSideEffect.ContentReset;\nvar Err$1 = ReactTypeOfSideEffect.Err;\nvar Ref$1 = ReactTypeOfSideEffect.Ref;\n\n\n\nvar ReactCurrentOwner$2 = ReactGlobalSharedState_1.ReactCurrentOwner;\n\n\n\n{\n  var ReactDebugCurrentFiber$4 = ReactDebugCurrentFiber_1;\n\n  var _require7 = ReactDebugFiberPerf_1,\n      cancelWorkTimer = _require7.cancelWorkTimer;\n\n  var warning$23 = require$$0;\n\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleUpdate, getPriorityContext) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      useSyncScheduling = config.useSyncScheduling,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleUpdate, getPriorityContext, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    var priorityLevel = workInProgress.pendingWorkPriority;\n    reconcileChildrenAtPriority(current, workInProgress, nextChildren, priorityLevel);\n  }\n\n  function reconcileChildrenAtPriority(current, workInProgress, nextChildren, priorityLevel) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n    } else if (current.child === workInProgress.child) {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n    } else {\n      // If, on the other hand, it is already using a clone, that means we've\n      // already begun some work on this tree and we can continue where we left\n      // off by reconciling against the existing children.\n      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged$1()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref$1;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    var memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged$1()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext$1(workInProgress);\n    var context = getMaskedContext$1(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner$2.current = workInProgress;\n      ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, 'render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork$1;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, priorityLevel) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider$1(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, priorityLevel);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, priorityLevel);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, priorityLevel);\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider$1(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner$2.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, 'render');\n      nextChildren = instance.render();\n      ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork$1;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider$1(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject$1(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject$1(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, priorityLevel) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = beginUpdateQueue$1(current, workInProgress, updateQueue, null, prevState, null, priorityLevel);\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work matching this priority.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      if ((current === null || current.child === null) && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement$2;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, priorityLevel);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderPriority) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = memoizedProps;\n      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged$1()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset$1;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderPriority !== OffscreenPriority$1 && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.pendingWorkPriority = OffscreenPriority$1;\n      // Bailout and come back to this fiber later at OffscreenPriority.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, priorityLevel) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext$1(workInProgress);\n    var context = getMaskedContext$1(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      ReactCurrentOwner$2.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork$1;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent$6;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider$1(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, priorityLevel);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent$1;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning$23(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber$4.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning$23(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber$4.getCurrentFiberStackAddendum());\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCoroutineComponent(current, workInProgress) {\n    var nextCoroutine = workInProgress.pendingProps;\n    if (hasContextChanged$1()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCoroutine === null) {\n        nextCoroutine = current && current.memoizedProps;\n        !(nextCoroutine !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextCoroutine === null || workInProgress.memoizedProps === nextCoroutine) {\n      nextCoroutine = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCoroutine.children;\n    var priorityLevel = workInProgress.pendingWorkPriority;\n\n    // The following is a fork of reconcileChildrenAtPriority but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, priorityLevel);\n    } else if (current.child === workInProgress.child) {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, priorityLevel);\n    } else {\n      workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, priorityLevel);\n    }\n\n    memoizeProps(workInProgress, nextCoroutine);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var priorityLevel = workInProgress.pendingWorkPriority;\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged$1()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    {\n      cancelWorkTimer(workInProgress);\n    }\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    {\n      cancelWorkTimer(workInProgress);\n    }\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot$7:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent$6:\n        pushContextProvider$1(workInProgress);\n        break;\n      case HostPortal$4:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by beginUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, priorityLevel) {\n    if (workInProgress.pendingWorkPriority === NoWork$3 || workInProgress.pendingWorkPriority > priorityLevel) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    {\n      ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, null);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent$2:\n        return mountIndeterminateComponent(current, workInProgress, priorityLevel);\n      case FunctionalComponent$1:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent$6:\n        return updateClassComponent(current, workInProgress, priorityLevel);\n      case HostRoot$7:\n        return updateHostRoot(current, workInProgress, priorityLevel);\n      case HostComponent$7:\n        return updateHostComponent(current, workInProgress, priorityLevel);\n      case HostText$4:\n        return updateHostText(current, workInProgress);\n      case CoroutineHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CoroutineComponent$1;\n      // Intentionally fall through since this is now the same.\n      case CoroutineComponent$1:\n        return updateCoroutineComponent(current, workInProgress);\n      case YieldComponent$2:\n        // A yield component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal$4:\n        return updatePortalComponent(current, workInProgress);\n      case Fragment$2:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, priorityLevel) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent$6:\n        pushContextProvider$1(workInProgress);\n        break;\n      case HostRoot$7:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err$1;\n\n    // This is a weird case where we do \"resume\" work — work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (workInProgress.pendingWorkPriority === NoWork$3 || workInProgress.pendingWorkPriority > priorityLevel) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtPriority(current, workInProgress, nextChildren, priorityLevel);\n\n    if (workInProgress.tag === ClassComponent$6) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar reconcileChildFibers$2 = ReactChildFiber.reconcileChildFibers;\n\nvar popContextProvider$2 = ReactFiberContext.popContextProvider;\nvar popTopLevelContextObject$1 = ReactFiberContext.popTopLevelContextObject;\n\n\n\n\nvar IndeterminateComponent$3 = ReactTypeOfWork.IndeterminateComponent;\nvar FunctionalComponent$3 = ReactTypeOfWork.FunctionalComponent;\nvar ClassComponent$8 = ReactTypeOfWork.ClassComponent;\nvar HostRoot$8 = ReactTypeOfWork.HostRoot;\nvar HostComponent$8 = ReactTypeOfWork.HostComponent;\nvar HostText$6 = ReactTypeOfWork.HostText;\nvar HostPortal$6 = ReactTypeOfWork.HostPortal;\nvar CoroutineComponent$3 = ReactTypeOfWork.CoroutineComponent;\nvar CoroutineHandlerPhase$1 = ReactTypeOfWork.CoroutineHandlerPhase;\nvar YieldComponent$4 = ReactTypeOfWork.YieldComponent;\nvar Fragment$4 = ReactTypeOfWork.Fragment;\nvar Placement$4 = ReactTypeOfSideEffect.Placement;\nvar Ref$2 = ReactTypeOfSideEffect.Ref;\nvar Update$2 = ReactTypeOfSideEffect.Update;\nvar OffscreenPriority$2 = ReactPriorityLevel.OffscreenPriority;\n\n\n{\n  var ReactDebugCurrentFiber$5 = ReactDebugCurrentFiber_1;\n}\n\n\n\nvar ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update$2;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref$2;\n  }\n\n  function appendAllYields(yields, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent$8 || node.tag === HostText$6 || node.tag === HostPortal$6) {\n        invariant(false, 'A coroutine cannot have host component children.');\n      } else if (node.tag === YieldComponent$4) {\n        yields.push(node.type);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCoroutineToHandlerPhase(current, workInProgress) {\n    var coroutine = workInProgress.memoizedProps;\n    !coroutine ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the coroutine has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage coroutine represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CoroutineHandlerPhase$1;\n\n    // Build up the yields.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var yields = [];\n    appendAllYields(yields, workInProgress);\n    var fn = coroutine.handler;\n    var props = coroutine.props;\n    var nextChildren = fn(props, yields);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    // Inherit the priority of the returnFiber.\n    var priority = workInProgress.pendingWorkPriority;\n    workInProgress.child = reconcileChildFibers$2(workInProgress, currentFirstChild, nextChildren, priority);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent$8 || node.tag === HostText$6) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal$6) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node = node.sibling;\n    }\n  }\n\n  function completeWork(current, workInProgress, renderPriority) {\n    {\n      ReactDebugCurrentFiber$5.setCurrentFiber(workInProgress, null);\n    }\n\n    // Get the latest props.\n    var newProps = workInProgress.pendingProps;\n    if (newProps === null) {\n      newProps = workInProgress.memoizedProps;\n    } else if (workInProgress.pendingWorkPriority !== OffscreenPriority$2 || renderPriority === OffscreenPriority$2) {\n      // Reset the pending props, unless this was a down-prioritization.\n      workInProgress.pendingProps = null;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent$3:\n        return null;\n      case ClassComponent$8:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popContextProvider$2(workInProgress);\n          return null;\n        }\n      case HostRoot$8:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelContextObject$1(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement$4;\n          }\n          return null;\n        }\n      case HostComponent$8:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            // TODO: Type this specific to this type of component.\n            workInProgress.updateQueue = updatePayload;\n            // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update.\n            if (updatePayload) {\n              markUpdate(workInProgress);\n            }\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TOOD: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText$6:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            if (oldText !== newText) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CoroutineComponent$3:\n        return moveCoroutineToHandlerPhase(current, workInProgress);\n      case CoroutineHandlerPhase$1:\n        // Reset the tag to now be a first phase coroutine.\n        workInProgress.tag = CoroutineComponent$3;\n        return null;\n      case YieldComponent$4:\n        // Does nothing.\n        return null;\n      case Fragment$4:\n        return null;\n      case HostPortal$6:\n        // TODO: Only mark this as an update if we have any pending callbacks.\n        markUpdate(workInProgress);\n        popHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent$3:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\n{\n  var warning$26 = require$$0;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning$26(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals$1(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (!hook.supportsFiber) {\n    {\n      warning$26(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning$26(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot$1(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount$1(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\nvar injectInternals_1 = injectInternals$1;\nvar onCommitRoot_1 = onCommitRoot$1;\nvar onCommitUnmount_1 = onCommitUnmount$1;\n\nvar ReactFiberDevToolsHook = {\n\tinjectInternals: injectInternals_1,\n\tonCommitRoot: onCommitRoot_1,\n\tonCommitUnmount: onCommitUnmount_1\n};\n\nvar ClassComponent$9 = ReactTypeOfWork.ClassComponent;\nvar HostRoot$9 = ReactTypeOfWork.HostRoot;\nvar HostComponent$9 = ReactTypeOfWork.HostComponent;\nvar HostText$7 = ReactTypeOfWork.HostText;\nvar HostPortal$7 = ReactTypeOfWork.HostPortal;\nvar CoroutineComponent$4 = ReactTypeOfWork.CoroutineComponent;\n\nvar commitCallbacks$1 = ReactFiberUpdateQueue.commitCallbacks;\n\nvar onCommitUnmount = ReactFiberDevToolsHook.onCommitUnmount;\n\nvar invokeGuardedCallback$2 = ReactErrorUtils_1.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils_1.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils_1.clearCaughtError;\n\nvar Placement$5 = ReactTypeOfSideEffect.Placement;\nvar Update$3 = ReactTypeOfSideEffect.Update;\nvar Callback$1 = ReactTypeOfSideEffect.Callback;\nvar ContentReset$2 = ReactTypeOfSideEffect.ContentReset;\n\n\n\n{\n  var _require5$1 = ReactDebugFiberPerf_1,\n      startPhaseTimer$2 = _require5$1.startPhaseTimer,\n      stopPhaseTimer$2 = _require5$1.stopPhaseTimer;\n}\n\nvar ReactFiberCommitWork = function (config, captureError) {\n  var commitMount = config.commitMount,\n      commitUpdate = config.commitUpdate,\n      resetTextContent = config.resetTextContent,\n      commitTextUpdate = config.commitTextUpdate,\n      appendChild = config.appendChild,\n      appendChildToContainer = config.appendChildToContainer,\n      insertBefore = config.insertBefore,\n      insertInContainerBefore = config.insertInContainerBefore,\n      removeChild = config.removeChild,\n      removeChildFromContainer = config.removeChildFromContainer,\n      getPublicInstance = config.getPublicInstance;\n\n\n  {\n    var callComponentWillUnmountWithTimerInDev = function (current, instance) {\n      startPhaseTimer$2(current, 'componentWillUnmount');\n      instance.props = current.memoizedProps;\n      instance.state = current.memoizedState;\n      instance.componentWillUnmount();\n      stopPhaseTimer$2();\n    };\n  }\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimerInDev, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent$9 || fiber.tag === HostRoot$9 || fiber.tag === HostPortal$7;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent$9 && node.tag !== HostText$7) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement$5) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal$7) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement$5)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent$9:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot$9:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal$7:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset$2) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset$2;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent$9 || node.tag === HostText$7) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal$7) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && node.tag !== HostPortal$7) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent$9:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot$9:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal$7:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent$9 || node.tag === HostText$7) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal$7) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal$7) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent$9:\n        {\n          safelyDetachRef(current);\n          var instance = current.stateNode;\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, instance);\n          }\n          return;\n        }\n      case HostComponent$9:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CoroutineComponent$4:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal$7:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          unmountHostComponents(current);\n          return;\n        }\n    }\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent$9:\n        {\n          return;\n        }\n      case HostComponent$9:\n        {\n          var instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText$7:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot$9:\n        {\n          return;\n        }\n      case HostPortal$7:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent$9:\n        {\n          var instance = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update$3) {\n            if (current === null) {\n              {\n                startPhaseTimer$2(finishedWork, 'componentDidMount');\n              }\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidMount();\n              {\n                stopPhaseTimer$2();\n              }\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              {\n                startPhaseTimer$2(finishedWork, 'componentDidUpdate');\n              }\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidUpdate(prevProps, prevState);\n              {\n                stopPhaseTimer$2();\n              }\n            }\n          }\n          if (finishedWork.effectTag & Callback$1 && finishedWork.updateQueue !== null) {\n            commitCallbacks$1(finishedWork, finishedWork.updateQueue, instance);\n          }\n          return;\n        }\n      case HostRoot$9:\n        {\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            var _instance = finishedWork.child && finishedWork.child.stateNode;\n            commitCallbacks$1(finishedWork, updateQueue, _instance);\n          }\n          return;\n        }\n      case HostComponent$9:\n        {\n          var _instance2 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update$3) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText$7:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal$7:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent$9:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  return {\n    commitPlacement: commitPlacement,\n    commitDeletion: commitDeletion,\n    commitWork: commitWork,\n    commitLifeCycles: commitLifeCycles,\n    commitAttachRef: commitAttachRef,\n    commitDetachRef: commitDetachRef\n  };\n};\n\nvar createCursor$2 = ReactFiberStack.createCursor;\nvar pop$2 = ReactFiberStack.pop;\nvar push$2 = ReactFiberStack.push;\n\n\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n\n\n  var contextStackCursor = createCursor$2(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor$2(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor$2(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push$2(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push$2(contextFiberStackCursor, fiber, fiber);\n    push$2(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop$2(contextStackCursor, fiber);\n    pop$2(contextFiberStackCursor, fiber);\n    pop$2(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push$2(contextFiberStackCursor, fiber, fiber);\n    push$2(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop$2(contextStackCursor, fiber);\n    pop$2(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar HostComponent$10 = ReactTypeOfWork.HostComponent;\nvar HostText$8 = ReactTypeOfWork.HostText;\nvar HostRoot$10 = ReactTypeOfWork.HostRoot;\n\nvar Deletion$2 = ReactTypeOfSideEffect.Deletion;\nvar Placement$6 = ReactTypeOfSideEffect.Placement;\n\nvar createFiberFromHostInstanceForDeletion$1 = ReactFiber.createFiberFromHostInstanceForDeletion;\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      canHydrateInstance = config.canHydrateInstance,\n      canHydrateTextInstance = config.canHydrateTextInstance,\n      getNextHydratableSibling = config.getNextHydratableSibling,\n      getFirstHydratableChild = config.getFirstHydratableChild,\n      hydrateInstance = config.hydrateInstance,\n      hydrateTextInstance = config.hydrateTextInstance,\n      didNotHydrateInstance = config.didNotHydrateInstance,\n      didNotFindHydratableInstance = config.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = config.didNotFindHydratableTextInstance;\n\n  // If this doesn't have hydration mode.\n\n  if (!(canHydrateInstance && canHydrateTextInstance && getNextHydratableSibling && getFirstHydratableChild && hydrateInstance && hydrateTextInstance && didNotHydrateInstance && didNotFindHydratableInstance && didNotFindHydratableTextInstance)) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot$10:\n          didNotHydrateInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent$10:\n          didNotHydrateInstance(returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion$1();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion$2;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement$6;\n    {\n      var parentInstance;\n      switch (returnFiber.tag) {\n        // TODO: Currently we don't warn for insertions into the root because\n        // we always insert into the root in the non-hydrating case. We just\n        // delete the existing content. Reenable this once we have a better\n        // strategy for determining if we're hydrating or not.\n        // case HostRoot:\n        //   parentInstance = returnFiber.stateNode.containerInfo;\n        //   break;\n        case HostComponent$10:\n          parentInstance = returnFiber.stateNode;\n          break;\n        default:\n          return;\n      }\n      switch (fiber.tag) {\n        case HostComponent$10:\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          didNotFindHydratableInstance(parentInstance, type, props);\n          break;\n        case HostText$8:\n          var text = fiber.pendingProps;\n          didNotFindHydratableTextInstance(parentInstance, text);\n          break;\n      }\n    }\n  }\n\n  function canHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent$10:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          return canHydrateInstance(nextInstance, type, props);\n        }\n      case HostText$8:\n        {\n          var text = fiber.pendingProps;\n          return canHydrateTextInstance(nextInstance, text);\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!canHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !canHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    fiber.stateNode = nextInstance;\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var shouldUpdate = hydrateTextInstance(textInstance, fiber.memoizedProps, fiber);\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent$10 && parent.tag !== HostRoot$10) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent$10 || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactFiberInstrumentation\n * \n */\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\n\nvar ReactFiberInstrumentation$2 = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation$2;\n\nvar popContextProvider$1 = ReactFiberContext.popContextProvider;\n\nvar reset$1 = ReactFiberStack.reset;\n\nvar getStackAddendumByWorkInProgressFiber$2 = ReactFiberComponentTreeHook.getStackAddendumByWorkInProgressFiber;\n\nvar logCapturedError = ReactFiberErrorLogger.logCapturedError;\n\nvar invokeGuardedCallback$1 = ReactErrorUtils_1.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils_1.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils_1.clearCaughtError;\n\n\n\n\n\n\n\nvar ReactCurrentOwner$1 = ReactGlobalSharedState_1.ReactCurrentOwner;\n\n\n\nvar createWorkInProgress$1 = ReactFiber.createWorkInProgress;\nvar largerPriority$1 = ReactFiber.largerPriority;\n\nvar onCommitRoot = ReactFiberDevToolsHook.onCommitRoot;\n\nvar NoWork$2 = ReactPriorityLevel.NoWork;\nvar SynchronousPriority$1 = ReactPriorityLevel.SynchronousPriority;\nvar TaskPriority$1 = ReactPriorityLevel.TaskPriority;\nvar HighPriority = ReactPriorityLevel.HighPriority;\nvar LowPriority = ReactPriorityLevel.LowPriority;\nvar OffscreenPriority = ReactPriorityLevel.OffscreenPriority;\n\nvar AsyncUpdates = ReactTypeOfInternalContext.AsyncUpdates;\n\nvar PerformedWork = ReactTypeOfSideEffect.PerformedWork;\nvar Placement$1 = ReactTypeOfSideEffect.Placement;\nvar Update = ReactTypeOfSideEffect.Update;\nvar PlacementAndUpdate = ReactTypeOfSideEffect.PlacementAndUpdate;\nvar Deletion = ReactTypeOfSideEffect.Deletion;\nvar ContentReset = ReactTypeOfSideEffect.ContentReset;\nvar Callback = ReactTypeOfSideEffect.Callback;\nvar Err = ReactTypeOfSideEffect.Err;\nvar Ref = ReactTypeOfSideEffect.Ref;\n\nvar HostRoot$6 = ReactTypeOfWork.HostRoot;\nvar HostComponent$6 = ReactTypeOfWork.HostComponent;\nvar HostPortal$3 = ReactTypeOfWork.HostPortal;\nvar ClassComponent$5 = ReactTypeOfWork.ClassComponent;\n\nvar getUpdatePriority$1 = ReactFiberUpdateQueue.getUpdatePriority;\n\nvar _require14 = ReactFiberContext;\nvar resetContext$1 = _require14.resetContext;\n\n\n\n{\n  var warning$22 = require$$0;\n  var ReactFiberInstrumentation$1 = ReactFiberInstrumentation_1;\n  var ReactDebugCurrentFiber$3 = ReactDebugCurrentFiber_1;\n\n  var _require15 = ReactDebugFiberPerf_1,\n      recordEffect = _require15.recordEffect,\n      recordScheduleUpdate = _require15.recordScheduleUpdate,\n      startWorkTimer = _require15.startWorkTimer,\n      stopWorkTimer = _require15.stopWorkTimer,\n      stopFailedWorkTimer = _require15.stopFailedWorkTimer,\n      startWorkLoopTimer = _require15.startWorkLoopTimer,\n      stopWorkLoopTimer = _require15.stopWorkLoopTimer,\n      startCommitTimer = _require15.startCommitTimer,\n      stopCommitTimer = _require15.stopCommitTimer,\n      startCommitHostEffectsTimer = _require15.startCommitHostEffectsTimer,\n      stopCommitHostEffectsTimer = _require15.stopCommitHostEffectsTimer,\n      startCommitLifeCyclesTimer = _require15.startCommitLifeCyclesTimer,\n      stopCommitLifeCyclesTimer = _require15.stopCommitLifeCyclesTimer;\n\n  var warnAboutUpdateOnUnmounted = function (instance) {\n    var ctor = instance.constructor;\n    warning$22(false, 'Can only update a mounted or mounting component. This usually means ' + 'you called setState, replaceState, or forceUpdate on an unmounted ' + 'component. This is a no-op.\\n\\nPlease check the code for the ' + '%s component.', ctor && (ctor.displayName || ctor.name) || 'ReactClass');\n  };\n\n  var warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber$3.phase) {\n      case 'getChildContext':\n        warning$22(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        break;\n      case 'render':\n        warning$22(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        break;\n    }\n  };\n}\n\nvar timeHeuristicForUnitOfWork = 1;\n\nvar ReactFiberScheduler = function (config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext,\n      resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleUpdate, getPriorityContext),\n      beginWork = _ReactFiberBeginWork.beginWork,\n      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var scheduleDeferredCallback = config.scheduleDeferredCallback,\n      useSyncScheduling = config.useSyncScheduling,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // The priority level to use when scheduling an update. We use NoWork to\n  // represent the default priority.\n  // TODO: Should we change this to an array instead of using the call stack?\n  // Might be less confusing.\n\n  var priorityContext = NoWork$2;\n\n  // Keeps track of whether we're currently in a work loop.\n  var isPerformingWork = false;\n\n  // Keeps track of whether the current deadline has expired.\n  var deadlineHasExpired = false;\n\n  // Keeps track of whether we should should batch sync updates.\n  var isBatchingUpdates = false;\n\n  // This is needed for the weird case where the initial mount is synchronous\n  // even inside batchedUpdates :(\n  var isUnbatchingUpdates = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextPriorityLevel = NoWork$2;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  var pendingCommit = null;\n\n  // Linked list of roots with scheduled work on them.\n  var nextScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  // Keep track of which host environment callbacks are scheduled.\n  var isCallbackScheduled = false;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n  var nextRenderedTree = null;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset$1();\n    // Reset the cursors\n    resetContext$1();\n    resetHostContainer();\n  }\n\n  // resetNextUnitOfWork mutates the current priority context. It is reset after\n  // after the workLoop exits, so never call resetNextUnitOfWork from outside\n  // the work loop.\n  function resetNextUnitOfWork() {\n    // Clear out roots with no more work on them, or if they have uncaught errors\n    while (nextScheduledRoot !== null && nextScheduledRoot.current.pendingWorkPriority === NoWork$2) {\n      // Unschedule this root.\n      nextScheduledRoot.isScheduled = false;\n      // Read the next pointer now.\n      // We need to clear it in case this root gets scheduled again later.\n      var next = nextScheduledRoot.nextScheduledRoot;\n      nextScheduledRoot.nextScheduledRoot = null;\n      // Exit if we cleared all the roots and there's no work to do.\n      if (nextScheduledRoot === lastScheduledRoot) {\n        nextScheduledRoot = null;\n        lastScheduledRoot = null;\n        nextPriorityLevel = NoWork$2;\n        return null;\n      }\n      // Continue with the next root.\n      // If there's no work on it, it will get unscheduled too.\n      nextScheduledRoot = next;\n    }\n\n    var root = nextScheduledRoot;\n    var highestPriorityRoot = null;\n    var highestPriorityLevel = NoWork$2;\n    while (root !== null) {\n      if (root.current.pendingWorkPriority !== NoWork$2 && (highestPriorityLevel === NoWork$2 || highestPriorityLevel > root.current.pendingWorkPriority)) {\n        highestPriorityLevel = root.current.pendingWorkPriority;\n        highestPriorityRoot = root;\n      }\n      // We didn't find anything to do in this root, so let's try the next one.\n      root = root.nextScheduledRoot;\n    }\n    if (highestPriorityRoot !== null) {\n      nextPriorityLevel = highestPriorityLevel;\n      // Before we start any new work, let's make sure that we have a fresh\n      // stack to work from.\n      // TODO: This call is buried a bit too deep. It would be nice to have\n      // a single point which happens right before any new work and\n      // unfortunately this is it.\n      resetContextStack();\n\n      nextUnitOfWork = createWorkInProgress$1(highestPriorityRoot.current, highestPriorityLevel);\n      if (highestPriorityRoot !== nextRenderedTree) {\n        // We've switched trees. Reset the nested update counter.\n        nestedUpdateCount = 0;\n        nextRenderedTree = highestPriorityRoot;\n      }\n      return;\n    }\n\n    nextPriorityLevel = NoWork$2;\n    nextUnitOfWork = null;\n    nextRenderedTree = null;\n    return;\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber$3.setCurrentFiber(nextEffect, null);\n        recordEffect();\n      }\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        config.resetTextContent(nextEffect.stateNode);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement$1:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement$1;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement$1;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            isUnmounting = true;\n            commitDeletion(nextEffect);\n            isUnmounting = false;\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber$3.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      // Use Task priority for lifecycle updates\n      if (effectTag & (Update | Callback)) {\n        {\n          recordEffect();\n        }\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        {\n          recordEffect();\n        }\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        {\n          recordEffect();\n        }\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitAllWork(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isCommitting = true;\n    {\n      startCommitTimer();\n    }\n\n    pendingCommit = null;\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    if (nextPriorityLevel === SynchronousPriority$1 || nextPriorityLevel === TaskPriority$1) {\n      // Keep track of the number of iterations to prevent an infinite\n      // update loop.\n      nestedUpdateCount++;\n    }\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner$1.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    {\n      startCommitHostEffectsTimer();\n    }\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    {\n      stopCommitHostEffectsTimer();\n    }\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    {\n      startCommitLifeCyclesTimer();\n    }\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    {\n      stopCommitLifeCyclesTimer();\n      stopCommitTimer();\n    }\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation$1.debugTool) {\n      ReactFiberInstrumentation$1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    // This tree is done. Reset the unit of work pointer to the next highest\n    // priority root. If there's no more work left, the pointer is set to null.\n    resetNextUnitOfWork();\n  }\n\n  function resetWorkPriority(workInProgress, renderPriority) {\n    if (workInProgress.pendingWorkPriority !== NoWork$2 && workInProgress.pendingWorkPriority > renderPriority) {\n      // This was a down-prioritization. Don't bubble priority from children.\n      return;\n    }\n\n    // Check for pending update priority.\n    var newPriority = getUpdatePriority$1(workInProgress);\n\n    // TODO: Coroutines need to visit stateNode\n\n    var child = workInProgress.child;\n    while (child !== null) {\n      // Ensure that remaining work priority bubbles up.\n      newPriority = largerPriority$1(newPriority, child.pendingWorkPriority);\n      child = child.sibling;\n    }\n    workInProgress.pendingWorkPriority = newPriority;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      var next = completeWork(current, workInProgress, nextPriorityLevel);\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      resetWorkPriority(workInProgress, nextPriorityLevel);\n\n      if (next !== null) {\n        {\n          stopWorkTimer(workInProgress);\n        }\n        if (true && ReactFiberInstrumentation$1.debugTool) {\n          ReactFiberInstrumentation$1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      {\n        stopWorkTimer(workInProgress);\n      }\n      if (true && ReactFiberInstrumentation$1.debugTool) {\n        ReactFiberInstrumentation$1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root. Mark the root as pending commit. Depending\n        // on how much time we have left, we'll either commit it now or in\n        // the next frame.\n        pendingCommit = workInProgress;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    {\n      startWorkTimer(workInProgress);\n    }\n    var next = beginWork(current, workInProgress, nextPriorityLevel);\n    if (true && ReactFiberInstrumentation$1.debugTool) {\n      ReactFiberInstrumentation$1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner$1.current = null;\n    {\n      ReactDebugCurrentFiber$3.resetCurrentFiber();\n    }\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    {\n      startWorkTimer(workInProgress);\n    }\n    var next = beginFailedWork(current, workInProgress, nextPriorityLevel);\n    if (true && ReactFiberInstrumentation$1.debugTool) {\n      ReactFiberInstrumentation$1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner$1.current = null;\n    {\n      ReactDebugCurrentFiber$3.resetCurrentFiber();\n    }\n\n    return next;\n  }\n\n  function performDeferredWork(deadline) {\n    performWork(OffscreenPriority, deadline);\n  }\n\n  function handleCommitPhaseErrors() {\n    // This is a special work loop for handling commit phase errors. It's\n    // similar to the syncrhonous work loop, but does an additional check on\n    // each fiber to see if it's an error boundary with an unhandled error. If\n    // so, it uses a forked version of performUnitOfWork that unmounts the\n    // failed subtree.\n    //\n    // The loop stops once the children have unmounted and error lifecycles are\n    // called. Then we return to the regular flow.\n\n    if (capturedErrors !== null && capturedErrors.size > 0 && nextPriorityLevel === TaskPriority$1) {\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n        if (nextUnitOfWork === null) {\n          !(pendingCommit !== null) ? invariant(false, 'Should have a pending commit. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          // We just completed a root. Commit it now.\n          priorityContext = TaskPriority$1;\n          commitAllWork(pendingCommit);\n          priorityContext = nextPriorityLevel;\n\n          if (capturedErrors === null || capturedErrors.size === 0 || nextPriorityLevel !== TaskPriority$1) {\n            // There are no more unhandled errors. We can exit this special\n            // work loop. If there's still additional work, we'll perform it\n            // using one of the normal work loops.\n            break;\n          }\n          // The commit phase produced additional errors. Continue working.\n        }\n      }\n    }\n  }\n\n  function workLoop(minPriorityLevel, deadline) {\n    if (pendingCommit !== null) {\n      priorityContext = TaskPriority$1;\n      commitAllWork(pendingCommit);\n      handleCommitPhaseErrors();\n    } else if (nextUnitOfWork === null) {\n      resetNextUnitOfWork();\n    }\n\n    if (nextPriorityLevel === NoWork$2 || nextPriorityLevel > minPriorityLevel) {\n      return;\n    }\n\n    // During the render phase, updates should have the same priority at which\n    // we're rendering.\n    priorityContext = nextPriorityLevel;\n\n    loop: do {\n      if (nextPriorityLevel <= TaskPriority$1) {\n        // Flush all synchronous and task work.\n        while (nextUnitOfWork !== null) {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          if (nextUnitOfWork === null) {\n            !(pendingCommit !== null) ? invariant(false, 'Should have a pending commit. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // We just completed a root. Commit it now.\n            priorityContext = TaskPriority$1;\n            commitAllWork(pendingCommit);\n            priorityContext = nextPriorityLevel;\n            // Clear any errors that were scheduled during the commit phase.\n            handleCommitPhaseErrors();\n            // The priority level may have changed. Check again.\n            if (nextPriorityLevel === NoWork$2 || nextPriorityLevel > minPriorityLevel || nextPriorityLevel > TaskPriority$1) {\n              // The priority level does not match.\n              break;\n            }\n          }\n        }\n      } else if (deadline !== null) {\n        // Flush asynchronous work until the deadline expires.\n        while (nextUnitOfWork !== null && !deadlineHasExpired) {\n          if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            // In a deferred work batch, iff nextUnitOfWork returns null, we just\n            // completed a root and a pendingCommit exists. Logically, we could\n            // omit either of the checks in the following condition, but we need\n            // both to satisfy Flow.\n            if (nextUnitOfWork === null) {\n              !(pendingCommit !== null) ? invariant(false, 'Should have a pending commit. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // We just completed a root. If we have time, commit it now.\n              // Otherwise, we'll commit it in the next frame.\n              if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n                priorityContext = TaskPriority$1;\n                commitAllWork(pendingCommit);\n                priorityContext = nextPriorityLevel;\n                // Clear any errors that were scheduled during the commit phase.\n                handleCommitPhaseErrors();\n                // The priority level may have changed. Check again.\n                if (nextPriorityLevel === NoWork$2 || nextPriorityLevel > minPriorityLevel || nextPriorityLevel < HighPriority) {\n                  // The priority level does not match.\n                  break;\n                }\n              } else {\n                deadlineHasExpired = true;\n              }\n            }\n          } else {\n            deadlineHasExpired = true;\n          }\n        }\n      }\n\n      // There might be work left. Depending on the priority, we should\n      // either perform it now or schedule a callback to perform it later.\n      switch (nextPriorityLevel) {\n        case SynchronousPriority$1:\n        case TaskPriority$1:\n          // We have remaining synchronous or task work. Keep performing it,\n          // regardless of whether we're inside a callback.\n          if (nextPriorityLevel <= minPriorityLevel) {\n            continue loop;\n          }\n          break loop;\n        case HighPriority:\n        case LowPriority:\n        case OffscreenPriority:\n          // We have remaining async work.\n          if (deadline === null) {\n            // We're not inside a callback. Exit and perform the work during\n            // the next callback.\n            break loop;\n          }\n          // We are inside a callback.\n          if (!deadlineHasExpired && nextPriorityLevel <= minPriorityLevel) {\n            // We still have time. Keep working.\n            continue loop;\n          }\n          // We've run out of time. Exit.\n          break loop;\n        case NoWork$2:\n          // No work left. We can exit.\n          break loop;\n        default:\n          invariant(false, 'Switch statement should be exhuastive. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } while (true);\n  }\n\n  function performWorkCatchBlock(failedWork, boundary, minPriorityLevel, deadline) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(minPriorityLevel, deadline);\n  }\n\n  function performWork(minPriorityLevel, deadline) {\n    {\n      startWorkLoopTimer();\n    }\n\n    !!isPerformingWork ? invariant(false, 'performWork was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isPerformingWork = true;\n\n    // The priority context changes during the render phase. We'll need to\n    // reset it at the end.\n    var previousPriorityContext = priorityContext;\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback$1(null, workLoop, null, minPriorityLevel, deadline);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback$1(null, performWorkCatchBlock, null, failedWork, boundary, minPriorityLevel, deadline);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    // Reset the priority context to its previous value.\n    priorityContext = previousPriorityContext;\n\n    // If we're inside a callback, set this to false, since we just flushed it.\n    if (deadline !== null) {\n      isCallbackScheduled = false;\n    }\n    // If there's remaining async work, make sure we schedule another callback.\n    if (nextPriorityLevel > TaskPriority$1 && !isCallbackScheduled) {\n      scheduleDeferredCallback(performDeferredWork);\n      isCallbackScheduled = true;\n    }\n\n    var errorToThrow = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    isPerformingWork = false;\n    deadlineHasExpired = false;\n    didFatal = false;\n    firstUncaughtError = null;\n    capturedErrors = null;\n    failedBoundaries = null;\n    nextRenderedTree = null;\n    nestedUpdateCount = 0;\n\n    {\n      stopWorkLoopTimer();\n    }\n\n    // It's safe to throw any unhandled errors.\n    if (errorToThrow !== null) {\n      throw errorToThrow;\n    }\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner$1.current = null;\n    {\n      ReactDebugCurrentFiber$3.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot$6) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork['return'];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent$5) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName_1(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot$6) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary -— we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node['return'];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber$2(failedWork);\n      var _componentName = getComponentName_1(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        console.error(e);\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors['delete'](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n        }\n      }\n    }\n\n    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent$5:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot$6:\n        if (firstUncaughtError === null) {\n          // If this is the host container, we treat it as a no-op error\n          // boundary. We'll throw the first uncaught error once it's safe to\n          // do so, at the end of the batch.\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent$5:\n          popContextProvider$1(node);\n          break;\n        case HostComponent$6:\n          popHostContext(node);\n          break;\n        case HostRoot$6:\n          popHostContainer(node);\n          break;\n        case HostPortal$3:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        {\n          stopFailedWorkTimer(node);\n        }\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node['return'];\n    }\n  }\n\n  function scheduleRoot(root, priorityLevel) {\n    if (priorityLevel === NoWork$2) {\n      return;\n    }\n\n    if (!root.isScheduled) {\n      root.isScheduled = true;\n      if (lastScheduledRoot) {\n        // Schedule ourselves to the end.\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n      } else {\n        // We're the only work scheduled.\n        nextScheduledRoot = root;\n        lastScheduledRoot = root;\n      }\n    }\n  }\n\n  function scheduleUpdate(fiber, priorityLevel) {\n    return scheduleUpdateImpl(fiber, priorityLevel, false);\n  }\n\n  function scheduleUpdateImpl(fiber, priorityLevel, isErrorRecovery) {\n    {\n      recordScheduleUpdate();\n    }\n\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      didFatal = true;\n      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n    }\n\n    if (!isPerformingWork && priorityLevel <= nextPriorityLevel) {\n      // We must reset the current unit of work pointer so that we restart the\n      // search from the root during the next tick, in case there is now higher\n      // priority work somewhere earlier than before.\n      nextUnitOfWork = null;\n    }\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent$5) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    var shouldContinue = true;\n    while (node !== null && shouldContinue) {\n      // Walk the parent path to the root and update each node's priority. Once\n      // we reach a node whose priority matches (and whose alternate's priority\n      // matches) we can exit safely knowing that the rest of the path is correct.\n      shouldContinue = false;\n      if (node.pendingWorkPriority === NoWork$2 || node.pendingWorkPriority > priorityLevel) {\n        // Priority did not match. Update and keep going.\n        shouldContinue = true;\n        node.pendingWorkPriority = priorityLevel;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.pendingWorkPriority === NoWork$2 || node.alternate.pendingWorkPriority > priorityLevel) {\n          // Priority did not match. Update and keep going.\n          shouldContinue = true;\n          node.alternate.pendingWorkPriority = priorityLevel;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot$6) {\n          var root = node.stateNode;\n          scheduleRoot(root, priorityLevel);\n          if (!isPerformingWork) {\n            switch (priorityLevel) {\n              case SynchronousPriority$1:\n                // Perform this update now.\n                if (isUnbatchingUpdates) {\n                  // We're inside unbatchedUpdates, which is inside either\n                  // batchedUpdates or a lifecycle. We should only flush\n                  // synchronous work, not task work.\n                  performWork(SynchronousPriority$1, null);\n                } else {\n                  // Flush both synchronous and task work.\n                  performWork(TaskPriority$1, null);\n                }\n                break;\n              case TaskPriority$1:\n                !isBatchingUpdates ? invariant(false, 'Task updates can only be scheduled as a nested update or inside batchedUpdates.') : void 0;\n                break;\n              default:\n                // Schedule a callback to perform the work later.\n                if (!isCallbackScheduled) {\n                  scheduleDeferredCallback(performDeferredWork);\n                  isCallbackScheduled = true;\n                }\n            }\n          }\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent$5) {\n              warnAboutUpdateOnUnmounted(fiber.stateNode);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function getPriorityContext(fiber, forceAsync) {\n    var priorityLevel = priorityContext;\n    if (priorityLevel === NoWork$2) {\n      if (!useSyncScheduling || fiber.internalContextTag & AsyncUpdates || forceAsync) {\n        priorityLevel = LowPriority;\n      } else {\n        priorityLevel = SynchronousPriority$1;\n      }\n    }\n\n    // If we're in a batch, or if we're already performing work, downgrade sync\n    // priority to task priority\n    if (priorityLevel === SynchronousPriority$1 && (isPerformingWork || isBatchingUpdates)) {\n      return TaskPriority$1;\n    }\n    return priorityLevel;\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleUpdateImpl(fiber, TaskPriority$1, true);\n  }\n\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      // If we're not already inside a batch, we need to flush any task work\n      // that was created by the user-provided function.\n      if (!isPerformingWork && !isBatchingUpdates) {\n        performWork(TaskPriority$1, null);\n      }\n    }\n  }\n\n  function unbatchedUpdates(fn) {\n    var previousIsUnbatchingUpdates = isUnbatchingUpdates;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    // This is only true if we're nested inside batchedUpdates.\n    isUnbatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = false;\n    try {\n      return fn();\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      isUnbatchingUpdates = previousIsUnbatchingUpdates;\n    }\n  }\n\n  function flushSync(batch) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    var previousPriorityContext = priorityContext;\n    isBatchingUpdates = true;\n    priorityContext = SynchronousPriority$1;\n    try {\n      return batch();\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      priorityContext = previousPriorityContext;\n\n      !!isPerformingWork ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n      performWork(TaskPriority$1, null);\n    }\n  }\n\n  function deferredUpdates(fn) {\n    var previousPriorityContext = priorityContext;\n    priorityContext = LowPriority;\n    try {\n      return fn();\n    } finally {\n      priorityContext = previousPriorityContext;\n    }\n  }\n\n  return {\n    scheduleUpdate: scheduleUpdate,\n    getPriorityContext: getPriorityContext,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates\n  };\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule getContextForSubtree\n * \n */\n\n\n\n\n\n\nvar getContextFiber = function (arg) {\n  invariant(false, 'Missing injection for fiber getContextForSubtree');\n};\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var instance = ReactInstanceMap_1.get(parentComponent);\n  if (typeof instance.tag === 'number') {\n    return getContextFiber(instance);\n  } else {\n    return instance._processChildContext(instance._context);\n  }\n}\n\ngetContextForSubtree._injectFiber = function (fn) {\n  getContextFiber = fn;\n};\n\nvar getContextForSubtree_1 = getContextForSubtree;\n\nvar addTopLevelUpdate = ReactFiberUpdateQueue.addTopLevelUpdate;\n\nvar findCurrentUnmaskedContext = ReactFiberContext.findCurrentUnmaskedContext;\nvar isContextProvider = ReactFiberContext.isContextProvider;\nvar processChildContext = ReactFiberContext.processChildContext;\n\nvar createFiberRoot = ReactFiberRoot.createFiberRoot;\n\n\n\nvar HostComponent$3 = ReactTypeOfWork.HostComponent;\n\n{\n  var warning$18 = require$$0;\n  var ReactFiberInstrumentation = ReactFiberInstrumentation_1;\n  var ReactDebugCurrentFiber$1 = ReactDebugCurrentFiber_1;\n  var getComponentName$4 = getComponentName_1;\n}\n\nvar findCurrentHostFiber$1 = ReactFiberTreeReflection.findCurrentHostFiber;\nvar findCurrentHostFiberWithNoPortals$1 = ReactFiberTreeReflection.findCurrentHostFiberWithNoPortals;\n\n\n\ngetContextForSubtree_1._injectFiber(function (fiber) {\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext, false) : parentContext;\n});\n\nvar ReactFiberReconciler = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      scheduleUpdate = _ReactFiberScheduler.scheduleUpdate,\n      getPriorityContext = _ReactFiberScheduler.getPriorityContext,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function scheduleTopLevelUpdate(current, element, callback) {\n    {\n      if (ReactDebugCurrentFiber$1.phase === 'render' && ReactDebugCurrentFiber$1.current !== null) {\n        warning$18(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName$4(ReactDebugCurrentFiber$1.current) || 'Unknown');\n      }\n    }\n\n    // Check if the top-level element is an async wrapper component. If so, treat\n    // updates to the root as async. This is a bit weird but lets us avoid a separate\n    // `renderAsync` API.\n    var forceAsync = ReactFeatureFlags_1.enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true;\n    var priorityLevel = getPriorityContext(current, forceAsync);\n    var nextState = { element: element };\n    callback = callback === undefined ? null : callback;\n    {\n      warning$18(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    }\n    addTopLevelUpdate(current, nextState, callback, priorityLevel);\n    scheduleUpdate(current, priorityLevel);\n  }\n\n  return {\n    createContainer: function (containerInfo) {\n      return createFiberRoot(containerInfo);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      // TODO: If this is a nested container, this won't be the root.\n      var current = container.current;\n\n      {\n        if (ReactFiberInstrumentation.debugTool) {\n          if (current.alternate === null) {\n            ReactFiberInstrumentation.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n\n      var context = getContextForSubtree_1(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      scheduleTopLevelUpdate(current, element, callback);\n    },\n\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent$3:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n    findHostInstance: function (fiber) {\n      var hostFiber = findCurrentHostFiber$1(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals$1(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    }\n  };\n};\n\nvar TEXT_NODE$3 = HTMLNodeType_1.TEXT_NODE;\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\n\n\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE$3) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\nvar getNodeForCharacterOffset_1 = getNodeForCharacterOffset;\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\nvar getTextContentAccessor_1 = getTextContentAccessor;\n\n/**\n * While `isCollapsed` is available on the Selection object and `collapsed`\n * is available on the Range object, IE11 sometimes gets them wrong.\n * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n */\nfunction isCollapsed(anchorNode, anchorOffset, focusNode$$1, focusOffset) {\n  return anchorNode === focusNode$$1 && anchorOffset === focusOffset;\n}\n\n/**\n * @param {DOMElement} node\n * @return {?object}\n */\nfunction getModernOffsets(node) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode;\n  var anchorOffset = selection.anchorOffset;\n  var focusNode$$1 = selection.focusNode;\n  var focusOffset = selection.focusOffset;\n\n  var currentRange = selection.getRangeAt(0);\n\n  // In Firefox, range.startContainer and range.endContainer can be \"anonymous\n  // divs\", e.g. the up/down buttons on an <input type=\"number\">. Anonymous\n  // divs do not seem to expose properties, triggering a \"Permission denied\n  // error\" if any of its properties are accessed. The only seemingly possible\n  // way to avoid erroring is to access a property that typically works for\n  // non-anonymous divs and catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n  try {\n    /* eslint-disable no-unused-expressions */\n    currentRange.startContainer.nodeType;\n    currentRange.endContainer.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  // If the node and offset values are the same, the selection is collapsed.\n  // `Selection.isCollapsed` is available natively, but IE sometimes gets\n  // this value wrong.\n  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n\n  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n\n  var tempRange = currentRange.cloneRange();\n  tempRange.selectNodeContents(node);\n  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\n  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);\n\n  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n  var end = start + rangeLength;\n\n  // Detect whether the selection is backward.\n  var detectionRange = document.createRange();\n  detectionRange.setStart(anchorNode, anchorOffset);\n  detectionRange.setEnd(focusNode$$1, focusOffset);\n  var isBackward = detectionRange.collapsed;\n\n  return {\n    start: isBackward ? end : start,\n    end: isBackward ? start : end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setModernOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor_1()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset_1(node, start);\n  var endMarker = getNodeForCharacterOffset_1(node, end);\n\n  if (startMarker && endMarker) {\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nvar ReactDOMSelection = {\n  /**\n   * @param {DOMElement} node\n   */\n  getOffsets: getModernOffsets,\n\n  /**\n   * @param {DOMElement|DOMTextNode} node\n   * @param {object} offsets\n   */\n  setOffsets: setModernOffsets\n};\n\nvar ReactDOMSelection_1 = ReactDOMSelection;\n\nvar ELEMENT_NODE$2 = HTMLNodeType_1.ELEMENT_NODE;\n\n\n\n\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\nvar ReactInputSelection = {\n  hasSelectionCapabilities: function (elem) {\n    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n  },\n\n  getSelectionInformation: function () {\n    var focusedElem = getActiveElement();\n    return {\n      focusedElem: focusedElem,\n      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null\n    };\n  },\n\n  /**\n   * @restoreSelection: If any selection information was potentially lost,\n   * restore it. This is useful when performing operations that could remove dom\n   * nodes and place them back in, resulting in focus being lost.\n   */\n  restoreSelection: function (priorSelectionInformation) {\n    var curFocusedElem = getActiveElement();\n    var priorFocusedElem = priorSelectionInformation.focusedElem;\n    var priorSelectionRange = priorSelectionInformation.selectionRange;\n    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);\n      }\n\n      // Focusing a node can change the scroll position, which is undesirable\n      var ancestors = [];\n      var ancestor = priorFocusedElem;\n      while (ancestor = ancestor.parentNode) {\n        if (ancestor.nodeType === ELEMENT_NODE$2) {\n          ancestors.push({\n            element: ancestor,\n            left: ancestor.scrollLeft,\n            top: ancestor.scrollTop\n          });\n        }\n      }\n\n      focusNode(priorFocusedElem);\n\n      for (var i = 0; i < ancestors.length; i++) {\n        var info = ancestors[i];\n        info.element.scrollLeft = info.left;\n        info.element.scrollTop = info.top;\n      }\n    }\n  },\n\n  /**\n   * @getSelection: Gets the selection bounds of a focused textarea, input or\n   * contentEditable node.\n   * -@input: Look up selection bounds of this input\n   * -@return {start: selectionStart, end: selectionEnd}\n   */\n  getSelection: function (input) {\n    var selection;\n\n    if ('selectionStart' in input) {\n      // Modern browser with input or textarea.\n      selection = {\n        start: input.selectionStart,\n        end: input.selectionEnd\n      };\n    } else {\n      // Content editable or old IE textarea.\n      selection = ReactDOMSelection_1.getOffsets(input);\n    }\n\n    return selection || { start: 0, end: 0 };\n  },\n\n  /**\n   * @setSelection: Sets the selection bounds of a textarea or input and focuses\n   * the input.\n   * -@input     Set selection bounds of this input or textarea\n   * -@offsets   Object of same form that is returned from get*\n   */\n  setSelection: function (input, offsets) {\n    var start = offsets.start;\n    var end = offsets.end;\n    if (end === undefined) {\n      end = start;\n    }\n\n    if ('selectionStart' in input) {\n      input.selectionStart = start;\n      input.selectionEnd = Math.min(end, input.value.length);\n    } else {\n      ReactDOMSelection_1.setOffsets(input, offsets);\n    }\n  }\n};\n\nvar ReactInputSelection_1 = ReactInputSelection;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ReactVersion\n */\n\nvar ReactVersion = '16.0.0';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule findDOMNode\n * \n */\n\n\n\nvar ELEMENT_NODE$3 = HTMLNodeType_1.ELEMENT_NODE;\n\nvar ReactCurrentOwner$3 = ReactGlobalSharedState_1.ReactCurrentOwner;\n\n\n\n\n{\n  var warning$27 = require$$0;\n}\n\nvar findFiber = function (arg) {\n  invariant(false, 'Missing injection for fiber findDOMNode');\n};\nvar findStack = function (arg) {\n  invariant(false, 'Missing injection for stack findDOMNode');\n};\n\nvar findDOMNode = function (componentOrElement) {\n  {\n    var owner = ReactCurrentOwner$3.current;\n    if (owner !== null) {\n      var isFiber = typeof owner.tag === 'number';\n      var warnedAboutRefsInRender = isFiber ? owner.stateNode._warnedAboutRefsInRender : owner._warnedAboutRefsInRender;\n      warning$27(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName_1(owner) || 'A component');\n      if (isFiber) {\n        owner.stateNode._warnedAboutRefsInRender = true;\n      } else {\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n  }\n  if (componentOrElement == null) {\n    return null;\n  }\n  if (componentOrElement.nodeType === ELEMENT_NODE$3) {\n    return componentOrElement;\n  }\n\n  var inst = ReactInstanceMap_1.get(componentOrElement);\n  if (inst) {\n    if (typeof inst.tag === 'number') {\n      return findFiber(inst);\n    } else {\n      return findStack(inst);\n    }\n  }\n\n  if (typeof componentOrElement.render === 'function') {\n    invariant(false, 'Unable to find node on an unmounted component.');\n  } else {\n    invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));\n  }\n};\n\nfindDOMNode._injectFiber = function (fn) {\n  findFiber = fn;\n};\nfindDOMNode._injectStack = function (fn) {\n  findStack = fn;\n};\n\nvar findDOMNode_1 = findDOMNode;\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule lowPriorityWarning\n */\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning$1 = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning$1 = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning_1 = lowPriorityWarning$1;\n\nvar validateDOMNesting$1 = emptyFunction;\n\n{\n  var warning$28 = require$$0;\n\n  var _require$13 = ReactDebugCurrentFiber_1,\n      getCurrentFiberStackAddendum$6 = _require$13.getCurrentFiberStackAddendum;\n\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n\n\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  /**\n   * Given a ReactCompositeComponent instance, return a list of its recursive\n   * owners, starting at the root and ending with the instance itself.\n   */\n  var findOwnerStack = function (instance) {\n    if (!instance) {\n      return [];\n    }\n\n    var stack = [];\n    do {\n      stack.push(instance);\n    } while (instance = instance._currentElement._owner);\n    stack.reverse();\n    return stack;\n  };\n\n  var getOwnerInfo = function (childInstance, childTag, ancestorInstance, ancestorTag, isParent) {\n    var childOwner = childInstance && childInstance._currentElement._owner;\n    var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;\n\n    var childOwners = findOwnerStack(childOwner);\n    var ancestorOwners = findOwnerStack(ancestorOwner);\n\n    var minStackLen = Math.min(childOwners.length, ancestorOwners.length);\n    var i;\n\n    var deepestCommon = -1;\n    for (i = 0; i < minStackLen; i++) {\n      if (childOwners[i] === ancestorOwners[i]) {\n        deepestCommon = i;\n      } else {\n        break;\n      }\n    }\n\n    var UNKNOWN = '(unknown)';\n    var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {\n      return getComponentName_1(inst) || UNKNOWN;\n    });\n    var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {\n      return getComponentName_1(inst) || UNKNOWN;\n    });\n    var ownerInfo = [].concat(\n    // If the parent and child instances have a common owner ancestor, start\n    // with that -- otherwise we just start with the parent's owners.\n    deepestCommon !== -1 ? getComponentName_1(childOwners[deepestCommon]) || UNKNOWN : [], ancestorOwnerNames, ancestorTag,\n    // If we're warning about an invalid (non-parent) ancestry, add '...'\n    isParent ? [] : ['...'], childOwnerNames, childTag).join(' > ');\n\n    return ownerInfo;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting$1 = function (childTag, childText, childInstance, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      warning$28(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorInstance = invalidParentOrAncestor.instance;\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum;\n\n    if (childInstance != null) {\n      addendum = ' See ' + getOwnerInfo(childInstance, childTag, ancestorInstance, ancestorTag, !!invalidParent) + '.';\n    } else {\n      addendum = getCurrentFiberStackAddendum$6();\n    }\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning$28(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning$28(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  validateDOMNesting$1.updatedAncestorInfo = updatedAncestorInfo$1;\n\n  // For testing\n  validateDOMNesting$1.isTagValidInContext = function (tag, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n  };\n}\n\nvar validateDOMNesting_1 = validateDOMNesting$1;\n\nvar HostComponent$11 = ReactTypeOfWork.HostComponent;\n\nfunction getParent(inst) {\n  if (inst._hostParent !== undefined) {\n    return inst._hostParent;\n  }\n  if (typeof inst.tag === 'number') {\n    do {\n      inst = inst['return'];\n      // TODO: If this is a HostRoot we might want to bail out.\n      // That is depending on if we want nested subtrees (layers) to bubble\n      // events to their parent. We could also go through parentNode on the\n      // host node but that wouldn't work for React Native and doesn't let us\n      // do the portal feature.\n    } while (inst && inst.tag !== HostComponent$11);\n    if (inst) {\n      return inst;\n    }\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  var i;\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n\nvar ReactTreeTraversal = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave\n};\n\nvar getListener = EventPluginHub_1.getListener;\n\n{\n  var warning$29 = require$$0;\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning$29(inst, 'Dispatching inst must not be null');\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto_1(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto_1(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    ReactTreeTraversal.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? ReactTreeTraversal.getParentInstance(targetInst) : null;\n    ReactTreeTraversal.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto_1(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto_1(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated_1(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated_1(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  ReactTreeTraversal.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated_1(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nvar EventPropagators_1 = EventPropagators;\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n * \n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nvar FallbackCompositionState = {\n  initialize: function (nativeEventTarget) {\n    compositionState._root = nativeEventTarget;\n    compositionState._startText = FallbackCompositionState.getText();\n    return true;\n  },\n  reset: function () {\n    compositionState._root = null;\n    compositionState._startText = null;\n    compositionState._fallbackText = null;\n  },\n  getData: function () {\n    if (compositionState._fallbackText) {\n      return compositionState._fallbackText;\n    }\n\n    var start;\n    var startValue = compositionState._startText;\n    var startLength = startValue.length;\n    var end;\n    var endValue = FallbackCompositionState.getText();\n    var endLength = endValue.length;\n\n    for (start = 0; start < startLength; start++) {\n      if (startValue[start] !== endValue[start]) {\n        break;\n      }\n    }\n\n    var minEnd = startLength - start;\n    for (end = 1; end <= minEnd; end++) {\n      if (startValue[startLength - end] !== endValue[endLength - end]) {\n        break;\n      }\n    }\n\n    var sliceTail = end > 1 ? 1 - end : undefined;\n    compositionState._fallbackText = endValue.slice(start, sliceTail);\n    return compositionState._fallbackText;\n  },\n  getText: function () {\n    if ('value' in compositionState._root) {\n      return compositionState._root.value;\n    }\n    return compositionState._root[getTextContentAccessor_1()];\n  }\n};\n\nvar FallbackCompositionState_1 = FallbackCompositionState;\n\nvar didWarnForAddedNewProperty = false;\nvar isProxySupported = typeof Proxy === 'function';\nvar EVENT_POOL_SIZE = 10;\n\n{\n  var warning$30 = require$$0;\n}\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function (Class, Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n  addEventPoolingTo(Class);\n};\n\n/** Proxying after everything set on SyntheticEvent\n  * to resolve Proxy issue on some WebKit browsers\n  * in which some Event properties are set to undefined (GH#10010)\n  */\n{\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              warning$30(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\nvar SyntheticEvent_1 = SyntheticEvent;\n\n/**\n  * Helper to nullify syntheticEvent instance properties when destructing\n  *\n  * @param {String} propName\n  * @param {?object} getVal\n  * @return {object} defineProperty object\n  */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning$30(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent_1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n\nvar SyntheticCompositionEvent_1 = SyntheticCompositionEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent_1.augmentClass(SyntheticInputEvent, InputEventInterface);\n\nvar SyntheticInputEvent_1 = SyntheticInputEvent;\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case 'topCompositionStart':\n      return eventTypes.compositionStart;\n    case 'topCompositionEnd':\n      return eventTypes.compositionEnd;\n    case 'topCompositionUpdate':\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topKeyUp':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'topKeyDown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'topKeyPress':\n    case 'topMouseDown':\n    case 'topBlur':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType;\n  var fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = FallbackCompositionState_1.initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = FallbackCompositionState_1.getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent_1.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  EventPropagators_1.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topCompositionEnd':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'topKeyPress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'topTextInput':\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = FallbackCompositionState_1.getData();\n      FallbackCompositionState_1.reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case 'topPaste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'topKeyPress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'topCompositionEnd':\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent_1.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  EventPropagators_1.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];\n  }\n};\n\nvar BeforeInputEventPlugin_1 = BeforeInputEventPlugin;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule isTextInputElement\n * \n */\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\n\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\nvar isTextInputElement_1 = isTextInputElement;\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent_1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  ReactControlledComponent_1.enqueueStateRestore(target);\n  EventPropagators_1.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget_1(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactGenericBatching_1.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub_1.enqueueEvents(event);\n  EventPluginHub_1.processEventQueue(false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = ReactDOMComponentTree_1.getNodeFromInstance(targetInst);\n  if (inputValueTracking_1.updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported_1('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree_1.getNodeFromInstance(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement_1(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\nvar ChangeEventPlugin_1 = ChangeEventPlugin;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule DOMEventPluginOrder\n */\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\n\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\nvar DOMEventPluginOrder_1 = DOMEventPluginOrder;\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: function (event) {\n    if (event.view) {\n      return event.view;\n    }\n\n    var target = getEventTarget_1(event);\n    if (target.window === target) {\n      // target is a window object\n      return target;\n    }\n\n    var doc = target.ownerDocument;\n    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n    if (doc) {\n      return doc.defaultView || doc.parentWindow;\n    } else {\n      return window;\n    }\n  },\n  detail: function (event) {\n    return event.detail || 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent_1.augmentClass(SyntheticUIEvent, UIEventInterface);\n\nvar SyntheticUIEvent_1 = SyntheticUIEvent;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule getEventModifierState\n */\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\nvar getEventModifierState_1 = getEventModifierState;\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState_1,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent_1.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nvar SyntheticMouseEvent_1 = SyntheticMouseEvent;\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from;\n    var to;\n    if (topLevelType === 'topMouseOut') {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? ReactDOMComponentTree_1.getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromNode = from == null ? win : ReactDOMComponentTree_1.getNodeFromInstance(from);\n    var toNode = to == null ? win : ReactDOMComponentTree_1.getNodeFromInstance(to);\n\n    var leave = SyntheticMouseEvent_1.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = SyntheticMouseEvent_1.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    EventPropagators_1.accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\nvar EnterLeaveEventPlugin_1 = EnterLeaveEventPlugin;\n\nvar DOCUMENT_NODE$2 = HTMLNodeType_1.DOCUMENT_NODE;\n\n\n\n\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n// Track whether all listeners exists for this plugin. If none exist, we do\n// not extract events. See #3639.\nvar isListeningToAllDependencies = ReactBrowserEventEmitter_1.isListeningToAllDependencies;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && ReactInputSelection_1.hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent_1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    EventPropagators_1.accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE$2 ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? ReactDOMComponentTree_1.getNodeFromInstance(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case 'topFocus':\n        if (isTextInputElement_1(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case 'topBlur':\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case 'topMouseDown':\n        mouseDown = true;\n        break;\n      case 'topContextMenu':\n      case 'topMouseUp':\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case 'topSelectionChange':\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case 'topKeyDown':\n      case 'topKeyUp':\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\nvar SelectEventPlugin_1 = SelectEventPlugin;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar AnimationEventInterface = {\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent_1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);\n\nvar SyntheticAnimationEvent_1 = SyntheticAnimationEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent_1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\nvar SyntheticClipboardEvent_1 = SyntheticClipboardEvent;\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent_1.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\nvar SyntheticFocusEvent_1 = SyntheticFocusEvent;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule getEventCharCode\n */\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\n\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\nvar getEventCharCode_1 = getEventCharCode;\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  8: 'Backspace',\n  9: 'Tab',\n  12: 'Clear',\n  13: 'Enter',\n  16: 'Shift',\n  17: 'Control',\n  18: 'Alt',\n  19: 'Pause',\n  20: 'CapsLock',\n  27: 'Escape',\n  32: ' ',\n  33: 'PageUp',\n  34: 'PageDown',\n  35: 'End',\n  36: 'Home',\n  37: 'ArrowLeft',\n  38: 'ArrowUp',\n  39: 'ArrowRight',\n  40: 'ArrowDown',\n  45: 'Insert',\n  46: 'Delete',\n  112: 'F1',\n  113: 'F2',\n  114: 'F3',\n  115: 'F4',\n  116: 'F5',\n  117: 'F6',\n  118: 'F7',\n  119: 'F8',\n  120: 'F9',\n  121: 'F10',\n  122: 'F11',\n  123: 'F12',\n  144: 'NumLock',\n  145: 'ScrollLock',\n  224: 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode_1(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\nvar getEventKey_1 = getEventKey;\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey_1,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState_1,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode_1(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode_1(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent_1.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\nvar SyntheticKeyboardEvent_1 = SyntheticKeyboardEvent;\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent_1.augmentClass(SyntheticDragEvent, DragEventInterface);\n\nvar SyntheticDragEvent_1 = SyntheticDragEvent;\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState_1\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent_1.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\nvar SyntheticTouchEvent_1 = SyntheticTouchEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar TransitionEventInterface = {\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent_1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);\n\nvar SyntheticTransitionEvent_1 = SyntheticTransitionEvent;\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent_1.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\nvar SyntheticWheelEvent_1 = SyntheticWheelEvent;\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: ['topAbort'],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = {\n *   'topAbort': { sameConfig }\n * };\n */\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n  var topEvent = 'top' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent]\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n});\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case 'topAbort':\n      case 'topCancel':\n      case 'topCanPlay':\n      case 'topCanPlayThrough':\n      case 'topClose':\n      case 'topDurationChange':\n      case 'topEmptied':\n      case 'topEncrypted':\n      case 'topEnded':\n      case 'topError':\n      case 'topInput':\n      case 'topInvalid':\n      case 'topLoad':\n      case 'topLoadedData':\n      case 'topLoadedMetadata':\n      case 'topLoadStart':\n      case 'topPause':\n      case 'topPlay':\n      case 'topPlaying':\n      case 'topProgress':\n      case 'topRateChange':\n      case 'topReset':\n      case 'topSeeked':\n      case 'topSeeking':\n      case 'topStalled':\n      case 'topSubmit':\n      case 'topSuspend':\n      case 'topTimeUpdate':\n      case 'topToggle':\n      case 'topVolumeChange':\n      case 'topWaiting':\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent_1;\n        break;\n      case 'topKeyPress':\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode_1(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case 'topKeyDown':\n      case 'topKeyUp':\n        EventConstructor = SyntheticKeyboardEvent_1;\n        break;\n      case 'topBlur':\n      case 'topFocus':\n        EventConstructor = SyntheticFocusEvent_1;\n        break;\n      case 'topClick':\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case 'topDoubleClick':\n      case 'topMouseDown':\n      case 'topMouseMove':\n      case 'topMouseUp':\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case 'topMouseOut':\n      case 'topMouseOver':\n      case 'topContextMenu':\n        EventConstructor = SyntheticMouseEvent_1;\n        break;\n      case 'topDrag':\n      case 'topDragEnd':\n      case 'topDragEnter':\n      case 'topDragExit':\n      case 'topDragLeave':\n      case 'topDragOver':\n      case 'topDragStart':\n      case 'topDrop':\n        EventConstructor = SyntheticDragEvent_1;\n        break;\n      case 'topTouchCancel':\n      case 'topTouchEnd':\n      case 'topTouchMove':\n      case 'topTouchStart':\n        EventConstructor = SyntheticTouchEvent_1;\n        break;\n      case 'topAnimationEnd':\n      case 'topAnimationIteration':\n      case 'topAnimationStart':\n        EventConstructor = SyntheticAnimationEvent_1;\n        break;\n      case 'topTransitionEnd':\n        EventConstructor = SyntheticTransitionEvent_1;\n        break;\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent_1;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent_1;\n        break;\n      case 'topCopy':\n      case 'topCut':\n      case 'topPaste':\n        EventConstructor = SyntheticClipboardEvent_1;\n        break;\n    }\n    !EventConstructor ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : void 0;\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    EventPropagators_1.accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nvar SimpleEventPlugin_1 = SimpleEventPlugin;\n\nReactDOMEventListener_1.setHandleTopLevel(ReactBrowserEventEmitter_1.handleTopLevel);\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\nEventPluginHub_1.injection.injectEventPluginOrder(DOMEventPluginOrder_1);\nEventPluginUtils_1.injection.injectComponentTree(ReactDOMComponentTree_1);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\nEventPluginHub_1.injection.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin_1,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin_1,\n  ChangeEventPlugin: ChangeEventPlugin_1,\n  SelectEventPlugin: SelectEventPlugin_1,\n  BeforeInputEventPlugin: BeforeInputEventPlugin_1\n});\n\nvar MUST_USE_PROPERTY = DOMProperty_1.injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = DOMProperty_1.injection.HAS_BOOLEAN_VALUE;\nvar HAS_NUMERIC_VALUE = DOMProperty_1.injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE = DOMProperty_1.injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty_1.injection.HAS_OVERLOADED_BOOLEAN_VALUE;\nvar HAS_STRING_BOOLEAN_VALUE = DOMProperty_1.injection.HAS_STRING_BOOLEAN_VALUE;\n\nvar HTMLDOMPropertyConfig = {\n  // When adding attributes to this list, be sure to also add them to\n  // the `possibleStandardNames` module to ensure casing and incorrect\n  // name warnings.\n  Properties: {\n    allowFullScreen: HAS_BOOLEAN_VALUE,\n    // IE only true/false iFrame attribute\n    // https://msdn.microsoft.com/en-us/library/ms533072(v=vs.85).aspx\n    allowTransparency: HAS_STRING_BOOLEAN_VALUE,\n    // specifies target context for links with `preload` type\n    async: HAS_BOOLEAN_VALUE,\n    // autoFocus is polyfilled/normalized by AutoFocusUtils\n    // autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    capture: HAS_BOOLEAN_VALUE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    cols: HAS_POSITIVE_NUMERIC_VALUE,\n    contentEditable: HAS_STRING_BOOLEAN_VALUE,\n    controls: HAS_BOOLEAN_VALUE,\n    'default': HAS_BOOLEAN_VALUE,\n    defer: HAS_BOOLEAN_VALUE,\n    disabled: HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: HAS_STRING_BOOLEAN_VALUE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    hidden: HAS_BOOLEAN_VALUE,\n    loop: HAS_BOOLEAN_VALUE,\n    // Caution; `option.selected` is not updated if `select.multiple` is\n    // disabled with `removeAttribute`.\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: HAS_BOOLEAN_VALUE,\n    playsInline: HAS_BOOLEAN_VALUE,\n    readOnly: HAS_BOOLEAN_VALUE,\n    required: HAS_BOOLEAN_VALUE,\n    reversed: HAS_BOOLEAN_VALUE,\n    rows: HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: HAS_NUMERIC_VALUE,\n    scoped: HAS_BOOLEAN_VALUE,\n    seamless: HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    size: HAS_POSITIVE_NUMERIC_VALUE,\n    start: HAS_NUMERIC_VALUE,\n    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: HAS_STRING_BOOLEAN_VALUE,\n    // Style must be explicitly set in the attribute list. React components\n    // expect a style object\n    style: 0,\n    // itemScope is for for Microdata support.\n    // See http://schema.org/docs/gs.html\n    itemScope: HAS_BOOLEAN_VALUE,\n    // These attributes must stay in the white-list because they have\n    // different attribute names (see DOMAttributeNames below)\n    acceptCharset: 0,\n    className: 0,\n    htmlFor: 0,\n    httpEquiv: 0,\n    // Attributes with mutation methods must be specified in the whitelist\n    // Set the string boolean flag to allow the behavior\n    value: HAS_STRING_BOOLEAN_VALUE\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMMutationMethods: {\n    value: function (node, value) {\n      if (value == null) {\n        return node.removeAttribute('value');\n      }\n\n      // Number inputs get special treatment due to some edge cases in\n      // Chrome. Let everything else assign the value attribute as normal.\n      // https://github.com/facebook/react/issues/7253#issuecomment-236074326\n      if (node.type !== 'number' || node.hasAttribute('value') === false) {\n        node.setAttribute('value', '' + value);\n      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {\n        // Don't assign an attribute if validation reports bad\n        // input. Chrome will clear the value. Additionally, don't\n        // operate on inputs that have focus, otherwise Chrome might\n        // strip off trailing decimal places and cause the user's\n        // cursor position to jump to the beginning of the input.\n        //\n        // In ReactDOMInput, we have an onBlur event that will trigger\n        // this function again when focus is lost.\n        node.setAttribute('value', '' + value);\n      }\n    }\n  }\n};\n\nvar HTMLDOMPropertyConfig_1 = HTMLDOMPropertyConfig;\n\nvar HAS_STRING_BOOLEAN_VALUE$1 = DOMProperty_1.injection.HAS_STRING_BOOLEAN_VALUE;\n\n\nvar NS = {\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\n\n/**\n * This is a list of all SVG attributes that need special casing,\n * namespacing, or boolean value assignment.\n *\n * When adding attributes to this list, be sure to also add them to\n * the `possibleStandardNames` module to ensure casing and incorrect\n * name warnings.\n *\n * SVG Attributes List:\n * https://www.w3.org/TR/SVG/attindex.html\n * SMIL Spec:\n * https://www.w3.org/TR/smil\n */\nvar ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,\n    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,\n    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1\n  },\n  DOMAttributeNames: {\n    autoReverse: 'autoReverse',\n    externalResourcesRequired: 'externalResourcesRequired',\n    preserveAlpha: 'preserveAlpha'\n  },\n  DOMAttributeNamespaces: {\n    xlinkActuate: NS.xlink,\n    xlinkArcrole: NS.xlink,\n    xlinkHref: NS.xlink,\n    xlinkRole: NS.xlink,\n    xlinkShow: NS.xlink,\n    xlinkTitle: NS.xlink,\n    xlinkType: NS.xlink,\n    xmlBase: NS.xml,\n    xmlLang: NS.xml,\n    xmlSpace: NS.xml\n  }\n};\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\nATTRS.forEach(function (original) {\n  var reactName = original.replace(CAMELIZE, capitalize);\n\n  SVGDOMPropertyConfig.Properties[reactName] = 0;\n  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;\n});\n\nvar SVGDOMPropertyConfig_1 = SVGDOMPropertyConfig;\n\nDOMProperty_1.injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig_1);\nDOMProperty_1.injection.injectDOMPropertyConfig(SVGDOMPropertyConfig_1);\n\nvar injectInternals = ReactFiberDevToolsHook.injectInternals;\n\nvar ELEMENT_NODE = HTMLNodeType_1.ELEMENT_NODE;\nvar TEXT_NODE = HTMLNodeType_1.TEXT_NODE;\nvar COMMENT_NODE = HTMLNodeType_1.COMMENT_NODE;\nvar DOCUMENT_NODE = HTMLNodeType_1.DOCUMENT_NODE;\nvar DOCUMENT_FRAGMENT_NODE = HTMLNodeType_1.DOCUMENT_FRAGMENT_NODE;\n\nvar ROOT_ATTRIBUTE_NAME = DOMProperty_1.ROOT_ATTRIBUTE_NAME;\n\n\n\n\nvar getChildNamespace = DOMNamespaces.getChildNamespace;\nvar createElement = ReactDOMFiberComponent_1.createElement;\nvar createTextNode = ReactDOMFiberComponent_1.createTextNode;\nvar setInitialProperties = ReactDOMFiberComponent_1.setInitialProperties;\nvar diffProperties = ReactDOMFiberComponent_1.diffProperties;\nvar updateProperties = ReactDOMFiberComponent_1.updateProperties;\nvar diffHydratedProperties = ReactDOMFiberComponent_1.diffHydratedProperties;\nvar diffHydratedText = ReactDOMFiberComponent_1.diffHydratedText;\nvar warnForDeletedHydratableElement = ReactDOMFiberComponent_1.warnForDeletedHydratableElement;\nvar warnForDeletedHydratableText = ReactDOMFiberComponent_1.warnForDeletedHydratableText;\nvar warnForInsertedHydratedElement = ReactDOMFiberComponent_1.warnForInsertedHydratedElement;\nvar warnForInsertedHydratedText = ReactDOMFiberComponent_1.warnForInsertedHydratedText;\nvar precacheFiberNode = ReactDOMComponentTree_1.precacheFiberNode;\nvar updateFiberProps = ReactDOMComponentTree_1.updateFiberProps;\n\n\n{\n  var lowPriorityWarning = lowPriorityWarning_1;\n  var warning = require$$0;\n  var validateDOMNesting = validateDOMNesting_1;\n  var updatedAncestorInfo = validateDOMNesting.updatedAncestorInfo;\n\n\n  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\n\n\nReactControlledComponent_1.injection.injectFiberControlledHostComponent(ReactDOMFiberComponent_1);\nfindDOMNode_1._injectFiber(function (fiber) {\n  return DOMRenderer.findHostInstance(fiber);\n});\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nvar DOMRenderer = ReactFiberReconciler({\n  getRootHostContext: function (rootContainerInstance) {\n    var type = void 0;\n    var namespace = void 0;\n    if (rootContainerInstance.nodeType === DOCUMENT_NODE) {\n      type = '#document';\n      var root = rootContainerInstance.documentElement;\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n    } else {\n      var container = rootContainerInstance.nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n      var ownNamespace = container.namespaceURI || null;\n      type = container.tagName;\n      namespace = getChildNamespace(ownNamespace, type);\n    }\n    {\n      var validatedTag = type.toLowerCase();\n      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n      return { namespace: namespace, ancestorInfo: _ancestorInfo };\n    }\n    return namespace;\n  },\n  getChildHostContext: function (parentHostContext, type) {\n    {\n      var parentHostContextDev = parentHostContext;\n      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n    }\n    var parentNamespace = parentHostContext;\n    return getChildNamespace(parentNamespace, type);\n  },\n  getPublicInstance: function (instance) {\n    return instance;\n  },\n  prepareForCommit: function () {\n    eventsEnabled = ReactBrowserEventEmitter_1.isEnabled();\n    selectionInformation = ReactInputSelection_1.getSelectionInformation();\n    ReactBrowserEventEmitter_1.setEnabled(false);\n  },\n  resetAfterCommit: function () {\n    ReactInputSelection_1.restoreSelection(selectionInformation);\n    selectionInformation = null;\n    ReactBrowserEventEmitter_1.setEnabled(eventsEnabled);\n    eventsEnabled = null;\n  },\n  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    var parentNamespace = void 0;\n    {\n      // TODO: take namespace into account when validating.\n      var hostContextDev = hostContext;\n      validateDOMNesting(type, null, null, hostContextDev.ancestorInfo);\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        var string = '' + props.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting(null, string, null, ownAncestorInfo);\n      }\n      parentNamespace = hostContextDev.namespace;\n    }\n    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n    precacheFiberNode(internalInstanceHandle, domElement);\n    updateFiberProps(domElement, props);\n    return domElement;\n  },\n  appendInitialChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n    setInitialProperties(domElement, type, props, rootContainerInstance);\n    return shouldAutoFocusHostComponent(type, props);\n  },\n  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    {\n      var hostContextDev = hostContext;\n      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n        var string = '' + newProps.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting(null, string, null, ownAncestorInfo);\n      }\n    }\n    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n  },\n  commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n    domElement.focus();\n  },\n  commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n    // Update the props handle so that we know which props are the ones with\n    // with current event handlers.\n    updateFiberProps(domElement, newProps);\n    // Apply the diff to the DOM node.\n    updateProperties(domElement, updatePayload, type, oldProps, newProps);\n  },\n  shouldSetTextContent: function (type, props) {\n    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n  },\n  resetTextContent: function (domElement) {\n    domElement.textContent = '';\n  },\n  shouldDeprioritizeSubtree: function (type, props) {\n    return !!props.hidden;\n  },\n  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n    {\n      var hostContextDev = hostContext;\n      validateDOMNesting(null, text, null, hostContextDev.ancestorInfo);\n    }\n    var textNode = createTextNode(text, rootContainerInstance);\n    precacheFiberNode(internalInstanceHandle, textNode);\n    return textNode;\n  },\n  commitTextUpdate: function (textInstance, oldText, newText) {\n    textInstance.nodeValue = newText;\n  },\n  appendChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  appendChildToContainer: function (container, child) {\n    if (container.nodeType === COMMENT_NODE) {\n      container.parentNode.insertBefore(child, container);\n    } else {\n      container.appendChild(child);\n    }\n  },\n  insertBefore: function (parentInstance, child, beforeChild) {\n    parentInstance.insertBefore(child, beforeChild);\n  },\n  insertInContainerBefore: function (container, child, beforeChild) {\n    if (container.nodeType === COMMENT_NODE) {\n      container.parentNode.insertBefore(child, beforeChild);\n    } else {\n      container.insertBefore(child, beforeChild);\n    }\n  },\n  removeChild: function (parentInstance, child) {\n    parentInstance.removeChild(child);\n  },\n  removeChildFromContainer: function (container, child) {\n    if (container.nodeType === COMMENT_NODE) {\n      container.parentNode.removeChild(child);\n    } else {\n      container.removeChild(child);\n    }\n  },\n  canHydrateInstance: function (instance, type, props) {\n    return instance.nodeType === ELEMENT_NODE && type === instance.nodeName.toLowerCase();\n  },\n  canHydrateTextInstance: function (instance, text) {\n    if (text === '') {\n      // Empty strings are not parsed by HTML so there won't be a correct match here.\n      return false;\n    }\n    return instance.nodeType === TEXT_NODE;\n  },\n  getNextHydratableSibling: function (instance) {\n    var node = instance.nextSibling;\n    // Skip non-hydratable nodes.\n    while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n      node = node.nextSibling;\n    }\n    return node;\n  },\n  getFirstHydratableChild: function (parentInstance) {\n    var next = parentInstance.firstChild;\n    // Skip non-hydratable nodes.\n    while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n  hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    precacheFiberNode(internalInstanceHandle, instance);\n    // TODO: Possibly defer this until the commit phase where all the events\n    // get attached.\n    updateFiberProps(instance, props);\n    var parentNamespace = void 0;\n    {\n      var hostContextDev = hostContext;\n      parentNamespace = hostContextDev.namespace;\n    }\n    return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n  },\n  hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n    precacheFiberNode(internalInstanceHandle, textInstance);\n    return diffHydratedText(textInstance, text);\n  },\n  didNotHydrateInstance: function (parentInstance, instance) {\n    if (instance.nodeType === 1) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  },\n  didNotFindHydratableInstance: function (parentInstance, type, props) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  },\n  didNotFindHydratableTextInstance: function (parentInstance, text) {\n    warnForInsertedHydratedText(parentInstance, text);\n  },\n\n\n  scheduleDeferredCallback: ReactDOMFrameScheduling.rIC,\n\n  useSyncScheduling: !ReactDOMFeatureFlags_1.fiberAsyncScheduling\n});\n\nReactGenericBatching_1.injection.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);\n      if (hostInstance) {\n        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && ReactDOMComponentTree_1.getInstanceFromNode(rootEl));\n\n    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n\n    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n  }\n\n  var root = container._reactRootContainer;\n  if (!root) {\n    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    // First clear any existing content.\n    if (!shouldHydrate) {\n      var warned = false;\n      var rootSibling = void 0;\n      while (rootSibling = container.lastChild) {\n        {\n          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n            warned = true;\n            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n          }\n        }\n        container.removeChild(rootSibling);\n      }\n    }\n    {\n      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n        warnedAboutHydrateAPI = true;\n        lowPriorityWarning(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n      }\n    }\n    var newRoot = DOMRenderer.createContainer(container);\n    root = container._reactRootContainer = newRoot;\n    // Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n    });\n  } else {\n    DOMRenderer.updateContainer(children, root, parentComponent, callback);\n  }\n  return DOMRenderer.getPublicRootInstance(root);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return ReactPortal.createPortal(children, container, null, key);\n}\n\nvar ReactDOMFiber = {\n  createPortal: createPortal,\n\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return renderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return renderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && ReactInstanceMap_1.has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !ReactDOMComponentTree_1.getInstanceFromNode(rootEl);\n        warning(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n      }\n\n      // Unmount should not be batched.\n      DOMRenderer.unbatchedUpdates(function () {\n        renderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && ReactDOMComponentTree_1.getInstanceFromNode(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        warning(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n      }\n\n      return false;\n    }\n  },\n\n\n  findDOMNode: findDOMNode_1,\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: createPortal,\n\n  unstable_batchedUpdates: ReactGenericBatching_1.batchedUpdates,\n\n  unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n\n  flushSync: DOMRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub_1,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry_1,\n    EventPropagators: EventPropagators_1,\n    ReactControlledComponent: ReactControlledComponent_1,\n    ReactDOMComponentTree: ReactDOMComponentTree_1,\n    ReactDOMEventListener: ReactDOMEventListener_1\n  }\n};\n\nvar foundDevTools = injectInternals({\n  findFiberByHostInstance: ReactDOMComponentTree_1.getClosestInstanceFromNode,\n  findHostInstanceByFiber: DOMRenderer.findHostInstance,\n  // This is an enum because we may add more (e.g. profiler build)\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\nvar ReactDOMFiberEntry = ReactDOMFiber;\n\nmodule.exports = ReactDOMFiberEntry;\n\n})();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/Y2FkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOEJBQThCO0FBQzlCO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBNEM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLEVBQUU7QUFDZixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLEVBQUU7QUFDZixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNkJBQTZCLHNCQUFzQjs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SyxZQUFZO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUxBQXVMLCtCQUErQjtBQUN0Tjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtLQUFrSyx5Q0FBeUM7QUFDM007QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5Q0FBeUM7QUFDekMsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlOQUFpTjtBQUNqTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVDQUF1QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4wLjBcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuKGZ1bmN0aW9uKCkge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciByZXF1aXJlJCQwID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcbnZhciBwcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHJlYWN0UHJvZEludmFyaWFudFxuICogXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2hlY2tSZWFjdFxuICogXG4gKi9cblxuXG5cblxuIXJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTmFtZXNwYWNlc1xuICovXG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07XG5cbi8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlJDEocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG52YXIgTmFtZXNwYWNlc18xID0gTmFtZXNwYWNlcztcbnZhciBnZXRJbnRyaW5zaWNOYW1lc3BhY2VfMSA9IGdldEludHJpbnNpY05hbWVzcGFjZTtcbnZhciBnZXRDaGlsZE5hbWVzcGFjZV8xID0gZ2V0Q2hpbGROYW1lc3BhY2UkMTtcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG5cdE5hbWVzcGFjZXM6IE5hbWVzcGFjZXNfMSxcblx0Z2V0SW50cmluc2ljTmFtZXNwYWNlOiBnZXRJbnRyaW5zaWNOYW1lc3BhY2VfMSxcblx0Z2V0Q2hpbGROYW1lc3BhY2U6IGdldENoaWxkTmFtZXNwYWNlXzFcbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICAgKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gICAqIG9ubHkgaW4gdHJ1ZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHt9LFxuICAvLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIWV2ZW50UGx1Z2luT3JkZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeV8xID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgYXV0b0ZvY3VzOiB0cnVlLFxuICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICBpbm5lckhUTUw6IHRydWUsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIURPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNTdHJpbmdCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcblxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIERvd25jYXNlIHJlZmVyZW5jZXMgdG8gd2hpdGVsaXN0IHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIG1lbWJlcnNoaXBcbiAgICAgIC8vIHdpdGhvdXQgY2FzZS1zZW5zaXRpdml0eS4gVGhpcyBhbGxvd3MgdGhlIHdoaXRlbGlzdCB0byBwaWNrIHVwXG4gICAgICAvLyBgYWxsb3dmdWxsc2NyZWVuYCwgd2hpY2ggc2hvdWxkIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIHByb3BlcnR5IGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIGZvciBgYWxsb3dGdWxsc2NyZWVuYFxuICAgICAgRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXG5cbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSB3cml0ZWFibGUgYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBzaG91bGRTZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiBET01Qcm9wZXJ0eS5zaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSk7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBnZXRQcm9wZXJ0eUluZm86IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgfSxcbiAgc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5nZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgcmV0dXJuIHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICByZXR1cm4gcHJlZml4ID09PSAnZGF0YS0nIHx8IHByZWZpeCA9PT0gJ2FyaWEtJztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgcHJvcGVydHkgbmFtZSBpcyB3aXRoaW4gdGhlIGxpc3Qgb2YgcHJvcGVydGllc1xuICAgKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAgICogbm90IGJlIHNldCBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBuYW1lIGlzIHdpdGhpbiByZXNlcnZlZCBwcm9wc1xuICAgKi9cbiAgaXNSZXNlcnZlZFByb3A6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9LFxuXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxudmFyIERPTVByb3BlcnR5XzEgPSBET01Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRGbGFnc1xuICovXG5cbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0ge1xuICBoYXNDYWNoZWRDaGlsZE5vZGVzOiAxIDw8IDBcbn07XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzXzEgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFR5cGVPZldvcmtcbiAqIFxuICovXG5cbnZhciBSZWFjdFR5cGVPZldvcmsgPSB7XG4gIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDAsIC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xuICBGdW5jdGlvbmFsQ29tcG9uZW50OiAxLFxuICBDbGFzc0NvbXBvbmVudDogMixcbiAgSG9zdFJvb3Q6IDMsIC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuICBIb3N0UG9ydGFsOiA0LCAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxuICBIb3N0Q29tcG9uZW50OiA1LFxuICBIb3N0VGV4dDogNixcbiAgQ29yb3V0aW5lQ29tcG9uZW50OiA3LFxuICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IDgsXG4gIFlpZWxkQ29tcG9uZW50OiA5LFxuICBGcmFnbWVudDogMTBcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxOb2RlVHlwZVxuICovXG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgSFRNTE5vZGVUeXBlID0ge1xuICBFTEVNRU5UX05PREU6IDEsXG4gIFRFWFRfTk9ERTogMyxcbiAgQ09NTUVOVF9OT0RFOiA4LFxuICBET0NVTUVOVF9OT0RFOiA5LFxuICBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOiAxMVxufTtcblxudmFyIEhUTUxOb2RlVHlwZV8xID0gSFRNTE5vZGVUeXBlO1xuXG52YXIgSG9zdENvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Q29tcG9uZW50O1xudmFyIEhvc3RUZXh0ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RUZXh0O1xuXG52YXIgRUxFTUVOVF9OT0RFJDEgPSBIVE1MTm9kZVR5cGVfMS5FTEVNRU5UX05PREU7XG52YXIgQ09NTUVOVF9OT0RFJDEgPSBIVE1MTm9kZVR5cGVfMS5DT01NRU5UX05PREU7XG5cblxuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHlfMS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3NfMTtcblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xuXG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBub2RlIHNob3VsZCBiZSBjYWNoZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByZWNhY2hlTm9kZShub2RlLCBub2RlSUQpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSQxICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09ICcnICsgbm9kZUlEIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSQxICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LXRleHQ6ICcgKyBub2RlSUQgKyAnICcgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFJDEgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtZW1wdHk6ICcgKyBub2RlSUQgKyAnICc7XG59XG5cbi8qKlxuICogRHJpbGwgZG93biAodGhyb3VnaCBjb21wb3NpdGVzIGFuZCBlbXB0eSBjb21wb25lbnRzKSB1bnRpbCB3ZSBnZXQgYSBob3N0IG9yXG4gKiBob3N0IHRleHQgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgcHJldHR5IHBvbHltb3JwaGljIGJ1dCB1bmF2b2lkYWJsZSB3aXRoIHRoZSBjdXJyZW50IHN0cnVjdHVyZSB3ZSBoYXZlXG4gKiBmb3IgYF9yZW5kZXJlZENoaWxkcmVuYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgdmFyIHJlbmRlcmVkO1xuICB3aGlsZSAocmVuZGVyZWQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gcmVuZGVyZWQ7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiB0aGUgcmVuZGVyZWQgaG9zdC90ZXh0IGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlblxuICogRE9NIG5vZGUuIFRoZSBwYXNzZWQgYGluc3RgIGNhbiBiZSBhIGNvbXBvc2l0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVOb2RlKGluc3QsIG5vZGUpIHtcbiAgdmFyIGhvc3RJbnN0ID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChpbnN0KTtcbiAgaG9zdEluc3QuX2hvc3ROb2RlID0gbm9kZTtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKHNob3VsZFByZWNhY2hlTm9kZShjaGlsZE5vZGUsIGNoaWxkSUQpKSB7XG4gICAgICAgIHByZWNhY2hlTm9kZShjaGlsZEluc3QsIGNoaWxkTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXG4gICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpO1xuICB9XG4gIGluc3QuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdDtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIsIHRoaXMgd2lsbCBhbHdheXMgYmUgdGhlIGRlZXBlc3Qgcm9vdC5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIGlmIChpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5faG9zdE5vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgIShpbnN0Ll9ob3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGluc3QuX2hvc3ROb2RlKSB7XG4gICAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIERPTSBub2RlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIWluc3QuX2hvc3ROb2RlKSB7XG4gICAgcGFyZW50cy5wdXNoKGluc3QpO1xuICAgICFpbnN0Ll9ob3N0UGFyZW50ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgRE9NIHRyZWUgcm9vdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBub2RlIHJlZmVyZW5jZS4nKSA6IHZvaWQgMDtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuXG4gIC8vIE5vdyBwYXJlbnRzIGNvbnRhaW5zIGVhY2ggYW5jZXN0b3IgdGhhdCBkb2VzICpub3QqIGhhdmUgYSBjYWNoZWQgbmF0aXZlXG4gIC8vIG5vZGUsIGFuZCBgaW5zdGAgaXMgdGhlIGRlZXBlc3QgYW5jZXN0b3IgdGhhdCBkb2VzLlxuICBmb3IgKDsgcGFyZW50cy5sZW5ndGg7IGluc3QgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIGluc3QuX2hvc3ROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyQxKG5vZGUsIHByb3BzKSB7XG4gIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9IHByb3BzO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0ge1xuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcbiAgdW5jYWNoZU5vZGU6IHVuY2FjaGVOb2RlLFxuICBwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSxcbiAgdXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59O1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlXzEgPSBSZWFjdERPTUNvbXBvbmVudFRyZWU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VNYXBcbiAqL1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuICAvKipcbiAgICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlciA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG4gIH1cbn07XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwXzEgPSBSZWFjdEluc3RhbmNlTWFwO1xuXG52YXIgUmVhY3RJbnRlcm5hbHMgPSByZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0R2xvYmFsU2hhcmVkU3RhdGUgPSB7XG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lclxufTtcblxue1xuICBfYXNzaWduKFJlYWN0R2xvYmFsU2hhcmVkU3RhdGUsIHtcbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiBSZWFjdEludGVybmFscy5SZWFjdENvbXBvbmVudFRyZWVIb29rLFxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0SW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWVcbiAgfSk7XG59XG5cbnZhciBSZWFjdEdsb2JhbFNoYXJlZFN0YXRlXzEgPSBSZWFjdEdsb2JhbFNoYXJlZFN0YXRlO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRDb21wb25lbnROYW1lXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlT3JGaWJlcikge1xuICBpZiAodHlwZW9mIGluc3RhbmNlT3JGaWJlci5nZXROYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gU3RhY2sgcmVjb25jaWxlclxuICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlT3JGaWJlcjtcbiAgICByZXR1cm4gaW5zdGFuY2UuZ2V0TmFtZSgpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5zdGFuY2VPckZpYmVyLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBGaWJlciByZWNvbmNpbGVyXG4gICAgdmFyIGZpYmVyID0gaW5zdGFuY2VPckZpYmVyO1xuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBnZXRDb21wb25lbnROYW1lXzEgPSBnZXRDb21wb25lbnROYW1lO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFR5cGVPZlNpZGVFZmZlY3RcbiAqIFxuICovXG5cbnZhciBSZWFjdFR5cGVPZlNpZGVFZmZlY3QgPSB7XG4gIC8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzOlxuICBOb0VmZmVjdDogMCwgLy8gICAgICAgICAgIDBiMDAwMDAwMDBcbiAgUGVyZm9ybWVkV29yazogMSwgLy8gICAgICAwYjAwMDAwMDAxXG4gIC8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxuICBQbGFjZW1lbnQ6IDIsIC8vICAgICAgICAgIDBiMDAwMDAwMTBcbiAgVXBkYXRlOiA0LCAvLyAgICAgICAgICAgICAwYjAwMDAwMTAwXG4gIFBsYWNlbWVudEFuZFVwZGF0ZTogNiwgLy8gMGIwMDAwMDExMFxuICBEZWxldGlvbjogOCwgLy8gICAgICAgICAgIDBiMDAwMDEwMDBcbiAgQ29udGVudFJlc2V0OiAxNiwgLy8gICAgICAwYjAwMDEwMDAwXG4gIENhbGxiYWNrOiAzMiwgLy8gICAgICAgICAgMGIwMDEwMDAwMFxuICBFcnI6IDY0LCAvLyAgICAgICAgICAgICAgIDBiMDEwMDAwMDBcbiAgUmVmOiAxMjggfTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RHbG9iYWxTaGFyZWRTdGF0ZV8xLlJlYWN0Q3VycmVudE93bmVyO1xuXG5cblxuXG57XG4gIHZhciB3YXJuaW5nJDEgPSByZXF1aXJlJCQwO1xufVxuXG52YXIgQ2xhc3NDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuQ2xhc3NDb21wb25lbnQ7XG52YXIgSG9zdENvbXBvbmVudCQxID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQ7XG52YXIgSG9zdFJvb3QkMSA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Um9vdDtcbnZhciBIb3N0UG9ydGFsID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RQb3J0YWw7XG52YXIgSG9zdFRleHQkMSA9IFJlYWN0VHlwZU9mV29yay5Ib3N0VGV4dDtcblxudmFyIE5vRWZmZWN0ID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0Lk5vRWZmZWN0O1xudmFyIFBsYWNlbWVudCA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QbGFjZW1lbnQ7XG5cbnZhciBNT1VOVElORyA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgVU5NT1VOVEVEID0gMztcblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290JDEpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cbnZhciBpc0ZpYmVyTW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn07XG5cbnZhciBpc01vdW50ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB3YXJuaW5nJDEoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZV8xKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBSZWFjdEluc3RhbmNlTWFwXzEuZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59O1xuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgIShpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIHN0YXRlID0gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKTtcbiAgICAhKHN0YXRlICE9PSBVTk1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgIGlmIChzdGF0ZSA9PT0gTU9VTlRJTkcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhWydyZXR1cm4nXTtcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEgPyBwYXJlbnRBLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgaWYgKCFwYXJlbnRBIHx8ICFwYXJlbnRCKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYVsncmV0dXJuJ10gIT09IGJbJ3JldHVybiddKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgIWRpZEZpbmRDaGlsZCA/IGludmFyaWFudChmYWxzZSwgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGEuYWx0ZXJuYXRlID09PSBiKSA/IGludmFyaWFudChmYWxzZSwgJ1JldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVyc1xcJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgIShhLnRhZyA9PT0gSG9zdFJvb3QkMSkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG52YXIgZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhfMSA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoO1xuXG52YXIgZmluZEN1cnJlbnRIb3N0RmliZXIgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50JDEgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0JDEpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50JDEgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0JDEpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBSZWFjdEZpYmVyVHJlZVJlZmxlY3Rpb24gPSB7XG5cdGlzRmliZXJNb3VudGVkOiBpc0ZpYmVyTW91bnRlZCxcblx0aXNNb3VudGVkOiBpc01vdW50ZWQsXG5cdGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoOiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aF8xLFxuXHRmaW5kQ3VycmVudEhvc3RGaWJlcjogZmluZEN1cnJlbnRIb3N0RmliZXIsXG5cdGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsczogZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzXG59O1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RXJyb3JVdGlsczogZnVuY3Rpb24gKGluamVjdGVkRXJyb3JVdGlscykge1xuICAgICAgISh0eXBlb2YgaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbmplY3RlZCBpbnZva2VHdWFyZGVkQ2FsbGJhY2soKSBtdXN0IGJlIGEgZnVuY3Rpb24uJykgOiB2b2lkIDA7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICAgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAgICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICB9XG59O1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVudGludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICB2YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVycm9yVXRpbHNfMSA9IFJlYWN0RXJyb3JVdGlscztcblxue1xuICB2YXIgd2FybmluZyQyID0gcmVxdWlyZSQkMDtcbn1cblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XG4gICAge1xuICAgICAgd2FybmluZyQyKEluamVjdGVkICYmIEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2UgJiYgSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJyk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlVXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoRW5kJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaENhbmNlbCc7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlTW92ZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hNb3ZlJztcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZURvd24nIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoU3RhcnQnO1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgd2FybmluZyQyKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBSZWFjdEVycm9yVXRpbHNfMS5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMsIGJ1dCBzdG9wc1xuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBpZCBvZiB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHdobydzIGxpc3RlbmVyIHJldHVybnNcbiAqIHRydWUsIG9yIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBkaXNwYXRjaExpc3RlbmVyID8gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGRpc3BhdGNoSW5zdGFuY2UpIDogbnVsbDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50KSA6IG51bGw7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpO1xuICB9LFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxudmFyIEV2ZW50UGx1Z2luVXRpbHNfMSA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cbi8vIFVzZSB0byByZXN0b3JlIGNvbnRyb2xsZWQgc3RhdGUgYWZ0ZXIgYSBjaGFuZ2UgZXZlbnQgaGFzIGZpcmVkLlxuXG52YXIgZmliZXJIb3N0Q29tcG9uZW50ID0gbnVsbDtcblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDogZnVuY3Rpb24gKGhvc3RDb21wb25lbnRJbXBsKSB7XG4gICAgLy8gVGhlIGZpYmVyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdXNlIGR5bmFtaWMgZGlzcGF0Y2ggc28gd2UgbmVlZCB0b1xuICAgIC8vIGluamVjdCB0aGUgaW1wbGVtZW50YXRpb24uXG4gICAgZmliZXJIb3N0Q29tcG9uZW50ID0gaG9zdENvbXBvbmVudEltcGw7XG4gIH1cbn07XG5cbnZhciByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbnZhciByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gRXZlbnRQbHVnaW5VdGlsc18xLmdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgaW50ZXJuYWxJbnN0YW5jZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgIShmaWJlckhvc3RDb21wb25lbnQgJiYgdHlwZW9mIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ZpYmVyIG5lZWRzIHRvIGJlIGluamVjdGVkIHRvIGhhbmRsZSBhIGZpYmVyIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIHByb3BzID0gRXZlbnRQbHVnaW5VdGlsc18xLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICAgIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgISh0eXBlb2YgaW50ZXJuYWxJbnN0YW5jZS5yZXN0b3JlQ29udHJvbGxlZFN0YXRlID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBpbnRlcm5hbCBpbnN0YW5jZSBtdXN0IGJlIGEgUmVhY3QgaG9zdCBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIC8vIElmIGl0IGlzIG5vdCBhIEZpYmVyLCB3ZSBjYW4ganVzdCB1c2UgZHluYW1pYyBkaXNwYXRjaC5cbiAgaW50ZXJuYWxJbnN0YW5jZS5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKCk7XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSB7XG4gIGluamVjdGlvbjogUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uLFxuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmU6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICB9LFxuICByZXN0b3JlU3RhdGVJZk5lZWRlZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudF8xID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50O1xuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBrbm93IGlmIHdlJ3JlIGluIGEgRmliZXJcbi8vIG9yIFN0YWNrIGNvbnRleHQuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBzdGFja0JhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiBmbihhLCBiLCBjLCBkLCBlKTtcbn07XG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbmZ1bmN0aW9uIHBlcmZvcm1GaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICAvLyBJZiB3ZSBoYXZlIEZpYmVyIGxvYWRlZCwgd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gYSBiYXRjaGluZyBjYWxsIHNvIHRoYXRcbiAgLy8gRmliZXIgY2FuIGFwcGx5IGl0cyBkZWZhdWx0IHByaW9yaXR5IGZvciB0aGlzIGNhbGwuXG4gIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG59XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgLy8gV2UgZmlyc3QgcGVyZm9ybSB3b3JrIHdpdGggdGhlIHN0YWNrIGJhdGNoaW5nIHN0cmF0ZWd5LCBieSBwYXNzaW5nIG91clxuICAvLyBpbmRpcmVjdGlvbiB0byBpdC5cbiAgcmV0dXJuIHN0YWNrQmF0Y2hlZFVwZGF0ZXMocGVyZm9ybUZpYmVyQmF0Y2hlZFVwZGF0ZXMsIGZuLCBib29ra2VlcGluZyk7XG59XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlc1dpdGhDb250cm9sbGVkQ29tcG9uZW50cyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfVxuICBpc05lc3RpbmdCYXRjaGVkID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuICAgIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudF8xLnJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH1cbn1cblxudmFyIFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uID0ge1xuICBpbmplY3RTdGFja0JhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoX2JhdGNoZWRVcGRhdGVzKSB7XG4gICAgc3RhY2tCYXRjaGVkVXBkYXRlcyA9IF9iYXRjaGVkVXBkYXRlcztcbiAgfSxcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZyA9IHtcbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzV2l0aENvbnRyb2xsZWRDb21wb25lbnRzLFxuICBpbmplY3Rpb246IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uXG59O1xuXG52YXIgUmVhY3RHZW5lcmljQmF0Y2hpbmdfMSA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nO1xuXG52YXIgVEVYVF9OT0RFJDEgPSBIVE1MTm9kZVR5cGVfMS5URVhUX05PREU7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSQxID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbnZhciBnZXRFdmVudFRhcmdldF8xID0gZ2V0RXZlbnRUYXJnZXQ7XG5cbnZhciBIb3N0Um9vdCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Um9vdDtcblxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICBpZiAodHlwZW9mIGluc3QudGFnID09PSAnbnVtYmVyJykge1xuICAgIHdoaWxlIChpbnN0WydyZXR1cm4nXSkge1xuICAgICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIH1cbiAgICBpZiAoaW5zdC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpbnN0Ll9ob3N0UGFyZW50KSB7XG4gICAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgICB9XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlXzEuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICByZXR1cm4gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0XzEoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RE9NRXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RE9NRXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RET01FdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RET01FdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXRfMShuYXRpdmVFdmVudCk7XG4gICAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhUmVhY3RGaWJlclRyZWVSZWZsZWN0aW9uLmlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0R2VuZXJpY0JhdGNoaW5nXzEuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcl8xID0gUmVhY3RET01FdmVudExpc3RlbmVyO1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxudmFyIGFjY3VtdWxhdGVJbnRvXzEgPSBhY2N1bXVsYXRlSW50bztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKiBcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGVhY2ggZWxlbWVudCBvciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0gez99IFtzY29wZV0gU2NvcGUgdXNlZCBhcyBgdGhpc2AgaW4gYSBjYWxsYmFjay5cbiAqL1xuXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkXzEgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlsc18xLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeV8xLmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnlfMS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgbGlzdGVuZXI7XG5cbiAgICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAgIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICAgIGlmICh0eXBlb2YgaW5zdC50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gICAgICBpZiAoIXN0YXRlTm9kZSkge1xuICAgICAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBFdmVudFBsdWdpblV0aWxzXzEuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IGluc3QuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50RWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGN1cnJlbnRFbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBUZXh0IG5vZGUsIGxldCBpdCBidWJibGUgdGhyb3VnaC5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWluc3QuX3Jvb3ROb2RlSUQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGlzIGFscmVhZHkgdW5tb3VudGVkLCB3ZSBoYXZlIG5vIGxpc3RlbmVycy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3Byb3BzID0gY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICBsaXN0ZW5lciA9IF9wcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBjdXJyZW50RWxlbWVudC50eXBlLCBfcHJvcHMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxpc3RlbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnlfMS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50b18xKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvXzEoZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NFdmVudFF1ZXVlOiBmdW5jdGlvbiAoc2ltdWxhdGVkKSB7XG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICAgIGV2ZW50UXVldWUgPSBudWxsO1xuICAgIGlmIChzaW11bGF0ZWQpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZF8xKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWRfMShwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgICBSZWFjdEVycm9yVXRpbHNfMS5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbiAgfVxufTtcblxudmFyIEV2ZW50UGx1Z2luSHViXzEgPSBFdmVudFBsdWdpbkh1YjtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViXzEuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yl8xLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yl8xLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluXzEgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxudmFyIGlzRXZlbnRTdXBwb3J0ZWRfMSA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZV8xID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWU7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWVfMSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWVfMSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZV8xKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lXzEoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbnZhciBCcm93c2VyRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMkMVxufTtcblxudmFyIEJyb3dzZXJFdmVudENvbnN0YW50c18xID0gQnJvd3NlckV2ZW50Q29uc3RhbnRzO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50c18xLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IF9hc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5fMSwge1xuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgaWYgKFJlYWN0RE9NRXZlbnRMaXN0ZW5lcl8xKSB7XG4gICAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXJfMS5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RET01FdmVudExpc3RlbmVyXzEgJiYgUmVhY3RET01FdmVudExpc3RlbmVyXzEuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5XzEucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFdoZWVsJykge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkXzEoJ3doZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcl8xLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkXzEoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RET01FdmVudExpc3RlbmVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wV2hlZWwnLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcl8xLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgICAgUmVhY3RET01FdmVudExpc3RlbmVyXzEudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wRm9jdXMnIHx8IGRlcGVuZGVuY3kgPT09ICd0b3BCbHVyJykge1xuICAgICAgICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcl8xLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcl8xLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2FuY2VsJykge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkXzEoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXJfMS50cmFwQ2FwdHVyZWRFdmVudCgndG9wQ2FuY2VsJywgJ2NhbmNlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDbG9zZScpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZF8xKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXJfMS50cmFwQ2FwdHVyZWRFdmVudCgndG9wQ2xvc2UnLCAnY2xvc2UnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZXMuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXJfMS50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzOiBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5XzEucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdERPTUV2ZW50TGlzdGVuZXJfMS50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdERPTUV2ZW50TGlzdGVuZXJfMS50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfVxufSk7XG5cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMSA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIGZpYmVyQXN5bmNTY2hlZHVsaW5nOiBmYWxzZSxcbiAgdXNlRmliZXI6IHRydWVcbn07XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFnc18xID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG52YXIgQ1NTUHJvcGVydHlfMSA9IENTU1Byb3BlcnR5O1xuXG52YXIgaXNVbml0bGVzc051bWJlciQxID0gQ1NTUHJvcGVydHlfMS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIkMS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyJDFbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZV8xID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBwcm92aWRlc01vZHVsZSBkZXNjcmliZUNvbXBvbmVudEZyYW1lXG4gKi9cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG52YXIgRnVuY3Rpb25hbENvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5GdW5jdGlvbmFsQ29tcG9uZW50O1xudmFyIENsYXNzQ29tcG9uZW50JDEgPSBSZWFjdFR5cGVPZldvcmsuQ2xhc3NDb21wb25lbnQ7XG52YXIgSG9zdENvbXBvbmVudCQyID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQ7XG5cblxuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkMTpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQkMjpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZV8xKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWVfMShvd25lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgd29yay1pbi1wcm9ncmVzcyBmaWJlciBhbmRcbi8vIG9ubHkgZHVyaW5nIGJlZ2luIG9yIGNvbXBsZXRlIHBoYXNlLiBEbyBub3QgY2FsbCBpdCB1bmRlciBhbnkgb3RoZXJcbi8vIGNpcmN1bXN0YW5jZXMuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyJDEod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxudmFyIFJlYWN0RmliZXJDb21wb25lbnRUcmVlSG9vayA9IHtcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcjogZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlciQxXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0R2xvYmFsU2hhcmVkU3RhdGVfMS5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG57XG4gIHZhciBnZXRDb21wb25lbnROYW1lJDMgPSBnZXRDb21wb25lbnROYW1lXzE7XG5cbiAgdmFyIF9yZXF1aXJlMiQyID0gUmVhY3RGaWJlckNvbXBvbmVudFRyZWVIb29rLFxuICAgICAgZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlciA9IF9yZXF1aXJlMiQyLmdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXI7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChmaWJlci5fZGVidWdPd25lciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSQzKGZpYmVyLl9kZWJ1Z093bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuICAgIHJldHVybiBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpYmVyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gbnVsbDtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlciwgcGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDE7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IGZpYmVyO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lOiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMixcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcl8xID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcjtcblxudmFyIHdhcm5WYWxpZFN0eWxlJDEgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIHZhciBjYW1lbGl6ZVN0eWxlTmFtZSQxID0gY2FtZWxpemVTdHlsZU5hbWU7XG4gIHZhciBnZXRDb21wb25lbnROYW1lJDIgPSBnZXRDb21wb25lbnROYW1lXzE7XG4gIHZhciB3YXJuaW5nJDQgPSByZXF1aXJlJCQwO1xuXG4gIHZhciBfcmVxdWlyZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcl8xLFxuICAgICAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBfcmVxdWlyZSQzLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcblxuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG5cblxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDQoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUkMShuYW1lKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDQoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDQoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiVzIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSwgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmckNChmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDQoZmFsc2UsICdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpO1xuICB9O1xuXG4gIHZhciBjaGVja1JlbmRlck1lc3NhZ2UgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICB2YXIgb3duZXJOYW1lO1xuICAgIGlmIChvd25lciAhPSBudWxsKSB7XG4gICAgICAvLyBTdGFjayBwYXNzZXMgdGhlIG93bmVyIG1hbnVhbGx5IGFsbCB0aGUgd2F5IHRvIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5cbiAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUkMihvd25lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpYmVyIGRvZXNuJ3QgcGFzcyBpdCBidXQgdXNlcyBSZWFjdERlYnVnQ3VycmVudEZpYmVyIHRvIHRyYWNrIGl0LlxuICAgICAgLy8gSXQgaXMgb25seSBlbmFibGVkIGluIGRldmVsb3BtZW50IGFuZCB0cmFja3MgaG9zdCBjb21wb25lbnRzIHRvby5cbiAgICAgIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCk7XG4gICAgICAvLyBUT0RPOiBhbHNvIHJlcG9ydCB0aGUgc3RhY2suXG4gICAgfVxuICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUkMSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIC8vIFRPRE86IHRoaXMgb25seSB3b3JrcyB3aXRoIFN0YWNrLiBTZWVtcyBsaWtlIHdlIG5lZWQgdG8gYWRkIHVuaXQgdGVzdHM/XG4gICAgICBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZV8xID0gd2FyblZhbGlkU3R5bGUkMTtcblxue1xuICB2YXIgaHlwaGVuYXRlU3R5bGVOYW1lJDEgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IHdhcm5WYWxpZFN0eWxlXzE7XG59XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBUaGlzIGNyZWF0ZXMgYSBzdHJpbmcgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBlcXVpdmFsZW50IHRvIHRoZSBzdHlsZVxuICAgKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICAgKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICAgKiBjb21wYXJpc29uLiBJdCBpcyBvbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAgICovXG4gIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG4gICAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZSQxKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlXzEoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICB7XG4gICAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZV8xKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eV8xLnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zXzEgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge307XG5cbntcbiAgdmFyIHdhcm5pbmckNyA9IHJlcXVpcmUkJDA7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2FybmluZyQ3KCFwcm9jZXNzaW5nQ2hpbGRDb250ZXh0LCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgfTtcblxuICBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xuICAgIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICAgIH0sXG4gICAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2tfMSA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rXG4gKiBcbiAqL1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHRoaXMgd2l0aCBhIHRydWUgY2hlY2tcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IG51bGw7XG5cbntcbiAgdmFyIGhpc3RvcnkgPSBbXTtcblxuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHtcbiAgICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucHVzaChvcGVyYXRpb24pO1xuICAgIH0sXG4gICAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suX3ByZXZlbnRDbGVhcmluZykge1xuICAgICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBoaXN0b3J5ID0gW107XG4gICAgfSxcbiAgICBnZXRIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9va18xID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2s7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gUmVhY3RHbG9iYWxTaGFyZWRTdGF0ZV8xLlJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cblxuXG57XG4gIHZhciB3YXJuaW5nJDYgPSByZXF1aXJlJCQwO1xufVxuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHRoaXMgd2l0aCBhIHRydWUgY2hlY2tcbnZhciBSZWFjdERlYnVnVG9vbCQxID0gbnVsbDtcblxue1xuICB2YXIgaG9va3MgPSBbXTtcbiAgdmFyIGRpZEhvb2tUaHJvd0ZvckV2ZW50ID0ge307XG5cbiAgdmFyIGNhbGxIb29rID0gZnVuY3Rpb24gKGV2ZW50LCBmbiwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgIHRyeSB7XG4gICAgICBmbi5jYWxsKGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm5pbmckNihkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0sICdFeGNlcHRpb24gdGhyb3duIGJ5IGhvb2sgd2hpbGUgaGFuZGxpbmcgJXM6ICVzJywgZXZlbnQsIGUgKyAnXFxuJyArIGUuc3RhY2spO1xuICAgICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVtaXRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgICB2YXIgZm4gPSBob29rW2V2ZW50XTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgdmFyIGZsdXNoSGlzdG9yeSA9IFtdO1xuICB2YXIgbGlmZUN5Y2xlVGltZXJTdGFjayA9IFtdO1xuICB2YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG4gIHZhciBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbiAgdmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IDA7XG4gIHZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IDA7XG4gIHZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgdmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG4gIHZhciBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IGZhbHNlO1xuXG4gIHZhciBjbGVhckhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9va18xLmNsZWFySGlzdG9yeSgpO1xuICB9O1xuXG4gIHZhciBnZXRUcmVlU25hcHNob3QgPSBmdW5jdGlvbiAocmVnaXN0ZXJlZElEcykge1xuICAgIHJldHVybiByZWdpc3RlcmVkSURzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwgaWQpIHtcbiAgICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICAgIHZhciBwYXJlbnRJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgICAgdHJlZVtpZF0gPSB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgICAgdGV4dDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRUZXh0KGlkKSxcbiAgICAgICAgdXBkYXRlQ291bnQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VXBkYXRlQ291bnQoaWQpLFxuICAgICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBvd25lcnMgYnV0IHRoaXMgaXMgY2xvc2UgZW5vdWdoLlxuICAgICAgICBvd25lcklEOiBvd25lcklEIHx8IHBhcmVudElEICYmIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChwYXJlbnRJRCkgfHwgMCxcbiAgICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfSwge30pO1xuICB9O1xuXG4gIHZhciByZXNldE1lYXN1cmVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldmlvdXNTdGFydFRpbWUgPSBjdXJyZW50Rmx1c2hTdGFydFRpbWU7XG4gICAgdmFyIHByZXZpb3VzTWVhc3VyZW1lbnRzID0gY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzO1xuICAgIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9va18xLmdldEhpc3RvcnkoKTtcblxuICAgIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG4gICAgICBjbGVhckhpc3RvcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgICBmbHVzaEhpc3RvcnkucHVzaCh7XG4gICAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXG4gICAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IHByZXZpb3VzT3BlcmF0aW9ucyB8fCBbXSxcbiAgICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG4gIH07XG5cbiAgdmFyIGNoZWNrRGVidWdJRCA9IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgICB3YXJuaW5nJDYoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYmVnaW5MaWZlQ3ljbGVUaW1lciA9IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICAgIHdhcm5pbmckNihmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLicgKyAnXFxuXFxuRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKTtcbiAgICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xuICB9O1xuXG4gIHZhciBlbmRMaWZlQ3ljbGVUaW1lciA9IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRpbWVyVHlwZSAhPT0gdGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgICAgd2FybmluZyQ2KGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnV2UgZGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RvcCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnIGluIFJlYWN0LicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJyk7XG4gICAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBjdXJyZW50VGltZXJTdGFydFRpbWUgLSBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbiAgfTtcblxuICB2YXIgcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVyU3RhcnRUaW1lLFxuICAgICAgbmVzdGVkRmx1c2hTdGFydFRpbWU6IHBlcmZvcm1hbmNlTm93KCksXG4gICAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgICAgdGltZXJUeXBlOiBjdXJyZW50VGltZXJUeXBlXG4gICAgfTtcbiAgICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xuICAgIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICAgIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuICB9O1xuXG4gIHZhciByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9saWZlQ3ljbGVUaW1lclN0YWNrJCA9IGxpZmVDeWNsZVRpbWVyU3RhY2sucG9wKCksXG4gICAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICAgIG5lc3RlZEZsdXNoU3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLm5lc3RlZEZsdXNoU3RhcnRUaW1lLFxuICAgICAgICBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQsXG4gICAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgICB2YXIgbmVzdGVkRmx1c2hEdXJhdGlvbiA9IHBlcmZvcm1hbmNlTm93KCkgLSBuZXN0ZWRGbHVzaFN0YXJ0VGltZTtcbiAgICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICAgIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICAgIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG4gIH07XG5cbiAgdmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbiAgdmFyIGNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbiAgdmFyIHNob3VsZE1hcmsgPSBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGlmICghaXNQcm9maWxpbmcgfHwgIWNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaXNIb3N0RWxlbWVudCA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnO1xuICAgIGlmIChpc0hvc3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciBtYXJrQmVnaW4gPSBmdW5jdGlvbiAoZGVidWdJRCwgbWFya1R5cGUpIHtcbiAgICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xuICAgIGxhc3RNYXJrVGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKG1hcmtOYW1lKTtcbiAgfTtcblxuICB2YXIgbWFya0VuZCA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBtYXJrVHlwZSkge1xuICAgIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShkZWJ1Z0lEKSB8fCAnVW5rbm93bic7XG5cbiAgICAvLyBDaHJvbWUgaGFzIGFuIGlzc3VlIG9mIGRyb3BwaW5nIG1hcmtlcnMgcmVjb3JkZWQgdG9vIGZhc3Q6XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjQwNjUyXG4gICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2Ugd2lsbCBub3QgcmVwb3J0IHZlcnkgc21hbGwgbWVhc3VyZW1lbnRzLlxuICAgIC8vIEkgZGV0ZXJtaW5lZCB0aGUgbWFnaWMgbnVtYmVyIGJ5IHR3ZWFraW5nIGl0IGJhY2sgYW5kIGZvcnRoLlxuICAgIC8vIDAuMDVtcyB3YXMgZW5vdWdoIHRvIHByZXZlbnQgdGhlIGlzc3VlLCBidXQgSSBzZXQgaXQgdG8gMC4xbXMgdG8gYmUgc2FmZS5cbiAgICAvLyBXaGVuIHRoZSBidWcgaXMgZml4ZWQsIHdlIGNhbiBgbWVhc3VyZSgpYCB1bmNvbmRpdGlvbmFsbHkgaWYgd2Ugd2FudCB0by5cbiAgICB2YXIgdGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICBpZiAodGltZVN0YW1wIC0gbGFzdE1hcmtUaW1lU3RhbXAgPiAwLjEpIHtcbiAgICAgIHZhciBtZWFzdXJlbWVudE5hbWUgPSBkaXNwbGF5TmFtZSArICcgWycgKyBtYXJrVHlwZSArICddJztcbiAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUobWVhc3VyZW1lbnROYW1lLCBtYXJrTmFtZSk7XG4gICAgfVxuXG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrTmFtZSk7XG4gICAgaWYgKG1lYXN1cmVtZW50TmFtZSkge1xuICAgICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlbWVudE5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdERlYnVnVG9vbCQxID0ge1xuICAgIGFkZEhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgICBob29rcy5wdXNoKGhvb2spO1xuICAgIH0sXG4gICAgcmVtb3ZlSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhvb2tzW2ldID09PSBob29rKSB7XG4gICAgICAgICAgaG9va3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXNQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpc1Byb2ZpbGluZztcbiAgICB9LFxuICAgIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBSZWFjdERlYnVnVG9vbCQxLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2tfMSk7XG4gICAgfSxcbiAgICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICAgICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIFJlYWN0RGVidWdUb29sJDEucmVtb3ZlSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9va18xKTtcbiAgICB9LFxuICAgIGdldEZsdXNoSGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcbiAgICB9LFxuICAgIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEZsdXNoTmVzdGluZysrO1xuICAgICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xuICAgIH0sXG4gICAgb25FbmRGbHVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICAgIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgICAgZW1pdEV2ZW50KCdvbkVuZEZsdXNoJyk7XG4gICAgfSxcbiAgICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICAgIG1hcmtCZWdpbihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgICAgYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIH0sXG4gICAgb25FbmRMaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICAgIG1hcmtFbmQoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICAgIGVtaXRFdmVudCgnb25FbmRMaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgfSxcbiAgICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgZW1pdEV2ZW50KCdvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICAgIH0sXG4gICAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBlbWl0RXZlbnQoJ29uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICAgIH0sXG4gICAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICBjaGVja0RlYnVnSUQob3BlcmF0aW9uLmluc3RhbmNlSUQpO1xuICAgICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBvcGVyYXRpb24pO1xuICAgIH0sXG4gICAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgZW1pdEV2ZW50KCdvblNldFN0YXRlJyk7XG4gICAgfSxcbiAgICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xuICAgICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XG4gICAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XG4gICAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgICBjaGVja0RlYnVnSUQocGFyZW50RGVidWdJRCwgdHJ1ZSk7XG4gICAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAnbW91bnQnKTtcbiAgICB9LFxuICAgIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgICBtYXJrRW5kKGRlYnVnSUQsICdtb3VudCcpO1xuICAgICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gICAgfSxcbiAgICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndXBkYXRlJyk7XG4gICAgfSxcbiAgICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VwZGF0ZScpO1xuICAgICAgZW1pdEV2ZW50KCdvblVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQpO1xuICAgIH0sXG4gICAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndW5tb3VudCcpO1xuICAgIH0sXG4gICAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgICAgbWFya0VuZChkZWJ1Z0lELCAndW5tb3VudCcpO1xuICAgICAgZW1pdEV2ZW50KCdvblVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgICB9LFxuICAgIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICBlbWl0RXZlbnQoJ29uVGVzdEV2ZW50Jyk7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0RGVidWdUb29sJDEuYWRkSG9vayhSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rXzEpO1xuICBSZWFjdERlYnVnVG9vbCQxLmFkZEhvb2soUmVhY3RDb21wb25lbnRUcmVlSG9vayk7XG4gIHZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG4gIGlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICAgIFJlYWN0RGVidWdUb29sJDEuYmVnaW5Qcm9maWxpbmcoKTtcbiAgfVxufVxuXG52YXIgUmVhY3REZWJ1Z1Rvb2xfMSA9IFJlYWN0RGVidWdUb29sJDE7XG5cbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgUmVhY3RJbnN0cnVtZW50YXRpb24gd2l0aCBhIHRydWUgY2hlY2tcblxudmFyIGRlYnVnVG9vbCA9IG51bGw7XG5cbntcbiAgdmFyIFJlYWN0RGVidWdUb29sID0gUmVhY3REZWJ1Z1Rvb2xfMTtcbiAgZGVidWdUb29sID0gUmVhY3REZWJ1Z1Rvb2w7XG59XG5cbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxue1xuICB2YXIgd2FybmluZyQ1ID0gcmVxdWlyZSQkMDtcbn1cblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHlfMS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5XzEuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmckNShmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5XzEuSURfQVRUUklCVVRFX05BTUUsIGlkKTtcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5XzEuUk9PVF9BVFRSSUJVVEVfTkFNRSwgJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gICAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gICAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICAgKi9cbiAgZ2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gICAge1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5XzEuZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAgICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gICAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAgICovXG4gIGdldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAgICB7XG4gICAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHlfMS5nZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgICBpZiAocHJvcGVydHlJbmZvICYmIERPTVByb3BlcnR5XzEuc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIERPTVByb3BlcnR5XzEuc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5XzEuZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxudmFyIERPTVByb3BlcnR5T3BlcmF0aW9uc18xID0gRE9NUHJvcGVydHlPcGVyYXRpb25zO1xuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciB3YXJuaW5nJDkgPSByZXF1aXJlJCQwO1xuICB2YXIgZW1wdHlGdW5jdGlvbiQyID0gZW1wdHlGdW5jdGlvbjtcbiAgdmFyIFByb3BUeXBlcyA9IHByb3BUeXBlcztcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb24kMjtcbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzJDEgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xuICB9O1xuXG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMkMSkge1xuICAgICAgaWYgKHByb3BUeXBlcyQxLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXMkMVtwcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCAncHJvcCcsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHdhcm5pbmckOShmYWxzZSwgJ0ZhaWxlZCBmb3JtIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgZ2V0U3RhY2soKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXNfMSA9IFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzO1xuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyXzEuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xuXG57XG4gIHZhciBfcmVxdWlyZTIkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXJfMSxcbiAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiA9IF9yZXF1aXJlMiQzLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbiAgdmFyIHdhcm5pbmckOCA9IHJlcXVpcmUkJDA7XG59XG5cblxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcbiAgICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgICAgc3RlcDogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXG4gICAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgfSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBpbml0V3JhcHBlclN0YXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB7XG4gICAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlc18xLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIpO1xuXG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgd2FybmluZyQ4KGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgICB3YXJuaW5nJDgoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAgIHtcbiAgICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICAgIHdhcm5pbmckOChmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICAgIHdhcm5pbmckOChmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9uc18xLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAgIC8vIE5vdGU6IElFOSByZXBvcnRzIGEgbnVtYmVyIGlucHV0cyBhcyAndGV4dCcsIHNvIGNoZWNrIHByb3BzIGluc3RlYWQuXG4gICAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgICAgdmFyIHZhbHVlQXNOdW1iZXIgPSBwYXJzZUZsb2F0KG5vZGUudmFsdWUpIHx8IDA7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdmFsdWUgIT0gdmFsdWVBc051bWJlciB8fFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdmFsdWUgPT0gdmFsdWVBc051bWJlciAmJiBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgICAvLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4gICAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4gICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG4gICAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIHZhciBub2RlID0gZWxlbWVudDtcblxuICAgIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxuICAgIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gICAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gICAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXG4gICAgLy8gcHJvdmlkZWQuXG5cbiAgICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnO1xuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gJyc7XG4gICAgfVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgfSxcblxuICByZXN0b3JlQ29udHJvbGxlZFN0YXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKG5vZGUsIHByb3BzKTtcbiAgICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJQcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJJbnB1dCA9IFJlYWN0RE9NSW5wdXQ7XG5cbntcbiAgdmFyIHdhcm5pbmckMTAgPSByZXF1aXJlJCQwO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICByZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgdmFsaWRhdGVQcm9wczogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAge1xuICAgICAgd2FybmluZyQxMChwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcblxuICAgIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cbn07XG5cbnZhciBSZWFjdERPTUZpYmVyT3B0aW9uID0gUmVhY3RET01PcHRpb247XG5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXJfMS5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG5cbntcbiAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG4gIHZhciB3YXJuaW5nJDExID0gcmVxdWlyZSQkMDtcblxuICB2YXIgX3JlcXVpcmUyJDQgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyXzEsXG4gICAgICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMgPSBfcmVxdWlyZTIkNC5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkNCgpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlc18xLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nJDExKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nJDExKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgaW5pdFdyYXBwZXJTdGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAgIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgICB3YXJuaW5nJDExKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIHZhciBub2RlID0gZWxlbWVudDtcbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG5cbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZXN0b3JlQ29udHJvbGxlZFN0YXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUmVhY3RET01GaWJlclNlbGVjdCA9IFJlYWN0RE9NU2VsZWN0O1xuXG57XG4gIHZhciB3YXJuaW5nJDEyID0gcmVxdWlyZSQkMDtcblxuICB2YXIgX3JlcXVpcmUkNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXJfMSxcbiAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IF9yZXF1aXJlJDQuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbn1cblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAgIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAgIC8vIHRvIGJlIGEgc3RyaW5nLlxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBpbml0V3JhcHBlclN0YXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICAge1xuICAgICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXNfMS5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgICB3YXJuaW5nJDEyKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB3YXJuaW5nJDEyKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIHZhciBub2RlID0gZWxlbWVudDtcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIHZhciBub2RlID0gZWxlbWVudDtcbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAgIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gICAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICAgIGlmICh0ZXh0Q29udGVudCA9PT0gbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfSxcblxuICByZXN0b3JlQ29udHJvbGxlZFN0YXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdERPTUZpYmVyVGV4dGFyZWEgPSBSZWFjdERPTVRleHRhcmVhO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbWl0dGVkQ2xvc2VUYWdzXG4gKi9cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG52YXIgb21pdHRlZENsb3NlVGFnc18xID0gb21pdHRlZENsb3NlVGFncztcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzXzEpO1xuXG52YXIgdm9pZEVsZW1lbnRUYWdzXzEgPSB2b2lkRWxlbWVudFRhZ3M7XG5cbntcbiAgdmFyIHdhcm5pbmckMTMgPSByZXF1aXJlJCQwO1xufVxuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSQxKGdldEN1cnJlbnRPd25lck5hbWUpIHtcbiAge1xuICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50T3duZXJOYW1lKCk7XG4gICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgLy8gVE9ETzogYWxzbyByZXBvcnQgdGhlIHN0YWNrLlxuICAgICAgcmV0dXJuICdcXG5cXG5UaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRDdXJyZW50T3duZXJOYW1lKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc18xW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0kMShnZXRDdXJyZW50T3duZXJOYW1lKSkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwkMSBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHdhcm5pbmckMTMocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtJDEoZ2V0Q3VycmVudE93bmVyTmFtZSkpIDogdm9pZCAwO1xufVxuXG52YXIgYXNzZXJ0VmFsaWRQcm9wc18xID0gYXNzZXJ0VmFsaWRQcm9wcztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5wdXRWYWx1ZVRyYWNraW5nXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tlcihub2RlKSB7XG4gIHJldHVybiBub2RlLl92YWx1ZVRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGRldGFjaFRyYWNrZXIobm9kZSkge1xuICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlID0gJyc7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICB2YXIgY3VycmVudFZhbHVlID0gJycgKyBub2RlW3ZhbHVlRmllbGRdO1xuXG4gIC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcbiAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCkgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0cmFja2VyID0ge1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9LFxuICAgIHN0b3BUcmFja2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgZGV0YWNoVHJhY2tlcihub2RlKTtcbiAgICAgIGRlbGV0ZSBub2RlW3ZhbHVlRmllbGRdO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYWNrZXI7XG59XG5cbnZhciBpbnB1dFZhbHVlVHJhY2tpbmcgPSB7XG4gIC8vIGV4cG9zZWQgZm9yIHRlc3RpbmdcbiAgX2dldFRyYWNrZXJGcm9tTm9kZTogZ2V0VHJhY2tlcixcblxuICB0cmFjazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gICAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbiAgfSxcbiAgdXBkYXRlVmFsdWVJZkNoYW5nZWQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gICAgLy8gdGhhdCB0cnlpbmcgYWdhaW4gd2lsbCBzdWNjZWVkXG4gICAgaWYgKCF0cmFja2VyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICAgIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICAgIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciB0cmFja2VyID0gZ2V0VHJhY2tlcihub2RlKTtcbiAgICBpZiAodHJhY2tlcikge1xuICAgICAgdHJhY2tlci5zdG9wVHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnB1dFZhbHVlVHJhY2tpbmdfMSA9IGlucHV0VmFsdWVUcmFja2luZztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNDdXN0b21Db21wb25lbnRcbiAqIFxuICovXG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIGlzQ3VzdG9tQ29tcG9uZW50XzEgPSBpc0N1c3RvbUNvbXBvbmVudDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvblxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb25fMSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb247XG5cbnZhciBOYW1lc3BhY2VzJDEgPSBET01OYW1lc3BhY2VzLk5hbWVzcGFjZXM7XG5cblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbl8xKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZXMkMS5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG52YXIgc2V0SW5uZXJIVE1MXzEgPSBzZXRJbm5lckhUTUw7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQmFzZWQgb24gdGhlIGVzY2FwZS1odG1sIGxpYnJhcnksIHdoaWNoIGlzIHVzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIGJlbG93OlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQW5kcmVhcyBMdWJiZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlclxuICovXG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJfMSA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjtcblxudmFyIFRFWFRfTk9ERSQyID0gSFRNTE5vZGVUeXBlXzEuVEVYVF9OT0RFO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUkMikge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSQyKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0SW5uZXJIVE1MXzEobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXzEodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIHNldFRleHRDb250ZW50XzEgPSBzZXRUZXh0Q29udGVudDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdmFsaWRBcmlhUHJvcGVydGllc1xuICovXG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHZhbGlkQXJpYVByb3BlcnRpZXMkMSA9IGFyaWFQcm9wZXJ0aWVzO1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIERPTVByb3BlcnR5XzEuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBET01Qcm9wZXJ0eV8xLkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbntcbiAgdmFyIHdhcm5pbmckMTQgPSByZXF1aXJlJCQwO1xuXG4gIHZhciBfcmVxdWlyZSQ1ID0gUmVhY3RHbG9iYWxTaGFyZWRTdGF0ZV8xLFxuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayQxID0gX3JlcXVpcmUkNS5SZWFjdENvbXBvbmVudFRyZWVIb29rLFxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gX3JlcXVpcmUkNS5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtQnlJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2skMS5nZXRTdGFja0FkZGVuZHVtQnlJRDtcblxuXG4gIHZhciB2YWxpZEFyaWFQcm9wZXJ0aWVzID0gdmFsaWRBcmlhUHJvcGVydGllcyQxO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtKGRlYnVnSUQpIHtcbiAgaWYgKGRlYnVnSUQgIT0gbnVsbCkge1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIG9uIFN0YWNrXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIG9uIEZpYmVyIC8gU2VydmVyXG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IHZhbGlkQXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuaW5nJDE0KGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKGRlYnVnSUQpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyQxNChmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bShkZWJ1Z0lEKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSB2YWxpZEFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nJDE0KGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bShkZWJ1Z0lEKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcywgZGVidWdJRCkge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgZGVidWdJRCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmckMTQoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKGRlYnVnSUQpKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmckMTQoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bShkZWJ1Z0lEKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBkZWJ1Z0lEIC8qIFN0YWNrIG9ubHkgKi8pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50XzEodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzLCBkZWJ1Z0lEKTtcbn1cblxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rJDEgPSB7XG4gIC8vIEZpYmVyXG4gIHZhbGlkYXRlUHJvcGVydGllczogdmFsaWRhdGVQcm9wZXJ0aWVzLFxuICAvLyBTdGFja1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGlmICh0cnVlICYmIGVsZW1lbnQgIT0gbnVsbCAmJiB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKGVsZW1lbnQudHlwZSwgZWxlbWVudC5wcm9wcywgZGVidWdJRCk7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBpZiAodHJ1ZSAmJiBlbGVtZW50ICE9IG51bGwgJiYgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMsIGRlYnVnSUQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rXzEgPSBSZWFjdERPTUludmFsaWRBUklBSG9vayQxO1xuXG57XG4gIHZhciB3YXJuaW5nJDE1ID0gcmVxdWlyZSQkMDtcblxuICB2YXIgX3JlcXVpcmUkNiA9IFJlYWN0R2xvYmFsU2hhcmVkU3RhdGVfMSxcbiAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2skMiA9IF9yZXF1aXJlJDYuUmVhY3RDb21wb25lbnRUcmVlSG9vayxcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMiA9IF9yZXF1aXJlJDYuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuICB2YXIgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQkMSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2skMi5nZXRTdGFja0FkZGVuZHVtQnlJRDtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKGRlYnVnSUQpIHtcbiAgaWYgKGRlYnVnSUQgIT0gbnVsbCkge1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIG9uIFN0YWNrXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeUlEJDEoZGVidWdJRCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gb24gRmliZXIgLyBTZXJ2ZXJcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDIuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcywgZGVidWdJRCAvKiBTdGFjayBvbmx5ICovKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICB3YXJuaW5nJDE1KGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIHRoZSBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMShkZWJ1Z0lEKSk7XG5cbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJDEgPSB7XG4gIC8vIEZpYmVyXG4gIHZhbGlkYXRlUHJvcGVydGllczogdmFsaWRhdGVQcm9wZXJ0aWVzJDEsXG4gIC8vIFN0YWNrXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHRydWUgJiYgZWxlbWVudCAhPSBudWxsICYmIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMShlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMsIGRlYnVnSUQpO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHRydWUgJiYgZWxlbWVudCAhPSBudWxsICYmIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMShlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMsIGRlYnVnSUQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9va18xID0gUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJDE7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBvc3NpYmxlU3RhbmRhcmROYW1lc1xuICovXG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzJDEgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsbG93dHJhbnNwYXJlbmN5OiAnYWxsb3dUcmFuc3BhcmVuY3knLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICAnZGVmYXVsdCc6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcblxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICAnaW4nOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICAndHlwZW9mJzogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzXzEgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXMkMTtcblxue1xuICB2YXIgd2FybmluZyQxNiA9IHJlcXVpcmUkJDA7XG5cbiAgdmFyIF9yZXF1aXJlJDcgPSBSZWFjdEdsb2JhbFNoYXJlZFN0YXRlXzEsXG4gICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rJDMgPSBfcmVxdWlyZSQ3LlJlYWN0Q29tcG9uZW50VHJlZUhvb2ssXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDMgPSBfcmVxdWlyZSQ3LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbiAgdmFyIGdldFN0YWNrQWRkZW5kdW1CeUlEJDIgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rJDMuZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMihkZWJ1Z0lEKSB7XG4gIGlmIChkZWJ1Z0lEICE9IG51bGwpIHtcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBvbiBTdGFja1xuICAgIHJldHVybiBnZXRTdGFja0FkZGVuZHVtQnlJRCQyKGRlYnVnSUQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIG9uIEZpYmVyIC8gU2VydmVyXG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQzLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uW0EtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBET01Qcm9wZXJ0eV8xLkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIERPTVByb3BlcnR5XzEuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc18xO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeV8xLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeV8xLnBsdWdpbnMubGVuZ3RoID09PSAwICYmIEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIG1pZ2h0IGJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gRG9uJ3QgY2hlY2sgZXZlbnRzIGluIHRoaXMgY2FzZS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnlfMS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IEV2ZW50UGx1Z2luUmVnaXN0cnlfMS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5nJDE2KGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKGRlYnVnSUQpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgd2FybmluZyQxNihmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoZGVidWdJRCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmckMTYoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmckMTYoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmckMTYoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyQxNihmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3Igc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgdHlwZW9mIHZhbHVlLCBnZXRTdGFja0FkZGVuZHVtJDIoZGVidWdJRCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyQxNihmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgbnVtZXJpYyBhdHRyaWJ1dGUgYCVzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMihkZWJ1Z0lEKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBET01Qcm9wZXJ0eV8xLmlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmckMTYoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKGRlYnVnSUQpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICB3YXJuaW5nJDE2KGZhbHNlLCAnUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4lcycsIG5hbWUsIGxvd2VyQ2FzZWROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoZGVidWdJRCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgd2FybmluZyQxNihET01Qcm9wZXJ0eV8xLnNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSwgJ1JlY2VpdmVkIGAlc2AgZm9yIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMihkZWJ1Z0lEKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoIURPTVByb3BlcnR5XzEuc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZGVidWdJRCkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZGVidWdJRCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nJDE2KGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKGRlYnVnSUQpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmckMTYoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoZGVidWdJRCkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgZGVidWdJRCAvKiBTdGFjayBvbmx5ICovKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudF8xKHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGRlYnVnSUQpO1xufVxuXG52YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJDEgPSB7XG4gIC8vIEZpYmVyXG4gIHZhbGlkYXRlUHJvcGVydGllczogdmFsaWRhdGVQcm9wZXJ0aWVzJDIsXG4gIC8vIFN0YWNrXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHRydWUgJiYgZWxlbWVudCAhPSBudWxsICYmIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMihlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMsIGRlYnVnSUQpO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHRydWUgJiYgZWxlbWVudCAhPSBudWxsICYmIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMihlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMsIGRlYnVnSUQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9va18xID0gUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJDE7XG5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyXzEuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xuXG52YXIgRE9DVU1FTlRfTk9ERSQxID0gSFRNTE5vZGVUeXBlXzEuRE9DVU1FTlRfTk9ERTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEgPSBIVE1MTm9kZVR5cGVfMS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuXG5cblxuXG5cblxuXG5cbntcbiAgdmFyIHdhcm5pbmckMyA9IHJlcXVpcmUkJDA7XG5cbiAgdmFyIF9yZXF1aXJlMyQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcl8xLFxuICAgICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSA9IF9yZXF1aXJlMyQxLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbiAgdmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0gUmVhY3RET01JbnZhbGlkQVJJQUhvb2tfMTtcbiAgdmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9va18xO1xuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rXzE7XG4gIHZhciB2YWxpZGF0ZUFSSUFQcm9wZXJ0aWVzID0gUmVhY3RET01JbnZhbGlkQVJJQUhvb2sudmFsaWRhdGVQcm9wZXJ0aWVzO1xuICB2YXIgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXMgPSBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sudmFsaWRhdGVQcm9wZXJ0aWVzO1xuICB2YXIgdmFsaWRhdGVVbmtub3duUHJvcGVydGllcyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay52YWxpZGF0ZVByb3BlcnRpZXM7XG59XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnlfMS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxudmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MID0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJztcbnZhciBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgPSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSBET01OYW1lc3BhY2VzLk5hbWVzcGFjZXMuaHRtbDtcbnZhciBnZXRJbnRyaW5zaWNOYW1lc3BhY2UkMSA9IERPTU5hbWVzcGFjZXMuZ2V0SW50cmluc2ljTmFtZXNwYWNlO1xuXG5cbntcbiAgdmFyIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZVxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVBUklBUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyQzKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgc2VydmVyVGV4dCwgY2xpZW50VGV4dCk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDMoZmFsc2UsICdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KHNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkoY2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nJDMoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIHdhcm5pbmckMyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSk7XG4gIH07XG5cbiAgdmFyIHRlc3REb2N1bWVudDtcbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIHZhciBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIGlmICghdGVzdERvY3VtZW50KSB7XG4gICAgICB0ZXN0RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgICB9XG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSA/IHRlc3REb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHRlc3REb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUkMSB8fCByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudE9yRnJhZ21lbnQgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUkMSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBuZXh0UHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNfMS5zZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTF8xKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBzZXRUZXh0Q29udGVudF8xKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBzZXRUZXh0Q29udGVudF8xKGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zXzEuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zXzEuc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNfMS5zZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHNldElubmVySFRNTF8xKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnRfMShkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnNfMS5zZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zXzEuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zXzEuc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnNfMS5kZWxldGVWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RET01GaWJlckNvbXBvbmVudCA9IHtcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgICB2YXIgZG9tRWxlbWVudDtcbiAgICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSQxKHR5cGUpO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50XzEodHlwZSwgcHJvcHMpO1xuICAgICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICAgd2FybmluZyQzKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWNhdXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuaW5nJDMoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBjcmVhdGVUZXh0Tm9kZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gIH0sXG4gIHNldEluaXRpYWxQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudF8xKHRhZywgcmF3UHJvcHMpO1xuICAgIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgJiYgIWRpZFdhcm5TaGFkeURPTSAmJiBkb21FbGVtZW50LnNoYWR5Um9vdCkge1xuICAgICAgICB3YXJuaW5nJDMoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgICB2YXIgcHJvcHM7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLnRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUZpYmVySW5wdXQuaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01GaWJlcklucHV0LmdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTUZpYmVyT3B0aW9uLnZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NRmliZXJPcHRpb24uZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTUZpYmVyU2VsZWN0LmluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NRmliZXJTZWxlY3QuZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01GaWJlclRleHRhcmVhLmluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NRmliZXJUZXh0YXJlYS5nZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzXzEodGFnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKTtcblxuICAgIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgICBpbnB1dFZhbHVlVHJhY2tpbmdfMS50cmFjayhkb21FbGVtZW50KTtcbiAgICAgICAgUmVhY3RET01GaWJlcklucHV0LnBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgICBpbnB1dFZhbHVlVHJhY2tpbmdfMS50cmFjayhkb21FbGVtZW50KTtcbiAgICAgICAgUmVhY3RET01GaWJlclRleHRhcmVhLnBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NRmliZXJPcHRpb24ucG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01GaWJlclNlbGVjdC5wb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbiAgZGlmZlByb3BlcnRpZXM6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICAgIHZhciBsYXN0UHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcztcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUZpYmVySW5wdXQuZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NRmliZXJJbnB1dC5nZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NRmliZXJPcHRpb24uZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NRmliZXJPcHRpb24uZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUZpYmVyU2VsZWN0LmdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUZpYmVyU2VsZWN0LmdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUZpYmVyVGV4dGFyZWEuZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NRmliZXJUZXh0YXJlYS5nZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wc18xKHRhZywgbmV4dFByb3BzLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUpO1xuXG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgIC8vIE5vb3AuIFRoaXMgaXMgaGFuZGxlZCBieSB0aGUgY2xlYXIgdGV4dCBtZWNoYW5pc20uXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIGZpYmVyIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGRlbGV0ZWQgcHJvcGVydGllcyB3ZSBhZGQgaXQgdG8gdGhlIHF1ZXVlLiBXZSB1c2VcbiAgICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgICAgLy8gaW5zZXJ0ZWQgYWxyZWFkeS5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgICBpZiAobGFzdFByb3AgIT09IG5leHRQcm9wICYmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbiAgfSxcblxuXG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcykge1xuICAgIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudF8xKHRhZywgbGFzdFJhd1Byb3BzKTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudF8xKHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgICAvLyBBcHBseSB0aGUgZGlmZi5cbiAgICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gICAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAgIC8vIGNoYW5nZWQuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01GaWJlcklucHV0LnVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcblxuICAgICAgICAvLyBXZSBhbHNvIGNoZWNrIHRoYXQgd2UgaGF2ZW4ndCBtaXNzZWQgYSB2YWx1ZSB1cGRhdGUsIHN1Y2ggYXMgYVxuICAgICAgICAvLyBSYWRpbyBncm91cCBzaGlmdGluZyB0aGUgY2hlY2tlZCB2YWx1ZSB0byBhbm90aGVyIG5hbWVkIHJhZGlvIGlucHV0LlxuICAgICAgICBpbnB1dFZhbHVlVHJhY2tpbmdfMS51cGRhdGVWYWx1ZUlmQ2hhbmdlZChkb21FbGVtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NRmliZXJUZXh0YXJlYS51cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICAgIFJlYWN0RE9NRmliZXJTZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuICBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50XzEodGFnLCByYXdQcm9wcyk7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgICAgd2FybmluZyQzKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLnRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS50cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUZpYmVySW5wdXQuaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTUZpYmVyT3B0aW9uLnZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIFJlYWN0RE9NRmliZXJTZWxlY3QuaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NRmliZXJUZXh0YXJlYS5pbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXzEudHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzXzEodGFnLCByYXdQcm9wcywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKTtcblxuICAgIHtcbiAgICAgIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgICB2YXIgc2VydmVyVmFsdWU7XG4gICAgICAgIHZhciBwcm9wZXJ0eUluZm87XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHxcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBwcm9wS2V5ID09PSAndmFsdWUnIHx8IHByb3BLZXkgPT09ICdjaGVja2VkJyB8fCBwcm9wS2V5ID09PSAnc2VsZWN0ZWQnKSB7XG4gICAgICAgICAgLy8gTm9vcFxuICAgICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgICAgdmFyIHJhd0h0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIHx8ICcnIDogJyc7XG4gICAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCByYXdIdG1sKTtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkU3R5bGUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNfMS5jcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gRE9NUHJvcGVydHlPcGVyYXRpb25zXzEuZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5XzEuc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eV8xLmdldFByb3BlcnR5SW5mbyhwcm9wS2V5KSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgc2VydmVyVmFsdWUgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNfMS5nZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlJDEodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlclZhbHVlID0gRE9NUHJvcGVydHlPcGVyYXRpb25zXzEuZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhleHRyYUF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICAgIGlucHV0VmFsdWVUcmFja2luZ18xLnRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgICBSZWFjdERPTUZpYmVySW5wdXQucG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICAgIGlucHV0VmFsdWVUcmFja2luZ18xLnRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgICBSZWFjdERPTUZpYmVyVGV4dGFyZWEucG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG4gIH0sXG4gIGRpZmZIeWRyYXRlZFRleHQ6IGZ1bmN0aW9uICh0ZXh0Tm9kZSwgdGV4dCkge1xuICAgIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgICB7XG4gICAgICBpZiAoaXNEaWZmZXJlbnQpIHtcbiAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0RpZmZlcmVudDtcbiAgfSxcbiAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gICAge1xuICAgICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmckMyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH0sXG4gIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQ6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBjaGlsZCkge1xuICAgIHtcbiAgICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nJDMoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfSxcbiAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICAgIHtcbiAgICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nJDMoZmFsc2UsICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH0sXG4gIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRleHQpIHtcbiAgICB7XG4gICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgaWYgd2UgY2FuIGp1c3QgYXZvaWQgaW5zZXJ0aW5nIGVtcHR5XG4gICAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nJDMoZmFsc2UsICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgdGV4dCBub2RlIGZvciBcIiVzXCIgaW4gPCVzPi4nLCB0ZXh0LCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfSxcbiAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUZpYmVySW5wdXQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01GaWJlclRleHRhcmVhLnJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTUZpYmVyU2VsZWN0LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG52YXIgUmVhY3RET01GaWJlckNvbXBvbmVudF8xID0gUmVhY3RET01GaWJlckNvbXBvbmVudDtcblxuLy8gVGhpcyBpcyBhIGJ1aWx0LWluIHBvbHlmaWxsIGZvciByZXF1ZXN0SWRsZUNhbGxiYWNrLiBJdCB3b3JrcyBieSBzY2hlZHVsaW5nXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxuXG5cbntcbiAgdmFyIHdhcm5pbmckMTcgPSByZXF1aXJlJCQwO1xuXG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmckMTcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lQ2FsbGJhY2soe1xuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gMDtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjay5cblxuICB2YXIgc2NoZWR1bGVkUkFGQ2FsbGJhY2sgPSBudWxsO1xuICB2YXIgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuXG4gIHZhciBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICB2YXIgZnJhbWVEZWFkbGluZSA9IDA7XG4gIC8vIFdlIHN0YXJ0IG91dCBhc3N1bWluZyB0aGF0IHdlIHJ1biBhdCAzMGZwcyBidXQgdGhlbiB0aGUgaGV1cmlzdGljIHRyYWNraW5nXG4gIC8vIHdpbGwgYWRqdXN0IHRoaXMgdmFsdWUgdG8gYSBmYXN0ZXIgZnBzIGlmIHdlIGdldCBtb3JlIGZyZXF1ZW50IGFuaW1hdGlvblxuICAvLyBmcmFtZXMuXG4gIHZhciBwcmV2aW91c0ZyYW1lVGltZSA9IDMzO1xuICB2YXIgYWN0aXZlRnJhbWVUaW1lID0gMzM7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmVPYmplY3QgPSB7XG4gICAgdGltZVJlbWFpbmluZzogdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaWYgd2UgaGF2ZSBhIHBlcmZvcm1hbmNlIHRpbWVyIHRoYXQgdGhlIHJBRiBjYWxsYmFja1xuICAgICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgICAgcmV0dXJuIGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQXMgYSBmYWxsYmFjayB3ZSB1c2UgRGF0ZS5ub3cuXG4gICAgICByZXR1cm4gZnJhbWVEZWFkbGluZSAtIERhdGUubm93KCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgICB2YXIgY2FsbGJhY2sgPSBzY2hlZHVsZWRSQUZDYWxsYmFjaztcbiAgICBzY2hlZHVsZWRSQUZDYWxsYmFjayA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhyYWZUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgcklDID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2Ugb25seSBzY2hlZHVsZSBvbmUgY2FsbGJhY2sgYXQgYSB0aW1lIGJlY2F1c2UgdGhhdCdzXG4gICAgLy8gaG93IEZpYmVyIHVzZXMgaXQuXG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgIC8vIElmIHJBRiBkaWRuJ3QgYWxyZWFkeSBzY2hlZHVsZSBvbmUsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBmcmFtZS5cbiAgICAgIC8vIFRPRE86IElmIHRoaXMgckFGIGRvZXNuJ3QgbWF0ZXJpYWxpemUgYmVjYXVzZSB0aGUgYnJvd3NlciB0aHJvdHRsZXMsIHdlXG4gICAgICAvLyBtaWdodCB3YW50IHRvIHN0aWxsIGhhdmUgc2V0VGltZW91dCB0cmlnZ2VyIHJJQyBhcyBhIGJhY2t1cCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgd2Uga2VlcCBwZXJmb3JtaW5nIHdvcmsuXG4gICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25UaWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSByZXF1ZXN0SWRsZUNhbGxiYWNrO1xufVxuXG52YXIgcklDXzEgPSBySUM7XG5cbnZhciBSZWFjdERPTUZyYW1lU2NoZWR1bGluZyA9IHtcblx0cklDOiBySUNfMVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RGZWF0dXJlRmxhZ3NcbiAqIFxuICovXG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJOiB0cnVlXG59O1xuXG52YXIgUmVhY3RGZWF0dXJlRmxhZ3NfMSA9IFJlYWN0RmVhdHVyZUZsYWdzO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByaW9yaXR5TGV2ZWxcbiAqIFxuICovXG5cbnZhciBSZWFjdFByaW9yaXR5TGV2ZWwgPSB7XG4gIE5vV29yazogMCwgLy8gTm8gd29yayBpcyBwZW5kaW5nLlxuICBTeW5jaHJvbm91c1ByaW9yaXR5OiAxLCAvLyBGb3IgY29udHJvbGxlZCB0ZXh0IGlucHV0cy4gU3luY2hyb25vdXMgc2lkZS1lZmZlY3RzLlxuICBUYXNrUHJpb3JpdHk6IDIsIC8vIENvbXBsZXRlcyBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHRpY2suXG4gIEhpZ2hQcmlvcml0eTogMywgLy8gSW50ZXJhY3Rpb24gdGhhdCBuZWVkcyB0byBjb21wbGV0ZSBwcmV0dHkgc29vbiB0byBmZWVsIHJlc3BvbnNpdmUuXG4gIExvd1ByaW9yaXR5OiA0LCAvLyBEYXRhIGZldGNoaW5nLCBvciByZXN1bHQgZnJvbSB1cGRhdGluZyBzdG9yZXMuXG4gIE9mZnNjcmVlblByaW9yaXR5OiA1IH07XG5cbnZhciBDYWxsYmFja0VmZmVjdCA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5DYWxsYmFjaztcblxudmFyIE5vV29yayA9IFJlYWN0UHJpb3JpdHlMZXZlbC5Ob1dvcms7XG52YXIgU3luY2hyb25vdXNQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbC5TeW5jaHJvbm91c1ByaW9yaXR5O1xudmFyIFRhc2tQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbC5UYXNrUHJpb3JpdHk7XG5cbnZhciBDbGFzc0NvbXBvbmVudCQyID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50O1xudmFyIEhvc3RSb290JDIgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3Q7XG5cblxue1xuICB2YXIgd2FybmluZyQxOSA9IHJlcXVpcmUkJDA7XG59XG5cbi8vIENhbGxiYWNrcyBhcmUgbm90IHZhbGlkYXRlZCB1bnRpbCBpbnZvY2F0aW9uXG5cblxuLy8gU2luZ2x5IGxpbmtlZC1saXN0IG9mIHVwZGF0ZXMuIFdoZW4gYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCwgaXQgaXMgYWRkZWQgdG9cbi8vIHRoZSBxdWV1ZSBvZiB0aGUgY3VycmVudCBmaWJlciBhbmQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoZSB0d28gcXVldWVzXG4vLyBhcmUgc2VwYXJhdGUgYnV0IHRoZXkgc2hhcmUgYSBwZXJzaXN0ZW50IHN0cnVjdHVyZS5cbi8vXG4vLyBEdXJpbmcgcmVjb25jaWxpYXRpb24sIHVwZGF0ZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlcixcbi8vIGJ1dCB0aGV5IHJlbWFpbiBvbiB0aGUgY3VycmVudCBmaWJlci4gVGhhdCBlbnN1cmVzIHRoYXQgaWYgYSB3b3JrLWluLXByb2dyZXNzXG4vLyBpcyBhYm9ydGVkLCB0aGUgYWJvcnRlZCB1cGRhdGVzIGFyZSByZWNvdmVyZWQgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYWx3YXlzIGEgc3Vic2V0IG9mIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIFdoZW4gdGhlIHRyZWUgaXMgY29tbWl0dGVkLCB0aGUgd29yay1pbi1wcm9ncmVzcyBiZWNvbWVzIHRoZSBjdXJyZW50LlxuXG5cbnZhciBfcXVldWUxID0gdm9pZCAwO1xudmFyIF9xdWV1ZTIgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGNvbXBhcmVQcmlvcml0eShhLCBiKSB7XG4gIC8vIFdoZW4gY29tcGFyaW5nIHVwZGF0ZSBwcmlvcml0aWVzLCB0cmVhdCBzeW5jIGFuZCBUYXNrIHdvcmsgYXMgZXF1YWwuXG4gIC8vIFRPRE86IENvdWxkIHdlIGF2b2lkIHRoZSBuZWVkIGZvciB0aGlzIGJ5IGFsd2F5cyBjb2VyY2luZyBzeW5jIHByaW9yaXR5XG4gIC8vIHRvIFRhc2sgd2hlbiBzY2hlZHVsaW5nIGFuIHVwZGF0ZT9cbiAgaWYgKChhID09PSBUYXNrUHJpb3JpdHkgfHwgYSA9PT0gU3luY2hyb25vdXNQcmlvcml0eSkgJiYgKGIgPT09IFRhc2tQcmlvcml0eSB8fCBiID09PSBTeW5jaHJvbm91c1ByaW9yaXR5KSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChhID09PSBOb1dvcmsgJiYgYiAhPT0gTm9Xb3JrKSB7XG4gICAgcmV0dXJuIC0yNTU7XG4gIH1cbiAgaWYgKGEgIT09IE5vV29yayAmJiBiID09PSBOb1dvcmspIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBhIC0gYjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBmaXJzdDogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGxcbiAgfTtcbiAge1xuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVVcGRhdGUodXBkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHlMZXZlbDogdXBkYXRlLnByaW9yaXR5TGV2ZWwsXG4gICAgcGFydGlhbFN0YXRlOiB1cGRhdGUucGFydGlhbFN0YXRlLFxuICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgaXNSZXBsYWNlOiB1cGRhdGUuaXNSZXBsYWNlLFxuICAgIGlzRm9yY2VkOiB1cGRhdGUuaXNGb3JjZWQsXG4gICAgaXNUb3BMZXZlbFVubW91bnQ6IHVwZGF0ZS5pc1RvcExldmVsVW5tb3VudCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZSwgdXBkYXRlLCBpbnNlcnRBZnRlciwgaW5zZXJ0QmVmb3JlKSB7XG4gIGlmIChpbnNlcnRBZnRlciAhPT0gbnVsbCkge1xuICAgIGluc2VydEFmdGVyLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcXVldWUuXG4gICAgdXBkYXRlLm5leHQgPSBxdWV1ZS5maXJzdDtcbiAgICBxdWV1ZS5maXJzdCA9IHVwZGF0ZTtcbiAgfVxuXG4gIGlmIChpbnNlcnRCZWZvcmUgIT09IG51bGwpIHtcbiAgICB1cGRhdGUubmV4dCA9IGluc2VydEJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHF1ZXVlLlxuICAgIHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgdXBkYXRlIGFmdGVyIHdoaWNoIHRoZSBpbmNvbWluZyB1cGRhdGUgc2hvdWxkIGJlIGluc2VydGVkIGludG9cbi8vIHRoZSBxdWV1ZSwgb3IgbnVsbCBpZiBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQgYXQgYmVnaW5uaW5nLlxuZnVuY3Rpb24gZmluZEluc2VydGlvblBvc2l0aW9uKHF1ZXVlLCB1cGRhdGUpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSB1cGRhdGUucHJpb3JpdHlMZXZlbDtcbiAgdmFyIGluc2VydEFmdGVyID0gbnVsbDtcbiAgdmFyIGluc2VydEJlZm9yZSA9IG51bGw7XG4gIGlmIChxdWV1ZS5sYXN0ICE9PSBudWxsICYmIGNvbXBhcmVQcmlvcml0eShxdWV1ZS5sYXN0LnByaW9yaXR5TGV2ZWwsIHByaW9yaXR5TGV2ZWwpIDw9IDApIHtcbiAgICAvLyBGYXN0IHBhdGggZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSB0aGUgdXBkYXRlIHNob3VsZCBiZSBpbnNlcnRlZCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIHF1ZXVlLlxuICAgIGluc2VydEFmdGVyID0gcXVldWUubGFzdDtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRCZWZvcmUgPSBxdWV1ZS5maXJzdDtcbiAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlICE9PSBudWxsICYmIGNvbXBhcmVQcmlvcml0eShpbnNlcnRCZWZvcmUucHJpb3JpdHlMZXZlbCwgcHJpb3JpdHlMZXZlbCkgPD0gMCkge1xuICAgICAgaW5zZXJ0QWZ0ZXIgPSBpbnNlcnRCZWZvcmU7XG4gICAgICBpbnNlcnRCZWZvcmUgPSBpbnNlcnRCZWZvcmUubmV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluc2VydEFmdGVyO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVVcGRhdGVRdWV1ZXMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZUZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIHZhciBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgfVxuXG4gIF9xdWV1ZTEgPSBxdWV1ZTE7XG4gIC8vIFJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSBxdWV1ZSwgb3IgaWYgaXRzIHF1ZXVlIGlzIHRoZSBzYW1lLlxuICBfcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xufVxuXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhIHN1YnNldCBvZiB0aGUgY3VycmVudCBxdWV1ZSAoaWYgaXQgZXhpc3RzKS5cbi8vIFdlIG5lZWQgdG8gaW5zZXJ0IHRoZSBpbmNvbWluZyB1cGRhdGUgaW50byBib3RoIGxpc3RzLiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlXG4vLyB0aGF0IHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIG9uZSBsaXN0IHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHBvc2l0aW9uIGluXG4vLyB0aGUgb3RoZXIuIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgY2FzZTpcbi8vXG4vLyAgICAgQ3VycmVudDogICAgICAgICAgICAgMy01LTZcbi8vICAgICBXb3JrLWluLXByb2dyZXNzOiAgICAgICAgNlxuLy9cbi8vIFRoZW4gd2UgcmVjZWl2ZSBhbiB1cGRhdGUgd2l0aCBwcmlvcml0eSA0IGFuZCBpbnNlcnQgaXQgaW50byBlYWNoIGxpc3Q6XG4vL1xuLy8gICAgIEN1cnJlbnQ6ICAgICAgICAgICAgIDMtNC01LTZcbi8vICAgICBXb3JrLWluLXByb2dyZXNzOiAgICAgICAgNC02XG4vL1xuLy8gSW4gdGhlIGN1cnJlbnQgcXVldWUsIHRoZSBuZXcgdXBkYXRlJ3MgYG5leHRgIHBvaW50ZXIgcG9pbnRzIHRvIHRoZSB1cGRhdGVcbi8vIHdpdGggcHJpb3JpdHkgNS4gQnV0IGluIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCB0aGUgcG9pbnRlciBwb2ludHMgdG8gdGhlXG4vLyB1cGRhdGUgd2l0aCBwcmlvcml0eSA2LiBCZWNhdXNlIHRoZXNlIHR3byBxdWV1ZXMgc2hhcmUgdGhlIHNhbWUgcGVyc2lzdGVudFxuLy8gZGF0YSBzdHJ1Y3R1cmUsIHRoaXMgd29uJ3QgZG8uIChUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aGVuIHRoZSBpbmNvbWluZyB1cGRhdGVcbi8vIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBhbGwgdGhlIHVwZGF0ZXMgaW4gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUuKVxuLy9cbi8vIFRvIHNvbHZlIHRoaXMsIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBpbmNvbWluZyB1cGRhdGUgbmVlZHMgdG8gYmUgaW5zZXJ0ZWRcbi8vIGludG8gdHdvIGRpZmZlcmVudCBwb3NpdGlvbnMsIHdlJ2xsIG1ha2UgYSBjbG9uZSBvZiB0aGUgdXBkYXRlIGFuZCBpbnNlcnRcbi8vIGVhY2ggY29weSBpbnRvIGEgc2VwYXJhdGUgcXVldWUuIFRoaXMgZm9ya3MgdGhlIGxpc3Qgd2hpbGUgbWFpbnRhaW5pbmcgYVxuLy8gcGVyc2lzdGVudCBzdHJ1Y3R1cmUsIGJlY2F1c2UgdGhlIHVwZGF0ZSB0aGF0IGlzIGFkZGVkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzXG4vLyBpcyBhbHdheXMgYWRkZWQgdG8gdGhlIGZyb250IG9mIHRoZSBsaXN0LlxuLy9cbi8vIEhvd2V2ZXIsIGlmIGluY29taW5nIHVwZGF0ZSBpcyBpbnNlcnRlZCBpbnRvIHRoZSBzYW1lIHBvc2l0aW9uIG9mIGJvdGggbGlzdHMsXG4vLyB3ZSBzaG91bGRuJ3QgbWFrZSBhIGNvcHkuXG4vL1xuLy8gSWYgdGhlIHVwZGF0ZSBpcyBjbG9uZWQsIGl0IHJldHVybnMgdGhlIGNsb25lZCB1cGRhdGUuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGUoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBXZSdsbCBoYXZlIGF0IGxlYXN0IG9uZSBhbmQgYXQgbW9zdCB0d28gZGlzdGluY3QgdXBkYXRlIHF1ZXVlcy5cbiAgZW5zdXJlVXBkYXRlUXVldWVzKGZpYmVyKTtcbiAgdmFyIHF1ZXVlMSA9IF9xdWV1ZTE7XG4gIHZhciBxdWV1ZTIgPSBfcXVldWUyO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKHF1ZXVlMS5pc1Byb2Nlc3NpbmcgfHwgcXVldWUyICE9PSBudWxsICYmIHF1ZXVlMi5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgIHdhcm5pbmckMTkoZmFsc2UsICdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgaW5zZXJ0aW9uIHBvc2l0aW9uIGluIHRoZSBmaXJzdCBxdWV1ZS5cbiAgdmFyIGluc2VydEFmdGVyMSA9IGZpbmRJbnNlcnRpb25Qb3NpdGlvbihxdWV1ZTEsIHVwZGF0ZSk7XG4gIHZhciBpbnNlcnRCZWZvcmUxID0gaW5zZXJ0QWZ0ZXIxICE9PSBudWxsID8gaW5zZXJ0QWZ0ZXIxLm5leHQgOiBxdWV1ZTEuZmlyc3Q7XG5cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gYWx0ZXJuYXRlIHF1ZXVlLCB0aGVyZSdzIG5vdGhpbmcgZWxzZSB0byBkbyBidXQgaW5zZXJ0LlxuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSwgaW5zZXJ0QWZ0ZXIxLCBpbnNlcnRCZWZvcmUxKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGlzIGFuIGFsdGVybmF0ZSBxdWV1ZSwgZmluZCB0aGUgaW5zZXJ0aW9uIHBvc2l0aW9uLlxuICB2YXIgaW5zZXJ0QWZ0ZXIyID0gZmluZEluc2VydGlvblBvc2l0aW9uKHF1ZXVlMiwgdXBkYXRlKTtcbiAgdmFyIGluc2VydEJlZm9yZTIgPSBpbnNlcnRBZnRlcjIgIT09IG51bGwgPyBpbnNlcnRBZnRlcjIubmV4dCA6IHF1ZXVlMi5maXJzdDtcblxuICAvLyBOb3cgd2UgY2FuIGluc2VydCBpbnRvIHRoZSBmaXJzdCBxdWV1ZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXIgZmluZGluZyBib3RoXG4gIC8vIGluc2VydGlvbiBwb3NpdGlvbnMgYmVjYXVzZSBpdCBtdXRhdGVzIHRoZSBsaXN0LlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUsIGluc2VydEFmdGVyMSwgaW5zZXJ0QmVmb3JlMSk7XG5cbiAgLy8gU2VlIGlmIHRoZSBpbnNlcnRpb24gcG9zaXRpb25zIGFyZSBlcXVhbC4gQmUgY2FyZWZ1bCB0byBvbmx5IGNvbXBhcmVcbiAgLy8gbm9uLW51bGwgdmFsdWVzLlxuICBpZiAoaW5zZXJ0QmVmb3JlMSA9PT0gaW5zZXJ0QmVmb3JlMiAmJiBpbnNlcnRCZWZvcmUxICE9PSBudWxsIHx8IGluc2VydEFmdGVyMSA9PT0gaW5zZXJ0QWZ0ZXIyICYmIGluc2VydEFmdGVyMSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBpbnNlcnRpb24gcG9zaXRpb25zIGFyZSB0aGUgc2FtZSwgc28gd2hlbiB3ZSBpbnNlcnRlZCBpbnRvIHRoZSBmaXJzdFxuICAgIC8vIHF1ZXVlLCBpdCBhbHNvIGluc2VydGVkIGludG8gdGhlIGFsdGVybmF0ZS4gQWxsIHdlIG5lZWQgdG8gZG8gaXMgdXBkYXRlXG4gICAgLy8gdGhlIGFsdGVybmF0ZSBxdWV1ZSdzIGBmaXJzdGAgYW5kIGBsYXN0YCBwb2ludGVycywgaW4gY2FzZSB0aGV5XG4gICAgLy8gaGF2ZSBjaGFuZ2VkLlxuICAgIGlmIChpbnNlcnRBZnRlcjIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMi5maXJzdCA9IHVwZGF0ZTtcbiAgICB9XG4gICAgaWYgKGluc2VydEJlZm9yZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMi5sYXN0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIGluc2VydGlvbiBwb3NpdGlvbnMgYXJlIGRpZmZlcmVudCwgc28gd2UgbmVlZCB0byBjbG9uZSB0aGUgdXBkYXRlIGFuZFxuICAgIC8vIGluc2VydCB0aGUgY2xvbmUgaW50byB0aGUgYWx0ZXJuYXRlIHF1ZXVlLlxuICAgIHZhciB1cGRhdGUyID0gY2xvbmVVcGRhdGUodXBkYXRlKTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUyLCB1cGRhdGUyLCBpbnNlcnRBZnRlcjIsIGluc2VydEJlZm9yZTIpO1xuICAgIHJldHVybiB1cGRhdGUyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFVwZGF0ZShmaWJlciwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgcHJpb3JpdHlMZXZlbCkge1xuICB2YXIgdXBkYXRlID0ge1xuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgIGlzVG9wTGV2ZWxVbm1vdW50OiBmYWxzZSxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIGluc2VydFVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbn1cbnZhciBhZGRVcGRhdGVfMSA9IGFkZFVwZGF0ZTtcblxuZnVuY3Rpb24gYWRkUmVwbGFjZVVwZGF0ZShmaWJlciwgc3RhdGUsIGNhbGxiYWNrLCBwcmlvcml0eUxldmVsKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBpc1JlcGxhY2U6IHRydWUsXG4gICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgIGlzVG9wTGV2ZWxVbm1vdW50OiBmYWxzZSxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIGluc2VydFVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbn1cbnZhciBhZGRSZXBsYWNlVXBkYXRlXzEgPSBhZGRSZXBsYWNlVXBkYXRlO1xuXG5mdW5jdGlvbiBhZGRGb3JjZVVwZGF0ZShmaWJlciwgY2FsbGJhY2ssIHByaW9yaXR5TGV2ZWwpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICBpc1RvcExldmVsVW5tb3VudDogZmFsc2UsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpbnNlcnRVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG59XG52YXIgYWRkRm9yY2VVcGRhdGVfMSA9IGFkZEZvcmNlVXBkYXRlO1xuXG5mdW5jdGlvbiBnZXRVcGRhdGVQcmlvcml0eShmaWJlcikge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5vV29yaztcbiAgfVxuICBpZiAoZmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCQyICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QkMikge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlLmZpcnN0ICE9PSBudWxsID8gdXBkYXRlUXVldWUuZmlyc3QucHJpb3JpdHlMZXZlbCA6IE5vV29yaztcbn1cbnZhciBnZXRVcGRhdGVQcmlvcml0eV8xID0gZ2V0VXBkYXRlUHJpb3JpdHk7XG5cbmZ1bmN0aW9uIGFkZFRvcExldmVsVXBkYXRlJDEoZmliZXIsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIHByaW9yaXR5TGV2ZWwpIHtcbiAgdmFyIGlzVG9wTGV2ZWxVbm1vdW50ID0gcGFydGlhbFN0YXRlLmVsZW1lbnQgPT09IG51bGw7XG5cbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHBhcnRpYWxTdGF0ZTogcGFydGlhbFN0YXRlLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICBpc1RvcExldmVsVW5tb3VudDogaXNUb3BMZXZlbFVubW91bnQsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICB2YXIgdXBkYXRlMiA9IGluc2VydFVwZGF0ZShmaWJlciwgdXBkYXRlKTtcblxuICBpZiAoaXNUb3BMZXZlbFVubW91bnQpIHtcbiAgICAvLyBUT0RPOiBSZWRlc2lnbiB0aGUgdG9wLWxldmVsIG1vdW50L3VwZGF0ZS91bm1vdW50IEFQSSB0byBhdm9pZCB0aGlzXG4gICAgLy8gc3BlY2lhbCBjYXNlLlxuICAgIHZhciBxdWV1ZTEgPSBfcXVldWUxO1xuICAgIHZhciBxdWV1ZTIgPSBfcXVldWUyO1xuXG4gICAgLy8gRHJvcCBhbGwgdXBkYXRlcyB0aGF0IGFyZSBsb3dlci1wcmlvcml0eSwgc28gdGhhdCB0aGUgdHJlZSBpcyBub3RcbiAgICAvLyByZW1vdW50ZWQuIFdlIG5lZWQgdG8gZG8gdGhpcyBmb3IgYm90aCBxdWV1ZXMuXG4gICAgaWYgKHF1ZXVlMSAhPT0gbnVsbCAmJiB1cGRhdGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgcXVldWUxLmxhc3QgPSB1cGRhdGU7XG4gICAgfVxuICAgIGlmIChxdWV1ZTIgIT09IG51bGwgJiYgdXBkYXRlMiAhPT0gbnVsbCAmJiB1cGRhdGUyLm5leHQgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZTIubmV4dCA9IG51bGw7XG4gICAgICBxdWV1ZTIubGFzdCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cbnZhciBhZGRUb3BMZXZlbFVwZGF0ZV8xID0gYWRkVG9wTGV2ZWxVcGRhdGUkMTtcblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCBpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcywgcHJpb3JpdHlMZXZlbCkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnVwZGF0ZVF1ZXVlID09PSBxdWV1ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbiAgICB2YXIgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGZpcnN0OiBjdXJyZW50UXVldWUuZmlyc3QsXG4gICAgICBsYXN0OiBjdXJyZW50UXVldWUubGFzdCxcbiAgICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgY29tbWl0dGVkLlxuICAgICAgLy8gUmVzZXQgdGhlbS5cbiAgICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gU2V0IHRoaXMgZmxhZyBzbyB3ZSBjYW4gd2FybiBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgaW5zaWRlIHRoZSB1cGRhdGVcbiAgICAvLyBmdW5jdGlvbiBvZiBhbm90aGVyIHNldFN0YXRlLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlc2UgdXNpbmcgdGhlIHRoZSBleGlzdGluZyB2YWx1ZXMgYXMgYSBiYXNlLlxuICB2YXIgY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICB2YXIgaGFzRm9yY2VVcGRhdGUgPSBxdWV1ZS5oYXNGb3JjZVVwZGF0ZTtcblxuICAvLyBBcHBsaWVzIHVwZGF0ZXMgd2l0aCBtYXRjaGluZyBwcmlvcml0eSB0byB0aGUgcHJldmlvdXMgc3RhdGUgdG8gY3JlYXRlXG4gIC8vIGEgbmV3IHN0YXRlIG9iamVjdC5cbiAgdmFyIHN0YXRlID0gcHJldlN0YXRlO1xuICB2YXIgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdDtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCAmJiBjb21wYXJlUHJpb3JpdHkodXBkYXRlLnByaW9yaXR5TGV2ZWwsIHByaW9yaXR5TGV2ZWwpIDw9IDApIHtcbiAgICAvLyBSZW1vdmUgZWFjaCB1cGRhdGUgZnJvbSB0aGUgcXVldWUgcmlnaHQgYmVmb3JlIGl0IGlzIHByb2Nlc3NlZC4gVGhhdCB3YXlcbiAgICAvLyBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlciBmdW5jdGlvbiwgdGhlIG5ldyB1cGRhdGVcbiAgICAvLyB3aWxsIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgIHF1ZXVlLmZpcnN0ID0gdXBkYXRlLm5leHQ7XG4gICAgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBoYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIFNlY29uZCBjb25kaXRpb24gaWdub3JlcyB0b3AtbGV2ZWwgdW5tb3VudCBjYWxsYmFja3MgaWYgdGhleSBhcmUgbm90IHRoZVxuICAgIC8vIGxhc3QgdXBkYXRlIGluIHRoZSBxdWV1ZSwgc2luY2UgYSBzdWJzZXF1ZW50IHVwZGF0ZSB3aWxsIGNhdXNlIGEgcmVtb3VudC5cbiAgICBpZiAodXBkYXRlLmNhbGxiYWNrICE9PSBudWxsICYmICEodXBkYXRlLmlzVG9wTGV2ZWxVbm1vdW50ICYmIHVwZGF0ZS5uZXh0ICE9PSBudWxsKSkge1xuICAgICAgY2FsbGJhY2tMaXN0ID0gY2FsbGJhY2tMaXN0ICE9PSBudWxsID8gY2FsbGJhY2tMaXN0IDogW107XG4gICAgICBjYWxsYmFja0xpc3QucHVzaCh1cGRhdGUuY2FsbGJhY2spO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrRWZmZWN0O1xuICAgIH1cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIHF1ZXVlLmNhbGxiYWNrTGlzdCA9IGNhbGxiYWNrTGlzdDtcbiAgcXVldWUuaGFzRm9yY2VVcGRhdGUgPSBoYXNGb3JjZVVwZGF0ZTtcblxuICBpZiAocXVldWUuZmlyc3QgPT09IG51bGwgJiYgY2FsbGJhY2tMaXN0ID09PSBudWxsICYmICFoYXNGb3JjZVVwZGF0ZSkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGNhbGxiYWNrcy4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbnZhciBiZWdpblVwZGF0ZVF1ZXVlXzEgPSBiZWdpblVwZGF0ZVF1ZXVlO1xuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MoZmluaXNoZWRXb3JrLCBxdWV1ZSwgY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICBpZiAoY2FsbGJhY2tMaXN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfY2FsbGJhY2sgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgISh0eXBlb2YgX2NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjaykgOiB2b2lkIDA7XG4gICAgX2NhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gIH1cbn1cbnZhciBjb21taXRDYWxsYmFja3NfMSA9IGNvbW1pdENhbGxiYWNrcztcblxudmFyIFJlYWN0RmliZXJVcGRhdGVRdWV1ZSA9IHtcblx0YWRkVXBkYXRlOiBhZGRVcGRhdGVfMSxcblx0YWRkUmVwbGFjZVVwZGF0ZTogYWRkUmVwbGFjZVVwZGF0ZV8xLFxuXHRhZGRGb3JjZVVwZGF0ZTogYWRkRm9yY2VVcGRhdGVfMSxcblx0Z2V0VXBkYXRlUHJpb3JpdHk6IGdldFVwZGF0ZVByaW9yaXR5XzEsXG5cdGFkZFRvcExldmVsVXBkYXRlOiBhZGRUb3BMZXZlbFVwZGF0ZV8xLFxuXHRiZWdpblVwZGF0ZVF1ZXVlOiBiZWdpblVwZGF0ZVF1ZXVlXzEsXG5cdGNvbW1pdENhbGxiYWNrczogY29tbWl0Q2FsbGJhY2tzXzFcbn07XG5cbntcbiAgdmFyIHdhcm5pbmckMjEgPSByZXF1aXJlJCQwO1xufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG57XG4gIHZhciBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG52YXIgY3JlYXRlQ3Vyc29yJDEgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59O1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGluZGV4ID09PSAtMTtcbn07XG5cbnZhciBwb3AkMSA9IGZ1bmN0aW9uIChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nJDIxKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nJDIxKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59O1xuXG52YXIgcHVzaCQxID0gZnVuY3Rpb24gKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59O1xuXG52YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn07XG5cbnZhciBSZWFjdEZpYmVyU3RhY2sgPSB7XG5cdGNyZWF0ZUN1cnNvcjogY3JlYXRlQ3Vyc29yJDEsXG5cdGlzRW1wdHk6IGlzRW1wdHksXG5cdHBvcDogcG9wJDEsXG5cdHB1c2g6IHB1c2gkMSxcblx0cmVzZXQ6IHJlc2V0XG59O1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHRoaXMgd2l0aCBhIHRydWUgY2hlY2tcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVidWdGaWJlclBlcmZcbiAqIFxuICovXG5cbnZhciBSZWFjdERlYnVnRmliZXJQZXJmID0gbnVsbDtcblxue1xuICB2YXIgX3JlcXVpcmUkOCA9IFJlYWN0VHlwZU9mV29yayxcbiAgICAgIEhvc3RSb290JDQgPSBfcmVxdWlyZSQ4Lkhvc3RSb290LFxuICAgICAgSG9zdENvbXBvbmVudCQ0ID0gX3JlcXVpcmUkOC5Ib3N0Q29tcG9uZW50LFxuICAgICAgSG9zdFRleHQkMiA9IF9yZXF1aXJlJDguSG9zdFRleHQsXG4gICAgICBIb3N0UG9ydGFsJDEgPSBfcmVxdWlyZSQ4Lkhvc3RQb3J0YWwsXG4gICAgICBZaWVsZENvbXBvbmVudCA9IF9yZXF1aXJlJDguWWllbGRDb21wb25lbnQsXG4gICAgICBGcmFnbWVudCA9IF9yZXF1aXJlJDguRnJhZ21lbnQ7XG5cbiAgdmFyIGdldENvbXBvbmVudE5hbWUkNSA9IGdldENvbXBvbmVudE5hbWVfMTtcblxuICAvLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbiAgLy8gTG9uZ2VyIHByZWZpeGVzIGFyZSBoYXJkIHRvIHJlYWQgaW4gRGV2VG9vbHMuXG4gIHZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xuICB2YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xuICB2YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuICAvLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbiAgLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xuICB2YXIgY3VycmVudEZpYmVyID0gbnVsbDtcbiAgLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4gIC8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4gIC8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2VcbiAgLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG4gIHZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xuICB2YXIgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICAvLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbiAgLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuICAvLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgdmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gIHZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xuICB2YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gIHZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gIC8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuICAvLyB0byBhdm9pZCBzdHJldGNoIHRoZSBjb21taXQgcGhhc2Ugd2l0aCBtZWFzdXJlbWVudCBvdmVyaGVhZC5cbiAgdmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxuICB2YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgICByZXR1cm4gcmVhY3RFbW9qaSArICcgJyArIG1hcmtOYW1lO1xuICB9O1xuXG4gIHZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZykge1xuICAgIHZhciBwcmVmaXggPSB3YXJuaW5nID8gd2FybmluZ0Vtb2ppICsgJyAnIDogcmVhY3RFbW9qaSArICcgJztcbiAgICB2YXIgc3VmZml4ID0gd2FybmluZyA/ICcgV2FybmluZzogJyArIHdhcm5pbmcgOiAnJztcbiAgICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbiAgfTtcblxuICB2YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gICAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xuICB9O1xuXG4gIHZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG4gIH07XG5cbiAgdmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nKSB7XG4gICAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICAgIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsLCB3YXJuaW5nKTtcbiAgICB0cnkge1xuICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAgIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gICAgLy8gRG9uJ3QgcGlsZSBvbiB3aXRoIG1vcmUgZXJyb3JzLlxuXG4gICAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhmb3JtYXR0ZWRMYWJlbCk7XG4gIH07XG5cbiAgdmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgICByZXR1cm4gbGFiZWwgKyAnICgjJyArIGRlYnVnSUQgKyAnKSc7XG4gIH07XG5cbiAgdmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSQ1KGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICAgIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgICAvLyBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2UgZG9uJ3Qgc2hvdyBkdXBsaWNhdGUgbGFiZWxzIGJlY2F1c2VcbiAgICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gICAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gICAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lJDUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICAgIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gICAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgICBjbGVhck1hcmsobWFya05hbWUpO1xuICB9O1xuXG4gIHZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lJDUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICAgIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gICAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyk7XG4gIH07XG5cbiAgdmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgICAvLyBXZSBjb3VsZCBjaGVjayB0eXBlb2YgZmliZXIudHlwZSwgYnV0IGRvZXMgdGhpcyB3b3JrIHdpdGggUk4/XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3QkNDpcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ0OlxuICAgICAgY2FzZSBIb3N0VGV4dCQyOlxuICAgICAgY2FzZSBIb3N0UG9ydGFsJDE6XG4gICAgICBjYXNlIFlpZWxkQ29tcG9uZW50OlxuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdG9wcyBhbGwgY3VycmVudGx5IGFjdGl2ZSBtZWFzdXJlbWVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXN1bWVkXG4gICAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICAgIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgICB3aGlsZSAoZmliZXIpIHtcbiAgICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgICAgfVxuICAgICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGZpYmVyWydyZXR1cm4nXSk7XG4gICAgfVxuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVzdW1lVGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICAgIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGN1cnJlbnRGaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0RGVidWdGaWJlclBlcmYgPSB7XG4gICAgcmVjb3JkRWZmZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCsrO1xuICAgIH0sXG4gICAgcmVjb3JkU2NoZWR1bGVVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbE1vdW50JyAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJykge1xuICAgICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFydFdvcmtUaW1lcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gICAgfSxcbiAgICBjYW5jZWxXb3JrVGltZXI6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgICB9LFxuICAgIHN0b3BXb3JrVGltZXI6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gICAgfSxcbiAgICBzdG9wRmFpbGVkV29ya1RpbWVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgICB2YXIgd2FybmluZyA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyk7XG4gICAgfSxcbiAgICBzdGFydFBoYXNlVGltZXI6IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIHBoYXNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50UGhhc2VGaWJlciA9IGZpYmVyO1xuICAgICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gICAgfSxcbiAgICBzdG9wUGhhc2VUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmluZyA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgICAgZW5kRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UsIHdhcm5pbmcpO1xuICAgICAgfVxuICAgICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgICB9LFxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgICAvLyBUaGlzIGlzIHRvcCBsZXZlbCBjYWxsLlxuICAgICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgICByZXN1bWVUaW1lcnMoKTtcbiAgICB9LFxuICAgIHN0b3BXb3JrTG9vcFRpbWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgd2FybmluZyA9IGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxID8gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnIDogbnVsbDtcbiAgICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgICAgcGF1c2VUaW1lcnMoKTtcbiAgICAgIGVuZE1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCB3YXJuaW5nKTtcbiAgICB9LFxuICAgIHN0YXJ0Q29tbWl0VGltZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScpO1xuICAgIH0sXG4gICAgc3RvcENvbW1pdFRpbWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXJuaW5nID0gbnVsbDtcbiAgICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgICAgd2FybmluZyA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDApIHtcbiAgICAgICAgd2FybmluZyA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICAgIH1cbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcblxuICAgICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nKTtcbiAgICB9LFxuICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gICAgfSxcbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgICB9LFxuICAgIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICAgIH0sXG4gICAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3REZWJ1Z0ZpYmVyUGVyZl8xID0gUmVhY3REZWJ1Z0ZpYmVyUGVyZjtcblxudmFyIGlzRmliZXJNb3VudGVkJDEgPSBSZWFjdEZpYmVyVHJlZVJlZmxlY3Rpb24uaXNGaWJlck1vdW50ZWQ7XG5cbnZhciBDbGFzc0NvbXBvbmVudCQzID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50O1xudmFyIEhvc3RSb290JDMgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3Q7XG5cbnZhciBjcmVhdGVDdXJzb3IgPSBSZWFjdEZpYmVyU3RhY2suY3JlYXRlQ3Vyc29yO1xudmFyIHBvcCA9IFJlYWN0RmliZXJTdGFjay5wb3A7XG52YXIgcHVzaCA9IFJlYWN0RmliZXJTdGFjay5wdXNoO1xuXG57XG4gIHZhciB3YXJuaW5nJDIwID0gcmVxdWlyZSQkMDtcbiAgdmFyIGNoZWNrUHJvcFR5cGVzJDEgPSBjaGVja1Byb3BUeXBlcztcbiAgdmFyIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXJfMTtcblxuICB2YXIgX3JlcXVpcmU0ID0gUmVhY3REZWJ1Z0ZpYmVyUGVyZl8xLFxuICAgICAgc3RhcnRQaGFzZVRpbWVyID0gX3JlcXVpcmU0LnN0YXJ0UGhhc2VUaW1lcixcbiAgICAgIHN0b3BQaGFzZVRpbWVyID0gX3JlcXVpcmU0LnN0b3BQaGFzZVRpbWVyO1xuXG4gIHZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBoYXNPd25Db250ZXh0ID0gaXNDb250ZXh0UHJvdmlkZXIkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gIGlmIChoYXNPd25Db250ZXh0KSB7XG4gICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG52YXIgZ2V0VW5tYXNrZWRDb250ZXh0XzEgPSBnZXRVbm1hc2tlZENvbnRleHQ7XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQgPSBtYXNrZWRDb250ZXh0O1xufVxudmFyIGNhY2hlQ29udGV4dF8xID0gY2FjaGVDb250ZXh0O1xuXG52YXIgZ2V0TWFza2VkQ29udGV4dCA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVfMSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMi5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIGNoZWNrUHJvcFR5cGVzJDEoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMi5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxudmFyIGhhc0NvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xufTtcblxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQkMyAmJiBmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsO1xufVxudmFyIGlzQ29udGV4dENvbnN1bWVyXzEgPSBpc0NvbnRleHRDb25zdW1lcjtcblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIkMShmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCQzICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cbnZhciBpc0NvbnRleHRQcm92aWRlcl8xID0gaXNDb250ZXh0UHJvdmlkZXIkMTtcblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIkMShmaWJlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG52YXIgcG9wQ29udGV4dFByb3ZpZGVyXzEgPSBwb3BDb250ZXh0UHJvdmlkZXI7XG5cbnZhciBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufTtcblxudmFyIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QgPSBmdW5jdGlvbiAoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQkMShmaWJlciwgcGFyZW50Q29udGV4dCwgaXNSZWNvbmNpbGluZykge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZV8xKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmckMjAoZmFsc2UsICclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMi5zZXRDdXJyZW50RmliZXIoZmliZXIsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgICBzdGFydFBoYXNlVGltZXIoZmliZXIsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMi5yZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWVfMShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lXzEoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICAvLyBXZSBjYW4gb25seSBwcm92aWRlIGFjY3VyYXRlIGVsZW1lbnQgc3RhY2tzIGlmIHdlIHBhc3Mgd29yay1pbi1wcm9ncmVzcyB0cmVlXG4gICAgLy8gZHVyaW5nIHRoZSBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gSG93ZXZlciBjdXJyZW50bHkgdGhpcyBmdW5jdGlvbiBpcyBhbHNvXG4gICAgLy8gY2FsbGVkIGZyb20gdW5zdGFibGVfcmVuZGVyU3VidHJlZSBsZWdhY3kgaW1wbGVtZW50YXRpb24uIEluIHRoaXMgY2FzZSBpdCB1bnNhZmUgdG9cbiAgICAvLyBhc3N1bWUgYW55dGhpbmcgYWJvdXQgdGhlIGdpdmVuIGZpYmVyLiBXZSB3b24ndCBwYXNzIGl0IGRvd24gaWYgd2UgYXJlbid0IHN1cmUuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgaGFjayB3aGVuIHdlIGRlbGV0ZSB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlIGluIEZpYmVyLlxuICAgIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGlzUmVjb25jaWxpbmcgPyBmaWJlciA6IG51bGw7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciQyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgY2hlY2tQcm9wVHlwZXMkMShjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMi5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxudmFyIHByb2Nlc3NDaGlsZENvbnRleHRfMSA9IHByb2Nlc3NDaGlsZENvbnRleHQkMTtcblxudmFyIHB1c2hDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlciQxKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRhbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgIWluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQkMSh3b3JrSW5Qcm9ncmVzcywgcHJldmlvdXNDb250ZXh0LCB0cnVlKTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59O1xuXG52YXIgcmVzZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59O1xuXG52YXIgZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQkMSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG4gICEoaXNGaWJlck1vdW50ZWQkMShmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCQzKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCQzKSB7XG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyJDEobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbnRleHQgPSB7XG5cdGdldFVubWFza2VkQ29udGV4dDogZ2V0VW5tYXNrZWRDb250ZXh0XzEsXG5cdGNhY2hlQ29udGV4dDogY2FjaGVDb250ZXh0XzEsXG5cdGdldE1hc2tlZENvbnRleHQ6IGdldE1hc2tlZENvbnRleHQsXG5cdGhhc0NvbnRleHRDaGFuZ2VkOiBoYXNDb250ZXh0Q2hhbmdlZCxcblx0aXNDb250ZXh0Q29uc3VtZXI6IGlzQ29udGV4dENvbnN1bWVyXzEsXG5cdGlzQ29udGV4dFByb3ZpZGVyOiBpc0NvbnRleHRQcm92aWRlcl8xLFxuXHRwb3BDb250ZXh0UHJvdmlkZXI6IHBvcENvbnRleHRQcm92aWRlcl8xLFxuXHRwb3BUb3BMZXZlbENvbnRleHRPYmplY3Q6IHBvcFRvcExldmVsQ29udGV4dE9iamVjdCxcblx0cHVzaFRvcExldmVsQ29udGV4dE9iamVjdDogcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCxcblx0cHJvY2Vzc0NoaWxkQ29udGV4dDogcHJvY2Vzc0NoaWxkQ29udGV4dF8xLFxuXHRwdXNoQ29udGV4dFByb3ZpZGVyOiBwdXNoQ29udGV4dFByb3ZpZGVyLFxuXHRpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyOiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyLFxuXHRyZXNldENvbnRleHQ6IHJlc2V0Q29udGV4dCxcblx0ZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQ6IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0JDFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHlwZU9mSW50ZXJuYWxDb250ZXh0XG4gKiBcbiAqL1xuXG52YXIgUmVhY3RUeXBlT2ZJbnRlcm5hbENvbnRleHQgPSB7XG4gIE5vQ29udGV4dDogMCxcbiAgQXN5bmNVcGRhdGVzOiAxXG59O1xuXG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCQxID0gUmVhY3RUeXBlT2ZXb3JrLkluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG52YXIgQ2xhc3NDb21wb25lbnQkNCA9IFJlYWN0VHlwZU9mV29yay5DbGFzc0NvbXBvbmVudDtcbnZhciBIb3N0Um9vdCQ1ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RSb290O1xudmFyIEhvc3RDb21wb25lbnQkNSA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Q29tcG9uZW50O1xudmFyIEhvc3RUZXh0JDMgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFRleHQ7XG52YXIgSG9zdFBvcnRhbCQyID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RQb3J0YWw7XG52YXIgQ29yb3V0aW5lQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkNvcm91dGluZUNvbXBvbmVudDtcbnZhciBZaWVsZENvbXBvbmVudCQxID0gUmVhY3RUeXBlT2ZXb3JrLllpZWxkQ29tcG9uZW50O1xudmFyIEZyYWdtZW50JDEgPSBSZWFjdFR5cGVPZldvcmsuRnJhZ21lbnQ7XG5cbnZhciBOb1dvcmskMSA9IFJlYWN0UHJpb3JpdHlMZXZlbC5Ob1dvcms7XG5cbnZhciBOb0NvbnRleHQgPSBSZWFjdFR5cGVPZkludGVybmFsQ29udGV4dC5Ob0NvbnRleHQ7XG5cbnZhciBOb0VmZmVjdCQxID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0Lk5vRWZmZWN0O1xuXG5cblxue1xuICB2YXIgZ2V0Q29tcG9uZW50TmFtZSQ2ID0gZ2V0Q29tcG9uZW50TmFtZV8xO1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cblxue1xuICB2YXIgZGVidWdDb3VudGVyID0gMTtcbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgLy8gRmliZXJcbiAgdGhpc1sncmV0dXJuJ10gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy5yZWYgPSBudWxsO1xuXG4gIHRoaXMucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cbiAgdGhpcy5pbnRlcm5hbENvbnRleHRUYWcgPSBpbnRlcm5hbENvbnRleHRUYWc7XG5cbiAgLy8gRWZmZWN0c1xuICB0aGlzLmVmZmVjdFRhZyA9IE5vRWZmZWN0JDE7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nV29ya1ByaW9yaXR5ID0gTm9Xb3JrJDE7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG52YXIgY3JlYXRlRmliZXIgPSBmdW5jdGlvbiAodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG52YXIgY3JlYXRlV29ya0luUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoY3VycmVudCwgcmVuZGVyUHJpb3JpdHkpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3QkMTtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1dvcmtQcmlvcml0eSA9IHJlbmRlclByaW9yaXR5O1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIHBlbmRpbmdQcm9wcyBpcyBzZXQgYnkgdGhlIHBhcmVudCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gIC8vIFRPRE86IFBhc3MgdGhpcyBhcyBhbiBhcmd1bWVudC5cblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn07XG5cbnZhciBjcmVhdGVIb3N0Um9vdEZpYmVyJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RSb290JDUsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn07XG5cbnZhciBjcmVhdGVGaWJlckZyb21FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHlMZXZlbCkge1xuICB2YXIgb3duZXIgPSBudWxsO1xuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnRUeXBlKGVsZW1lbnQudHlwZSwgZWxlbWVudC5rZXksIGludGVybmFsQ29udGV4dFRhZywgb3duZXIpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICBmaWJlci5wZW5kaW5nV29ya1ByaW9yaXR5ID0gcHJpb3JpdHlMZXZlbDtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59O1xuXG52YXIgY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHlMZXZlbCkge1xuICAvLyBUT0RPOiBDb25zaWRlciBzdXBwb3J0aW5nIGtleWVkIGZyYWdtZW50cy4gVGVjaG5pY2FsbHksIHdlIGFjY2lkZW50YWxseVxuICAvLyBzdXBwb3J0IHRoYXQgaW4gdGhlIGV4aXN0aW5nIFJlYWN0LlxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCQxLCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIucGVuZGluZ1dvcmtQcmlvcml0eSA9IHByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmaWJlcjtcbn07XG5cbnZhciBjcmVhdGVGaWJlckZyb21UZXh0ID0gZnVuY3Rpb24gKGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHlMZXZlbCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCQzLCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5wZW5kaW5nV29ya1ByaW9yaXR5ID0gcHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZpYmVyO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudFR5cGUodHlwZSwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcsIGRlYnVnT3duZXIpIHtcbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWJlciA9IHNob3VsZENvbnN0cnVjdCh0eXBlKSA/IGNyZWF0ZUZpYmVyKENsYXNzQ29tcG9uZW50JDQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQkMSwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCQ1LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAge1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbi5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBvd25lck5hbWUgPSBkZWJ1Z093bmVyID8gZ2V0Q29tcG9uZW50TmFtZSQ2KGRlYnVnT3duZXIpIDogbnVsbDtcbiAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gZmliZXI7XG59XG5cbnZhciBjcmVhdGVGaWJlckZyb21FbGVtZW50VHlwZV8xID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudFR5cGU7XG5cbnZhciBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCQ1LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59O1xuXG52YXIgY3JlYXRlRmliZXJGcm9tQ29yb3V0aW5lID0gZnVuY3Rpb24gKGNvcm91dGluZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBwcmlvcml0eUxldmVsKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENvcm91dGluZUNvbXBvbmVudCwgY29yb3V0aW5lLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNvcm91dGluZS5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3JvdXRpbmU7XG4gIGZpYmVyLnBlbmRpbmdXb3JrUHJpb3JpdHkgPSBwcmlvcml0eUxldmVsO1xuICByZXR1cm4gZmliZXI7XG59O1xuXG52YXIgY3JlYXRlRmliZXJGcm9tWWllbGQgPSBmdW5jdGlvbiAoeWllbGROb2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5TGV2ZWwpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoWWllbGRDb21wb25lbnQkMSwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgcmV0dXJuIGZpYmVyO1xufTtcblxudmFyIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwsIGludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHlMZXZlbCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsJDIsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIucGVuZGluZ1dvcmtQcmlvcml0eSA9IHByaW9yaXR5TGV2ZWw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn07XG5cbnZhciBsYXJnZXJQcmlvcml0eSA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgcmV0dXJuIHAxICE9PSBOb1dvcmskMSAmJiAocDIgPT09IE5vV29yayQxIHx8IHAyID4gcDEpID8gcDEgOiBwMjtcbn07XG5cbnZhciBSZWFjdEZpYmVyID0ge1xuXHRjcmVhdGVXb3JrSW5Qcm9ncmVzczogY3JlYXRlV29ya0luUHJvZ3Jlc3MsXG5cdGNyZWF0ZUhvc3RSb290RmliZXI6IGNyZWF0ZUhvc3RSb290RmliZXIkMSxcblx0Y3JlYXRlRmliZXJGcm9tRWxlbWVudDogY3JlYXRlRmliZXJGcm9tRWxlbWVudCxcblx0Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQ6IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50LFxuXHRjcmVhdGVGaWJlckZyb21UZXh0OiBjcmVhdGVGaWJlckZyb21UZXh0LFxuXHRjcmVhdGVGaWJlckZyb21FbGVtZW50VHlwZTogY3JlYXRlRmliZXJGcm9tRWxlbWVudFR5cGVfMSxcblx0Y3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb246IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uLFxuXHRjcmVhdGVGaWJlckZyb21Db3JvdXRpbmU6IGNyZWF0ZUZpYmVyRnJvbUNvcm91dGluZSxcblx0Y3JlYXRlRmliZXJGcm9tWWllbGQ6IGNyZWF0ZUZpYmVyRnJvbVlpZWxkLFxuXHRjcmVhdGVGaWJlckZyb21Qb3J0YWw6IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbCxcblx0bGFyZ2VyUHJpb3JpdHk6IGxhcmdlclByaW9yaXR5XG59O1xuXG52YXIgY3JlYXRlSG9zdFJvb3RGaWJlciA9IFJlYWN0RmliZXIuY3JlYXRlSG9zdFJvb3RGaWJlcjtcblxudmFyIGNyZWF0ZUZpYmVyUm9vdCQxID0gZnVuY3Rpb24gKGNvbnRhaW5lckluZm8pIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGlzU2NoZWR1bGVkOiBmYWxzZSxcbiAgICBuZXh0U2NoZWR1bGVkUm9vdDogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn07XG5cbnZhciBSZWFjdEZpYmVyUm9vdCA9IHtcblx0Y3JlYXRlRmliZXJSb290OiBjcmVhdGVGaWJlclJvb3QkMVxufTtcblxudmFyIGRlZmF1bHRTaG93RGlhbG9nID0gZnVuY3Rpb24gKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2hvd0RpYWxvZyA9IGRlZmF1bHRTaG93RGlhbG9nO1xuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yJDEoY2FwdHVyZWRFcnJvcikge1xuICB2YXIgbG9nRXJyb3IgPSBzaG93RGlhbG9nKGNhcHR1cmVkRXJyb3IpO1xuXG4gIC8vIEFsbG93IGluamVjdGVkIHNob3dEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG4gIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnWW91IGNhbiBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMgYXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzLic7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSAnJyArIGNvbXBvbmVudE5hbWVNZXNzYWdlICsgY29tcG9uZW50U3RhY2sgKyAnXFxuXFxuJyArICgnJyArIGVycm9yQm91bmRhcnlNZXNzYWdlKTtcblxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuICAgIGNvbnNvbGUuZXJyb3IoY29tYmluZWRNZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgaW5qZWN0aW9uJDEgPSB7XG4gIC8qKlxuICAgKiBEaXNwbGF5IGN1c3RvbSBkaWFsb2cgZm9yIGxpZmVjeWNsZSBlcnJvcnMuXG4gICAqIFJldHVybiBmYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgbG9nZ2luZyB0byBjb25zb2xlLmVycm9yLlxuICAgKi9cbiAgaW5qZWN0RGlhbG9nOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAhKHNob3dEaWFsb2cgPT09IGRlZmF1bHRTaG93RGlhbG9nKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBjdXN0b20gZGlhbG9nIHdhcyBhbHJlYWR5IGluamVjdGVkLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0luamVjdGVkIHNob3dEaWFsb2coKSBtdXN0IGJlIGEgZnVuY3Rpb24uJykgOiB2b2lkIDA7XG4gICAgc2hvd0RpYWxvZyA9IGZuO1xuICB9XG59O1xuXG52YXIgbG9nQ2FwdHVyZWRFcnJvcl8xID0gbG9nQ2FwdHVyZWRFcnJvciQxO1xuXG52YXIgUmVhY3RGaWJlckVycm9yTG9nZ2VyID0ge1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQxLFxuXHRsb2dDYXB0dXJlZEVycm9yOiBsb2dDYXB0dXJlZEVycm9yXzFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29yb3V0aW5lXG4gKiBcbiAqL1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBzcGVjaWFsIFJlYWN0IHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfQ09ST1VUSU5FX1RZUEUkMTtcbnZhciBSRUFDVF9ZSUVMRF9UWVBFJDE7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddKSB7XG4gIFJFQUNUX0NPUk9VVElORV9UWVBFJDEgPSBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jb3JvdXRpbmUnKTtcbiAgUkVBQ1RfWUlFTERfVFlQRSQxID0gU3ltYm9sWydmb3InXSgncmVhY3QueWllbGQnKTtcbn0gZWxzZSB7XG4gIFJFQUNUX0NPUk9VVElORV9UWVBFJDEgPSAweGVhYzg7XG4gIFJFQUNUX1lJRUxEX1RZUEUkMSA9IDB4ZWFjOTtcbn1cblxudmFyIGNyZWF0ZUNvcm91dGluZSA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgaGFuZGxlciwgcHJvcHMpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29yb3V0aW5lID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBDb3JvdXRpbmVcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09ST1VUSU5FX1RZUEUkMSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIHByb3BzOiBwcm9wc1xuICB9O1xuXG4gIHtcbiAgICAvLyBUT0RPOiBBZGQgX3N0b3JlIHByb3BlcnR5IGZvciBtYXJraW5nIHRoaXMgYXMgdmFsaWRhdGVkLlxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGNvcm91dGluZS5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGNvcm91dGluZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcm91dGluZTtcbn07XG5cbnZhciBjcmVhdGVZaWVsZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgeWllbGROb2RlID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBZaWVsZFxuICAgICQkdHlwZW9mOiBSRUFDVF9ZSUVMRF9UWVBFJDEsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG5cbiAge1xuICAgIC8vIFRPRE86IEFkZCBfc3RvcmUgcHJvcGVydHkgZm9yIG1hcmtpbmcgdGhpcyBhcyB2YWxpZGF0ZWQuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoeWllbGROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geWllbGROb2RlO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgY29yb3V0aW5lIG9iamVjdC5cbiAqL1xudmFyIGlzQ29yb3V0aW5lID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09ST1VUSU5FX1RZUEUkMTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIHlpZWxkIG9iamVjdC5cbiAqL1xudmFyIGlzWWllbGQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9ZSUVMRF9UWVBFJDE7XG59O1xuXG52YXIgUkVBQ1RfWUlFTERfVFlQRV8xID0gUkVBQ1RfWUlFTERfVFlQRSQxO1xudmFyIFJFQUNUX0NPUk9VVElORV9UWVBFXzEgPSBSRUFDVF9DT1JPVVRJTkVfVFlQRSQxO1xuXG52YXIgUmVhY3RDb3JvdXRpbmUgPSB7XG5cdGNyZWF0ZUNvcm91dGluZTogY3JlYXRlQ29yb3V0aW5lLFxuXHRjcmVhdGVZaWVsZDogY3JlYXRlWWllbGQsXG5cdGlzQ29yb3V0aW5lOiBpc0Nvcm91dGluZSxcblx0aXNZaWVsZDogaXNZaWVsZCxcblx0UkVBQ1RfWUlFTERfVFlQRTogUkVBQ1RfWUlFTERfVFlQRV8xLFxuXHRSRUFDVF9DT1JPVVRJTkVfVFlQRTogUkVBQ1RfQ09ST1VUSU5FX1RZUEVfMVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQb3J0YWxcbiAqIFxuICovXG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIHNwZWNpYWwgUmVhY3QgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9QT1JUQUxfVFlQRSQxID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIHx8IDB4ZWFjYTtcblxudmFyIGNyZWF0ZVBvcnRhbCQxID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLFxuLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFJDEsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIHBvcnRhbCBvYmplY3QuXG4gKi9cbnZhciBpc1BvcnRhbCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX1BPUlRBTF9UWVBFJDE7XG59O1xuXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEVfMSA9IFJFQUNUX1BPUlRBTF9UWVBFJDE7XG5cbnZhciBSZWFjdFBvcnRhbCA9IHtcblx0Y3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwkMSxcblx0aXNQb3J0YWw6IGlzUG9ydGFsLFxuXHRSRUFDVF9QT1JUQUxfVFlQRTogUkVBQ1RfUE9SVEFMX1RZUEVfMVxufTtcblxudmFyIFJFQUNUX0NPUk9VVElORV9UWVBFID0gUmVhY3RDb3JvdXRpbmUuUkVBQ1RfQ09ST1VUSU5FX1RZUEU7XG52YXIgUkVBQ1RfWUlFTERfVFlQRSA9IFJlYWN0Q29yb3V0aW5lLlJFQUNUX1lJRUxEX1RZUEU7XG5cbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFJlYWN0UG9ydGFsLlJFQUNUX1BPUlRBTF9UWVBFO1xuXG5cblxuXG5cblxuXG5cbntcbiAgdmFyIF9yZXF1aXJlMyQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcl8xLFxuICAgICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1ID0gX3JlcXVpcmUzJDQuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuICB2YXIgd2FybmluZyQyNCA9IHJlcXVpcmUkJDA7XG4gIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cbiAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG4gIHZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSgpIHx8ICcnKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nJDI0KGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUoKSk7XG4gIH07XG59XG5cbnZhciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyQyID0gUmVhY3RGaWJlci5jcmVhdGVXb3JrSW5Qcm9ncmVzcztcbnZhciBjcmVhdGVGaWJlckZyb21FbGVtZW50JDEgPSBSZWFjdEZpYmVyLmNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQ7XG52YXIgY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQkMSA9IFJlYWN0RmliZXIuY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQ7XG52YXIgY3JlYXRlRmliZXJGcm9tVGV4dCQxID0gUmVhY3RGaWJlci5jcmVhdGVGaWJlckZyb21UZXh0O1xudmFyIGNyZWF0ZUZpYmVyRnJvbUNvcm91dGluZSQxID0gUmVhY3RGaWJlci5jcmVhdGVGaWJlckZyb21Db3JvdXRpbmU7XG52YXIgY3JlYXRlRmliZXJGcm9tWWllbGQkMSA9IFJlYWN0RmliZXIuY3JlYXRlRmliZXJGcm9tWWllbGQ7XG52YXIgY3JlYXRlRmliZXJGcm9tUG9ydGFsJDEgPSBSZWFjdEZpYmVyLmNyZWF0ZUZpYmVyRnJvbVBvcnRhbDtcblxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50JDIgPSBSZWFjdFR5cGVPZldvcmsuRnVuY3Rpb25hbENvbXBvbmVudDtcbnZhciBDbGFzc0NvbXBvbmVudCQ3ID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50O1xudmFyIEhvc3RUZXh0JDUgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFRleHQ7XG52YXIgSG9zdFBvcnRhbCQ1ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RQb3J0YWw7XG52YXIgQ29yb3V0aW5lQ29tcG9uZW50JDIgPSBSZWFjdFR5cGVPZldvcmsuQ29yb3V0aW5lQ29tcG9uZW50O1xudmFyIFlpZWxkQ29tcG9uZW50JDMgPSBSZWFjdFR5cGVPZldvcmsuWWllbGRDb21wb25lbnQ7XG52YXIgRnJhZ21lbnQkMyA9IFJlYWN0VHlwZU9mV29yay5GcmFnbWVudDtcbnZhciBOb0VmZmVjdCQyID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0Lk5vRWZmZWN0O1xudmFyIFBsYWNlbWVudCQzID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlBsYWNlbWVudDtcbnZhciBEZWxldGlvbiQxID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LkRlbGV0aW9uO1xuXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpdGVyYXRvckZuID0gSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3duZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQkNykgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdGFja1xuICAgICAgICAgIGluc3QgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFlvdSBtYXkgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkLiAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHdhcm5pbmckMjQoZmFsc2UsICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSgpIHx8ICcnKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRDbG9uZSwgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG91bGRDbG9uZSkge1xuICAgICAgLy8gV2hlbiB3ZSdyZSByZWNvbmNpbGluZyBpbiBwbGFjZSB3ZSBoYXZlIGEgd29yayBpbiBwcm9ncmVzcyBjb3B5LiBXZVxuICAgICAgLy8gYWN0dWFsbHkgd2FudCB0aGUgY3VycmVudCBjb3B5LiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IGNvcHksIHRoZW4gd2VcbiAgICAgIC8vIGRvbid0IG5lZWQgdG8gdHJhY2sgZGVsZXRpb24gc2lkZS1lZmZlY3RzLlxuICAgICAgaWYgKGNoaWxkVG9EZWxldGUuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLmFsdGVybmF0ZTtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uJDE7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHByaW9yaXR5KSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIGlmIChzaG91bGRDbG9uZSkge1xuICAgICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MkMihmaWJlciwgcHJpb3JpdHkpO1xuICAgICAgY2xvbmUuaW5kZXggPSAwO1xuICAgICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIG92ZXJyaWRlIHRoZSBwZW5kaW5nIHByaW9yaXR5IGV2ZW4gaWYgaXQgaXMgaGlnaGVyLCBiZWNhdXNlIGlmXG4gICAgICAvLyB3ZSdyZSByZWNvbmNpbGluZyBhdCBhIGxvd2VyIHByaW9yaXR5IHRoYXQgbWVhbnMgdGhhdCB0aGlzIHdhc1xuICAgICAgLy8gZG93bi1wcmlvcml0aXplZC5cbiAgICAgIGZpYmVyLnBlbmRpbmdXb3JrUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgIGZpYmVyLmVmZmVjdFRhZyA9IE5vRWZmZWN0JDI7XG4gICAgICBmaWJlci5pbmRleCA9IDA7XG4gICAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICAgIHJldHVybiBmaWJlcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50JDM7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQkMztcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudCQzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIHByaW9yaXR5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0JDUpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0JDEodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHByaW9yaXR5KTtcbiAgICAgIGV4aXN0aW5nLnBlbmRpbmdQcm9wcyA9IHRleHRDb250ZW50O1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgcHJpb3JpdHkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnR5cGUgIT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQkMShlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwcmlvcml0eSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZy5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb3JvdXRpbmUocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNvcm91dGluZSwgcHJpb3JpdHkpIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBhbHNvIGNvbXBhcmUgaGFuZGxlciB0byBkZXRlcm1pbmUgd2hldGhlciB0byByZXVzZT9cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gQ29yb3V0aW5lQ29tcG9uZW50JDIpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Db3JvdXRpbmUkMShjb3JvdXRpbmUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwcmlvcml0eSk7XG4gICAgICBleGlzdGluZy5wZW5kaW5nUHJvcHMgPSBjb3JvdXRpbmU7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVZaWVsZChyZXR1cm5GaWJlciwgY3VycmVudCwgeWllbGROb2RlLCBwcmlvcml0eSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBZaWVsZENvbXBvbmVudCQzKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tWWllbGQkMSh5aWVsZE5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHkpO1xuICAgICAgY3JlYXRlZC50eXBlID0geWllbGROb2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwcmlvcml0eSk7XG4gICAgICBleGlzdGluZy50eXBlID0geWllbGROb2RlLnZhbHVlO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIHByaW9yaXR5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwkNSB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsJDEocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwcmlvcml0eSk7XG4gICAgICBleGlzdGluZy5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIHByaW9yaXR5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50JDMpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudCQxKGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwcmlvcml0eSk7XG4gICAgICBleGlzdGluZy5wZW5kaW5nUHJvcHMgPSBmcmFnbWVudDtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgcHJpb3JpdHkpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvZXNuJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCQxKCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQkMShuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBwcmlvcml0eSk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYobnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ09ST1VUSU5FX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUNvcm91dGluZSQxKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIF9jcmVhdGVkMlsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfWUlFTERfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tWWllbGQkMShuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBwcmlvcml0eSk7XG4gICAgICAgICAgICBfY3JlYXRlZDMudHlwZSA9IG5ld0NoaWxkLnZhbHVlO1xuICAgICAgICAgICAgX2NyZWF0ZWQzWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsJDEobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHkpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQ1ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQkMShuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBwcmlvcml0eSk7XG4gICAgICAgIF9jcmVhdGVkNVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkNTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgcHJpb3JpdHkpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb2Vzbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgcHJpb3JpdHkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBwcmlvcml0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DT1JPVVRJTkVfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNvcm91dGluZShyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBwcmlvcml0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9ZSUVMRF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFlpZWxkcyBkb2Vzbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhXG4gICAgICAgICAgICAvLyB5aWVsZC5cbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVlpZWxkKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIC8vIEZyYWdtZW50cyBkb2Vzbid0IGhhdmUga2V5cyBzbyBpZiB0aGUgcHJldmlvdXMga2V5IGlzIGltcGxpY2l0IHdlIGNhblxuICAgICAgICAvLyB1cGRhdGUgaXQuXG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgcHJpb3JpdHkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgcHJpb3JpdHkpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvZXNuJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBwcmlvcml0eSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIHByaW9yaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DT1JPVVRJTkVfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQ29yb3V0aW5lKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIHByaW9yaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9ZSUVMRF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFlpZWxkcyBkb2Vzbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgeWllbGRzLCB0aGV5IG1hdGNoLlxuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVlpZWxkKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIHByaW9yaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjQgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyNCwgbmV3Q2hpbGQsIHByaW9yaXR5KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjUgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjUsIG5ld0NoaWxkLCBwcmlvcml0eSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0NPUk9VVElORV9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmckMjQoZmFsc2UsICdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiVzJywga2V5LCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIHByaW9yaXR5KSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aHMgZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cblxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cblxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIHByaW9yaXR5KTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIHByaW9yaXR5KTtcbiAgICAgICAgaWYgKCFfbmV3RmliZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgcHJpb3JpdHkpO1xuICAgICAgaWYgKF9uZXdGaWJlcjIpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIHByaW9yaXR5KSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHtcbiAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBvc3NpYmxlTWFwID0gbmV3Q2hpbGRyZW5JdGVyYWJsZTtcbiAgICAgICAgaWYgKHBvc3NpYmxlTWFwLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB3YXJuaW5nJDI0KGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgcHJpb3JpdHkpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIHByaW9yaXR5KTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBwcmlvcml0eSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBwcmlvcml0eSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCQ1KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCBwcmlvcml0eSk7XG4gICAgICBleGlzdGluZy5wZW5kaW5nUHJvcHMgPSB0ZXh0Q29udGVudDtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQkMSh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBwcmlvcml0eSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBwcmlvcml0eSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwcmlvcml0eSk7XG4gICAgICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICBleGlzdGluZy5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudCQxKGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgcHJpb3JpdHkpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlQ29yb3V0aW5lKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY29yb3V0aW5lLCBwcmlvcml0eSkge1xuICAgIHZhciBrZXkgPSBjb3JvdXRpbmUua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IENvcm91dGluZUNvbXBvbmVudCQyKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwcmlvcml0eSk7XG4gICAgICAgICAgZXhpc3RpbmcucGVuZGluZ1Byb3BzID0gY29yb3V0aW5lO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ29yb3V0aW5lJDEoY29yb3V0aW5lLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlWWllbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB5aWVsZE5vZGUsIHByaW9yaXR5KSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHlpZWxkcyBzaW5jZSB0aGV5J3JlIHN0YXRlbGVzcy5cbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09IFlpZWxkQ29tcG9uZW50JDMpIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcHJpb3JpdHkpO1xuICAgICAgICBleGlzdGluZy50eXBlID0geWllbGROb2RlLnZhbHVlO1xuICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVlpZWxkJDEoeWllbGROb2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICBjcmVhdGVkLnR5cGUgPSB5aWVsZE5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgcHJpb3JpdHkpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsJDUgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwcmlvcml0eSk7XG4gICAgICAgICAgZXhpc3RpbmcucGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuIHx8IFtdO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsJDEocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIHByaW9yaXR5KTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBwcmlvcml0eSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIC8vIFN1cHBvcnQgb25seSB0aGUgc3Vic2V0IG9mIHJldHVybiB0eXBlcyB0aGF0IFN0YWNrIHN1cHBvcnRzLiBUcmVhdFxuICAgICAgLy8gZXZlcnl0aGluZyBlbHNlIGFzIGVtcHR5LCBidXQgbG9nIGEgd2FybmluZy5cbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBwcmlvcml0eSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ09ST1VUSU5FX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlQ29yb3V0aW5lKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIHByaW9yaXR5KSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9ZSUVMRF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVlpZWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIHByaW9yaXR5KSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgcHJpb3JpdHkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIHByaW9yaXR5KSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBwcmlvcml0eSk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBwcmlvcml0eSk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkNzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudCQyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMkMSA9IENoaWxkUmVjb25jaWxlcih0cnVlLCB0cnVlKTtcblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSQxID0gQ2hpbGRSZWNvbmNpbGVyKGZhbHNlLCB0cnVlKTtcblxudmFyIG1vdW50Q2hpbGRGaWJlcnNJblBsYWNlJDEgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UsIGZhbHNlKTtcblxudmFyIGNsb25lQ2hpbGRGaWJlcnMkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAhKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MkMihjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nV29ya1ByaW9yaXR5KTtcbiAgLy8gVE9ETzogUGFzcyB0aGlzIGFzIGFuIGFyZ3VtZW50LCBzaW5jZSBpdCdzIGVhc3kgdG8gZm9yZ2V0LlxuICBuZXdDaGlsZC5wZW5kaW5nUHJvcHMgPSBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyQyKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdXb3JrUHJpb3JpdHkpO1xuICAgIG5ld0NoaWxkLnBlbmRpbmdQcm9wcyA9IGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHM7XG4gICAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59O1xuXG52YXIgUmVhY3RDaGlsZEZpYmVyID0ge1xuXHRyZWNvbmNpbGVDaGlsZEZpYmVyczogcmVjb25jaWxlQ2hpbGRGaWJlcnMkMSxcblx0cmVjb25jaWxlQ2hpbGRGaWJlcnNJblBsYWNlOiByZWNvbmNpbGVDaGlsZEZpYmVyc0luUGxhY2UkMSxcblx0bW91bnRDaGlsZEZpYmVyc0luUGxhY2U6IG1vdW50Q2hpbGRGaWJlcnNJblBsYWNlJDEsXG5cdGNsb25lQ2hpbGRGaWJlcnM6IGNsb25lQ2hpbGRGaWJlcnMkMVxufTtcblxudmFyIFVwZGF0ZSQxID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlVwZGF0ZTtcblxuXG5cbnZhciBBc3luY1VwZGF0ZXMkMSA9IFJlYWN0VHlwZU9mSW50ZXJuYWxDb250ZXh0LkFzeW5jVXBkYXRlcztcblxudmFyIGNhY2hlQ29udGV4dCQxID0gUmVhY3RGaWJlckNvbnRleHQuY2FjaGVDb250ZXh0O1xudmFyIGdldE1hc2tlZENvbnRleHQkMiA9IFJlYWN0RmliZXJDb250ZXh0LmdldE1hc2tlZENvbnRleHQ7XG52YXIgZ2V0VW5tYXNrZWRDb250ZXh0JDIgPSBSZWFjdEZpYmVyQ29udGV4dC5nZXRVbm1hc2tlZENvbnRleHQ7XG52YXIgaXNDb250ZXh0Q29uc3VtZXIkMSA9IFJlYWN0RmliZXJDb250ZXh0LmlzQ29udGV4dENvbnN1bWVyO1xuXG52YXIgYWRkVXBkYXRlJDEgPSBSZWFjdEZpYmVyVXBkYXRlUXVldWUuYWRkVXBkYXRlO1xudmFyIGFkZFJlcGxhY2VVcGRhdGUkMSA9IFJlYWN0RmliZXJVcGRhdGVRdWV1ZS5hZGRSZXBsYWNlVXBkYXRlO1xudmFyIGFkZEZvcmNlVXBkYXRlJDEgPSBSZWFjdEZpYmVyVXBkYXRlUXVldWUuYWRkRm9yY2VVcGRhdGU7XG52YXIgYmVnaW5VcGRhdGVRdWV1ZSQyID0gUmVhY3RGaWJlclVwZGF0ZVF1ZXVlLmJlZ2luVXBkYXRlUXVldWU7XG5cbnZhciBfcmVxdWlyZTUgPSBSZWFjdEZpYmVyQ29udGV4dDtcbnZhciBoYXNDb250ZXh0Q2hhbmdlZCQyID0gX3JlcXVpcmU1Lmhhc0NvbnRleHRDaGFuZ2VkO1xuXG52YXIgaXNNb3VudGVkJDEgPSBSZWFjdEZpYmVyVHJlZVJlZmxlY3Rpb24uaXNNb3VudGVkO1xuXG5cblxuXG5cblxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG57XG4gIHZhciBfcmVxdWlyZTckMSA9IFJlYWN0RGVidWdGaWJlclBlcmZfMSxcbiAgICAgIHN0YXJ0UGhhc2VUaW1lciQxID0gX3JlcXVpcmU3JDEuc3RhcnRQaGFzZVRpbWVyLFxuICAgICAgc3RvcFBoYXNlVGltZXIkMSA9IF9yZXF1aXJlNyQxLnN0b3BQaGFzZVRpbWVyO1xuXG4gIHZhciB3YXJuaW5nJDI1ID0gcmVxdWlyZSQkMDtcbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmckMjUoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlVXBkYXRlLCBnZXRQcmlvcml0eUNvbnRleHQsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSB7XG4gIC8vIENsYXNzIGNvbXBvbmVudCBzdGF0ZSB1cGRhdGVyXG4gIHZhciB1cGRhdGVyID0ge1xuICAgIGlzTW91bnRlZDogaXNNb3VudGVkJDEsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IFJlYWN0SW5zdGFuY2VNYXBfMS5nZXQoaW5zdGFuY2UpO1xuICAgICAgdmFyIHByaW9yaXR5TGV2ZWwgPSBnZXRQcmlvcml0eUNvbnRleHQoZmliZXIsIGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIGFkZFVwZGF0ZSQxKGZpYmVyLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBwcmlvcml0eUxldmVsKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlKGZpYmVyLCBwcmlvcml0eUxldmVsKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBSZWFjdEluc3RhbmNlTWFwXzEuZ2V0KGluc3RhbmNlKTtcbiAgICAgIHZhciBwcmlvcml0eUxldmVsID0gZ2V0UHJpb3JpdHlDb250ZXh0KGZpYmVyLCBmYWxzZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgYWRkUmVwbGFjZVVwZGF0ZSQxKGZpYmVyLCBzdGF0ZSwgY2FsbGJhY2ssIHByaW9yaXR5TGV2ZWwpO1xuICAgICAgc2NoZWR1bGVVcGRhdGUoZmliZXIsIHByaW9yaXR5TGV2ZWwpO1xuICAgIH0sXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBSZWFjdEluc3RhbmNlTWFwXzEuZ2V0KGluc3RhbmNlKTtcbiAgICAgIHZhciBwcmlvcml0eUxldmVsID0gZ2V0UHJpb3JpdHlDb250ZXh0KGZpYmVyLCBmYWxzZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgICBhZGRGb3JjZVVwZGF0ZSQxKGZpYmVyLCBjYWxsYmFjaywgcHJpb3JpdHlMZXZlbCk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZShmaWJlciwgcHJpb3JpdHlMZXZlbCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgICAgLy8gSWYgdGhlIHdvcmtJblByb2dyZXNzIGFscmVhZHkgaGFzIGFuIFVwZGF0ZSBlZmZlY3QsIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHN0YXJ0UGhhc2VUaW1lciQxKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICB7XG4gICAgICAgIHN0b3BQaGFzZVRpbWVyJDEoKTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB3YXJuaW5nJDI1KHNob3VsZFVwZGF0ZSAhPT0gdW5kZWZpbmVkLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZV8xKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZV8xKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuICAgICAgd2FybmluZyQyNShyZW5kZXJQcmVzZW50LCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA9ICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3RhbmNlLnN0YXRlO1xuICAgICAgd2FybmluZyQyNShub0dldEluaXRpYWxTdGF0ZU9uRVM2LCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAgIHdhcm5pbmckMjUobm9HZXREZWZhdWx0UHJvcHNPbkVTNiwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICAgd2FybmluZyQyNShub0luc3RhbmNlUHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZXM7XG4gICAgICB3YXJuaW5nJDI1KG5vSW5zdGFuY2VDb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nJDI1KG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyQyNShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWVfMSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmckMjUobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmckMjUobm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgd2FybmluZyQyNShpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgICB3YXJuaW5nJDI1KG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheSQxKHN0YXRlKSkpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWVfMSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgISh0eXBlb2Ygd29ya0luUHJvZ3Jlc3MudHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgZ2V0Q29tcG9uZW50TmFtZV8xKHdvcmtJblByb2dyZXNzKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIFJlYWN0SW5zdGFuY2VNYXBfMS5zZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpIHtcbiAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCQyKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0JDIod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkgOiBlbXB0eU9iamVjdDtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gICAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbiAgICBpZiAobmVlZHNDb250ZXh0KSB7XG4gICAgICBjYWNoZUNvbnRleHQkMSh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lciQxKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfVxuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHtcbiAgICAgIHN0b3BQaGFzZVRpbWVyJDEoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmckMjUoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZV8xKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KSB7XG4gICAge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyJDEod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgfVxuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIHtcbiAgICAgIHN0b3BQaGFzZVRpbWVyJDEoKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmckMjUoZmFsc2UsICclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVfMSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIHtcbiAgICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlIHx8IG51bGw7XG5cbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgIXByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgbXVzdCBiZSBwZW5kaW5nIHByb3BzIGZvciBhbiBpbml0aWFsIG1vdW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCQyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQkMih3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChSZWFjdEZlYXR1cmVGbGFnc18xLmVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPT09IHRydWUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmludGVybmFsQ29udGV4dFRhZyB8PSBBc3luY1VwZGF0ZXMkMTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gYmVnaW5VcGRhdGVRdWV1ZSQyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcywgcHJpb3JpdHlMZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGUkMTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb24gYSBwcmVleGlzdGluZyBjbGFzcyBpbnN0YW5jZS4gUmV0dXJucyBmYWxzZSBpZiBhIHJlc3VtZWQgcmVuZGVyXG4gIC8vIGNvdWxkIGJlIHJldXNlZC5cbiAgLy8gZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKFxuICAvLyAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgLy8gICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxuICAvLyApOiBib29sZWFuIHtcbiAgLy8gICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAvLyAgIGxldCBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vICAgbGV0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAvLyAgIGlmICghbmV3UHJvcHMpIHtcbiAgLy8gICAgIC8vIElmIHRoZXJlIGlzbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAvLyAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gIC8vICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIC8vICAgICBpbnZhcmlhbnQoXG4gIC8vICAgICAgIG5ld1Byb3BzICE9IG51bGwsXG4gIC8vICAgICAgICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gIC8vICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gIC8vICAgICApO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAvLyAgIGNvbnN0IG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIC8vICAgY29uc3Qgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIC8vICAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gICAgIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dClcbiAgLy8gICApIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gIC8vICAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgIG5ld1N0YXRlID0gYmVnaW5VcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gYmVnaW5VcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgICBuZXdVcGRhdGVRdWV1ZSxcbiAgLy8gICAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgICApO1xuICAvLyAgICAgfVxuICAvLyAgIH1cblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIC8vICAgfVxuXG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAvLyAgIHJldHVybiB0cnVlO1xuICAvLyB9XG5cbiAgLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpb3JpdHlMZXZlbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0JDIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCQyKHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gICAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAgIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gICAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXh0IHN0YXRlIHVzaW5nIHRoZSBtZW1vaXplZCBzdGF0ZSBhbmQgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIC8vIFRPRE86IFByZXZpb3VzIHN0YXRlIGNhbiBiZSBudWxsLlxuICAgIHZhciBuZXdTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIG5ld1N0YXRlID0gYmVnaW5VcGRhdGVRdWV1ZSQyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIG9sZFN0YXRlLCBuZXdQcm9wcywgcHJpb3JpdHlMZXZlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0YXRlID0gb2xkU3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkJDIoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGUkMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBzdGFydFBoYXNlVGltZXIkMSh3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIHtcbiAgICAgICAgICBzdG9wUGhhc2VUaW1lciQxKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGUkMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGUkMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcyk7XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gICAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlOiBhZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZTogY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICBtb3VudENsYXNzSW5zdGFuY2U6IG1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAvLyByZXN1bWVNb3VudENsYXNzSW5zdGFuY2UsXG4gICAgdXBkYXRlQ2xhc3NJbnN0YW5jZTogdXBkYXRlQ2xhc3NJbnN0YW5jZVxuICB9O1xufTtcblxudmFyIG1vdW50Q2hpbGRGaWJlcnNJblBsYWNlID0gUmVhY3RDaGlsZEZpYmVyLm1vdW50Q2hpbGRGaWJlcnNJblBsYWNlO1xudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gUmVhY3RDaGlsZEZpYmVyLnJlY29uY2lsZUNoaWxkRmliZXJzO1xudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSA9IFJlYWN0Q2hpbGRGaWJlci5yZWNvbmNpbGVDaGlsZEZpYmVyc0luUGxhY2U7XG52YXIgY2xvbmVDaGlsZEZpYmVycyA9IFJlYWN0Q2hpbGRGaWJlci5jbG9uZUNoaWxkRmliZXJzO1xuXG52YXIgYmVnaW5VcGRhdGVRdWV1ZSQxID0gUmVhY3RGaWJlclVwZGF0ZVF1ZXVlLmJlZ2luVXBkYXRlUXVldWU7XG5cblxuXG52YXIgZ2V0TWFza2VkQ29udGV4dCQxID0gUmVhY3RGaWJlckNvbnRleHQuZ2V0TWFza2VkQ29udGV4dDtcbnZhciBnZXRVbm1hc2tlZENvbnRleHQkMSA9IFJlYWN0RmliZXJDb250ZXh0LmdldFVubWFza2VkQ29udGV4dDtcbnZhciBoYXNDb250ZXh0Q2hhbmdlZCQxID0gUmVhY3RGaWJlckNvbnRleHQuaGFzQ29udGV4dENoYW5nZWQ7XG52YXIgcHVzaENvbnRleHRQcm92aWRlciQxID0gUmVhY3RGaWJlckNvbnRleHQucHVzaENvbnRleHRQcm92aWRlcjtcbnZhciBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0JDEgPSBSZWFjdEZpYmVyQ29udGV4dC5wdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0O1xudmFyIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIkMSA9IFJlYWN0RmliZXJDb250ZXh0LmludmFsaWRhdGVDb250ZXh0UHJvdmlkZXI7XG5cbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50JDIgPSBSZWFjdFR5cGVPZldvcmsuSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50JDEgPSBSZWFjdFR5cGVPZldvcmsuRnVuY3Rpb25hbENvbXBvbmVudDtcbnZhciBDbGFzc0NvbXBvbmVudCQ2ID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50O1xudmFyIEhvc3RSb290JDcgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3Q7XG52YXIgSG9zdENvbXBvbmVudCQ3ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQ7XG52YXIgSG9zdFRleHQkNCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0VGV4dDtcbnZhciBIb3N0UG9ydGFsJDQgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFBvcnRhbDtcbnZhciBDb3JvdXRpbmVDb21wb25lbnQkMSA9IFJlYWN0VHlwZU9mV29yay5Db3JvdXRpbmVDb21wb25lbnQ7XG52YXIgQ29yb3V0aW5lSGFuZGxlclBoYXNlID0gUmVhY3RUeXBlT2ZXb3JrLkNvcm91dGluZUhhbmRsZXJQaGFzZTtcbnZhciBZaWVsZENvbXBvbmVudCQyID0gUmVhY3RUeXBlT2ZXb3JrLllpZWxkQ29tcG9uZW50O1xudmFyIEZyYWdtZW50JDIgPSBSZWFjdFR5cGVPZldvcmsuRnJhZ21lbnQ7XG5cbnZhciBOb1dvcmskMyA9IFJlYWN0UHJpb3JpdHlMZXZlbC5Ob1dvcms7XG52YXIgT2Zmc2NyZWVuUHJpb3JpdHkkMSA9IFJlYWN0UHJpb3JpdHlMZXZlbC5PZmZzY3JlZW5Qcmlvcml0eTtcblxudmFyIFBlcmZvcm1lZFdvcmskMSA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QZXJmb3JtZWRXb3JrO1xudmFyIFBsYWNlbWVudCQyID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlBsYWNlbWVudDtcbnZhciBDb250ZW50UmVzZXQkMSA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5Db250ZW50UmVzZXQ7XG52YXIgRXJyJDEgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuRXJyO1xudmFyIFJlZiQxID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlJlZjtcblxuXG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQyID0gUmVhY3RHbG9iYWxTaGFyZWRTdGF0ZV8xLlJlYWN0Q3VycmVudE93bmVyO1xuXG5cblxue1xuICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcl8xO1xuXG4gIHZhciBfcmVxdWlyZTcgPSBSZWFjdERlYnVnRmliZXJQZXJmXzEsXG4gICAgICBjYW5jZWxXb3JrVGltZXIgPSBfcmVxdWlyZTcuY2FuY2VsV29ya1RpbWVyO1xuXG4gIHZhciB3YXJuaW5nJDIzID0gcmVxdWlyZSQkMDtcblxuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlVXBkYXRlLCBnZXRQcmlvcml0eUNvbnRleHQpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlID0gY29uZmlnLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU7XG4gIHZhciBwdXNoSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRleHQsXG4gICAgICBwdXNoSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGFpbmVyO1xuICB2YXIgZW50ZXJIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQuZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ2xhc3NDb21wbyA9IFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudChzY2hlZHVsZVVwZGF0ZSwgZ2V0UHJpb3JpdHlDb250ZXh0LCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSksXG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgICAgbW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLm1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5O1xuICAgIHJlY29uY2lsZUNoaWxkcmVuQXRQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCBwcmlvcml0eUxldmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCBwcmlvcml0eUxldmVsKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVyc0luUGxhY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHByaW9yaXR5TGV2ZWwpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5jaGlsZCA9PT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHByaW9yaXR5TGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiwgb24gdGhlIG90aGVyIGhhbmQsIGl0IGlzIGFscmVhZHkgdXNpbmcgYSBjbG9uZSwgdGhhdCBtZWFucyB3ZSd2ZVxuICAgICAgLy8gYWxyZWFkeSBiZWd1biBzb21lIHdvcmsgb24gdGhpcyB0cmVlIGFuZCB3ZSBjYW4gY29udGludWUgd2hlcmUgd2UgbGVmdFxuICAgICAgLy8gb2ZmIGJ5IHJlY29uY2lsaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0luUGxhY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHByaW9yaXR5TGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQkMSgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsICYmICghY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKSkge1xuICAgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmJDE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQkMSgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCQxKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQkMSh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIkNC5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MsICdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDQuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrJDE7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmlvcml0eUxldmVsKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlciQxKHdvcmtJblByb2dyZXNzKTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICghd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByaW9yaXR5TGV2ZWwpO1xuICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICAgICAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICAgICAgLy8gc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcmlvcml0eUxldmVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpb3JpdHlMZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpIHtcbiAgICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciQxKHdvcmtJblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAvLyBSZXJlbmRlclxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciQ0LnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcywgJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDQuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrJDE7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgLy8gTWVtb2l6ZSBwcm9wcyBhbmQgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAgIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2Uuc3RhdGUpO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gICAgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIkMSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0JDEod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0JDEod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmlvcml0eUxldmVsKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IGJlZ2luVXBkYXRlUXVldWUkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIHByZXZTdGF0ZSwgbnVsbCwgcHJpb3JpdHlMZXZlbCk7XG4gICAgICBpZiAocHJldlN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgdGhlIHNhbWUgYXMgYmVmb3JlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2Ugd2UgaGFkXG4gICAgICAgIC8vIG5vIHdvcmsgbWF0Y2hpbmcgdGhpcyBwcmlvcml0eS5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnQ7XG4gICAgICBpZiAoKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiYgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgICAvLyBXZSBhbHdheXMgdHJ5IHRvIGh5ZHJhdGUuIElmIHRoaXMgaXNuJ3QgYSBoeWRyYXRpb24gcGFzcyB0aGVyZSB3b24ndFxuICAgICAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgICAgICAvLyBub3QgaHlkcmF0aW5nLlxuXG4gICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLiBXZSB0cmFjayB0aGUgaG9zdCByb290IGFzIGEgcGxhY2VtZW50IHRvXG4gICAgICAgIC8vIGtub3cgdGhhdCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBtb3VudGluZyBzdGF0ZS4gVGhhdCB3YXkgaXNNb3VudGVkXG4gICAgICAgIC8vIHdvcmtzIGFzIGV4cGVjdGVkLiBXZSBtdXN0IHJlc2V0IHRoaXMgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgIC8vIFRPRE86IERlbGV0ZSB0aGlzIHdoZW4gd2UgZGVsZXRlIGlzTW91bnRlZCBhbmQgZmluZERPTU5vZGUuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQkMjtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnNJblBsYWNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgZWxlbWVudCwgcHJpb3JpdHlMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgcmVzZXQgaHlkcmF0aW9uIHN0YXRlIGluIGNhc2Ugd2UgYWJvcnRlZCBhbmQgcmVzdW1lZCBhbm90aGVyXG4gICAgICAgIC8vIHJvb3QuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyB1cGRhdGUgcXVldWUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB0aGUgcm9vdCBoYXMgbm8gcHJvcHMuXG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyUHJpb3JpdHkpIHtcbiAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gbWVtb2l6ZWRQcm9wcztcbiAgICAgICEobmV4dFByb3BzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcblxuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCQxKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldCQxO1xuICAgIH1cblxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gICAgaWYgKHJlbmRlclByaW9yaXR5ICE9PSBPZmZzY3JlZW5Qcmlvcml0eSQxICYmICF1c2VTeW5jU2NoZWR1bGluZyAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAgIC8vIERvd24tcHJpb3JpdGl6ZSB0aGUgY2hpbGRyZW4uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5ID0gT2Zmc2NyZWVuUHJpb3JpdHkkMTtcbiAgICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyIGF0IE9mZnNjcmVlblByaW9yaXR5LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH1cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICAhKGN1cnJlbnQgPT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0JDEod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCQxKHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrJDE7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudCQ2O1xuXG4gICAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyJDEod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByaW9yaXR5TGV2ZWwpO1xuICAgICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0cnVlLCBoYXNDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudCQxO1xuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybmluZyQyMyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICAgIHZhciBvd25lck5hbWUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDQuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyQyMyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIkNC5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvcm91dGluZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q29yb3V0aW5lID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCQxKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q29yb3V0aW5lID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDb3JvdXRpbmUgPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q29yb3V0aW5lICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q29yb3V0aW5lID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDb3JvdXRpbmUpIHtcbiAgICAgIG5leHRDb3JvdXRpbmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgLy8gVE9ETzogV2hlbiBiYWlsaW5nIG91dCwgd2UgbWlnaHQgbmVlZCB0byByZXR1cm4gdGhlIHN0YXRlTm9kZSBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgY2hpbGQuIFRvIGNoZWNrIGl0IGZvciB3b3JrLlxuICAgICAgLy8gcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29yb3V0aW5lLmNoaWxkcmVuO1xuICAgIHZhciBwcmlvcml0eUxldmVsID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1dvcmtQcmlvcml0eTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSBmb3JrIG9mIHJlY29uY2lsZUNoaWxkcmVuQXRQcmlvcml0eSBidXQgdXNpbmdcbiAgICAvLyBzdGF0ZU5vZGUgdG8gc3RvcmUgdGhlIGNoaWxkLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBtb3VudENoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHByaW9yaXR5TGV2ZWwpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5jaGlsZCA9PT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcHJpb3JpdHlMZXZlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHByaW9yaXR5TGV2ZWwpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENvcm91dGluZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHRha2UgYXJiaXRyYXJ5IHRpbWUgc28gd2UgY291bGQgc3luY2hyb25vdXNseSBqdXN0IGJlZ2luXG4gICAgLy8gZWFnZXJseSBkbyB0aGUgd29yayBvZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5O1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkJDEoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MuY2hpbGQsIG5leHRDaGlsZHJlbiwgcHJpb3JpdHlMZXZlbCk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICAvKlxuICBmdW5jdGlvbiByZXVzZUNoaWxkcmVuRWZmZWN0cyhyZXR1cm5GaWJlciA6IEZpYmVyLCBmaXJzdENoaWxkIDogRmliZXIpIHtcbiAgICBsZXQgY2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIGRvIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCBlZmZlY3Qgb2YgdGhlIHBhcmVudCBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNoaWxkcmVuJ3MgZmlyc3QgYW5kIGxhc3QgZWZmZWN0LlxuICAgICAgaWYgKCFyZXR1cm5GaWJlci5maXJzdEVmZmVjdCkge1xuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGQubGFzdEVmZmVjdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHtcbiAgICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHtcbiAgICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSGFuZGxlIEhvc3RDb21wb25lbnQgdGFncyBoZXJlIGFzIHdlbGwgYW5kIGNhbGwgcHVzaEhvc3RDb250ZXh0KCk/XG4gICAgLy8gU2VlIFBSIDg1OTAgZGlzY3Vzc2lvbiBmb3IgY29udGV4dFxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290JDc6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkNjpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlciQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RQb3J0YWwkNDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgYmVnaW5VcGRhdGVRdWV1ZS5cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpb3JpdHlMZXZlbCkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5ID09PSBOb1dvcmskMyB8fCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5ID4gcHJpb3JpdHlMZXZlbCkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDQuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50JDI6XG4gICAgICAgIHJldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW9yaXR5TGV2ZWwpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50JDE6XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkNjpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmlvcml0eUxldmVsKTtcbiAgICAgIGNhc2UgSG9zdFJvb3QkNzpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmlvcml0eUxldmVsKTtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ3OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpb3JpdHlMZXZlbCk7XG4gICAgICBjYXNlIEhvc3RUZXh0JDQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENvcm91dGluZUhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENvcm91dGluZUNvbXBvbmVudCQxO1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggc2luY2UgdGhpcyBpcyBub3cgdGhlIHNhbWUuXG4gICAgICBjYXNlIENvcm91dGluZUNvbXBvbmVudCQxOlxuICAgICAgICByZXR1cm4gdXBkYXRlQ29yb3V0aW5lQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgWWllbGRDb21wb25lbnQkMjpcbiAgICAgICAgLy8gQSB5aWVsZCBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsJDQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBGcmFnbWVudCQyOlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIGNvbnRleHQgbWlzbWF0Y2guXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkNjpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlciQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290JDc6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbiBlcnJvciBlZmZlY3Qgc28gd2UgY2FuIGhhbmRsZSB0aGUgZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyJDE7XG5cbiAgICAvLyBUaGlzIGlzIGEgd2VpcmQgY2FzZSB3aGVyZSB3ZSBkbyBcInJlc3VtZVwiIHdvcmsg4oCUIHdvcmsgdGhhdCBmYWlsZWQgb25cbiAgICAvLyBvdXIgZmlyc3QgYXR0ZW1wdC4gQmVjYXVzZSB3ZSBubyBsb25nZXIgaGF2ZSBhIG5vdGlvbiBvZiBcInByb2dyZXNzZWRcbiAgICAvLyBkZWxldGlvbnMsXCIgcmVzZXQgdGhlIGNoaWxkIHRvIHRoZSBjdXJyZW50IGNoaWxkIHRvIG1ha2Ugc3VyZSB3ZSBkZWxldGVcbiAgICAvLyBpdCBhZ2Fpbi4gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMsIHBlcmhhcHMgZHVyaW5nIGEgbW9yZVxuICAgIC8vIGdlbmVyYWwgb3ZlcmhhdWwgb2YgZXJyb3IgaGFuZGxpbmcuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdXb3JrUHJpb3JpdHkgPT09IE5vV29yayQzIHx8IHdvcmtJblByb2dyZXNzLnBlbmRpbmdXb3JrUHJpb3JpdHkgPiBwcmlvcml0eUxldmVsKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdFByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHByaW9yaXR5TGV2ZWwpO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQkNikge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVnaW5Xb3JrOiBiZWdpbldvcmssXG4gICAgYmVnaW5GYWlsZWRXb3JrOiBiZWdpbkZhaWxlZFdvcmtcbiAgfTtcbn07XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyQyID0gUmVhY3RDaGlsZEZpYmVyLnJlY29uY2lsZUNoaWxkRmliZXJzO1xuXG52YXIgcG9wQ29udGV4dFByb3ZpZGVyJDIgPSBSZWFjdEZpYmVyQ29udGV4dC5wb3BDb250ZXh0UHJvdmlkZXI7XG52YXIgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0JDEgPSBSZWFjdEZpYmVyQ29udGV4dC5wb3BUb3BMZXZlbENvbnRleHRPYmplY3Q7XG5cblxuXG5cbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50JDMgPSBSZWFjdFR5cGVPZldvcmsuSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50JDMgPSBSZWFjdFR5cGVPZldvcmsuRnVuY3Rpb25hbENvbXBvbmVudDtcbnZhciBDbGFzc0NvbXBvbmVudCQ4ID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50O1xudmFyIEhvc3RSb290JDggPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3Q7XG52YXIgSG9zdENvbXBvbmVudCQ4ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQ7XG52YXIgSG9zdFRleHQkNiA9IFJlYWN0VHlwZU9mV29yay5Ib3N0VGV4dDtcbnZhciBIb3N0UG9ydGFsJDYgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFBvcnRhbDtcbnZhciBDb3JvdXRpbmVDb21wb25lbnQkMyA9IFJlYWN0VHlwZU9mV29yay5Db3JvdXRpbmVDb21wb25lbnQ7XG52YXIgQ29yb3V0aW5lSGFuZGxlclBoYXNlJDEgPSBSZWFjdFR5cGVPZldvcmsuQ29yb3V0aW5lSGFuZGxlclBoYXNlO1xudmFyIFlpZWxkQ29tcG9uZW50JDQgPSBSZWFjdFR5cGVPZldvcmsuWWllbGRDb21wb25lbnQ7XG52YXIgRnJhZ21lbnQkNCA9IFJlYWN0VHlwZU9mV29yay5GcmFnbWVudDtcbnZhciBQbGFjZW1lbnQkNCA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QbGFjZW1lbnQ7XG52YXIgUmVmJDIgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuUmVmO1xudmFyIFVwZGF0ZSQyID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlVwZGF0ZTtcbnZhciBPZmZzY3JlZW5Qcmlvcml0eSQyID0gUmVhY3RQcmlvcml0eUxldmVsLk9mZnNjcmVlblByaW9yaXR5O1xuXG5cbntcbiAgdmFyIFJlYWN0RGVidWdDdXJyZW50RmliZXIkNSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXJfMTtcbn1cblxuXG5cbnZhciBSZWFjdEZpYmVyQ29tcGxldGVXb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpIHtcbiAgdmFyIGNyZWF0ZUluc3RhbmNlID0gY29uZmlnLmNyZWF0ZUluc3RhbmNlLFxuICAgICAgY3JlYXRlVGV4dEluc3RhbmNlID0gY29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGFwcGVuZEluaXRpYWxDaGlsZCA9IGNvbmZpZy5hcHBlbmRJbml0aWFsQ2hpbGQsXG4gICAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiA9IGNvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixcbiAgICAgIHByZXBhcmVVcGRhdGUgPSBjb25maWcucHJlcGFyZVVwZGF0ZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGUkMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmJDI7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxZaWVsZHMoeWllbGRzLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50JDggfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0JDYgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwkNikge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNvcm91dGluZSBjYW5ub3QgaGF2ZSBob3N0IGNvbXBvbmVudCBjaGlsZHJlbi4nKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFlpZWxkQ29tcG9uZW50JDQpIHtcbiAgICAgICAgeWllbGRzLnB1c2gobm9kZS50eXBlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVDb3JvdXRpbmVUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBjb3JvdXRpbmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICFjb3JvdXRpbmUgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY29yb3V0aW5lIGhhcyBjb21wbGV0ZWQuIE5vdyB3ZSBuZWVkIHRvIGRvIHRoZSBzZWNvbmQuXG4gICAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSB0byBoYXZlIGEgbXVsdGkgc3RhZ2UgY29yb3V0aW5lIHJlcHJlc2VudGVkIGJ5IGFcbiAgICAvLyBzaW5nbGUgY29tcG9uZW50LCBvciBhdCBsZWFzdCB0YWlsIGNhbGwgb3B0aW1pemUgbmVzdGVkIG9uZXMuIEN1cnJlbnRseVxuICAgIC8vIHRoYXQgcmVxdWlyZXMgYWRkaXRpb25hbCBmaWVsZHMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIGFkZCB0byB0aGUgZmliZXIuXG4gICAgLy8gU28gdGhpcyByZXF1aXJlcyBuZXN0ZWQgaGFuZGxlcnMuXG4gICAgLy8gTm90ZTogVGhpcyBkb2Vzbid0IG11dGF0ZSB0aGUgYWx0ZXJuYXRlIG5vZGUuIEkgZG9uJ3QgdGhpbmsgaXQgbmVlZHMgdG9cbiAgICAvLyBzaW5jZSB0aGlzIHN0YWdlIGlzIHJlc2V0IGZvciBldmVyeSBwYXNzLlxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENvcm91dGluZUhhbmRsZXJQaGFzZSQxO1xuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHlpZWxkcy5cbiAgICAvLyBUT0RPOiBDb21wYXJlIHRoaXMgdG8gYSBnZW5lcmF0b3Igb3Igb3BhcXVlIGhlbHBlcnMgbGlrZSBDaGlsZHJlbi5cbiAgICB2YXIgeWllbGRzID0gW107XG4gICAgYXBwZW5kQWxsWWllbGRzKHlpZWxkcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBmbiA9IGNvcm91dGluZS5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNvcm91dGluZS5wcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZm4ocHJvcHMsIHlpZWxkcyk7XG5cbiAgICB2YXIgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5jaGlsZCA6IG51bGw7XG4gICAgLy8gSW5oZXJpdCB0aGUgcHJpb3JpdHkgb2YgdGhlIHJldHVybkZpYmVyLlxuICAgIHZhciBwcmlvcml0eSA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdXb3JrUHJpb3JpdHk7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyQyKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCBwcmlvcml0eSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQkOCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQkNikge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsJDYpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJQcmlvcml0eSkge1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIkNS5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbGF0ZXN0IHByb3BzLlxuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV3UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdXb3JrUHJpb3JpdHkgIT09IE9mZnNjcmVlblByaW9yaXR5JDIgfHwgcmVuZGVyUHJpb3JpdHkgPT09IE9mZnNjcmVlblByaW9yaXR5JDIpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBwZW5kaW5nIHByb3BzLCB1bmxlc3MgdGhpcyB3YXMgYSBkb3duLXByaW9yaXRpemF0aW9uLlxuICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50JDM6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudCQ4OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyJDIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290JDg6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQkNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ4OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9PRDogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0JDY6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dDIsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ29yb3V0aW5lQ29tcG9uZW50JDM6XG4gICAgICAgIHJldHVybiBtb3ZlQ29yb3V0aW5lVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDb3JvdXRpbmVIYW5kbGVyUGhhc2UkMTpcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRhZyB0byBub3cgYmUgYSBmaXJzdCBwaGFzZSBjb3JvdXRpbmUuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENvcm91dGluZUNvbXBvbmVudCQzO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgWWllbGRDb21wb25lbnQkNDpcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQkNDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWwkNjpcbiAgICAgICAgLy8gVE9ETzogT25seSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlIGlmIHdlIGhhdmUgYW55IHBlbmRpbmcgY2FsbGJhY2tzLlxuICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgLy8gRXJyb3IgY2FzZXNcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCQzOlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgaGF2ZSBiZWNvbWUgZGV0ZXJtaW5hdGUgYmVmb3JlIGNvbXBsZXRpbmcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gdW5pdCBvZiB3b3JrIHRhZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBsZXRlV29yazogY29tcGxldGVXb3JrXG4gIH07XG59O1xuXG57XG4gIHZhciB3YXJuaW5nJDI2ID0gcmVxdWlyZSQkMDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nJDI2KGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyQxKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nJDI2KGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmckMjYoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3QkMShyb290KSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyUm9vdChyb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFVubW91bnQkMShmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbnZhciBpbmplY3RJbnRlcm5hbHNfMSA9IGluamVjdEludGVybmFscyQxO1xudmFyIG9uQ29tbWl0Um9vdF8xID0gb25Db21taXRSb290JDE7XG52YXIgb25Db21taXRVbm1vdW50XzEgPSBvbkNvbW1pdFVubW91bnQkMTtcblxudmFyIFJlYWN0RmliZXJEZXZUb29sc0hvb2sgPSB7XG5cdGluamVjdEludGVybmFsczogaW5qZWN0SW50ZXJuYWxzXzEsXG5cdG9uQ29tbWl0Um9vdDogb25Db21taXRSb290XzEsXG5cdG9uQ29tbWl0VW5tb3VudDogb25Db21taXRVbm1vdW50XzFcbn07XG5cbnZhciBDbGFzc0NvbXBvbmVudCQ5ID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50O1xudmFyIEhvc3RSb290JDkgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3Q7XG52YXIgSG9zdENvbXBvbmVudCQ5ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQ7XG52YXIgSG9zdFRleHQkNyA9IFJlYWN0VHlwZU9mV29yay5Ib3N0VGV4dDtcbnZhciBIb3N0UG9ydGFsJDcgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFBvcnRhbDtcbnZhciBDb3JvdXRpbmVDb21wb25lbnQkNCA9IFJlYWN0VHlwZU9mV29yay5Db3JvdXRpbmVDb21wb25lbnQ7XG5cbnZhciBjb21taXRDYWxsYmFja3MkMSA9IFJlYWN0RmliZXJVcGRhdGVRdWV1ZS5jb21taXRDYWxsYmFja3M7XG5cbnZhciBvbkNvbW1pdFVubW91bnQgPSBSZWFjdEZpYmVyRGV2VG9vbHNIb29rLm9uQ29tbWl0VW5tb3VudDtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzXzEuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHNfMS5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHNfMS5jbGVhckNhdWdodEVycm9yO1xuXG52YXIgUGxhY2VtZW50JDUgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuUGxhY2VtZW50O1xudmFyIFVwZGF0ZSQzID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlVwZGF0ZTtcbnZhciBDYWxsYmFjayQxID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LkNhbGxiYWNrO1xudmFyIENvbnRlbnRSZXNldCQyID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LkNvbnRlbnRSZXNldDtcblxuXG5cbntcbiAgdmFyIF9yZXF1aXJlNSQxID0gUmVhY3REZWJ1Z0ZpYmVyUGVyZl8xLFxuICAgICAgc3RhcnRQaGFzZVRpbWVyJDIgPSBfcmVxdWlyZTUkMS5zdGFydFBoYXNlVGltZXIsXG4gICAgICBzdG9wUGhhc2VUaW1lciQyID0gX3JlcXVpcmU1JDEuc3RvcFBoYXNlVGltZXI7XG59XG5cbnZhciBSZWFjdEZpYmVyQ29tbWl0V29yayA9IGZ1bmN0aW9uIChjb25maWcsIGNhcHR1cmVFcnJvcikge1xuICB2YXIgY29tbWl0TW91bnQgPSBjb25maWcuY29tbWl0TW91bnQsXG4gICAgICBjb21taXRVcGRhdGUgPSBjb25maWcuY29tbWl0VXBkYXRlLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9IGNvbmZpZy5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IGNvbmZpZy5jb21taXRUZXh0VXBkYXRlLFxuICAgICAgYXBwZW5kQ2hpbGQgPSBjb25maWcuYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBjb25maWcuaW5zZXJ0QmVmb3JlLFxuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUgPSBjb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9IGNvbmZpZy5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IGNvbmZpZy5yZW1vdmVDaGlsZEZyb21Db250YWluZXIsXG4gICAgICBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuXG4gIHtcbiAgICB2YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVySW5EZXYgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lciQyKGN1cnJlbnQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICBzdG9wUGhhc2VUaW1lciQyKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lckluRGV2LCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50JDkgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCQ5IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbCQ3O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCQ5ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCQ3KSB7XG4gICAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgICBpZiAobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQkNSkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCQ3KSB7XG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuICAgICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQkNSkpIHtcbiAgICAgICAgLy8gRm91bmQgaXQhXG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgaW5zZXJ0IGFsbCBob3N0IG5vZGVzIGludG8gdGhlIHBhcmVudC5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcbiAgICB2YXIgcGFyZW50ID0gdm9pZCAwO1xuICAgIHZhciBpc0NvbnRhaW5lciA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50JDk6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290JDk6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsJDc6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCQyKSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQkMjtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQkOSB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQkNykge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwkNykge1xuICAgICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKHJvb3QpIHtcbiAgICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAgIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsJDcpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gcm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gY3VycmVudDtcblxuICAgIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ5OlxuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290JDk6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWwkNzpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCQ5IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCQ3KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsJDcpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwkNykge1xuICAgICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtlZXAgYSBzdGFjayBvZiB0aGVtLCB3ZSB3aWxsIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50KSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcblxuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkOTpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ5OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDb3JvdXRpbmVDb21wb25lbnQkNDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbCQ3OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkOTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50JDk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dCQ3OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdCQ5OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWwkNzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkOTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUkMykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lciQyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyJDIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lciQyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lciQyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBDYWxsYmFjayQxICYmIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzJDEoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290JDk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICYmIGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MkMShmaW5pc2hlZFdvcmssIHVwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ5OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSQzKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQkNzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWwkNzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQkOTpcbiAgICAgICAgICByZWYoZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIGN1cnJlbnRSZWYgPSBjdXJyZW50LnJlZjtcbiAgICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICBjb21taXRXb3JrOiBjb21taXRXb3JrLFxuICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVDdXJzb3IkMiA9IFJlYWN0RmliZXJTdGFjay5jcmVhdGVDdXJzb3I7XG52YXIgcG9wJDIgPSBSZWFjdEZpYmVyU3RhY2sucG9wO1xudmFyIHB1c2gkMiA9IFJlYWN0RmliZXJTdGFjay5wdXNoO1xuXG5cblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yJDIoTk9fQ09OVEVYVCk7XG4gIHZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvciQyKE5PX0NPTlRFWFQpO1xuICB2YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IkMihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaCQyKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG5cbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoJDIoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaCQyKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wJDIoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wJDIoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AkMihyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoJDIoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaCQyKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBvcCQyKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcCQyKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvc3RDb250YWluZXIoKSB7XG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dCxcbiAgICByZXNldEhvc3RDb250YWluZXI6IHJlc2V0SG9zdENvbnRhaW5lclxuICB9O1xufTtcblxudmFyIEhvc3RDb21wb25lbnQkMTAgPSBSZWFjdFR5cGVPZldvcmsuSG9zdENvbXBvbmVudDtcbnZhciBIb3N0VGV4dCQ4ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RUZXh0O1xudmFyIEhvc3RSb290JDEwID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RSb290O1xuXG52YXIgRGVsZXRpb24kMiA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5EZWxldGlvbjtcbnZhciBQbGFjZW1lbnQkNiA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QbGFjZW1lbnQ7XG5cbnZhciBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiQxID0gUmVhY3RGaWJlci5jcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbjtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBjYW5IeWRyYXRlSW5zdGFuY2UgPSBjb25maWcuY2FuSHlkcmF0ZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gY29uZmlnLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLFxuICAgICAgaHlkcmF0ZUluc3RhbmNlID0gY29uZmlnLmh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGNvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlID0gY29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIShjYW5IeWRyYXRlSW5zdGFuY2UgJiYgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSAmJiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgJiYgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgJiYgaHlkcmF0ZUluc3RhbmNlICYmIGh5ZHJhdGVUZXh0SW5zdGFuY2UgJiYgZGlkTm90SHlkcmF0ZUluc3RhbmNlICYmIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgJiYgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBUaGUgZGVlcGVzdCBGaWJlciBvbiB0aGUgc3RhY2sgaW52b2x2ZWQgaW4gYSBoeWRyYXRpb24gY29udGV4dC5cbiAgLy8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290JDEwOlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQkMTA6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24kMSgpO1xuICAgIGNoaWxkVG9EZWxldGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgY2hpbGRUb0RlbGV0ZVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uJDI7XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudCQ2O1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIC8vIFRPRE86IEN1cnJlbnRseSB3ZSBkb24ndCB3YXJuIGZvciBpbnNlcnRpb25zIGludG8gdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgICAvLyB3ZSBhbHdheXMgaW5zZXJ0IGludG8gdGhlIHJvb3QgaW4gdGhlIG5vbi1oeWRyYXRpbmcgY2FzZS4gV2UganVzdFxuICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIGNvbnRlbnQuIFJlZW5hYmxlIHRoaXMgb25jZSB3ZSBoYXZlIGEgYmV0dGVyXG4gICAgICAgIC8vIHN0cmF0ZWd5IGZvciBkZXRlcm1pbmluZyBpZiB3ZSdyZSBoeWRyYXRpbmcgb3Igbm90LlxuICAgICAgICAvLyBjYXNlIEhvc3RSb290OlxuICAgICAgICAvLyAgIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQxMDpcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQkMTA6XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFRleHQkODpcbiAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuSHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQxMDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgcmV0dXJuIGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dCQ4OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgcmV0dXJuIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbkh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhY2FuSHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBmaWJlci5zdGF0ZU5vZGUgPSBuZXh0SW5zdGFuY2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dEluc3RhbmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyKTtcbiAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCBmaWJlci5tZW1vaXplZFByb3BzLCBmaWJlcik7XG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgICB2YXIgcGFyZW50ID0gZmliZXJbJ3JldHVybiddO1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LnRhZyAhPT0gSG9zdENvbXBvbmVudCQxMCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Um9vdCQxMCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICB9XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAgIC8vIHRyZWUuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBjdXJyZW50bHkgaHlkcmF0aW5nIGJ1dCB3ZSdyZSBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LCB0aGVuXG4gICAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgICAgLy8gc2libGluZ3MuXG4gICAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gICAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gICAgLy8gc2lkZSBvZiB0aGVtLlxuICAgIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG4gICAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCQxMCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50ZXJIeWRyYXRpb25TdGF0ZTogZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlOiByZXNldEh5ZHJhdGlvblN0YXRlLFxuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICBwb3BIeWRyYXRpb25TdGF0ZTogcG9wSHlkcmF0aW9uU3RhdGVcbiAgfTtcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25cbiAqIFxuICovXG5cbi8vIFRoaXMgbGV0cyB1cyBob29rIGludG8gRmliZXIgdG8gZGVidWcgd2hhdCBpdCdzIGRvaW5nLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzgwMzMuXG4vLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLCBub3QgZXZlbiBmb3IgUmVhY3QgRGV2VG9vbHMuXG4vLyBZb3UgbWF5IG9ubHkgaW5qZWN0IGEgZGVidWdUb29sIGlmIHlvdSB3b3JrIG9uIFJlYWN0IEZpYmVyIGl0c2VsZi5cblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24kMiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiQyO1xuXG52YXIgcG9wQ29udGV4dFByb3ZpZGVyJDEgPSBSZWFjdEZpYmVyQ29udGV4dC5wb3BDb250ZXh0UHJvdmlkZXI7XG5cbnZhciByZXNldCQxID0gUmVhY3RGaWJlclN0YWNrLnJlc2V0O1xuXG52YXIgZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlciQyID0gUmVhY3RGaWJlckNvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXI7XG5cbnZhciBsb2dDYXB0dXJlZEVycm9yID0gUmVhY3RGaWJlckVycm9yTG9nZ2VyLmxvZ0NhcHR1cmVkRXJyb3I7XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlsc18xLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlsc18xLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHNfMS5jbGVhckNhdWdodEVycm9yO1xuXG5cblxuXG5cblxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0R2xvYmFsU2hhcmVkU3RhdGVfMS5SZWFjdEN1cnJlbnRPd25lcjtcblxuXG5cbnZhciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyQxID0gUmVhY3RGaWJlci5jcmVhdGVXb3JrSW5Qcm9ncmVzcztcbnZhciBsYXJnZXJQcmlvcml0eSQxID0gUmVhY3RGaWJlci5sYXJnZXJQcmlvcml0eTtcblxudmFyIG9uQ29tbWl0Um9vdCA9IFJlYWN0RmliZXJEZXZUb29sc0hvb2sub25Db21taXRSb290O1xuXG52YXIgTm9Xb3JrJDIgPSBSZWFjdFByaW9yaXR5TGV2ZWwuTm9Xb3JrO1xudmFyIFN5bmNocm9ub3VzUHJpb3JpdHkkMSA9IFJlYWN0UHJpb3JpdHlMZXZlbC5TeW5jaHJvbm91c1ByaW9yaXR5O1xudmFyIFRhc2tQcmlvcml0eSQxID0gUmVhY3RQcmlvcml0eUxldmVsLlRhc2tQcmlvcml0eTtcbnZhciBIaWdoUHJpb3JpdHkgPSBSZWFjdFByaW9yaXR5TGV2ZWwuSGlnaFByaW9yaXR5O1xudmFyIExvd1ByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVsLkxvd1ByaW9yaXR5O1xudmFyIE9mZnNjcmVlblByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVsLk9mZnNjcmVlblByaW9yaXR5O1xuXG52YXIgQXN5bmNVcGRhdGVzID0gUmVhY3RUeXBlT2ZJbnRlcm5hbENvbnRleHQuQXN5bmNVcGRhdGVzO1xuXG52YXIgUGVyZm9ybWVkV29yayA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QZXJmb3JtZWRXb3JrO1xudmFyIFBsYWNlbWVudCQxID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LlBsYWNlbWVudDtcbnZhciBVcGRhdGUgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuVXBkYXRlO1xudmFyIFBsYWNlbWVudEFuZFVwZGF0ZSA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QbGFjZW1lbnRBbmRVcGRhdGU7XG52YXIgRGVsZXRpb24gPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuRGVsZXRpb247XG52YXIgQ29udGVudFJlc2V0ID0gUmVhY3RUeXBlT2ZTaWRlRWZmZWN0LkNvbnRlbnRSZXNldDtcbnZhciBDYWxsYmFjayA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5DYWxsYmFjaztcbnZhciBFcnIgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuRXJyO1xudmFyIFJlZiA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5SZWY7XG5cbnZhciBIb3N0Um9vdCQ2ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RSb290O1xudmFyIEhvc3RDb21wb25lbnQkNiA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Q29tcG9uZW50O1xudmFyIEhvc3RQb3J0YWwkMyA9IFJlYWN0VHlwZU9mV29yay5Ib3N0UG9ydGFsO1xudmFyIENsYXNzQ29tcG9uZW50JDUgPSBSZWFjdFR5cGVPZldvcmsuQ2xhc3NDb21wb25lbnQ7XG5cbnZhciBnZXRVcGRhdGVQcmlvcml0eSQxID0gUmVhY3RGaWJlclVwZGF0ZVF1ZXVlLmdldFVwZGF0ZVByaW9yaXR5O1xuXG52YXIgX3JlcXVpcmUxNCA9IFJlYWN0RmliZXJDb250ZXh0O1xudmFyIHJlc2V0Q29udGV4dCQxID0gX3JlcXVpcmUxNC5yZXNldENvbnRleHQ7XG5cblxuXG57XG4gIHZhciB3YXJuaW5nJDIyID0gcmVxdWlyZSQkMDtcbiAgdmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24kMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMTtcbiAgdmFyIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXJfMTtcblxuICB2YXIgX3JlcXVpcmUxNSA9IFJlYWN0RGVidWdGaWJlclBlcmZfMSxcbiAgICAgIHJlY29yZEVmZmVjdCA9IF9yZXF1aXJlMTUucmVjb3JkRWZmZWN0LFxuICAgICAgcmVjb3JkU2NoZWR1bGVVcGRhdGUgPSBfcmVxdWlyZTE1LnJlY29yZFNjaGVkdWxlVXBkYXRlLFxuICAgICAgc3RhcnRXb3JrVGltZXIgPSBfcmVxdWlyZTE1LnN0YXJ0V29ya1RpbWVyLFxuICAgICAgc3RvcFdvcmtUaW1lciA9IF9yZXF1aXJlMTUuc3RvcFdvcmtUaW1lcixcbiAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIgPSBfcmVxdWlyZTE1LnN0b3BGYWlsZWRXb3JrVGltZXIsXG4gICAgICBzdGFydFdvcmtMb29wVGltZXIgPSBfcmVxdWlyZTE1LnN0YXJ0V29ya0xvb3BUaW1lcixcbiAgICAgIHN0b3BXb3JrTG9vcFRpbWVyID0gX3JlcXVpcmUxNS5zdG9wV29ya0xvb3BUaW1lcixcbiAgICAgIHN0YXJ0Q29tbWl0VGltZXIgPSBfcmVxdWlyZTE1LnN0YXJ0Q29tbWl0VGltZXIsXG4gICAgICBzdG9wQ29tbWl0VGltZXIgPSBfcmVxdWlyZTE1LnN0b3BDb21taXRUaW1lcixcbiAgICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lciA9IF9yZXF1aXJlMTUuc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyLFxuICAgICAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIgPSBfcmVxdWlyZTE1LnN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyLFxuICAgICAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIgPSBfcmVxdWlyZTE1LnN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyLFxuICAgICAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lciA9IF9yZXF1aXJlMTUuc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcjtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICB2YXIgY3RvciA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHdhcm5pbmckMjIoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gVGhpcyB1c3VhbGx5IG1lYW5zICcgKyAneW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSBvbiBhbiB1bm1vdW50ZWQgJyArICdjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAnICsgJyVzIGNvbXBvbmVudC4nLCBjdG9yICYmIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKTtcbiAgfTtcblxuICB2YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKFJlYWN0RGVidWdDdXJyZW50RmliZXIkMy5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgd2FybmluZyQyMihmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgd2FybmluZyQyMihmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG52YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG52YXIgUmVhY3RGaWJlclNjaGVkdWxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGhvc3RDb250ZXh0ID0gUmVhY3RGaWJlckhvc3RDb250ZXh0KGNvbmZpZyk7XG4gIHZhciBoeWRyYXRpb25Db250ZXh0ID0gUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQoY29uZmlnKTtcbiAgdmFyIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyLFxuICAgICAgcG9wSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGV4dCxcbiAgICAgIHJlc2V0SG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnJlc2V0SG9zdENvbnRhaW5lcjtcblxuICB2YXIgX1JlYWN0RmliZXJCZWdpbldvcmsgPSBSZWFjdEZpYmVyQmVnaW5Xb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlVXBkYXRlLCBnZXRQcmlvcml0eUNvbnRleHQpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSBjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSBjb25maWcucmVzZXRBZnRlckNvbW1pdDtcblxuICAvLyBUaGUgcHJpb3JpdHkgbGV2ZWwgdG8gdXNlIHdoZW4gc2NoZWR1bGluZyBhbiB1cGRhdGUuIFdlIHVzZSBOb1dvcmsgdG9cbiAgLy8gcmVwcmVzZW50IHRoZSBkZWZhdWx0IHByaW9yaXR5LlxuICAvLyBUT0RPOiBTaG91bGQgd2UgY2hhbmdlIHRoaXMgdG8gYW4gYXJyYXkgaW5zdGVhZCBvZiB1c2luZyB0aGUgY2FsbCBzdGFjaz9cbiAgLy8gTWlnaHQgYmUgbGVzcyBjb25mdXNpbmcuXG5cbiAgdmFyIHByaW9yaXR5Q29udGV4dCA9IE5vV29yayQyO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgd2UncmUgY3VycmVudGx5IGluIGEgd29yayBsb29wLlxuICB2YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGN1cnJlbnQgZGVhZGxpbmUgaGFzIGV4cGlyZWQuXG4gIHZhciBkZWFkbGluZUhhc0V4cGlyZWQgPSBmYWxzZTtcblxuICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHdlIHNob3VsZCBzaG91bGQgYmF0Y2ggc3luYyB1cGRhdGVzLlxuICB2YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBUaGlzIGlzIG5lZWRlZCBmb3IgdGhlIHdlaXJkIGNhc2Ugd2hlcmUgdGhlIGluaXRpYWwgbW91bnQgaXMgc3luY2hyb25vdXNcbiAgLy8gZXZlbiBpbnNpZGUgYmF0Y2hlZFVwZGF0ZXMgOihcbiAgdmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gIHZhciBuZXh0UHJpb3JpdHlMZXZlbCA9IE5vV29yayQyO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICB2YXIgcGVuZGluZ0NvbW1pdCA9IG51bGw7XG5cbiAgLy8gTGlua2VkIGxpc3Qgb2Ygcm9vdHMgd2l0aCBzY2hlZHVsZWQgd29yayBvbiB0aGVtLlxuICB2YXIgbmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggaG9zdCBlbnZpcm9ubWVudCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZC5cbiAgdmFyIGlzQ2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgdmFyIG5leHRSZW5kZXJlZFRyZWUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCQxKCk7XG4gICAgcmVzZXRIb3N0Q29udGFpbmVyKCk7XG4gIH1cblxuICAvLyByZXNldE5leHRVbml0T2ZXb3JrIG11dGF0ZXMgdGhlIGN1cnJlbnQgcHJpb3JpdHkgY29udGV4dC4gSXQgaXMgcmVzZXQgYWZ0ZXJcbiAgLy8gYWZ0ZXIgdGhlIHdvcmtMb29wIGV4aXRzLCBzbyBuZXZlciBjYWxsIHJlc2V0TmV4dFVuaXRPZldvcmsgZnJvbSBvdXRzaWRlXG4gIC8vIHRoZSB3b3JrIGxvb3AuXG4gIGZ1bmN0aW9uIHJlc2V0TmV4dFVuaXRPZldvcmsoKSB7XG4gICAgLy8gQ2xlYXIgb3V0IHJvb3RzIHdpdGggbm8gbW9yZSB3b3JrIG9uIHRoZW0sIG9yIGlmIHRoZXkgaGF2ZSB1bmNhdWdodCBlcnJvcnNcbiAgICB3aGlsZSAobmV4dFNjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbmV4dFNjaGVkdWxlZFJvb3QuY3VycmVudC5wZW5kaW5nV29ya1ByaW9yaXR5ID09PSBOb1dvcmskMikge1xuICAgICAgLy8gVW5zY2hlZHVsZSB0aGlzIHJvb3QuXG4gICAgICBuZXh0U2NoZWR1bGVkUm9vdC5pc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgLy8gUmVhZCB0aGUgbmV4dCBwb2ludGVyIG5vdy5cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xlYXIgaXQgaW4gY2FzZSB0aGlzIHJvb3QgZ2V0cyBzY2hlZHVsZWQgYWdhaW4gbGF0ZXIuXG4gICAgICB2YXIgbmV4dCA9IG5leHRTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgbmV4dFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgLy8gRXhpdCBpZiB3ZSBjbGVhcmVkIGFsbCB0aGUgcm9vdHMgYW5kIHRoZXJlJ3Mgbm8gd29yayB0byBkby5cbiAgICAgIGlmIChuZXh0U2NoZWR1bGVkUm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgbmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIG5leHRQcmlvcml0eUxldmVsID0gTm9Xb3JrJDI7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgbmV4dCByb290LlxuICAgICAgLy8gSWYgdGhlcmUncyBubyB3b3JrIG9uIGl0LCBpdCB3aWxsIGdldCB1bnNjaGVkdWxlZCB0b28uXG4gICAgICBuZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBuZXh0U2NoZWR1bGVkUm9vdDtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG4gICAgdmFyIGhpZ2hlc3RQcmlvcml0eUxldmVsID0gTm9Xb3JrJDI7XG4gICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGlmIChyb290LmN1cnJlbnQucGVuZGluZ1dvcmtQcmlvcml0eSAhPT0gTm9Xb3JrJDIgJiYgKGhpZ2hlc3RQcmlvcml0eUxldmVsID09PSBOb1dvcmskMiB8fCBoaWdoZXN0UHJpb3JpdHlMZXZlbCA+IHJvb3QuY3VycmVudC5wZW5kaW5nV29ya1ByaW9yaXR5KSkge1xuICAgICAgICBoaWdoZXN0UHJpb3JpdHlMZXZlbCA9IHJvb3QuY3VycmVudC5wZW5kaW5nV29ya1ByaW9yaXR5O1xuICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpZG4ndCBmaW5kIGFueXRoaW5nIHRvIGRvIGluIHRoaXMgcm9vdCwgc28gbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgIH1cbiAgICBpZiAoaGlnaGVzdFByaW9yaXR5Um9vdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dFByaW9yaXR5TGV2ZWwgPSBoaWdoZXN0UHJpb3JpdHlMZXZlbDtcbiAgICAgIC8vIEJlZm9yZSB3ZSBzdGFydCBhbnkgbmV3IHdvcmssIGxldCdzIG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBmcmVzaFxuICAgICAgLy8gc3RhY2sgdG8gd29yayBmcm9tLlxuICAgICAgLy8gVE9ETzogVGhpcyBjYWxsIGlzIGJ1cmllZCBhIGJpdCB0b28gZGVlcC4gSXQgd291bGQgYmUgbmljZSB0byBoYXZlXG4gICAgICAvLyBhIHNpbmdsZSBwb2ludCB3aGljaCBoYXBwZW5zIHJpZ2h0IGJlZm9yZSBhbnkgbmV3IHdvcmsgYW5kXG4gICAgICAvLyB1bmZvcnR1bmF0ZWx5IHRoaXMgaXMgaXQuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuXG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzJDEoaGlnaGVzdFByaW9yaXR5Um9vdC5jdXJyZW50LCBoaWdoZXN0UHJpb3JpdHlMZXZlbCk7XG4gICAgICBpZiAoaGlnaGVzdFByaW9yaXR5Um9vdCAhPT0gbmV4dFJlbmRlcmVkVHJlZSkge1xuICAgICAgICAvLyBXZSd2ZSBzd2l0Y2hlZCB0cmVlcy4gUmVzZXQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnRlci5cbiAgICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgICBuZXh0UmVuZGVyZWRUcmVlID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0UHJpb3JpdHlMZXZlbCA9IE5vV29yayQyO1xuICAgIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgICBuZXh0UmVuZGVyZWRUcmVlID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDMuc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QsIG51bGwpO1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb25maWcucmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0LnN0YXRlTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH4oQ2FsbGJhY2sgfCBFcnIgfCBDb250ZW50UmVzZXQgfCBSZWYgfCBQZXJmb3JtZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudCQxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgICAgLy8gVE9ETzogZmluZERPTU5vZGUgZG9lc24ndCByZWx5IG9uIHRoaXMgYW55IG1vcmUgYnV0IGlzTW91bnRlZFxuICAgICAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgICAgICAvLyB0byBraWxsIHRoaXMuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50JDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50JDE7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyJDMucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxMaWZlQ3ljbGVzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIC8vIFVzZSBUYXNrIHByaW9yaXR5IGZvciBsaWZlY3ljbGUgdXBkYXRlc1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICB7XG4gICAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxXb3JrKGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIHtcbiAgICAgIHN0YXJ0Q29tbWl0VGltZXIoKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlmIChuZXh0UHJpb3JpdHlMZXZlbCA9PT0gU3luY2hyb25vdXNQcmlvcml0eSQxIHx8IG5leHRQcmlvcml0eUxldmVsID09PSBUYXNrUHJpb3JpdHkkMSkge1xuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZVxuICAgICAgLy8gdXBkYXRlIGxvb3AuXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gbnVsbDtcblxuICAgIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfVxuXG4gICAgcHJlcGFyZUZvckNvbW1pdCgpO1xuXG4gICAgLy8gQ29tbWl0IGFsbCB0aGUgc2lkZS1lZmZlY3RzIHdpdGhpbiBhIHRyZWUuIFdlJ2xsIGRvIHRoaXMgaW4gdHdvIHBhc3Nlcy5cbiAgICAvLyBUaGUgZmlyc3QgcGFzcyBwZXJmb3JtcyBhbGwgdGhlIGhvc3QgaW5zZXJ0aW9ucywgdXBkYXRlcywgZGVsZXRpb25zIGFuZFxuICAgIC8vIHJlZiB1bm1vdW50cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gICAge1xuICAgICAgc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG4gICAgfVxuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbEhvc3RFZmZlY3RzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yKTtcbiAgICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG4gICAgfVxuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICB7XG4gICAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIH1cbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9kaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvcjIgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIF9kaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kaWRFcnJvcikge1xuICAgICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGNhcHR1cmVFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAge1xuICAgICAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25Db21taXRSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24kMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24kMS5kZWJ1Z1Rvb2wub25Db21taXRXb3JrKGZpbmlzaGVkV29yayk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgY2F1Z2h0IGFueSBlcnJvcnMgZHVyaW5nIHRoaXMgY29tbWl0LCBzY2hlZHVsZSB0aGVpciBib3VuZGFyaWVzXG4gICAgLy8gdG8gdXBkYXRlLlxuICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMpIHtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5mb3JFYWNoKHNjaGVkdWxlRXJyb3JSZWNvdmVyeSk7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdHJlZSBpcyBkb25lLiBSZXNldCB0aGUgdW5pdCBvZiB3b3JrIHBvaW50ZXIgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAgIC8vIHByaW9yaXR5IHJvb3QuIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQsIHRoZSBwb2ludGVyIGlzIHNldCB0byBudWxsLlxuICAgIHJlc2V0TmV4dFVuaXRPZldvcmsoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0V29ya1ByaW9yaXR5KHdvcmtJblByb2dyZXNzLCByZW5kZXJQcmlvcml0eSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5ICE9PSBOb1dvcmskMiAmJiB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nV29ya1ByaW9yaXR5ID4gcmVuZGVyUHJpb3JpdHkpIHtcbiAgICAgIC8vIFRoaXMgd2FzIGEgZG93bi1wcmlvcml0aXphdGlvbi4gRG9uJ3QgYnViYmxlIHByaW9yaXR5IGZyb20gY2hpbGRyZW4uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuICAgIHZhciBuZXdQcmlvcml0eSA9IGdldFVwZGF0ZVByaW9yaXR5JDEod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ29yb3V0aW5lcyBuZWVkIHRvIHZpc2l0IHN0YXRlTm9kZVxuXG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCByZW1haW5pbmcgd29yayBwcmlvcml0eSBidWJibGVzIHVwLlxuICAgICAgbmV3UHJpb3JpdHkgPSBsYXJnZXJQcmlvcml0eSQxKG5ld1ByaW9yaXR5LCBjaGlsZC5wZW5kaW5nV29ya1ByaW9yaXR5KTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1dvcmtQcmlvcml0eSA9IG5ld1ByaW9yaXR5O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAgIC8vIHByb2dyZXNzLlxuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW9yaXR5TGV2ZWwpO1xuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgcmVzZXRXb3JrUHJpb3JpdHkod29ya0luUHJvZ3Jlc3MsIG5leHRQcmlvcml0eUxldmVsKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAge1xuICAgICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24kMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uJDEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiQxLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uJDEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC4gTWFyayB0aGUgcm9vdCBhcyBwZW5kaW5nIGNvbW1pdC4gRGVwZW5kaW5nXG4gICAgICAgIC8vIG9uIGhvdyBtdWNoIHRpbWUgd2UgaGF2ZSBsZWZ0LCB3ZSdsbCBlaXRoZXIgY29tbWl0IGl0IG5vdyBvciBpblxuICAgICAgICAvLyB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgcGVuZGluZ0NvbW1pdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAgIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICB7XG4gICAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJpb3JpdHlMZXZlbCk7XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiQxLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiQxLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciQzLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICB7XG4gICAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJpb3JpdHlMZXZlbCk7XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiQxLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiQxLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciQzLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRGVmZXJyZWRXb3JrKGRlYWRsaW5lKSB7XG4gICAgcGVyZm9ybVdvcmsoT2Zmc2NyZWVuUHJpb3JpdHksIGRlYWRsaW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbW1pdFBoYXNlRXJyb3JzKCkge1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIHdvcmsgbG9vcCBmb3IgaGFuZGxpbmcgY29tbWl0IHBoYXNlIGVycm9ycy4gSXQnc1xuICAgIC8vIHNpbWlsYXIgdG8gdGhlIHN5bmNyaG9ub3VzIHdvcmsgbG9vcCwgYnV0IGRvZXMgYW4gYWRkaXRpb25hbCBjaGVjayBvblxuICAgIC8vIGVhY2ggZmliZXIgdG8gc2VlIGlmIGl0J3MgYW4gZXJyb3IgYm91bmRhcnkgd2l0aCBhbiB1bmhhbmRsZWQgZXJyb3IuIElmXG4gICAgLy8gc28sIGl0IHVzZXMgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29yayB0aGF0IHVubW91bnRzIHRoZVxuICAgIC8vIGZhaWxlZCBzdWJ0cmVlLlxuICAgIC8vXG4gICAgLy8gVGhlIGxvb3Agc3RvcHMgb25jZSB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQgYW5kIGVycm9yIGxpZmVjeWNsZXMgYXJlXG4gICAgLy8gY2FsbGVkLiBUaGVuIHdlIHJldHVybiB0byB0aGUgcmVndWxhciBmbG93LlxuXG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIGNhcHR1cmVkRXJyb3JzLnNpemUgPiAwICYmIG5leHRQcmlvcml0eUxldmVsID09PSBUYXNrUHJpb3JpdHkkMSkge1xuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAgICAgIShwZW5kaW5nQ29tbWl0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGEgcGVuZGluZyBjb21taXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgLy8gV2UganVzdCBjb21wbGV0ZWQgYSByb290LiBDb21taXQgaXQgbm93LlxuICAgICAgICAgIHByaW9yaXR5Q29udGV4dCA9IFRhc2tQcmlvcml0eSQxO1xuICAgICAgICAgIGNvbW1pdEFsbFdvcmsocGVuZGluZ0NvbW1pdCk7XG4gICAgICAgICAgcHJpb3JpdHlDb250ZXh0ID0gbmV4dFByaW9yaXR5TGV2ZWw7XG5cbiAgICAgICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwgfHwgY2FwdHVyZWRFcnJvcnMuc2l6ZSA9PT0gMCB8fCBuZXh0UHJpb3JpdHlMZXZlbCAhPT0gVGFza1ByaW9yaXR5JDEpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBtb3JlIHVuaGFuZGxlZCBlcnJvcnMuIFdlIGNhbiBleGl0IHRoaXMgc3BlY2lhbFxuICAgICAgICAgICAgLy8gd29yayBsb29wLiBJZiB0aGVyZSdzIHN0aWxsIGFkZGl0aW9uYWwgd29yaywgd2UnbGwgcGVyZm9ybSBpdFxuICAgICAgICAgICAgLy8gdXNpbmcgb25lIG9mIHRoZSBub3JtYWwgd29yayBsb29wcy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY29tbWl0IHBoYXNlIHByb2R1Y2VkIGFkZGl0aW9uYWwgZXJyb3JzLiBDb250aW51ZSB3b3JraW5nLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd29ya0xvb3AobWluUHJpb3JpdHlMZXZlbCwgZGVhZGxpbmUpIHtcbiAgICBpZiAocGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgICAgcHJpb3JpdHlDb250ZXh0ID0gVGFza1ByaW9yaXR5JDE7XG4gICAgICBjb21taXRBbGxXb3JrKHBlbmRpbmdDb21taXQpO1xuICAgICAgaGFuZGxlQ29tbWl0UGhhc2VFcnJvcnMoKTtcbiAgICB9IGVsc2UgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICByZXNldE5leHRVbml0T2ZXb3JrKCk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcmlvcml0eUxldmVsID09PSBOb1dvcmskMiB8fCBuZXh0UHJpb3JpdHlMZXZlbCA+IG1pblByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgdXBkYXRlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBwcmlvcml0eSBhdCB3aGljaFxuICAgIC8vIHdlJ3JlIHJlbmRlcmluZy5cbiAgICBwcmlvcml0eUNvbnRleHQgPSBuZXh0UHJpb3JpdHlMZXZlbDtcblxuICAgIGxvb3A6IGRvIHtcbiAgICAgIGlmIChuZXh0UHJpb3JpdHlMZXZlbCA8PSBUYXNrUHJpb3JpdHkkMSkge1xuICAgICAgICAvLyBGbHVzaCBhbGwgc3luY2hyb25vdXMgYW5kIHRhc2sgd29yay5cbiAgICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgICAgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAgICAgICAhKHBlbmRpbmdDb21taXQgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwZW5kaW5nIGNvbW1pdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIFdlIGp1c3QgY29tcGxldGVkIGEgcm9vdC4gQ29tbWl0IGl0IG5vdy5cbiAgICAgICAgICAgIHByaW9yaXR5Q29udGV4dCA9IFRhc2tQcmlvcml0eSQxO1xuICAgICAgICAgICAgY29tbWl0QWxsV29yayhwZW5kaW5nQ29tbWl0KTtcbiAgICAgICAgICAgIHByaW9yaXR5Q29udGV4dCA9IG5leHRQcmlvcml0eUxldmVsO1xuICAgICAgICAgICAgLy8gQ2xlYXIgYW55IGVycm9ycyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgaGFuZGxlQ29tbWl0UGhhc2VFcnJvcnMoKTtcbiAgICAgICAgICAgIC8vIFRoZSBwcmlvcml0eSBsZXZlbCBtYXkgaGF2ZSBjaGFuZ2VkLiBDaGVjayBhZ2Fpbi5cbiAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHlMZXZlbCA9PT0gTm9Xb3JrJDIgfHwgbmV4dFByaW9yaXR5TGV2ZWwgPiBtaW5Qcmlvcml0eUxldmVsIHx8IG5leHRQcmlvcml0eUxldmVsID4gVGFza1ByaW9yaXR5JDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHByaW9yaXR5IGxldmVsIGRvZXMgbm90IG1hdGNoLlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIGV4cGlyZXMuXG4gICAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhZGVhZGxpbmVIYXNFeHBpcmVkKSB7XG4gICAgICAgICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgICAgIC8vIEluIGEgZGVmZXJyZWQgd29yayBiYXRjaCwgaWZmIG5leHRVbml0T2ZXb3JrIHJldHVybnMgbnVsbCwgd2UganVzdFxuICAgICAgICAgICAgLy8gY29tcGxldGVkIGEgcm9vdCBhbmQgYSBwZW5kaW5nQ29tbWl0IGV4aXN0cy4gTG9naWNhbGx5LCB3ZSBjb3VsZFxuICAgICAgICAgICAgLy8gb21pdCBlaXRoZXIgb2YgdGhlIGNoZWNrcyBpbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGJvdGggdG8gc2F0aXNmeSBGbG93LlxuICAgICAgICAgICAgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICEocGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHBlbmRpbmcgY29tbWl0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBXZSBqdXN0IGNvbXBsZXRlZCBhIHJvb3QuIElmIHdlIGhhdmUgdGltZSwgY29tbWl0IGl0IG5vdy5cbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBjb21taXQgaXQgaW4gdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAgICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5Q29udGV4dCA9IFRhc2tQcmlvcml0eSQxO1xuICAgICAgICAgICAgICAgIGNvbW1pdEFsbFdvcmsocGVuZGluZ0NvbW1pdCk7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlDb250ZXh0ID0gbmV4dFByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgYW55IGVycm9ycyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgICAgIGhhbmRsZUNvbW1pdFBoYXNlRXJyb3JzKCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByaW9yaXR5IGxldmVsIG1heSBoYXZlIGNoYW5nZWQuIENoZWNrIGFnYWluLlxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHlMZXZlbCA9PT0gTm9Xb3JrJDIgfHwgbmV4dFByaW9yaXR5TGV2ZWwgPiBtaW5Qcmlvcml0eUxldmVsIHx8IG5leHRQcmlvcml0eUxldmVsIDwgSGlnaFByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgcHJpb3JpdHkgbGV2ZWwgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVhZGxpbmVIYXNFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWFkbGluZUhhc0V4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGVyZSBtaWdodCBiZSB3b3JrIGxlZnQuIERlcGVuZGluZyBvbiB0aGUgcHJpb3JpdHksIHdlIHNob3VsZFxuICAgICAgLy8gZWl0aGVyIHBlcmZvcm0gaXQgbm93IG9yIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gcGVyZm9ybSBpdCBsYXRlci5cbiAgICAgIHN3aXRjaCAobmV4dFByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSBTeW5jaHJvbm91c1ByaW9yaXR5JDE6XG4gICAgICAgIGNhc2UgVGFza1ByaW9yaXR5JDE6XG4gICAgICAgICAgLy8gV2UgaGF2ZSByZW1haW5pbmcgc3luY2hyb25vdXMgb3IgdGFzayB3b3JrLiBLZWVwIHBlcmZvcm1pbmcgaXQsXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlJ3JlIGluc2lkZSBhIGNhbGxiYWNrLlxuICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHlMZXZlbCA8PSBtaW5Qcmlvcml0eUxldmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICBjYXNlIEhpZ2hQcmlvcml0eTpcbiAgICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgY2FzZSBPZmZzY3JlZW5Qcmlvcml0eTpcbiAgICAgICAgICAvLyBXZSBoYXZlIHJlbWFpbmluZyBhc3luYyB3b3JrLlxuICAgICAgICAgIGlmIChkZWFkbGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UncmUgbm90IGluc2lkZSBhIGNhbGxiYWNrLiBFeGl0IGFuZCBwZXJmb3JtIHRoZSB3b3JrIGR1cmluZ1xuICAgICAgICAgICAgLy8gdGhlIG5leHQgY2FsbGJhY2suXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSBhcmUgaW5zaWRlIGEgY2FsbGJhY2suXG4gICAgICAgICAgaWYgKCFkZWFkbGluZUhhc0V4cGlyZWQgJiYgbmV4dFByaW9yaXR5TGV2ZWwgPD0gbWluUHJpb3JpdHlMZXZlbCkge1xuICAgICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0aW1lLiBLZWVwIHdvcmtpbmcuXG4gICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSd2ZSBydW4gb3V0IG9mIHRpbWUuIEV4aXQuXG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgY2FzZSBOb1dvcmskMjpcbiAgICAgICAgICAvLyBObyB3b3JrIGxlZnQuIFdlIGNhbiBleGl0LlxuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnU3dpdGNoIHN0YXRlbWVudCBzaG91bGQgYmUgZXhodWFzdGl2ZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrQ2F0Y2hCbG9jayhmYWlsZWRXb3JrLCBib3VuZGFyeSwgbWluUHJpb3JpdHlMZXZlbCwgZGVhZGxpbmUpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvci5cbiAgICAvLyBDb25jZXB0dWFsbHksIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2suIFdlIG5lZWQgdG8gdW53aW5kIHRoZVxuICAgIC8vIGNvbnRleHQgc3RhY2ssIHRvby5cbiAgICB1bndpbmRDb250ZXh0cyhmYWlsZWRXb3JrLCBib3VuZGFyeSk7XG5cbiAgICAvLyBSZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB1c2luZyBhIGZvcmtlZCB2ZXJzaW9uIG9mXG4gICAgLy8gcGVyZm9ybVVuaXRPZldvcmsgdGhhdCBkZWxldGVzIHRoZSBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGUgZW50aXJlXG4gICAgLy8gZmFpbGVkIHN1YnJlZSB3aWxsIGJlIHVubW91bnRlZC4gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIGEgc3BlY2lhbFxuICAgIC8vIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBlcnJvciBib3VuZGFyeSwgd2hpY2ggdHJpZ2dlcnNcbiAgICAvLyBhIHJlLXJlbmRlci5cbiAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKGJvdW5kYXJ5KTtcblxuICAgIC8vIENvbnRpbnVlIHdvcmtpbmcuXG4gICAgd29ya0xvb3AobWluUHJpb3JpdHlMZXZlbCwgZGVhZGxpbmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluUHJpb3JpdHlMZXZlbCwgZGVhZGxpbmUpIHtcbiAgICB7XG4gICAgICBzdGFydFdvcmtMb29wVGltZXIoKTtcbiAgICB9XG5cbiAgICAhIWlzUGVyZm9ybWluZ1dvcmsgPyBpbnZhcmlhbnQoZmFsc2UsICdwZXJmb3JtV29yayB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuXG4gICAgLy8gVGhlIHByaW9yaXR5IGNvbnRleHQgY2hhbmdlcyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gV2UnbGwgbmVlZCB0b1xuICAgIC8vIHJlc2V0IGl0IGF0IHRoZSBlbmQuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlDb250ZXh0ID0gcHJpb3JpdHlDb250ZXh0O1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgbWluUHJpb3JpdHlMZXZlbCwgZGVhZGxpbmUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcGVyZm9ybVdvcmtDYXRjaEJsb2NrLCBudWxsLCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgbWluUHJpb3JpdHlMZXZlbCwgZGVhZGxpbmUpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UncmUgZmluaXNoZWQgd29ya2luZy4gRXhpdCB0aGUgZXJyb3IgbG9vcC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHRoZSBwcmlvcml0eSBjb250ZXh0IHRvIGl0cyBwcmV2aW91cyB2YWx1ZS5cbiAgICBwcmlvcml0eUNvbnRleHQgPSBwcmV2aW91c1ByaW9yaXR5Q29udGV4dDtcblxuICAgIC8vIElmIHdlJ3JlIGluc2lkZSBhIGNhbGxiYWNrLCBzZXQgdGhpcyB0byBmYWxzZSwgc2luY2Ugd2UganVzdCBmbHVzaGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgaXNDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHJlbWFpbmluZyBhc3luYyB3b3JrLCBtYWtlIHN1cmUgd2Ugc2NoZWR1bGUgYW5vdGhlciBjYWxsYmFjay5cbiAgICBpZiAobmV4dFByaW9yaXR5TGV2ZWwgPiBUYXNrUHJpb3JpdHkkMSAmJiAhaXNDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1EZWZlcnJlZFdvcmspO1xuICAgICAgaXNDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGVycm9yVG9UaHJvdyA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblxuICAgIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgICBkZWFkbGluZUhhc0V4cGlyZWQgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAgIG5leHRSZW5kZXJlZFRyZWUgPSBudWxsO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIHtcbiAgICAgIHN0b3BXb3JrTG9vcFRpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gSXQncyBzYWZlIHRvIHRocm93IGFueSB1bmhhbmRsZWQgZXJyb3JzLlxuICAgIGlmIChlcnJvclRvVGhyb3cgIT09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yVG9UaHJvdztcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvciwgb3IgbnVsbCBpZiB0aGUgZXJyb3IgaXMgaWdub3JlZFxuICBmdW5jdGlvbiBjYXB0dXJlRXJyb3IoZmFpbGVkV29yaywgZXJyb3IpIHtcbiAgICAvLyBJdCBpcyBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB3ZSBleGl0ZWQgdGhlIHVzZXIgY29kZS5cbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMy5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkuXG4gICAgdmFyIGJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIC8vIFBhc3NlZCB0byBsb2dDYXB0dXJlZEVycm9yKClcbiAgICB2YXIgZXJyb3JCb3VuZGFyeUZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5cbiAgICAvLyBIb3N0IGNvbnRhaW5lcnMgYXJlIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGUgZmFpbGVkIHdvcmsgaXRzZWxmIGlzIGEgaG9zdFxuICAgIC8vIGNvbnRhaW5lciwgdGhlbiBpdCBhY3RzIGFzIGl0cyBvd24gYm91bmRhcnkuIEluIGFsbCBvdGhlciBjYXNlcywgd2VcbiAgICAvLyBpZ25vcmUgdGhlIHdvcmsgaXRzZWxmIGFuZCBvbmx5IHNlYXJjaCB0aHJvdWdoIHRoZSBwYXJlbnRzLlxuICAgIGlmIChmYWlsZWRXb3JrLnRhZyA9PT0gSG9zdFJvb3QkNikge1xuICAgICAgYm91bmRhcnkgPSBmYWlsZWRXb3JrO1xuXG4gICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShmYWlsZWRXb3JrKSkge1xuICAgICAgICAvLyBJZiB0aGlzIHJvb3QgYWxyZWFkeSBmYWlsZWQsIHRoZXJlIG11c3QgaGF2ZSBiZWVuIGFuIGVycm9yIHdoZW5cbiAgICAgICAgLy8gYXR0ZW1wdGluZyB0byB1bm1vdW50IGl0LiBUaGlzIGlzIGEgd29yc3QtY2FzZSBzY2VuYXJpbyBhbmRcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgcG9zc2libGUgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBmYWlsZWRXb3JrWydyZXR1cm4nXTtcbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQkNSkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWVfMShub2RlKTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXJyb3IgYm91bmRhcnkhXG4gICAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QkNikge1xuICAgICAgICAgIC8vIFRyZWF0IHRoZSByb290IGxpa2UgYSBuby1vcCBlcnJvciBib3VuZGFyeVxuICAgICAgICAgIGJvdW5kYXJ5ID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KG5vZGUpKSB7XG4gICAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBhbHJlYWR5IGluIGEgZmFpbGVkIHN0YXRlLlxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHVubW91bnRpbmcsIHRoYXQgbWVhbnMgdGhpcyBlcnJvciB3YXNcbiAgICAgICAgICAvLyB0aHJvd24gd2hpbGUgdW5tb3VudGluZyBhIGZhaWxlZCBzdWJ0cmVlLiBXZSBzaG91bGQgaWdub3JlXG4gICAgICAgICAgLy8gdGhlIGVycm9yLlxuICAgICAgICAgIGlmIChpc1VubW91bnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIHdlIHNob3VsZCBjaGVjayB0byBzZWUgaWZcbiAgICAgICAgICAvLyB0aGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoaXMgY29tbWl0LlxuICAgICAgICAgIC8vIFRoaXMgY2FzZSBleGlzdHMgYmVjYXVzZSBtdWx0aXBsZSBlcnJvcnMgY2FuIGJlIHRocm93biBkdXJpbmdcbiAgICAgICAgICAvLyBhIHNpbmdsZSBjb21taXQgd2l0aG91dCBpbnRlcnJ1cHRpb24uXG4gICAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlKSB8fCBub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUuYWx0ZXJuYXRlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBzaG91bGQgaWdub3JlIHRoaXMgZXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgZXJyb3Igc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeSAt4oCUIHdlIGtlZXAgbG9va2luZy5cbiAgICAgICAgICBib3VuZGFyeSA9IG51bGw7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgZmFpbGVkIGJvdW5kYXJpZXMuIFRoaXMgbGV0cyB1cyBrbm93IHRoYXRcbiAgICAgIC8vIHN1YnNlcXVlbnQgZXJyb3JzIGluIHRoaXMgc3VidHJlZSBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcblxuICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdW5zYWZlIG91dHNpZGUgb2YgdGhlIGJlZ2luIGFuZCBjb21wbGV0ZSBwaGFzZXMuXG4gICAgICAvLyBXZSBtaWdodCBiZSBpbiB0aGUgY29tbWl0IHBoYXNlIHdoZW4gYW4gZXJyb3IgaXMgY2FwdHVyZWQuXG4gICAgICAvLyBUaGUgcmlzayBpcyB0aGF0IHRoZSByZXR1cm4gcGF0aCBmcm9tIHRoaXMgRmliZXIgbWF5IG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgIC8vIFRoYXQgcmlzayBpcyBhY2NlcHRhYmxlIGdpdmVuIHRoZSBiZW5lZml0IG9mIHByb3ZpZGluZyB1c2VycyBtb3JlIGNvbnRleHQuXG4gICAgICB2YXIgX2NvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlciQyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZV8xKGZhaWxlZFdvcmspO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY2FwdHVyZWQgZXJyb3JzLiBUaGlzIGlzIHN0b3JlZCBhcyBhIGdsb2JhbFxuICAgICAgLy8gbWFwIG9mIGVycm9ycyBhbmQgdGhlaXIgY29tcG9uZW50IHN0YWNrIGxvY2F0aW9uIGtleWVkIGJ5IHRoZSBib3VuZGFyaWVzXG4gICAgICAvLyB0aGF0IGNhcHR1cmUgdGhlbS4gV2UgbW9zdGx5IHVzZSB0aGlzIE1hcCBhcyBhIFNldDsgaXQncyBhIE1hcCBvbmx5IHRvXG4gICAgICAvLyBhdm9pZCBhZGRpbmcgYSBmaWVsZCB0byBGaWJlciB0byBzdG9yZSB0aGUgZXJyb3IuXG4gICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgY2FwdHVyZWRFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IF9jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5OiBlcnJvckJvdW5kYXJ5Rm91bmQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWU6IGVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICB3aWxsUmV0cnk6IHdpbGxSZXRyeVxuICAgICAgfTtcblxuICAgICAgY2FwdHVyZWRFcnJvcnMuc2V0KGJvdW5kYXJ5LCBjYXB0dXJlZEVycm9yKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBjeWNsZSBpZiBsb2dDYXB0dXJlZEVycm9yKCkgdGhyb3dzLlxuICAgICAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIGRlZmVyIHNjaGVkdWxpbmcgYW4gdXBkYXRlIG9uIHRoZVxuICAgICAgLy8gYm91bmRhcnkgdW50aWwgYWZ0ZXIgdGhlIGNvbW1pdCBpcyBjb21wbGV0ZVxuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzY2hlZHVsZSBhbiB1cGRhdGUgbm93LlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjdHVhbGx5IG5lY2Vzc2FyeSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZT8gSXMgaXRcbiAgICAgICAgLy8gcG9zc2libGUgdG8gdW53aW5kIGFuZCBjb250aW51ZSByZW5kZXJpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHksXG4gICAgICAgIC8vIHdpdGhvdXQgY29ycnVwdGluZyBpbnRlcm5hbCBzdGF0ZT9cbiAgICAgICAgc2NoZWR1bGVFcnJvclJlY292ZXJ5KGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm8gYm91bmRhcnkgaXMgZm91bmQsIHdlJ2xsIG5lZWQgdG8gdGhyb3cgdGhlIGVycm9yXG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDYXB0dXJlZEVycm9yKGZpYmVyKSB7XG4gICAgLy8gVE9ETzogY2FwdHVyZWRFcnJvcnMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWQgbmVlZGluZ1xuICAgIC8vIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIChjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhaWxlZEJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgLy8gVE9ETzogZmFpbGVkQm91bmRhcmllcyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZFxuICAgIC8vIG5lZWRpbmcgdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9ySGFuZGxpbmcoZWZmZWN0ZnVsRmliZXIpIHtcbiAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGlmIChjYXB0dXJlZEVycm9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVmZmVjdGZ1bEZpYmVyID0gZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNhcHR1cmVkRXJyb3IgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdObyBlcnJvciBmb3IgZ2l2ZW4gdW5pdCBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgc3dpdGNoIChlZmZlY3RmdWxGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQkNTpcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZWZmZWN0ZnVsRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWxsb3cgdGhlIGJvdW5kYXJ5IHRvIGhhbmRsZSB0aGUgZXJyb3IsIHVzdWFsbHkgYnkgc2NoZWR1bGluZ1xuICAgICAgICAvLyBhbiB1cGRhdGUgdG8gaXRzZWxmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGNhcHR1cmVkRXJyb3IuZXJyb3IsIGluZm8pO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEhvc3RSb290JDY6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBob3N0IGNvbnRhaW5lciwgd2UgdHJlYXQgaXQgYXMgYSBuby1vcCBlcnJvclxuICAgICAgICAgIC8vIGJvdW5kYXJ5LiBXZSdsbCB0aHJvdyB0aGUgZmlyc3QgdW5jYXVnaHQgZXJyb3Igb25jZSBpdCdzIHNhZmUgdG9cbiAgICAgICAgICAvLyBkbyBzbywgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2guXG4gICAgICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndpbmRDb250ZXh0cyhmcm9tLCB0bykge1xuICAgIHZhciBub2RlID0gZnJvbTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50JDU6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyJDEobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudCQ2OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RSb290JDY6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsJDM6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0byB8fCBub2RlLmFsdGVybmF0ZSA9PT0gdG8pIHtcbiAgICAgICAge1xuICAgICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlUm9vdChyb290LCBwcmlvcml0eUxldmVsKSB7XG4gICAgaWYgKHByaW9yaXR5TGV2ZWwgPT09IE5vV29yayQyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFyb290LmlzU2NoZWR1bGVkKSB7XG4gICAgICByb290LmlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAvLyBTY2hlZHVsZSBvdXJzZWx2ZXMgdG8gdGhlIGVuZC5cbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSdyZSB0aGUgb25seSB3b3JrIHNjaGVkdWxlZC5cbiAgICAgICAgbmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGUoZmliZXIsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVVcGRhdGVJbXBsKGZpYmVyLCBwcmlvcml0eUxldmVsLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZUltcGwoZmliZXIsIHByaW9yaXR5TGV2ZWwsIGlzRXJyb3JSZWNvdmVyeSkge1xuICAgIHtcbiAgICAgIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLicpO1xuICAgIH1cblxuICAgIGlmICghaXNQZXJmb3JtaW5nV29yayAmJiBwcmlvcml0eUxldmVsIDw9IG5leHRQcmlvcml0eUxldmVsKSB7XG4gICAgICAvLyBXZSBtdXN0IHJlc2V0IHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yayBwb2ludGVyIHNvIHRoYXQgd2UgcmVzdGFydCB0aGVcbiAgICAgIC8vIHNlYXJjaCBmcm9tIHRoZSByb290IGR1cmluZyB0aGUgbmV4dCB0aWNrLCBpbiBjYXNlIHRoZXJlIGlzIG5vdyBoaWdoZXJcbiAgICAgIC8vIHByaW9yaXR5IHdvcmsgc29tZXdoZXJlIGVhcmxpZXIgdGhhbiBiZWZvcmUuXG4gICAgICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCQ1KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIHNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBzaG91bGRDb250aW51ZSkge1xuICAgICAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSBlYWNoIG5vZGUncyBwcmlvcml0eS4gT25jZVxuICAgICAgLy8gd2UgcmVhY2ggYSBub2RlIHdob3NlIHByaW9yaXR5IG1hdGNoZXMgKGFuZCB3aG9zZSBhbHRlcm5hdGUncyBwcmlvcml0eVxuICAgICAgLy8gbWF0Y2hlcykgd2UgY2FuIGV4aXQgc2FmZWx5IGtub3dpbmcgdGhhdCB0aGUgcmVzdCBvZiB0aGUgcGF0aCBpcyBjb3JyZWN0LlxuICAgICAgc2hvdWxkQ29udGludWUgPSBmYWxzZTtcbiAgICAgIGlmIChub2RlLnBlbmRpbmdXb3JrUHJpb3JpdHkgPT09IE5vV29yayQyIHx8IG5vZGUucGVuZGluZ1dvcmtQcmlvcml0eSA+IHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgZGlkIG5vdCBtYXRjaC4gVXBkYXRlIGFuZCBrZWVwIGdvaW5nLlxuICAgICAgICBzaG91bGRDb250aW51ZSA9IHRydWU7XG4gICAgICAgIG5vZGUucGVuZGluZ1dvcmtQcmlvcml0eSA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnBlbmRpbmdXb3JrUHJpb3JpdHkgPT09IE5vV29yayQyIHx8IG5vZGUuYWx0ZXJuYXRlLnBlbmRpbmdXb3JrUHJpb3JpdHkgPiBwcmlvcml0eUxldmVsKSB7XG4gICAgICAgICAgLy8gUHJpb3JpdHkgZGlkIG5vdCBtYXRjaC4gVXBkYXRlIGFuZCBrZWVwIGdvaW5nLlxuICAgICAgICAgIHNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICAgICAgICBub2RlLmFsdGVybmF0ZS5wZW5kaW5nV29ya1ByaW9yaXR5ID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QkNikge1xuICAgICAgICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgc2NoZWR1bGVSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpO1xuICAgICAgICAgIGlmICghaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3luY2hyb25vdXNQcmlvcml0eSQxOlxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhpcyB1cGRhdGUgbm93LlxuICAgICAgICAgICAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgd2hpY2ggaXMgaW5zaWRlIGVpdGhlclxuICAgICAgICAgICAgICAgICAgLy8gYmF0Y2hlZFVwZGF0ZXMgb3IgYSBsaWZlY3ljbGUuIFdlIHNob3VsZCBvbmx5IGZsdXNoXG4gICAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbm91cyB3b3JrLCBub3QgdGFzayB3b3JrLlxuICAgICAgICAgICAgICAgICAgcGVyZm9ybVdvcmsoU3luY2hyb25vdXNQcmlvcml0eSQxLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gRmx1c2ggYm90aCBzeW5jaHJvbm91cyBhbmQgdGFzayB3b3JrLlxuICAgICAgICAgICAgICAgICAgcGVyZm9ybVdvcmsoVGFza1ByaW9yaXR5JDEsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBUYXNrUHJpb3JpdHkkMTpcbiAgICAgICAgICAgICAgICAhaXNCYXRjaGluZ1VwZGF0ZXMgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXNrIHVwZGF0ZXMgY2FuIG9ubHkgYmUgc2NoZWR1bGVkIGFzIGEgbmVzdGVkIHVwZGF0ZSBvciBpbnNpZGUgYmF0Y2hlZFVwZGF0ZXMuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBjYWxsYmFjayB0byBwZXJmb3JtIHRoZSB3b3JrIGxhdGVyLlxuICAgICAgICAgICAgICAgIGlmICghaXNDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1EZWZlcnJlZFdvcmspO1xuICAgICAgICAgICAgICAgICAgaXNDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50JDUpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJpb3JpdHlDb250ZXh0KGZpYmVyLCBmb3JjZUFzeW5jKSB7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUNvbnRleHQ7XG4gICAgaWYgKHByaW9yaXR5TGV2ZWwgPT09IE5vV29yayQyKSB7XG4gICAgICBpZiAoIXVzZVN5bmNTY2hlZHVsaW5nIHx8IGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcyB8fCBmb3JjZUFzeW5jKSB7XG4gICAgICAgIHByaW9yaXR5TGV2ZWwgPSBMb3dQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW9yaXR5TGV2ZWwgPSBTeW5jaHJvbm91c1ByaW9yaXR5JDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaW4gYSBiYXRjaCwgb3IgaWYgd2UncmUgYWxyZWFkeSBwZXJmb3JtaW5nIHdvcmssIGRvd25ncmFkZSBzeW5jXG4gICAgLy8gcHJpb3JpdHkgdG8gdGFzayBwcmlvcml0eVxuICAgIGlmIChwcmlvcml0eUxldmVsID09PSBTeW5jaHJvbm91c1ByaW9yaXR5JDEgJiYgKGlzUGVyZm9ybWluZ1dvcmsgfHwgaXNCYXRjaGluZ1VwZGF0ZXMpKSB7XG4gICAgICByZXR1cm4gVGFza1ByaW9yaXR5JDE7XG4gICAgfVxuICAgIHJldHVybiBwcmlvcml0eUxldmVsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVFcnJvclJlY292ZXJ5KGZpYmVyKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVJbXBsKGZpYmVyLCBUYXNrUHJpb3JpdHkkMSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBhbHJlYWR5IGluc2lkZSBhIGJhdGNoLCB3ZSBuZWVkIHRvIGZsdXNoIGFueSB0YXNrIHdvcmtcbiAgICAgIC8vIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICBpZiAoIWlzUGVyZm9ybWluZ1dvcmsgJiYgIWlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIHBlcmZvcm1Xb3JrKFRhc2tQcmlvcml0eSQxLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzSXNVbmJhdGNoaW5nVXBkYXRlcyA9IGlzVW5iYXRjaGluZ1VwZGF0ZXM7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICAvLyBUaGlzIGlzIG9ubHkgdHJ1ZSBpZiB3ZSdyZSBuZXN0ZWQgaW5zaWRlIGJhdGNoZWRVcGRhdGVzLlxuICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNVbmJhdGNoaW5nVXBkYXRlcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFN5bmMoYmF0Y2gpIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5Q29udGV4dCA9IHByaW9yaXR5Q29udGV4dDtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgcHJpb3JpdHlDb250ZXh0ID0gU3luY2hyb25vdXNQcmlvcml0eSQxO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmF0Y2goKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgcHJpb3JpdHlDb250ZXh0ID0gcHJldmlvdXNQcmlvcml0eUNvbnRleHQ7XG5cbiAgICAgICEhaXNQZXJmb3JtaW5nV29yayA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoVGFza1ByaW9yaXR5JDEsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5Q29udGV4dCA9IHByaW9yaXR5Q29udGV4dDtcbiAgICBwcmlvcml0eUNvbnRleHQgPSBMb3dQcmlvcml0eTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHByaW9yaXR5Q29udGV4dCA9IHByZXZpb3VzUHJpb3JpdHlDb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2NoZWR1bGVVcGRhdGU6IHNjaGVkdWxlVXBkYXRlLFxuICAgIGdldFByaW9yaXR5Q29udGV4dDogZ2V0UHJpb3JpdHlDb250ZXh0LFxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuICAgIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzXG4gIH07XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRDb250ZXh0Rm9yU3VidHJlZVxuICogXG4gKi9cblxuXG5cblxuXG5cbnZhciBnZXRDb250ZXh0RmliZXIgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgaW5qZWN0aW9uIGZvciBmaWJlciBnZXRDb250ZXh0Rm9yU3VidHJlZScpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcF8xLmdldChwYXJlbnRDb21wb25lbnQpO1xuICBpZiAodHlwZW9mIGluc3RhbmNlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dEZpYmVyKGluc3RhbmNlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX3Byb2Nlc3NDaGlsZENvbnRleHQoaW5zdGFuY2UuX2NvbnRleHQpO1xuICB9XG59XG5cbmdldENvbnRleHRGb3JTdWJ0cmVlLl9pbmplY3RGaWJlciA9IGZ1bmN0aW9uIChmbikge1xuICBnZXRDb250ZXh0RmliZXIgPSBmbjtcbn07XG5cbnZhciBnZXRDb250ZXh0Rm9yU3VidHJlZV8xID0gZ2V0Q29udGV4dEZvclN1YnRyZWU7XG5cbnZhciBhZGRUb3BMZXZlbFVwZGF0ZSA9IFJlYWN0RmliZXJVcGRhdGVRdWV1ZS5hZGRUb3BMZXZlbFVwZGF0ZTtcblxudmFyIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0ID0gUmVhY3RGaWJlckNvbnRleHQuZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQ7XG52YXIgaXNDb250ZXh0UHJvdmlkZXIgPSBSZWFjdEZpYmVyQ29udGV4dC5pc0NvbnRleHRQcm92aWRlcjtcbnZhciBwcm9jZXNzQ2hpbGRDb250ZXh0ID0gUmVhY3RGaWJlckNvbnRleHQucHJvY2Vzc0NoaWxkQ29udGV4dDtcblxudmFyIGNyZWF0ZUZpYmVyUm9vdCA9IFJlYWN0RmliZXJSb290LmNyZWF0ZUZpYmVyUm9vdDtcblxuXG5cbnZhciBIb3N0Q29tcG9uZW50JDMgPSBSZWFjdFR5cGVPZldvcmsuSG9zdENvbXBvbmVudDtcblxue1xuICB2YXIgd2FybmluZyQxOCA9IHJlcXVpcmUkJDA7XG4gIHZhciBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xO1xuICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlcl8xO1xuICB2YXIgZ2V0Q29tcG9uZW50TmFtZSQ0ID0gZ2V0Q29tcG9uZW50TmFtZV8xO1xufVxuXG52YXIgZmluZEN1cnJlbnRIb3N0RmliZXIkMSA9IFJlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5maW5kQ3VycmVudEhvc3RGaWJlcjtcbnZhciBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMkMSA9IFJlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5maW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHM7XG5cblxuXG5nZXRDb250ZXh0Rm9yU3VidHJlZV8xLl9pbmplY3RGaWJlcihmdW5jdGlvbiAoZmliZXIpIHtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gIHJldHVybiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikgPyBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0LCBmYWxzZSkgOiBwYXJlbnRDb250ZXh0O1xufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlclNjaGVkdWxlciA9IFJlYWN0RmliZXJTY2hlZHVsZXIoY29uZmlnKSxcbiAgICAgIHNjaGVkdWxlVXBkYXRlID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVVcGRhdGUsXG4gICAgICBnZXRQcmlvcml0eUNvbnRleHQgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5nZXRQcmlvcml0eUNvbnRleHQsXG4gICAgICBiYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmJhdGNoZWRVcGRhdGVzLFxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICBmbHVzaFN5bmMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5mbHVzaFN5bmMsXG4gICAgICBkZWZlcnJlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5kZWZlcnJlZFVwZGF0ZXM7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHtcbiAgICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyJDEucGhhc2UgPT09ICdyZW5kZXInICYmIFJlYWN0RGVidWdDdXJyZW50RmliZXIkMS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHdhcm5pbmckMTgoZmFsc2UsICdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZSQ0KFJlYWN0RGVidWdDdXJyZW50RmliZXIkMS5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBpcyBhbiBhc3luYyB3cmFwcGVyIGNvbXBvbmVudC4gSWYgc28sIHRyZWF0XG4gICAgLy8gdXBkYXRlcyB0byB0aGUgcm9vdCBhcyBhc3luYy4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBidXQgbGV0cyB1cyBhdm9pZCBhIHNlcGFyYXRlXG4gICAgLy8gYHJlbmRlckFzeW5jYCBBUEkuXG4gICAgdmFyIGZvcmNlQXN5bmMgPSBSZWFjdEZlYXR1cmVGbGFnc18xLmVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC50eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlO1xuICAgIHZhciBwcmlvcml0eUxldmVsID0gZ2V0UHJpb3JpdHlDb250ZXh0KGN1cnJlbnQsIGZvcmNlQXN5bmMpO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAge1xuICAgICAgd2FybmluZyQxOChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYWRkVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgbmV4dFN0YXRlLCBjYWxsYmFjaywgcHJpb3JpdHlMZXZlbCk7XG4gICAgc2NoZWR1bGVVcGRhdGUoY3VycmVudCwgcHJpb3JpdHlMZXZlbCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lckluZm8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbyk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcblxuICAgICAge1xuICAgICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlXzEocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG5cbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50JDM6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyJDEoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyQxKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgVEVYVF9OT0RFJDMgPSBIVE1MTm9kZVR5cGVfMS5URVhUX05PREU7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSQzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRfMSA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvcl8xID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUkJDEsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUkJDEgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlJCQxID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3JfMSgpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XzEobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldF8xKG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb25fMSA9IFJlYWN0RE9NU2VsZWN0aW9uO1xuXG52YXIgRUxFTUVOVF9OT0RFJDIgPSBIVE1MTm9kZVR5cGVfMS5FTEVNRU5UX05PREU7XG5cblxuXG5cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgICAgdmFyIGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUkMikge1xuICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbl8xLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbl8xLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb25fMSA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VmVyc2lvblxuICovXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMC4wJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZERPTU5vZGVcbiAqIFxuICovXG5cblxuXG52YXIgRUxFTUVOVF9OT0RFJDMgPSBIVE1MTm9kZVR5cGVfMS5FTEVNRU5UX05PREU7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQzID0gUmVhY3RHbG9iYWxTaGFyZWRTdGF0ZV8xLlJlYWN0Q3VycmVudE93bmVyO1xuXG5cblxuXG57XG4gIHZhciB3YXJuaW5nJDI3ID0gcmVxdWlyZSQkMDtcbn1cblxudmFyIGZpbmRGaWJlciA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBpbmplY3Rpb24gZm9yIGZpYmVyIGZpbmRET01Ob2RlJyk7XG59O1xudmFyIGZpbmRTdGFjayA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBpbmplY3Rpb24gZm9yIHN0YWNrIGZpbmRET01Ob2RlJyk7XG59O1xuXG52YXIgZmluZERPTU5vZGUgPSBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgaXNGaWJlciA9IHR5cGVvZiBvd25lci50YWcgPT09ICdudW1iZXInO1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gaXNGaWJlciA/IG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgOiBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI7XG4gICAgICB3YXJuaW5nJDI3KHdhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lXzEob3duZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaWYgKGlzRmliZXIpIHtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUkMykge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB2YXIgaW5zdCA9IFJlYWN0SW5zdGFuY2VNYXBfMS5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAodHlwZW9mIGluc3QudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGZpbmRGaWJlcihpbnN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbmRTdGFjayhpbnN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSk7XG4gIH1cbn07XG5cbmZpbmRET01Ob2RlLl9pbmplY3RGaWJlciA9IGZ1bmN0aW9uIChmbikge1xuICBmaW5kRmliZXIgPSBmbjtcbn07XG5maW5kRE9NTm9kZS5faW5qZWN0U3RhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgZmluZFN0YWNrID0gZm47XG59O1xuXG52YXIgZmluZERPTU5vZGVfMSA9IGZpbmRET01Ob2RlO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBsb3dQcmlvcml0eVdhcm5pbmdcbiAqL1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmdfMSA9IGxvd1ByaW9yaXR5V2FybmluZyQxO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIHZhciB3YXJuaW5nJDI4ID0gcmVxdWlyZSQkMDtcblxuICB2YXIgX3JlcXVpcmUkMTMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyXzEsXG4gICAgICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYgPSBfcmVxdWlyZSQxMy5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuXG5cbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8kMSA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBnZXRPd25lckluZm8gPSBmdW5jdGlvbiAoY2hpbGRJbnN0YW5jZSwgY2hpbGRUYWcsIGFuY2VzdG9ySW5zdGFuY2UsIGFuY2VzdG9yVGFnLCBpc1BhcmVudCkge1xuICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgIHZhciBpO1xuXG4gICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lXzEoaW5zdCkgfHwgVU5LTk9XTjtcbiAgICB9KTtcbiAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVfMShpbnN0KSB8fCBVTktOT1dOO1xuICAgIH0pO1xuICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGdldENvbXBvbmVudE5hbWVfMShjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXSkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgIGlzUGFyZW50ID8gW10gOiBbJy4uLiddLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgIHJldHVybiBvd25lckluZm87XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmckMSA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgd2FybmluZyQyOChjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IuaW5zdGFuY2U7XG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciBhZGRlbmR1bTtcblxuICAgIGlmIChjaGlsZEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIGFkZGVuZHVtID0gJyBTZWUgJyArIGdldE93bmVySW5mbyhjaGlsZEluc3RhbmNlLCBjaGlsZFRhZywgYW5jZXN0b3JJbnN0YW5jZSwgYW5jZXN0b3JUYWcsICEhaW52YWxpZFBhcmVudCkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG4gICAgfVxuXG4gICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgYWRkZW5kdW07XG4gICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9IFwiIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gXCIgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICB9XG4gICAgICB3YXJuaW5nJDI4KGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8sIGFkZGVuZHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyQyOChmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmckMS5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmdfMSA9IHZhbGlkYXRlRE9NTmVzdGluZyQxO1xuXG52YXIgSG9zdENvbXBvbmVudCQxMSA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Q29tcG9uZW50O1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBpZiAoaW5zdC5faG9zdFBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0LnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICBkbyB7XG4gICAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICAgIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQkMTEpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB3aGlsZSAoaW5zdEIpIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0byAmJiB0byAhPT0gY29tbW9uKSB7XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yIChpID0gcGF0aFRvLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9baV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG52YXIgUmVhY3RUcmVlVHJhdmVyc2FsID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViXzEuZ2V0TGlzdGVuZXI7XG5cbntcbiAgdmFyIHdhcm5pbmckMjkgPSByZXF1aXJlJCQwO1xufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgd2FybmluZyQyOShpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvXzEoZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG9fMShldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIFJlYWN0VHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IFJlYWN0VHJlZVRyYXZlcnNhbC5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgUmVhY3RUcmVlVHJhdmVyc2FsLnRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvXzEoZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50b18xKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZF8xKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWRfMShldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgUmVhY3RUcmVlVHJhdmVyc2FsLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWRfMShldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxudmFyIEV2ZW50UHJvcGFnYXRvcnNfMSA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICogXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0VGV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QgPSBudWxsO1xuICAgIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFRleHQoKTtcbiAgICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gICAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbiAgfSxcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QpIHtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yXzEoKV07XG4gIH1cbn07XG5cbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVfMSA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxue1xuICB2YXIgd2FybmluZyQzMCA9IHJlcXVpcmUkJDA7XG59XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hdGl2ZUV2ZW50JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG4gIGFkZEV2ZW50UG9vbGluZ1RvKENsYXNzKTtcbn07XG5cbi8qKiBQcm94eWluZyBhZnRlciBldmVyeXRoaW5nIHNldCBvbiBTeW50aGV0aWNFdmVudFxuICAqIHRvIHJlc29sdmUgUHJveHkgaXNzdWUgb24gc29tZSBXZWJLaXQgYnJvd3NlcnNcbiAgKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICAqL1xue1xuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHRhcmdldCwgT2JqZWN0LmNyZWF0ZSh0YXJnZXQucHJvdG90eXBlKSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3MpLCB7XG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmckMzAoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbnZhciBTeW50aGV0aWNFdmVudF8xID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICogQHBhcmFtIHs/b2JqZWN0fSBnZXRWYWxcbiAgKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICB3YXJuaW5nJDMwKHdhcm5pbmdDb25kaXRpb24sIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb29sZWRFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucG9wKCk7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgIShldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IpID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gZXZlbnQgaW5zdGFuY2UgIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50XzEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50XzEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudF8xID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudF8xLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudF8xLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnRfMSA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblN0YXJ0JywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblN0YXJ0JzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbnZhciBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlXzEuaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZykge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVfMS5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudF8xLmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzXzEuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RvcExldmVsVHlwZXN9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZV8xLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZV8xLnJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudF8xLmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9yc18xLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXzEgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqIFxuICovXG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gIGNvbG9yOiB0cnVlLFxuICBkYXRlOiB0cnVlLFxuICBkYXRldGltZTogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgZW1haWw6IHRydWUsXG4gIG1vbnRoOiB0cnVlLFxuICBudW1iZXI6IHRydWUsXG4gIHBhc3N3b3JkOiB0cnVlLFxuICByYW5nZTogdHJ1ZSxcbiAgc2VhcmNoOiB0cnVlLFxuICB0ZWw6IHRydWUsXG4gIHRleHQ6IHRydWUsXG4gIHRpbWU6IHRydWUsXG4gIHVybDogdHJ1ZSxcbiAgd2VlazogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzVGV4dElucHV0RWxlbWVudF8xID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnRfMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRfMS5lbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIEV2ZW50UHJvcGFnYXRvcnNfMS5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldF8xKG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0R2VuZXJpY0JhdGNoaW5nXzEuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yl8xLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yl8xLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuICBpZiAoaW5wdXRWYWx1ZVRyYWNraW5nXzEudXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZF8xKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIoaW5zdCwgbm9kZSkge1xuICAvLyBUT0RPOiBJbiBJRSwgaW5zdCBpcyBvY2Nhc2lvbmFsbHkgbnVsbC4gV2h5P1xuICBpZiAoaW5zdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmliZXIgYW5kIFJlYWN0RE9NIGtlZXAgd3JhcHBlciBzdGF0ZSBpbiBzZXBhcmF0ZSBwbGFjZXNcbiAgdmFyIHN0YXRlID0gaW5zdC5fd3JhcHBlclN0YXRlIHx8IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHZhciB2YWx1ZSA9ICcnICsgbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlXzEuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnRfMSh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIENoYW5nZUV2ZW50UGx1Z2luXzEgPSBDaGFuZ2VFdmVudFBsdWdpbjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NRXZlbnRQbHVnaW5PcmRlclxuICovXG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cblxudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbnZhciBET01FdmVudFBsdWdpbk9yZGVyXzEgPSBET01FdmVudFBsdWdpbk9yZGVyO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0XzEoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50XzEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50XzEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgU3ludGhldGljVUlFdmVudF8xID0gU3ludGhldGljVUlFdmVudDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKi9cblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZV8xID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZV8xLFxuICBidXR0b246IG51bGwsXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudF8xLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50XzEuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudF8xID0gU3ludGhldGljTW91c2VFdmVudDtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZV8xLmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnRfMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQyLm1vdXNlTGVhdmUsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudF8xLmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9yc18xLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcblxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbl8xID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG52YXIgRE9DVU1FTlRfTk9ERSQyID0gSFRNTE5vZGVUeXBlXzEuRE9DVU1FTlRfTk9ERTtcblxuXG5cblxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMkMyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbnRleHRNZW51JywgJ3RvcEZvY3VzJywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJywgJ3RvcE1vdXNlVXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLmlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXM7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uXzEuaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudF8xLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnNfMS5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSQyID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZV8xLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnRfMSh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgU2VsZWN0RXZlbnRQbHVnaW5fMSA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnRfMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnRfMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50XzEgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudF8xLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudF8xLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRfMSA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50XzEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnRfMS5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50XzEgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudENoYXJDb2RlXG4gKi9cblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIGdldEV2ZW50Q2hhckNvZGVfMSA9IGdldEV2ZW50Q2hhckNvZGU7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsXG4gIDExMzogJ0YyJyxcbiAgMTE0OiAnRjMnLFxuICAxMTU6ICdGNCcsXG4gIDExNjogJ0Y1JyxcbiAgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsXG4gIDExOTogJ0Y4JyxcbiAgMTIwOiAnRjknLFxuICAxMjE6ICdGMTAnLFxuICAxMjI6ICdGMTEnLFxuICAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZV8xKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIGdldEV2ZW50S2V5XzEgPSBnZXRFdmVudEtleTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleV8xLFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZV8xLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGVfMShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZV8xKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnRfMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudF8xLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnRfMSA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudF8xLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50XzEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY0RyYWdFdmVudF8xID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXzFcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnRfMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudF8xLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnRfMSA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50XzEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50XzEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudF8xID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnRfMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudF8xLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnRfMSA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkNCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEFib3J0JzpcbiAgICAgIGNhc2UgJ3RvcENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcbiAgICAgIGNhc2UgJ3RvcENsb3NlJzpcbiAgICAgIGNhc2UgJ3RvcER1cmF0aW9uQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuZGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcbiAgICAgIGNhc2UgJ3RvcEludmFsaWQnOlxuICAgICAgY2FzZSAndG9wTG9hZCc6XG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZE1ldGFkYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XG4gICAgICBjYXNlICd0b3BQYXVzZSc6XG4gICAgICBjYXNlICd0b3BQbGF5JzpcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndG9wUmF0ZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BSZXNldCc6XG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxuICAgICAgY2FzZSAndG9wU2Vla2luZyc6XG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XG4gICAgICBjYXNlICd0b3BTdXNwZW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxuICAgICAgY2FzZSAndG9wVG9nZ2xlJzpcbiAgICAgIGNhc2UgJ3RvcFZvbHVtZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BXYWl0aW5nJzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudF8xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGVfMShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XzE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50XzE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudF8xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudF8xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnRfMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50XzE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnRfMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudF8xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnRfMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudF8xO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IHZvaWQgMDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzXzEuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW5fMSA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5SZWFjdERPTUV2ZW50TGlzdGVuZXJfMS5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS5oYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbkV2ZW50UGx1Z2luSHViXzEuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcl8xKTtcbkV2ZW50UGx1Z2luVXRpbHNfMS5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWVfMSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuRXZlbnRQbHVnaW5IdWJfMS5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luXzEsXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXzEsXG4gIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbl8xLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW5fMSxcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpbl8xXG59KTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHlfMS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eV8xLmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5XzEuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHlfMS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5XzEuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHlfMS5pbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gIC8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gIC8vIG5hbWUgd2FybmluZ3MuXG4gIFByb3BlcnRpZXM6IHtcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIElFIG9ubHkgdHJ1ZS9mYWxzZSBpRnJhbWUgYXR0cmlidXRlXG4gICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMzA3Mih2PXZzLjg1KS5hc3B4XG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIGl0ZW1TY29wZSBpcyBmb3IgZm9yIE1pY3JvZGF0YSBzdXBwb3J0LlxuICAgIC8vIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgbXVzdCBzdGF5IGluIHRoZSB3aGl0ZS1saXN0IGJlY2F1c2UgdGhleSBoYXZlXG4gICAgLy8gZGlmZmVyZW50IGF0dHJpYnV0ZSBuYW1lcyAoc2VlIERPTUF0dHJpYnV0ZU5hbWVzIGJlbG93KVxuICAgIGFjY2VwdENoYXJzZXQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGh0bWxGb3I6IDAsXG4gICAgaHR0cEVxdWl2OiAwLFxuICAgIC8vIEF0dHJpYnV0ZXMgd2l0aCBtdXRhdGlvbiBtZXRob2RzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB3aGl0ZWxpc3RcbiAgICAvLyBTZXQgdGhlIHN0cmluZyBib29sZWFuIGZsYWcgdG8gYWxsb3cgdGhlIGJlaGF2aW9yXG4gICAgdmFsdWU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTU11dGF0aW9uTWV0aG9kczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gTnVtYmVyIGlucHV0cyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIHNvbWUgZWRnZSBjYXNlcyBpblxuICAgICAgLy8gQ2hyb21lLiBMZXQgZXZlcnl0aGluZyBlbHNlIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIGFzIG5vcm1hbC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1MyNpc3N1ZWNvbW1lbnQtMjM2MDc0MzI2XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsaWRpdHkgJiYgIW5vZGUudmFsaWRpdHkuYmFkSW5wdXQgJiYgbm9kZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IG5vZGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgYXNzaWduIGFuIGF0dHJpYnV0ZSBpZiB2YWxpZGF0aW9uIHJlcG9ydHMgYmFkXG4gICAgICAgIC8vIGlucHV0LiBDaHJvbWUgd2lsbCBjbGVhciB0aGUgdmFsdWUuIEFkZGl0aW9uYWxseSwgZG9uJ3RcbiAgICAgICAgLy8gb3BlcmF0ZSBvbiBpbnB1dHMgdGhhdCBoYXZlIGZvY3VzLCBvdGhlcndpc2UgQ2hyb21lIG1pZ2h0XG4gICAgICAgIC8vIHN0cmlwIG9mZiB0cmFpbGluZyBkZWNpbWFsIHBsYWNlcyBhbmQgY2F1c2UgdGhlIHVzZXInc1xuICAgICAgICAvLyBjdXJzb3IgcG9zaXRpb24gdG8ganVtcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gUmVhY3RET01JbnB1dCwgd2UgaGF2ZSBhbiBvbkJsdXIgZXZlbnQgdGhhdCB3aWxsIHRyaWdnZXJcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBhZ2FpbiB3aGVuIGZvY3VzIGlzIGxvc3QuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ18xID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBET01Qcm9wZXJ0eV8xLmluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsXG4gKiBuYW1lc3BhY2luZywgb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LlxuICpcbiAqIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAqIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gKiBuYW1lIHdhcm5pbmdzLlxuICpcbiAqIFNWRyBBdHRyaWJ1dGVzIExpc3Q6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2F0dGluZGV4Lmh0bWxcbiAqIFNNSUwgU3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zbWlsXG4gKi9cbnZhciBBVFRSUyA9IFsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneC1oZWlnaHQnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sbnM6eGxpbmsnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ107XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGF1dG9SZXZlcnNlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBwcmVzZXJ2ZUFscGhhOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYSdcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9XG59O1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbkFUVFJTLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciByZWFjdE5hbWUgPSBvcmlnaW5hbC5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcblxuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW3JlYWN0TmFtZV0gPSAwO1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1tyZWFjdE5hbWVdID0gb3JpZ2luYWw7XG59KTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnXzEgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuRE9NUHJvcGVydHlfMS5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnXzEpO1xuRE9NUHJvcGVydHlfMS5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWdfMSk7XG5cbnZhciBpbmplY3RJbnRlcm5hbHMgPSBSZWFjdEZpYmVyRGV2VG9vbHNIb29rLmluamVjdEludGVybmFscztcblxudmFyIEVMRU1FTlRfTk9ERSA9IEhUTUxOb2RlVHlwZV8xLkVMRU1FTlRfTk9ERTtcbnZhciBURVhUX05PREUgPSBIVE1MTm9kZVR5cGVfMS5URVhUX05PREU7XG52YXIgQ09NTUVOVF9OT0RFID0gSFRNTE5vZGVUeXBlXzEuQ09NTUVOVF9OT0RFO1xudmFyIERPQ1VNRU5UX05PREUgPSBIVE1MTm9kZVR5cGVfMS5ET0NVTUVOVF9OT0RFO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSBIVE1MTm9kZVR5cGVfMS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuXG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9IERPTVByb3BlcnR5XzEuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxuXG5cblxudmFyIGdldENoaWxkTmFtZXNwYWNlID0gRE9NTmFtZXNwYWNlcy5nZXRDaGlsZE5hbWVzcGFjZTtcbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RET01GaWJlckNvbXBvbmVudF8xLmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEuY3JlYXRlVGV4dE5vZGU7XG52YXIgc2V0SW5pdGlhbFByb3BlcnRpZXMgPSBSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEuc2V0SW5pdGlhbFByb3BlcnRpZXM7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEuZGlmZlByb3BlcnRpZXM7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IFJlYWN0RE9NRmliZXJDb21wb25lbnRfMS51cGRhdGVQcm9wZXJ0aWVzO1xudmFyIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMgPSBSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEuZGlmZkh5ZHJhdGVkUHJvcGVydGllcztcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gUmVhY3RET01GaWJlckNvbXBvbmVudF8xLmRpZmZIeWRyYXRlZFRleHQ7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCA9IFJlYWN0RE9NRmliZXJDb21wb25lbnRfMS53YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50O1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSBSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEud2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSBSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEud2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50O1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCA9IFJlYWN0RE9NRmliZXJDb21wb25lbnRfMS53YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ7XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5wcmVjYWNoZUZpYmVyTm9kZTtcbnZhciB1cGRhdGVGaWJlclByb3BzID0gUmVhY3RET01Db21wb25lbnRUcmVlXzEudXBkYXRlRmliZXJQcm9wcztcblxuXG57XG4gIHZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBsb3dQcmlvcml0eVdhcm5pbmdfMTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlJCQwO1xuICB2YXIgdmFsaWRhdGVET01OZXN0aW5nID0gdmFsaWRhdGVET01OZXN0aW5nXzE7XG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm87XG5cblxuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cblxuXG5SZWFjdENvbnRyb2xsZWRDb21wb25lbnRfMS5pbmplY3Rpb24uaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50XzEpO1xuZmluZERPTU5vZGVfMS5faW5qZWN0RmliZXIoZnVuY3Rpb24gKGZpYmVyKSB7XG4gIHJldHVybiBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlKGZpYmVyKTtcbn0pO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSBSZWFjdEZpYmVyUmVjb25jaWxlcih7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gKHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgaWYgKHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgICAgdHlwZSA9ICcjZG9jdW1lbnQnO1xuICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgIH1cbiAgICB7XG4gICAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZywgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH0sXG4gIGdldENoaWxkSG9zdENvbnRleHQ6IGZ1bmN0aW9uIChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSkge1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gICAgfVxuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50c0VuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS5pc0VuYWJsZWQoKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IFJlYWN0SW5wdXRTZWxlY3Rpb25fMS5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcl8xLnNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RJbnB1dFNlbGVjdGlvbl8xLnJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJfMS5zZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB7XG4gICAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgbnVsbCwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG51bGwsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBudWxsLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICB9LFxuICBjb21taXRNb3VudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICB9LFxuICBjb21taXRVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgPT09ICdzdHJpbmcnO1xuICB9LFxuICByZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gICAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9LFxuICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG4gIH0sXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9LFxuICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9LFxuICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0sXG4gIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNhbkh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiBpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHR5cGUgPT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH0sXG4gIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2Uubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbiAgfSxcbiAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgdmFyIG5leHQgPSBwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkO1xuICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9LFxuICBoeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gICAgLy8gZ2V0IGF0dGFjaGVkLlxuICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgfSxcbiAgaHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfSxcbiAgZGlkTm90SHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG4gIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH0sXG5cblxuICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6IFJlYWN0RE9NRnJhbWVTY2hlZHVsaW5nLnJJQyxcblxuICB1c2VTeW5jU2NoZWR1bGluZzogIVJlYWN0RE9NRmVhdHVyZUZsYWdzXzEuZmliZXJBc3luY1NjaGVkdWxpbmdcbn0pO1xuXG5SZWFjdEdlbmVyaWNCYXRjaGluZ18xLmluamVjdGlvbi5pbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzKERPTVJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzKTtcblxudmFyIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICB3YXJuaW5nKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgUmVhY3RET01Db21wb25lbnRUcmVlXzEuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE3LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld1Jvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyKTtcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBuZXdSb290O1xuICAgIC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCBuZXdSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBET01SZW5kZXJlci5nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gIC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIHJldHVybiBSZWFjdFBvcnRhbC5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxudmFyIFJlYWN0RE9NRmliZXIgPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGh5ZHJhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIHRydWUsIGNhbGxiYWNrKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcF8xLmhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFSZWFjdERPTUNvbXBvbmVudFRyZWVfMS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgUmVhY3RET01Db21wb25lbnRUcmVlXzEuZ2V0SW5zdGFuY2VGcm9tTm9kZShfcm9vdEVsKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJiAhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgICAgICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cblxuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGVfMSxcblxuICAvLyBUZW1wb3JhcnkgYWxpYXMgc2luY2Ugd2UgYWxyZWFkeSBzaGlwcGVkIFJlYWN0IDE2IFJDIHdpdGggaXQuXG4gIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy5cbiAgdW5zdGFibGVfY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0R2VuZXJpY0JhdGNoaW5nXzEuYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yl8xLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnlfMSxcbiAgICBFdmVudFByb3BhZ2F0b3JzOiBFdmVudFByb3BhZ2F0b3JzXzEsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRfMSxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZV8xLFxuICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjogUmVhY3RET01FdmVudExpc3RlbmVyXzFcbiAgfVxufTtcblxudmFyIGZvdW5kRGV2VG9vbHMgPSBpbmplY3RJbnRlcm5hbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogUmVhY3RET01Db21wb25lbnRUcmVlXzEuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlLFxuICAvLyBUaGlzIGlzIGFuIGVudW0gYmVjYXVzZSB3ZSBtYXkgYWRkIG1vcmUgKGUuZy4gcHJvZmlsZXIgYnVpbGQpXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyRW50cnkgPSBSZWFjdERPTUZpYmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmliZXJFbnRyeTtcblxufSkoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar emptyFunction = __webpack_require__(1);\n\n/**\n * Upstream version of event listener. Does not take into account specific\n * nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function listen(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function remove() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  },\n\n  /**\n   * Listen to DOM events during the capture phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  capture: function capture(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, true);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, true);\n        }\n      };\n    } else {\n      if (true) {\n        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');\n      }\n      return {\n        remove: emptyFunction\n      };\n    }\n  },\n\n  registerDefault: function registerDefault() {}\n};\n\nmodule.exports = EventListener;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcz9hM2VhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar hyphenate = __webpack_require__(21);\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzPzk4YmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzPzAwZjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar camelize = __webpack_require__(23);\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanM/ZmU1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanM/MGZlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar performance = __webpack_require__(25);\n\nvar performanceNow;\n\n/**\n * Detect if we can use `window.performance.now()` and gracefully fallback to\n * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now\n * because of Facebook's testing infrastructure.\n */\nif (performance.now) {\n  performanceNow = function performanceNow() {\n    return performance.now();\n  };\n} else {\n  performanceNow = function performanceNow() {\n    return Date.now();\n  };\n}\n\nmodule.exports = performanceNow;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanM/ZTcyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar ExecutionEnvironment = __webpack_require__(9);\n\nvar performance;\n\nif (ExecutionEnvironment.canUseDOM) {\n  performance = window.performance || window.msPerformance || window.webkitPerformance;\n}\n\nmodule.exports = performance || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2UuanM/MmIyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(27)(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz8yOTIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(1);\nvar invariant = __webpack_require__(4);\nvar warning = __webpack_require__(3);\nvar assign = __webpack_require__(5);\n\nvar ReactPropTypesSecret = __webpack_require__(8);\nvar checkPropTypes = __webpack_require__(6);\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (\"development\" !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcz8yNmQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzP2IyMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = __webpack_require__(30);\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzP2Q4MWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = __webpack_require__(31);\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcz9iOGVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzPzdmNjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIGRvYyA9IG9iamVjdCA/IG9iamVjdC5vd25lckRvY3VtZW50IHx8IG9iamVjdCA6IGRvY3VtZW50O1xuICB2YXIgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgZGVmYXVsdFZpZXcuTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIGRlZmF1bHRWaWV3Lk5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\n\nfunction focusNode(node) {\n  // IE8 can throw \"Can't move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch (e) {}\n}\n\nmodule.exports = focusNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzPzI1MzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcz9mNTRlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _AddOperationForm = __webpack_require__(35);\n\nvar _AddOperationForm2 = _interopRequireDefault(_AddOperationForm);\n\nvar _OperationList = __webpack_require__(36);\n\nvar _OperationList2 = _interopRequireDefault(_OperationList);\n\nvar _Chart = __webpack_require__(38);\n\nvar _Chart2 = _interopRequireDefault(_Chart);\n\nvar _Utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MoneyPalApp = function (_React$Component) {\n    _inherits(MoneyPalApp, _React$Component);\n\n    function MoneyPalApp(props) {\n        _classCallCheck(this, MoneyPalApp);\n\n        var _this = _possibleConstructorReturn(this, (MoneyPalApp.__proto__ || Object.getPrototypeOf(MoneyPalApp)).call(this, props));\n\n        _this.showSort = function (e) {\n            e.preventDefault();\n            _this.setState({\n                showSort: true\n            });\n        };\n\n        _this.showFilter = function (e) {\n            e.preventDefault();\n            _this.setState({\n                showFilter: true\n            });\n        };\n\n        _this.hideSort = function (e) {\n            e.preventDefault();\n            _this.setState({\n                showSort: false\n            });\n        };\n\n        _this.hideFilter = function (e) {\n            e.preventDefault();\n            _this.setState({\n                showFilter: false\n            });\n        };\n\n        _this.changeSort = function (e) {\n            e.preventDefault();\n            _this.setState({\n                currentSort: e.target.value\n            });\n        };\n\n        _this.changeFilter = function (e) {\n            e.preventDefault();\n            _this.setState({\n                currentFilter: e.target.value\n            });\n        };\n\n        _this.addMinus = function (e) {\n            e.preventDefault();\n            _this.setState({\n                currentBlock: 'add',\n                currentOperation: 'expenses'\n            });\n        };\n\n        _this.addPlus = function (e) {\n            e.preventDefault();\n            _this.setState({\n                currentBlock: 'add',\n                currentOperation: 'incomes'\n            });\n        };\n\n        _this.toHome = function (e) {\n            e.preventDefault();\n            _this.setState({\n                currentBlock: 'operations',\n                currentOperation: null\n            });\n        };\n\n        _this.showChart = function (e) {\n            e.preventDefault();\n            _this.setState({\n                currentBlock: 'chart',\n                currentOperation: null\n            });\n        };\n\n        _this.calcAmount = function (arrOperations) {\n            return arrOperations.reduce(function (a, b) {\n                return parseFloat(a) + parseFloat(b.summ);\n            }, 0);\n        };\n\n        _this.state = {\n            operations: [],\n            currentBlock: 'operations',\n            showSort: false,\n            showFilter: false,\n            currentFilter: null,\n            currentSort: null,\n            amount: 0,\n            currency: 'usd',\n            currentOperation: null\n        };\n\n        _this.addMinus = _this.addMinus.bind(_this);\n        _this.addPlus = _this.addPlus.bind(_this);\n        _this.toHome = _this.toHome.bind(_this);\n        _this.showChart = _this.showChart.bind(_this);\n        _this.handleOperationDelete = _this.handleOperationDelete.bind(_this);\n        _this.handleOperationAdd = _this.handleOperationAdd.bind(_this);\n\n        _this.showSort = _this.showSort.bind(_this);\n        _this.showFilter = _this.showFilter.bind(_this);\n\n        _this.changeSort = _this.changeSort.bind(_this);\n        _this.changeFilter = _this.changeFilter.bind(_this);\n\n        _this.getOperationList = _this.getOperationList.bind(_this);\n\n        return _this;\n    }\n\n    _createClass(MoneyPalApp, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            var lsOperations = JSON.parse(localStorage.getItem('operations'));\n            if (lsOperations) {\n                this.setState({\n                    operations: lsOperations,\n                    amount: this.calcAmount(lsOperations)\n                });\n            }\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate() {\n            var operations = JSON.stringify(this.state.operations);\n            localStorage.setItem('operations', operations);\n        }\n    }, {\n        key: 'handleOperationDelete',\n        value: function handleOperationDelete(operationId) {\n            var newOperations = this.state.operations.filter(function (operation) {\n                return operation.id !== operationId;\n            });\n            this.setState({\n                operations: newOperations,\n                amount: this.calcAmount(newOperations)\n            });\n        }\n    }, {\n        key: 'handleOperationAdd',\n        value: function handleOperationAdd(newOperation) {\n            var calcAmount = parseFloat(this.state.amount) + parseFloat(newOperation.summ);\n            this.setState({\n                operations: [newOperation].concat(_toConsumableArray(this.state.operations)),\n                amount: calcAmount,\n                currentBlock: 'operations'\n            });\n        }\n    }, {\n        key: 'getOperationList',\n        value: function getOperationList() {\n            var _this2 = this;\n\n            var operations = this.state.operations;\n\n            if (this.state.currentFilter && this.state.currentFilter.length) operations = operations.filter(function (operation) {\n                return operation.direction == _this2.state.currentFilter;\n            });\n            if (this.state.currentSort) {\n                var _state$currentSort$sp = this.state.currentSort.split('-'),\n                    _state$currentSort$sp2 = _slicedToArray(_state$currentSort$sp, 2),\n                    sortField = _state$currentSort$sp2[0],\n                    sortOrder = _state$currentSort$sp2[1];\n\n                operations.sort(function (a, b) {\n                    return sortOrder == 'asc' ? a[sortField] - b[sortField] : b[sortField] - a[sortField];\n                });\n            }\n            return operations;\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement(\n                'div',\n                { className: 'app container text-center' },\n                _react2.default.createElement(\n                    'div',\n                    { className: 'row' },\n                    _react2.default.createElement(\n                        'div',\n                        { className: 'col-sm-6 col-sm-push-3' },\n                        _react2.default.createElement(\n                            'div',\n                            { className: 'panel panel-default' },\n                            _react2.default.createElement(\n                                'div',\n                                { className: 'panel-heading' },\n                                _react2.default.createElement(\n                                    'h2',\n                                    { className: 'app__header' },\n                                    'MoneyPalApp'\n                                )\n                            ),\n                            _react2.default.createElement(\n                                'div',\n                                { className: 'app_amount panel-heading' },\n                                _react2.default.createElement(\n                                    'div',\n                                    { className: 'row' },\n                                    _react2.default.createElement(\n                                        'div',\n                                        { className: 'col-sm-3 text-left' },\n                                        this.state.currentBlock == 'operations' && _react2.default.createElement(\n                                            'i',\n                                            { className: 'material-icons', onClick: this.addMinus },\n                                            'remove_circle_outline'\n                                        ),\n                                        this.state.currentBlock != 'operations' && _react2.default.createElement(\n                                            'i',\n                                            { className: 'material-icons', onClick: this.toHome },\n                                            'arrow_back'\n                                        )\n                                    ),\n                                    _react2.default.createElement(\n                                        'div',\n                                        { className: 'col-sm-6 amount-container' },\n                                        '$ ',\n                                        _react2.default.createElement(\n                                            'span',\n                                            { className: 'amount' },\n                                            this.state.amount\n                                        )\n                                    ),\n                                    _react2.default.createElement(\n                                        'div',\n                                        { className: 'col-sm-3 text-right' },\n                                        this.state.currentBlock == 'operations' && _react2.default.createElement(\n                                            'i',\n                                            { className: 'material-icons', onClick: this.addPlus },\n                                            'add_circle_outline'\n                                        )\n                                    )\n                                )\n                            ),\n                            _react2.default.createElement(\n                                'div',\n                                { className: 'panel-body' },\n                                _react2.default.createElement(\n                                    'div',\n                                    { className: 'app_container' },\n                                    this.state.currentBlock == 'operations' && _react2.default.createElement(\n                                        'div',\n                                        null,\n                                        _react2.default.createElement(\n                                            'div',\n                                            { className: 'app_operationListMenu' },\n                                            _react2.default.createElement(\n                                                'div',\n                                                { className: 'col-sm-8' },\n                                                this.state.showSort && _react2.default.createElement(\n                                                    'select',\n                                                    { id: '', name: 'sort', className: 'form-control', defaultValue: this.state.currentSort, onChange: this.changeSort },\n                                                    Object.keys(_Utils.sortVariants).map(function (sort) {\n                                                        return _react2.default.createElement(\n                                                            'option',\n                                                            { key: sort, value: sort },\n                                                            _Utils.sortVariants[sort]\n                                                        );\n                                                    })\n                                                ),\n                                                this.state.showFilter && _react2.default.createElement(\n                                                    'select',\n                                                    { id: '', name: 'sort', className: 'form-control', defaultValue: this.state.currentFilter, onChange: this.changeFilter },\n                                                    _react2.default.createElement(\n                                                        'option',\n                                                        { value: '' },\n                                                        '\\u0412\\u0441\\u0435'\n                                                    ),\n                                                    Object.keys(_Utils.operationDirection).map(function (direction) {\n                                                        return _react2.default.createElement(\n                                                            'option',\n                                                            { key: direction, value: direction },\n                                                            _Utils.operationDirection[direction]\n                                                        );\n                                                    })\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'div',\n                                                { className: 'col-sm-4' },\n                                                (this.state.showSort || this.state.showFilter) && _react2.default.createElement(\n                                                    'div',\n                                                    null,\n                                                    this.state.showSort && _react2.default.createElement(\n                                                        'div',\n                                                        { className: 'pull-right' },\n                                                        _react2.default.createElement(\n                                                            'i',\n                                                            { className: 'material-icons', onClick: this.hideSort },\n                                                            'close'\n                                                        )\n                                                    ),\n                                                    this.state.showFilter && _react2.default.createElement(\n                                                        'div',\n                                                        { className: 'pull-right' },\n                                                        _react2.default.createElement(\n                                                            'i',\n                                                            { className: 'material-icons', onClick: this.hideFilter },\n                                                            'close'\n                                                        )\n                                                    )\n                                                ) || _react2.default.createElement(\n                                                    'div',\n                                                    null,\n                                                    _react2.default.createElement(\n                                                        'div',\n                                                        { className: 'pull-right' },\n                                                        _react2.default.createElement(\n                                                            'i',\n                                                            { className: 'material-icons', onClick: this.showSort },\n                                                            'sort'\n                                                        )\n                                                    ),\n                                                    _react2.default.createElement(\n                                                        'div',\n                                                        { className: 'pull-right' },\n                                                        _react2.default.createElement(\n                                                            'i',\n                                                            { className: 'material-icons', onClick: this.showFilter },\n                                                            'filter_list'\n                                                        )\n                                                    )\n                                                )\n                                            )\n                                        ),\n                                        _react2.default.createElement(_OperationList2.default, { operations: this.getOperationList(), onOperationDelete: this.handleOperationDelete })\n                                    ),\n                                    this.state.currentBlock == 'add' && _react2.default.createElement(_AddOperationForm2.default, { operation: this.state.currentOperation, onOperationAdd: this.handleOperationAdd }),\n                                    this.state.currentBlock == 'chart' && _react2.default.createElement(_Chart2.default, { operations: this.state.operations })\n                                )\n                            ),\n                            _react2.default.createElement(\n                                'div',\n                                { className: 'panel-footer' },\n                                this.state.currentBlock != 'chart' && _react2.default.createElement(\n                                    'i',\n                                    { className: 'material-icons', onClick: this.showChart },\n                                    'show_chart'\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n        }\n    }]);\n\n    return MoneyPalApp;\n}(_react2.default.Component);\n\n;\n\nexports.default = MoneyPalApp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Nb25leVBhbEFwcC5qc3g/ZWE2MSJdLCJuYW1lcyI6WyJNb25leVBhbEFwcCIsInByb3BzIiwic2hvd1NvcnQiLCJlIiwicHJldmVudERlZmF1bHQiLCJzZXRTdGF0ZSIsInNob3dGaWx0ZXIiLCJoaWRlU29ydCIsImhpZGVGaWx0ZXIiLCJjaGFuZ2VTb3J0IiwiY3VycmVudFNvcnQiLCJ0YXJnZXQiLCJ2YWx1ZSIsImNoYW5nZUZpbHRlciIsImN1cnJlbnRGaWx0ZXIiLCJhZGRNaW51cyIsImN1cnJlbnRCbG9jayIsImN1cnJlbnRPcGVyYXRpb24iLCJhZGRQbHVzIiwidG9Ib21lIiwic2hvd0NoYXJ0IiwiY2FsY0Ftb3VudCIsImFyck9wZXJhdGlvbnMiLCJyZWR1Y2UiLCJhIiwiYiIsInBhcnNlRmxvYXQiLCJzdW1tIiwic3RhdGUiLCJvcGVyYXRpb25zIiwiYW1vdW50IiwiY3VycmVuY3kiLCJiaW5kIiwiaGFuZGxlT3BlcmF0aW9uRGVsZXRlIiwiaGFuZGxlT3BlcmF0aW9uQWRkIiwiZ2V0T3BlcmF0aW9uTGlzdCIsImxzT3BlcmF0aW9ucyIsIkpTT04iLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzdHJpbmdpZnkiLCJzZXRJdGVtIiwib3BlcmF0aW9uSWQiLCJuZXdPcGVyYXRpb25zIiwiZmlsdGVyIiwib3BlcmF0aW9uIiwiaWQiLCJuZXdPcGVyYXRpb24iLCJsZW5ndGgiLCJkaXJlY3Rpb24iLCJzcGxpdCIsInNvcnRGaWVsZCIsInNvcnRPcmRlciIsInNvcnQiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7Ozs7Ozs7Ozs7O0lBSU1BLFc7OztBQUNGLHlCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsOEhBQ1RBLEtBRFM7O0FBQUEsY0ErQm5CQyxRQS9CbUIsR0ErQlIsYUFBSztBQUNaQyxjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWSCwwQkFBVTtBQURBLGFBQWQ7QUFHSCxTQXBDa0I7O0FBQUEsY0FxQ25CSSxVQXJDbUIsR0FxQ04sYUFBSztBQUNkSCxjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWQyw0QkFBWTtBQURGLGFBQWQ7QUFHSCxTQTFDa0I7O0FBQUEsY0EyQ25CQyxRQTNDbUIsR0EyQ1IsYUFBSztBQUNaSixjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWSCwwQkFBVTtBQURBLGFBQWQ7QUFHSCxTQWhEa0I7O0FBQUEsY0FpRG5CTSxVQWpEbUIsR0FpRE4sYUFBSztBQUNkTCxjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWQyw0QkFBWTtBQURGLGFBQWQ7QUFHSCxTQXREa0I7O0FBQUEsY0F3RG5CRyxVQXhEbUIsR0F3RE4sYUFBSztBQUNkTixjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWSyw2QkFBYVAsRUFBRVEsTUFBRixDQUFTQztBQURaLGFBQWQ7QUFHSCxTQTdEa0I7O0FBQUEsY0ErRG5CQyxZQS9EbUIsR0ErREosYUFBSztBQUNoQlYsY0FBRUMsY0FBRjtBQUNBLGtCQUFLQyxRQUFMLENBQWM7QUFDVlMsK0JBQWVYLEVBQUVRLE1BQUYsQ0FBU0M7QUFEZCxhQUFkO0FBR0gsU0FwRWtCOztBQUFBLGNBc0VuQkcsUUF0RW1CLEdBc0VSLGFBQUs7QUFDWlosY0FBRUMsY0FBRjtBQUNBLGtCQUFLQyxRQUFMLENBQWM7QUFDVlcsOEJBQWMsS0FESjtBQUVWQyxrQ0FBa0I7QUFGUixhQUFkO0FBSUgsU0E1RWtCOztBQUFBLGNBNkVuQkMsT0E3RW1CLEdBNkVULGFBQUs7QUFDWGYsY0FBRUMsY0FBRjtBQUNBLGtCQUFLQyxRQUFMLENBQWM7QUFDVlcsOEJBQWMsS0FESjtBQUVWQyxrQ0FBa0I7QUFGUixhQUFkO0FBSUgsU0FuRmtCOztBQUFBLGNBb0ZuQkUsTUFwRm1CLEdBb0ZWLGFBQUs7QUFDVmhCLGNBQUVDLGNBQUY7QUFDQSxrQkFBS0MsUUFBTCxDQUFjO0FBQ1ZXLDhCQUFjLFlBREo7QUFFVkMsa0NBQWtCO0FBRlIsYUFBZDtBQUlILFNBMUZrQjs7QUFBQSxjQTJGbkJHLFNBM0ZtQixHQTJGUCxhQUFLO0FBQ2JqQixjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWVyw4QkFBYyxPQURKO0FBRVZDLGtDQUFrQjtBQUZSLGFBQWQ7QUFJSCxTQWpHa0I7O0FBQUEsY0FtR25CSSxVQW5HbUIsR0FtR04sVUFBQ0MsYUFBRDtBQUFBLG1CQUFtQkEsY0FBY0MsTUFBZCxDQUFxQixVQUFDQyxDQUFELEVBQUdDLENBQUgsRUFBTztBQUN4RCx1QkFBT0MsV0FBV0YsQ0FBWCxJQUFjRSxXQUFXRCxFQUFFRSxJQUFiLENBQXJCO0FBQ0gsYUFGK0IsRUFFOUIsQ0FGOEIsQ0FBbkI7QUFBQSxTQW5HTTs7QUFFZixjQUFLQyxLQUFMLEdBQWE7QUFDVEMsd0JBQVcsRUFERjtBQUVUYiwwQkFBYyxZQUZMO0FBR1RkLHNCQUFVLEtBSEQ7QUFJVEksd0JBQVksS0FKSDtBQUtUUSwyQkFBZSxJQUxOO0FBTVRKLHlCQUFhLElBTko7QUFPVG9CLG9CQUFRLENBUEM7QUFRVEMsc0JBQVUsS0FSRDtBQVNUZCw4QkFBa0I7QUFUVCxTQUFiOztBQVlBLGNBQUtGLFFBQUwsR0FBZ0IsTUFBS0EsUUFBTCxDQUFjaUIsSUFBZCxPQUFoQjtBQUNBLGNBQUtkLE9BQUwsR0FBZSxNQUFLQSxPQUFMLENBQWFjLElBQWIsT0FBZjtBQUNBLGNBQUtiLE1BQUwsR0FBYyxNQUFLQSxNQUFMLENBQVlhLElBQVosT0FBZDtBQUNBLGNBQUtaLFNBQUwsR0FBaUIsTUFBS0EsU0FBTCxDQUFlWSxJQUFmLE9BQWpCO0FBQ0EsY0FBS0MscUJBQUwsR0FBNkIsTUFBS0EscUJBQUwsQ0FBMkJELElBQTNCLE9BQTdCO0FBQ0EsY0FBS0Usa0JBQUwsR0FBMEIsTUFBS0Esa0JBQUwsQ0FBd0JGLElBQXhCLE9BQTFCOztBQUVBLGNBQUs5QixRQUFMLEdBQWdCLE1BQUtBLFFBQUwsQ0FBYzhCLElBQWQsT0FBaEI7QUFDQSxjQUFLMUIsVUFBTCxHQUFrQixNQUFLQSxVQUFMLENBQWdCMEIsSUFBaEIsT0FBbEI7O0FBRUEsY0FBS3ZCLFVBQUwsR0FBa0IsTUFBS0EsVUFBTCxDQUFnQnVCLElBQWhCLE9BQWxCO0FBQ0EsY0FBS25CLFlBQUwsR0FBb0IsTUFBS0EsWUFBTCxDQUFrQm1CLElBQWxCLE9BQXBCOztBQUVBLGNBQUtHLGdCQUFMLEdBQXdCLE1BQUtBLGdCQUFMLENBQXNCSCxJQUF0QixPQUF4Qjs7QUEzQmU7QUE2QmxCOzs7OzRDQTBFbUI7QUFDaEIsZ0JBQU1JLGVBQWVDLEtBQUtDLEtBQUwsQ0FBV0MsYUFBYUMsT0FBYixDQUFxQixZQUFyQixDQUFYLENBQXJCO0FBQ0EsZ0JBQUlKLFlBQUosRUFBa0I7QUFDZCxxQkFBSy9CLFFBQUwsQ0FBYztBQUNWd0IsZ0NBQVlPLFlBREY7QUFFVk4sNEJBQVEsS0FBS1QsVUFBTCxDQUFnQmUsWUFBaEI7QUFGRSxpQkFBZDtBQUlIO0FBQ0o7Ozs2Q0FFb0I7QUFDakIsZ0JBQU1QLGFBQWFRLEtBQUtJLFNBQUwsQ0FBZSxLQUFLYixLQUFMLENBQVdDLFVBQTFCLENBQW5CO0FBQ0FVLHlCQUFhRyxPQUFiLENBQXFCLFlBQXJCLEVBQW1DYixVQUFuQztBQUNIOzs7OENBRXFCYyxXLEVBQWE7QUFDL0IsZ0JBQU1DLGdCQUFnQixLQUFLaEIsS0FBTCxDQUFXQyxVQUFYLENBQXNCZ0IsTUFBdEIsQ0FBNkI7QUFBQSx1QkFBYUMsVUFBVUMsRUFBVixLQUFpQkosV0FBOUI7QUFBQSxhQUE3QixDQUF0QjtBQUNBLGlCQUFLdEMsUUFBTCxDQUFjO0FBQ1Z3Qiw0QkFBWWUsYUFERjtBQUVWZCx3QkFBUyxLQUFLVCxVQUFMLENBQWdCdUIsYUFBaEI7QUFGQyxhQUFkO0FBSUg7OzsyQ0FFa0JJLFksRUFBYztBQUM3QixnQkFBTTNCLGFBQWFLLFdBQVcsS0FBS0UsS0FBTCxDQUFXRSxNQUF0QixJQUE4QkosV0FBV3NCLGFBQWFyQixJQUF4QixDQUFqRDtBQUNBLGlCQUFLdEIsUUFBTCxDQUFjO0FBQ1Z3Qiw2QkFBYW1CLFlBQWIsNEJBQThCLEtBQUtwQixLQUFMLENBQVdDLFVBQXpDLEVBRFU7QUFFVkMsd0JBQVFULFVBRkU7QUFHVkwsOEJBQWM7QUFISixhQUFkO0FBS0g7OzsyQ0FFa0I7QUFBQTs7QUFDZixnQkFBSWEsYUFBYSxLQUFLRCxLQUFMLENBQVdDLFVBQTVCOztBQUVBLGdCQUFJLEtBQUtELEtBQUwsQ0FBV2QsYUFBWCxJQUE0QixLQUFLYyxLQUFMLENBQVdkLGFBQVgsQ0FBeUJtQyxNQUF6RCxFQUNJcEIsYUFBYUEsV0FBV2dCLE1BQVgsQ0FBa0I7QUFBQSx1QkFBYUMsVUFBVUksU0FBVixJQUF1QixPQUFLdEIsS0FBTCxDQUFXZCxhQUEvQztBQUFBLGFBQWxCLENBQWI7QUFDSixnQkFBSSxLQUFLYyxLQUFMLENBQVdsQixXQUFmLEVBQ0E7QUFBQSw0Q0FDaUMsS0FBS2tCLEtBQUwsQ0FBV2xCLFdBQVgsQ0FBdUJ5QyxLQUF2QixDQUE2QixHQUE3QixDQURqQztBQUFBO0FBQUEsb0JBQ1NDLFNBRFQ7QUFBQSxvQkFDb0JDLFNBRHBCOztBQUVJeEIsMkJBQVd5QixJQUFYLENBQWdCLFVBQUM5QixDQUFELEVBQUlDLENBQUosRUFBVTtBQUN0QiwyQkFBUTRCLGFBQVcsS0FBWixHQUFtQjdCLEVBQUU0QixTQUFGLElBQWEzQixFQUFFMkIsU0FBRixDQUFoQyxHQUE2QzNCLEVBQUUyQixTQUFGLElBQWE1QixFQUFFNEIsU0FBRixDQUFqRTtBQUNILGlCQUZEO0FBR0g7QUFDRCxtQkFBT3ZCLFVBQVA7QUFDSDs7O2lDQUVRO0FBQ0wsbUJBQ0k7QUFBQTtBQUFBLGtCQUFLLFdBQVUsMkJBQWY7QUFDSTtBQUFBO0FBQUEsc0JBQUssV0FBVSxLQUFmO0FBQ0k7QUFBQTtBQUFBLDBCQUFLLFdBQVUsd0JBQWY7QUFDSTtBQUFBO0FBQUEsOEJBQUssV0FBVSxxQkFBZjtBQUNJO0FBQUE7QUFBQSxrQ0FBSyxXQUFVLGVBQWY7QUFDSTtBQUFBO0FBQUEsc0NBQUksV0FBVSxhQUFkO0FBQUE7QUFBQTtBQURKLDZCQURKO0FBSUk7QUFBQTtBQUFBLGtDQUFLLFdBQVUsMEJBQWY7QUFDSTtBQUFBO0FBQUEsc0NBQUssV0FBVSxLQUFmO0FBQ0k7QUFBQTtBQUFBLDBDQUFLLFdBQVUsb0JBQWY7QUFDSyw2Q0FBS0QsS0FBTCxDQUFXWixZQUFYLElBQTJCLFlBQTNCLElBQ0c7QUFBQTtBQUFBLDhDQUFHLFdBQVUsZ0JBQWIsRUFBOEIsU0FBUyxLQUFLRCxRQUE1QztBQUFBO0FBQUEseUNBRlI7QUFJSyw2Q0FBS2EsS0FBTCxDQUFXWixZQUFYLElBQTJCLFlBQTNCLElBQ0c7QUFBQTtBQUFBLDhDQUFHLFdBQVUsZ0JBQWIsRUFBOEIsU0FBUyxLQUFLRyxNQUE1QztBQUFBO0FBQUE7QUFMUixxQ0FESjtBQVNJO0FBQUE7QUFBQSwwQ0FBSyxXQUFVLDJCQUFmO0FBQUE7QUFDTTtBQUFBO0FBQUEsOENBQU0sV0FBVSxRQUFoQjtBQUEwQixpREFBS1MsS0FBTCxDQUFXRTtBQUFyQztBQUROLHFDQVRKO0FBWUk7QUFBQTtBQUFBLDBDQUFLLFdBQVUscUJBQWY7QUFDSyw2Q0FBS0YsS0FBTCxDQUFXWixZQUFYLElBQTJCLFlBQTNCLElBQ0c7QUFBQTtBQUFBLDhDQUFHLFdBQVUsZ0JBQWIsRUFBOEIsU0FBUyxLQUFLRSxPQUE1QztBQUFBO0FBQUE7QUFGUjtBQVpKO0FBREosNkJBSko7QUF3Qkk7QUFBQTtBQUFBLGtDQUFLLFdBQVUsWUFBZjtBQUNJO0FBQUE7QUFBQSxzQ0FBSyxXQUFVLGVBQWY7QUFDSyx5Q0FBS1UsS0FBTCxDQUFXWixZQUFYLElBQTJCLFlBQTNCLElBQ0c7QUFBQTtBQUFBO0FBQ0k7QUFBQTtBQUFBLDhDQUFLLFdBQVUsdUJBQWY7QUFDSTtBQUFBO0FBQUEsa0RBQUssV0FBVSxVQUFmO0FBQ0sscURBQUtZLEtBQUwsQ0FBVzFCLFFBQVgsSUFDRDtBQUFBO0FBQUEsc0RBQVEsSUFBRyxFQUFYLEVBQWMsTUFBSyxNQUFuQixFQUEwQixXQUFVLGNBQXBDLEVBQW1ELGNBQWMsS0FBSzBCLEtBQUwsQ0FBV2xCLFdBQTVFLEVBQXlGLFVBQVUsS0FBS0QsVUFBeEc7QUFFUThDLDJEQUFPQyxJQUFQLHNCQUEwQkMsR0FBMUIsQ0FBOEI7QUFBQSwrREFDMUI7QUFBQTtBQUFBLDhEQUFRLEtBQUtILElBQWIsRUFBbUIsT0FBT0EsSUFBMUI7QUFBaUMsZ0ZBQWFBLElBQWI7QUFBakMseURBRDBCO0FBQUEscURBQTlCO0FBRlIsaURBRko7QUFVSyxxREFBSzFCLEtBQUwsQ0FBV3RCLFVBQVgsSUFDRDtBQUFBO0FBQUEsc0RBQVEsSUFBRyxFQUFYLEVBQWMsTUFBSyxNQUFuQixFQUEwQixXQUFVLGNBQXBDLEVBQW1ELGNBQWMsS0FBS3NCLEtBQUwsQ0FBV2QsYUFBNUUsRUFBMkYsVUFBVSxLQUFLRCxZQUExRztBQUNJO0FBQUE7QUFBQSwwREFBUSxPQUFNLEVBQWQ7QUFBQTtBQUFBLHFEQURKO0FBR1EwQywyREFBT0MsSUFBUCw0QkFBZ0NDLEdBQWhDLENBQW9DO0FBQUEsK0RBQ2hDO0FBQUE7QUFBQSw4REFBUSxLQUFLUCxTQUFiLEVBQXdCLE9BQU9BLFNBQS9CO0FBQTJDLHNGQUFtQkEsU0FBbkI7QUFBM0MseURBRGdDO0FBQUEscURBQXBDO0FBSFI7QUFYSiw2Q0FESjtBQXNCSTtBQUFBO0FBQUEsa0RBQUssV0FBVSxVQUFmO0FBQ0ssaURBQUMsS0FBS3RCLEtBQUwsQ0FBVzFCLFFBQVgsSUFBdUIsS0FBSzBCLEtBQUwsQ0FBV3RCLFVBQW5DLEtBQ0c7QUFBQTtBQUFBO0FBQ0sseURBQUtzQixLQUFMLENBQVcxQixRQUFYLElBQ0c7QUFBQTtBQUFBLDBEQUFLLFdBQVUsWUFBZjtBQUNJO0FBQUE7QUFBQSw4REFBRyxXQUFVLGdCQUFiLEVBQThCLFNBQVMsS0FBS0ssUUFBNUM7QUFBQTtBQUFBO0FBREoscURBRlI7QUFNSyx5REFBS3FCLEtBQUwsQ0FBV3RCLFVBQVgsSUFDRztBQUFBO0FBQUEsMERBQUssV0FBVSxZQUFmO0FBQ0k7QUFBQTtBQUFBLDhEQUFHLFdBQVUsZ0JBQWIsRUFBOEIsU0FBUyxLQUFLRSxVQUE1QztBQUFBO0FBQUE7QUFESjtBQVBSLGlEQURILElBY0c7QUFBQTtBQUFBO0FBQ0k7QUFBQTtBQUFBLDBEQUFLLFdBQVUsWUFBZjtBQUNJO0FBQUE7QUFBQSw4REFBRyxXQUFVLGdCQUFiLEVBQThCLFNBQVMsS0FBS04sUUFBNUM7QUFBQTtBQUFBO0FBREoscURBREo7QUFJSTtBQUFBO0FBQUEsMERBQUssV0FBVSxZQUFmO0FBQ0k7QUFBQTtBQUFBLDhEQUFHLFdBQVUsZ0JBQWIsRUFBOEIsU0FBUyxLQUFLSSxVQUE1QztBQUFBO0FBQUE7QUFESjtBQUpKO0FBZlI7QUF0QkoseUNBREo7QUFpREksaUdBQWUsWUFBWSxLQUFLNkIsZ0JBQUwsRUFBM0IsRUFBb0QsbUJBQW1CLEtBQUtGLHFCQUE1RTtBQWpESixxQ0FGUjtBQXNESyx5Q0FBS0wsS0FBTCxDQUFXWixZQUFYLElBQTJCLEtBQTNCLElBQ0csNERBQWtCLFdBQVcsS0FBS1ksS0FBTCxDQUFXWCxnQkFBeEMsRUFBMEQsZ0JBQWdCLEtBQUtpQixrQkFBL0UsR0F2RFI7QUF5REsseUNBQUtOLEtBQUwsQ0FBV1osWUFBWCxJQUEyQixPQUEzQixJQUNHLGlEQUFPLFlBQVksS0FBS1ksS0FBTCxDQUFXQyxVQUE5QjtBQTFEUjtBQURKLDZCQXhCSjtBQXVGSztBQUFBO0FBQUEsa0NBQUssV0FBVSxjQUFmO0FBQ0sscUNBQUtELEtBQUwsQ0FBV1osWUFBWCxJQUEyQixPQUEzQixJQUNHO0FBQUE7QUFBQSxzQ0FBRyxXQUFVLGdCQUFiLEVBQThCLFNBQVMsS0FBS0ksU0FBNUM7QUFBQTtBQUFBO0FBRlI7QUF2Rkw7QUFESjtBQURKO0FBREosYUFESjtBQXFHSDs7OztFQTdQcUIsZ0JBQU1zQyxTOztBQThQL0I7O2tCQUVjMUQsVyIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQWRkT3BlcmF0aW9uRm9ybSBmcm9tICcuL0FkZE9wZXJhdGlvbkZvcm0uanN4JztcbmltcG9ydCBPcGVyYXRpb25MaXN0IGZyb20gJy4vT3BlcmF0aW9uTGlzdC5qc3gnO1xuXG5pbXBvcnQgQ2hhcnQgZnJvbSAnLi9DaGFydC5qc3gnO1xuXG5pbXBvcnQgeyBjb250ZW50QmxvY2tzLCBvcGVyYXRpb25EaXJlY3Rpb24sIHNvcnRWYXJpYW50cywgZXhwZW5zZXNUeXBlcyB9IGZyb20gJy4vVXRpbHMuanMnO1xuXG5cblxuY2xhc3MgTW9uZXlQYWxBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6W10sXG4gICAgICAgICAgICBjdXJyZW50QmxvY2s6ICdvcGVyYXRpb25zJyxcbiAgICAgICAgICAgIHNob3dTb3J0OiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgY3VycmVudEZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRTb3J0OiBudWxsLFxuICAgICAgICAgICAgYW1vdW50OiAwLFxuICAgICAgICAgICAgY3VycmVuY3k6ICd1c2QnLFxuICAgICAgICAgICAgY3VycmVudE9wZXJhdGlvbjogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkTWludXMgPSB0aGlzLmFkZE1pbnVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkUGx1cyA9IHRoaXMuYWRkUGx1cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvSG9tZSA9IHRoaXMudG9Ib21lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2hvd0NoYXJ0ID0gdGhpcy5zaG93Q2hhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVPcGVyYXRpb25EZWxldGUgPSB0aGlzLmhhbmRsZU9wZXJhdGlvbkRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZU9wZXJhdGlvbkFkZCA9IHRoaXMuaGFuZGxlT3BlcmF0aW9uQWRkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zaG93U29ydCA9IHRoaXMuc2hvd1NvcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zaG93RmlsdGVyID0gdGhpcy5zaG93RmlsdGVyLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VTb3J0ID0gdGhpcy5jaGFuZ2VTb3J0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlRmlsdGVyID0gdGhpcy5jaGFuZ2VGaWx0ZXIuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmdldE9wZXJhdGlvbkxpc3QgPSB0aGlzLmdldE9wZXJhdGlvbkxpc3QuYmluZCh0aGlzKTtcblxuICAgIH1cblxuICAgIHNob3dTb3J0ID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzaG93U29ydDogdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cbiAgICBzaG93RmlsdGVyID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzaG93RmlsdGVyOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGhpZGVTb3J0ID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzaG93U29ydDogZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG4gICAgaGlkZUZpbHRlciA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2hvd0ZpbHRlcjogZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjaGFuZ2VTb3J0ID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50U29ydDogZS50YXJnZXQudmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjaGFuZ2VGaWx0ZXIgPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnRGaWx0ZXI6IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkTWludXMgPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnRCbG9jazogJ2FkZCcsXG4gICAgICAgICAgICBjdXJyZW50T3BlcmF0aW9uOiAnZXhwZW5zZXMnXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGFkZFBsdXMgPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnRCbG9jazogJ2FkZCcsXG4gICAgICAgICAgICBjdXJyZW50T3BlcmF0aW9uOiAnaW5jb21lcydcbiAgICAgICAgfSlcbiAgICB9XG4gICAgdG9Ib21lID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50QmxvY2s6ICdvcGVyYXRpb25zJyxcbiAgICAgICAgICAgIGN1cnJlbnRPcGVyYXRpb246IG51bGxcbiAgICAgICAgfSlcbiAgICB9XG4gICAgc2hvd0NoYXJ0ID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50QmxvY2s6ICdjaGFydCcsXG4gICAgICAgICAgICBjdXJyZW50T3BlcmF0aW9uOiBudWxsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY2FsY0Ftb3VudCA9IChhcnJPcGVyYXRpb25zKSA9PiBhcnJPcGVyYXRpb25zLnJlZHVjZSgoYSxiKT0+e1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhKStwYXJzZUZsb2F0KGIuc3VtbSk7XG4gICAgfSwwKTtcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBsc09wZXJhdGlvbnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdvcGVyYXRpb25zJykpO1xuICAgICAgICBpZiAobHNPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zOiBsc09wZXJhdGlvbnMsXG4gICAgICAgICAgICAgICAgYW1vdW50OiB0aGlzLmNhbGNBbW91bnQobHNPcGVyYXRpb25zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRlLm9wZXJhdGlvbnMpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMpO1xuICAgIH1cblxuICAgIGhhbmRsZU9wZXJhdGlvbkRlbGV0ZShvcGVyYXRpb25JZCkge1xuICAgICAgICBjb25zdCBuZXdPcGVyYXRpb25zID0gdGhpcy5zdGF0ZS5vcGVyYXRpb25zLmZpbHRlcihvcGVyYXRpb24gPT4gb3BlcmF0aW9uLmlkICE9PSBvcGVyYXRpb25JZCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uczogbmV3T3BlcmF0aW9ucyxcbiAgICAgICAgICAgIGFtb3VudDogIHRoaXMuY2FsY0Ftb3VudChuZXdPcGVyYXRpb25zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFuZGxlT3BlcmF0aW9uQWRkKG5ld09wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBjYWxjQW1vdW50ID0gcGFyc2VGbG9hdCh0aGlzLnN0YXRlLmFtb3VudCkrcGFyc2VGbG9hdChuZXdPcGVyYXRpb24uc3VtbSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4udGhpcy5zdGF0ZS5vcGVyYXRpb25zXSxcbiAgICAgICAgICAgIGFtb3VudDogY2FsY0Ftb3VudCxcbiAgICAgICAgICAgIGN1cnJlbnRCbG9jazogJ29wZXJhdGlvbnMnXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldE9wZXJhdGlvbkxpc3QoKSB7XG4gICAgICAgIGxldCBvcGVyYXRpb25zID0gdGhpcy5zdGF0ZS5vcGVyYXRpb25zO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnRGaWx0ZXIgJiYgdGhpcy5zdGF0ZS5jdXJyZW50RmlsdGVyLmxlbmd0aClcbiAgICAgICAgICAgIG9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLmZpbHRlcihvcGVyYXRpb24gPT4gb3BlcmF0aW9uLmRpcmVjdGlvbiA9PSB0aGlzLnN0YXRlLmN1cnJlbnRGaWx0ZXIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jdXJyZW50U29ydClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IFtzb3J0RmllbGQsIHNvcnRPcmRlcl0gPSB0aGlzLnN0YXRlLmN1cnJlbnRTb3J0LnNwbGl0KCctJyk7XG4gICAgICAgICAgICBvcGVyYXRpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNvcnRPcmRlcj09J2FzYycpP2Fbc29ydEZpZWxkXS1iW3NvcnRGaWVsZF06Yltzb3J0RmllbGRdLWFbc29ydEZpZWxkXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0aW9ucztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcCBjb250YWluZXIgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS02IGNvbC1zbS1wdXNoLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtaGVhZGluZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwiYXBwX19oZWFkZXJcIj5Nb25leVBhbEFwcDwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhcHBfYW1vdW50IHBhbmVsLWhlYWRpbmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTMgdGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuY3VycmVudEJsb2NrID09ICdvcGVyYXRpb25zJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJtYXRlcmlhbC1pY29uc1wiIG9uQ2xpY2s9e3RoaXMuYWRkTWludXN9PnJlbW92ZV9jaXJjbGVfb3V0bGluZTwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuY3VycmVudEJsb2NrICE9ICdvcGVyYXRpb25zJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJtYXRlcmlhbC1pY29uc1wiIG9uQ2xpY2s9e3RoaXMudG9Ib21lfT5hcnJvd19iYWNrPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNiBhbW91bnQtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCA8c3BhbiBjbGFzc05hbWU9XCJhbW91bnRcIj57dGhpcy5zdGF0ZS5hbW91bnR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0zIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5jdXJyZW50QmxvY2sgPT0gJ29wZXJhdGlvbnMnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cIm1hdGVyaWFsLWljb25zXCIgb25DbGljaz17dGhpcy5hZGRQbHVzfT5hZGRfY2lyY2xlX291dGxpbmU8L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcF9jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmN1cnJlbnRCbG9jayA9PSAnb3BlcmF0aW9ucycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcF9vcGVyYXRpb25MaXN0TWVudVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tOFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLnNob3dTb3J0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cIlwiIG5hbWU9XCJzb3J0XCIgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgZGVmYXVsdFZhbHVlPXt0aGlzLnN0YXRlLmN1cnJlbnRTb3J0fSBvbkNoYW5nZT17dGhpcy5jaGFuZ2VTb3J0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc29ydFZhcmlhbnRzKS5tYXAoc29ydCA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PXtzb3J0fSB2YWx1ZT17c29ydH0+e3NvcnRWYXJpYW50c1tzb3J0XX08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5zaG93RmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cIlwiIG5hbWU9XCJzb3J0XCIgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgZGVmYXVsdFZhbHVlPXt0aGlzLnN0YXRlLmN1cnJlbnRGaWx0ZXJ9IG9uQ2hhbmdlPXt0aGlzLmNoYW5nZUZpbHRlcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj7QktGB0LU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3BlcmF0aW9uRGlyZWN0aW9uKS5tYXAoZGlyZWN0aW9uID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e2RpcmVjdGlvbn0gdmFsdWU9e2RpcmVjdGlvbn0+e29wZXJhdGlvbkRpcmVjdGlvbltkaXJlY3Rpb25dfTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyh0aGlzLnN0YXRlLnNob3dTb3J0IHx8IHRoaXMuc3RhdGUuc2hvd0ZpbHRlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLnNob3dTb3J0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cIm1hdGVyaWFsLWljb25zXCIgb25DbGljaz17dGhpcy5oaWRlU29ydH0+Y2xvc2U8L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5zaG93RmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cIm1hdGVyaWFsLWljb25zXCIgb25DbGljaz17dGhpcy5oaWRlRmlsdGVyfT5jbG9zZTwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInB1bGwtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJtYXRlcmlhbC1pY29uc1wiIG9uQ2xpY2s9e3RoaXMuc2hvd1NvcnR9PnNvcnQ8L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHVsbC1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cIm1hdGVyaWFsLWljb25zXCIgb25DbGljaz17dGhpcy5zaG93RmlsdGVyfT5maWx0ZXJfbGlzdDwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxPcGVyYXRpb25MaXN0IG9wZXJhdGlvbnM9e3RoaXMuZ2V0T3BlcmF0aW9uTGlzdCgpfSBvbk9wZXJhdGlvbkRlbGV0ZT17dGhpcy5oYW5kbGVPcGVyYXRpb25EZWxldGV9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5jdXJyZW50QmxvY2sgPT0gJ2FkZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QWRkT3BlcmF0aW9uRm9ybSBvcGVyYXRpb249e3RoaXMuc3RhdGUuY3VycmVudE9wZXJhdGlvbn0gb25PcGVyYXRpb25BZGQ9e3RoaXMuaGFuZGxlT3BlcmF0aW9uQWRkfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuY3VycmVudEJsb2NrID09ICdjaGFydCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hhcnQgb3BlcmF0aW9ucz17dGhpcy5zdGF0ZS5vcGVyYXRpb25zfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYW5lbC1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmN1cnJlbnRCbG9jayAhPSAnY2hhcnQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwibWF0ZXJpYWwtaWNvbnNcIiBvbkNsaWNrPXt0aGlzLnNob3dDaGFydH0+c2hvd19jaGFydDwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNb25leVBhbEFwcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL01vbmV5UGFsQXBwLmpzeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AddOperationForm = function (_React$Component) {\n    _inherits(AddOperationForm, _React$Component);\n\n    function AddOperationForm(props) {\n        _classCallCheck(this, AddOperationForm);\n\n        var _this = _possibleConstructorReturn(this, (AddOperationForm.__proto__ || Object.getPrototypeOf(AddOperationForm)).call(this, props));\n\n        _this.changeOperationDirection = function (e) {\n            e.preventDefault();\n            _this.setState({\n                direction: e.target.value\n            });\n        };\n\n        _this.changeOperationSumm = function (e) {\n            e.preventDefault();\n            _this.setState({\n                summ: e.target.value\n            });\n        };\n\n        _this.changeOperationTitle = function (e) {\n            e.preventDefault();\n            _this.setState({\n                title: e.target.value\n            });\n        };\n\n        _this.changeOperationType = function (e) {\n            e.preventDefault();\n            _this.setState({\n                type: e.target.value\n            });\n        };\n\n        _this.handleOperationAdd = function (e) {\n            e.preventDefault();\n            var date = Date.now();\n            var newOperation = {\n                direction: _this.state.direction,\n                summ: _this.state.direction == 'expenses' ? -1 * _this.state.summ : _this.state.summ,\n                type: _this.state.direction == 'expenses' ? _this.state.type ? _this.state.type : 'other' : null,\n                title: _this.state.title,\n                date: date,\n                id: date\n            };\n            _this.props.onOperationAdd(newOperation);\n            //this.resetState();\n        };\n\n        _this.state = {\n            direction: _this.props.operation,\n            summ: 0,\n            title: \"\",\n            type: null\n        };\n\n        _this.changeOperationDirection = _this.changeOperationDirection.bind(_this);\n        _this.changeOperationSumm = _this.changeOperationSumm.bind(_this);\n        _this.changeOperationType = _this.changeOperationType.bind(_this);\n        _this.handleOperationAdd = _this.handleOperationAdd.bind(_this);\n        _this.changeOperationTitle = _this.changeOperationTitle.bind(_this);\n        return _this;\n    }\n\n    _createClass(AddOperationForm, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement(\n                'div',\n                { className: 'app_add_operation' },\n                _react2.default.createElement(\n                    'form',\n                    { action: '' },\n                    _react2.default.createElement(\n                        'div',\n                        { className: 'form-group' },\n                        _react2.default.createElement(\n                            'select',\n                            { id: '', name: 'direction', className: 'form-control', defaultValue: this.state.direction, onChange: this.changeOperationDirection },\n                            Object.keys(_Utils.operationDirection).map(function (direction) {\n                                return _react2.default.createElement(\n                                    'option',\n                                    { key: direction, value: direction },\n                                    _Utils.operationDirection[direction]\n                                );\n                            })\n                        )\n                    ),\n                    _react2.default.createElement(\n                        'div',\n                        { className: 'form-group' },\n                        _react2.default.createElement('input', { type: 'text', className: 'form-control title', placeholder: '\\u041D\\u0430\\u0437\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u043E\\u043A\\u0443\\u043F\\u043A\\u0438, \\u043F\\u043E\\u0441\\u0442\\u0443\\u043F\\u043B\\u0435\\u043D\\u0438\\u044F', name: 'title', value: this.state.title, onChange: this.changeOperationTitle })\n                    ),\n                    _react2.default.createElement(\n                        'div',\n                        { className: 'form-group' },\n                        _react2.default.createElement(\n                            'div',\n                            { className: 'input-group' },\n                            _react2.default.createElement(\n                                'div',\n                                { className: 'input-group-addon' },\n                                '$'\n                            ),\n                            _react2.default.createElement('input', { type: 'text', className: 'form-control summ', name: 'summ', value: this.state.summ, onChange: this.changeOperationSumm })\n                        )\n                    ),\n                    this.state.direction == 'expenses' && _react2.default.createElement(\n                        'div',\n                        { className: 'form-group' },\n                        _react2.default.createElement(\n                            'select',\n                            { id: '', className: 'form-control', name: 'type', defaultValue: this.state.type || 'other', onChange: this.changeOperationType },\n                            Object.keys(_Utils.expensesTypes).map(function (type) {\n                                return _react2.default.createElement(\n                                    'option',\n                                    { key: type, value: type },\n                                    _Utils.expensesTypes[type]\n                                );\n                            })\n                        )\n                    ),\n                    _react2.default.createElement(\n                        'button',\n                        { type: 'submit', className: 'btn btn-default', onClick: this.handleOperationAdd },\n                        '\\u0421\\u043E\\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C'\n                    )\n                )\n            );\n        }\n    }]);\n\n    return AddOperationForm;\n}(_react2.default.Component);\n\n;\n\nexports.default = AddOperationForm;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRPcGVyYXRpb25Gb3JtLmpzeD84Y2FmIl0sIm5hbWVzIjpbIkFkZE9wZXJhdGlvbkZvcm0iLCJwcm9wcyIsImNoYW5nZU9wZXJhdGlvbkRpcmVjdGlvbiIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInNldFN0YXRlIiwiZGlyZWN0aW9uIiwidGFyZ2V0IiwidmFsdWUiLCJjaGFuZ2VPcGVyYXRpb25TdW1tIiwic3VtbSIsImNoYW5nZU9wZXJhdGlvblRpdGxlIiwidGl0bGUiLCJjaGFuZ2VPcGVyYXRpb25UeXBlIiwidHlwZSIsImhhbmRsZU9wZXJhdGlvbkFkZCIsImRhdGUiLCJEYXRlIiwibm93IiwibmV3T3BlcmF0aW9uIiwic3RhdGUiLCJpZCIsIm9uT3BlcmF0aW9uQWRkIiwib3BlcmF0aW9uIiwiYmluZCIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7Ozs7OztJQUVNQSxnQjs7O0FBQ0YsOEJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSx3SUFDVEEsS0FEUzs7QUFBQSxjQWVuQkMsd0JBZm1CLEdBZVEsYUFBSztBQUM1QkMsY0FBRUMsY0FBRjtBQUNBLGtCQUFLQyxRQUFMLENBQWM7QUFDVkMsMkJBQVdILEVBQUVJLE1BQUYsQ0FBU0M7QUFEVixhQUFkO0FBR0gsU0FwQmtCOztBQUFBLGNBcUJuQkMsbUJBckJtQixHQXFCRyxhQUFLO0FBQ3ZCTixjQUFFQyxjQUFGO0FBQ0Esa0JBQUtDLFFBQUwsQ0FBYztBQUNWSyxzQkFBTVAsRUFBRUksTUFBRixDQUFTQztBQURMLGFBQWQ7QUFHSCxTQTFCa0I7O0FBQUEsY0EyQm5CRyxvQkEzQm1CLEdBMkJJLGFBQUs7QUFDeEJSLGNBQUVDLGNBQUY7QUFDQSxrQkFBS0MsUUFBTCxDQUFjO0FBQ1ZPLHVCQUFPVCxFQUFFSSxNQUFGLENBQVNDO0FBRE4sYUFBZDtBQUdILFNBaENrQjs7QUFBQSxjQWlDbkJLLG1CQWpDbUIsR0FpQ0csYUFBSztBQUN2QlYsY0FBRUMsY0FBRjtBQUNBLGtCQUFLQyxRQUFMLENBQWM7QUFDVlMsc0JBQU1YLEVBQUVJLE1BQUYsQ0FBU0M7QUFETCxhQUFkO0FBR0gsU0F0Q2tCOztBQUFBLGNBdUNuQk8sa0JBdkNtQixHQXVDRSxhQUFLO0FBQ3RCWixjQUFFQyxjQUFGO0FBQ0EsZ0JBQU1ZLE9BQU9DLEtBQUtDLEdBQUwsRUFBYjtBQUNBLGdCQUFNQyxlQUFlO0FBQ2pCYiwyQkFBVyxNQUFLYyxLQUFMLENBQVdkLFNBREw7QUFFakJJLHNCQUFPLE1BQUtVLEtBQUwsQ0FBV2QsU0FBWCxJQUF3QixVQUF6QixHQUFxQyxDQUFDLENBQUQsR0FBRyxNQUFLYyxLQUFMLENBQVdWLElBQW5ELEdBQXdELE1BQUtVLEtBQUwsQ0FBV1YsSUFGeEQ7QUFHakJJLHNCQUFPLE1BQUtNLEtBQUwsQ0FBV2QsU0FBWCxJQUF3QixVQUF6QixHQUFzQyxNQUFLYyxLQUFMLENBQVdOLElBQVgsR0FBZ0IsTUFBS00sS0FBTCxDQUFXTixJQUEzQixHQUFnQyxPQUF0RSxHQUErRSxJQUhwRTtBQUlqQkYsdUJBQU8sTUFBS1EsS0FBTCxDQUFXUixLQUpEO0FBS2pCSSxzQkFBTUEsSUFMVztBQU1qQkssb0JBQUlMO0FBTmEsYUFBckI7QUFRQSxrQkFBS2YsS0FBTCxDQUFXcUIsY0FBWCxDQUEwQkgsWUFBMUI7QUFDQTtBQUNILFNBcERrQjs7QUFFZixjQUFLQyxLQUFMLEdBQWE7QUFDWGQsdUJBQVcsTUFBS0wsS0FBTCxDQUFXc0IsU0FEWDtBQUVYYixrQkFBTSxDQUZLO0FBR1hFLG1CQUFPLEVBSEk7QUFJWEUsa0JBQU07QUFKSyxTQUFiOztBQU9BLGNBQUtaLHdCQUFMLEdBQWdDLE1BQUtBLHdCQUFMLENBQThCc0IsSUFBOUIsT0FBaEM7QUFDQSxjQUFLZixtQkFBTCxHQUEyQixNQUFLQSxtQkFBTCxDQUF5QmUsSUFBekIsT0FBM0I7QUFDQSxjQUFLWCxtQkFBTCxHQUEyQixNQUFLQSxtQkFBTCxDQUF5QlcsSUFBekIsT0FBM0I7QUFDQSxjQUFLVCxrQkFBTCxHQUEwQixNQUFLQSxrQkFBTCxDQUF3QlMsSUFBeEIsT0FBMUI7QUFDQSxjQUFLYixvQkFBTCxHQUE0QixNQUFLQSxvQkFBTCxDQUEwQmEsSUFBMUIsT0FBNUI7QUFiZTtBQWNsQjs7OztpQ0F1Q1E7QUFDTCxtQkFDSTtBQUFBO0FBQUEsa0JBQUssV0FBVSxtQkFBZjtBQUNJO0FBQUE7QUFBQSxzQkFBTSxRQUFPLEVBQWI7QUFDSTtBQUFBO0FBQUEsMEJBQUssV0FBVSxZQUFmO0FBQ0k7QUFBQTtBQUFBLDhCQUFRLElBQUcsRUFBWCxFQUFjLE1BQUssV0FBbkIsRUFBK0IsV0FBVSxjQUF6QyxFQUF3RCxjQUFjLEtBQUtKLEtBQUwsQ0FBV2QsU0FBakYsRUFBNEYsVUFBVSxLQUFLSix3QkFBM0c7QUFFUXVCLG1DQUFPQyxJQUFQLDRCQUFnQ0MsR0FBaEMsQ0FBb0M7QUFBQSx1Q0FDaEM7QUFBQTtBQUFBLHNDQUFRLEtBQUtyQixTQUFiLEVBQXdCLE9BQU9BLFNBQS9CO0FBQTJDLDhEQUFtQkEsU0FBbkI7QUFBM0MsaUNBRGdDO0FBQUEsNkJBQXBDO0FBRlI7QUFESixxQkFESjtBQVVJO0FBQUE7QUFBQSwwQkFBSyxXQUFVLFlBQWY7QUFDSSxpRUFBTyxNQUFLLE1BQVosRUFBbUIsV0FBVSxvQkFBN0IsRUFBa0QsYUFBWSxpS0FBOUQsRUFBOEYsTUFBSyxPQUFuRyxFQUEyRyxPQUFPLEtBQUtjLEtBQUwsQ0FBV1IsS0FBN0gsRUFBb0ksVUFBVSxLQUFLRCxvQkFBbko7QUFESixxQkFWSjtBQWFJO0FBQUE7QUFBQSwwQkFBSyxXQUFVLFlBQWY7QUFDSTtBQUFBO0FBQUEsOEJBQUssV0FBVSxhQUFmO0FBQ0k7QUFBQTtBQUFBLGtDQUFLLFdBQVUsbUJBQWY7QUFBQTtBQUFBLDZCQURKO0FBRUkscUVBQU8sTUFBSyxNQUFaLEVBQW1CLFdBQVUsbUJBQTdCLEVBQWlELE1BQUssTUFBdEQsRUFBNkQsT0FBTyxLQUFLUyxLQUFMLENBQVdWLElBQS9FLEVBQXFGLFVBQVUsS0FBS0QsbUJBQXBHO0FBRko7QUFESixxQkFiSjtBQW1CSyx5QkFBS1csS0FBTCxDQUFXZCxTQUFYLElBQXdCLFVBQXhCLElBQ0Q7QUFBQTtBQUFBLDBCQUFLLFdBQVUsWUFBZjtBQUNJO0FBQUE7QUFBQSw4QkFBUSxJQUFHLEVBQVgsRUFBYyxXQUFVLGNBQXhCLEVBQXVDLE1BQUssTUFBNUMsRUFBbUQsY0FBYyxLQUFLYyxLQUFMLENBQVdOLElBQVgsSUFBaUIsT0FBbEYsRUFBMkYsVUFBVSxLQUFLRCxtQkFBMUc7QUFFUVksbUNBQU9DLElBQVAsdUJBQTJCQyxHQUEzQixDQUErQjtBQUFBLHVDQUMzQjtBQUFBO0FBQUEsc0NBQVEsS0FBS2IsSUFBYixFQUFtQixPQUFPQSxJQUExQjtBQUFpQyx5REFBY0EsSUFBZDtBQUFqQyxpQ0FEMkI7QUFBQSw2QkFBL0I7QUFGUjtBQURKLHFCQXBCSjtBQThCSTtBQUFBO0FBQUEsMEJBQVEsTUFBSyxRQUFiLEVBQXNCLFdBQVUsaUJBQWhDLEVBQWtELFNBQVMsS0FBS0Msa0JBQWhFO0FBQUE7QUFBQTtBQTlCSjtBQURKLGFBREo7QUFvQ0g7Ozs7RUEzRjBCLGdCQUFNYSxTOztBQTRGcEM7O2tCQUVjNUIsZ0IiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29udGVudEJsb2Nrcywgb3BlcmF0aW9uRGlyZWN0aW9uLCBzb3J0VmFyaWFudHMsIGV4cGVuc2VzVHlwZXMgfSBmcm9tICcuL1V0aWxzLmpzJztcblxuY2xhc3MgQWRkT3BlcmF0aW9uRm9ybSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5wcm9wcy5vcGVyYXRpb24sXG4gICAgICAgICAgc3VtbTogMCxcbiAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICB0eXBlOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VPcGVyYXRpb25EaXJlY3Rpb24gPSB0aGlzLmNoYW5nZU9wZXJhdGlvbkRpcmVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNoYW5nZU9wZXJhdGlvblN1bW0gPSB0aGlzLmNoYW5nZU9wZXJhdGlvblN1bW0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VPcGVyYXRpb25UeXBlID0gdGhpcy5jaGFuZ2VPcGVyYXRpb25UeXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlT3BlcmF0aW9uQWRkID0gdGhpcy5oYW5kbGVPcGVyYXRpb25BZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VPcGVyYXRpb25UaXRsZSA9IHRoaXMuY2hhbmdlT3BlcmF0aW9uVGl0bGUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgY2hhbmdlT3BlcmF0aW9uRGlyZWN0aW9uID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGFuZ2VPcGVyYXRpb25TdW1tID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzdW1tOiBlLnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hhbmdlT3BlcmF0aW9uVGl0bGUgPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHRpdGxlOiBlLnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hhbmdlT3BlcmF0aW9uVHlwZSA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdHlwZTogZS50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZU9wZXJhdGlvbkFkZCA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBuZXdPcGVyYXRpb24gPSB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuc3RhdGUuZGlyZWN0aW9uLFxuICAgICAgICAgICAgc3VtbTogKHRoaXMuc3RhdGUuZGlyZWN0aW9uID09ICdleHBlbnNlcycpPy0xKnRoaXMuc3RhdGUuc3VtbTp0aGlzLnN0YXRlLnN1bW0sXG4gICAgICAgICAgICB0eXBlOiAodGhpcy5zdGF0ZS5kaXJlY3Rpb24gPT0gJ2V4cGVuc2VzJyk/KHRoaXMuc3RhdGUudHlwZT90aGlzLnN0YXRlLnR5cGU6J290aGVyJyk6bnVsbCxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnN0YXRlLnRpdGxlLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIGlkOiBkYXRlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMub25PcGVyYXRpb25BZGQobmV3T3BlcmF0aW9uKTtcbiAgICAgICAgLy90aGlzLnJlc2V0U3RhdGUoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhcHBfYWRkX29wZXJhdGlvblwiPlxuICAgICAgICAgICAgICAgIDxmb3JtIGFjdGlvbj1cIlwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJcIiBuYW1lPVwiZGlyZWN0aW9uXCIgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgZGVmYXVsdFZhbHVlPXt0aGlzLnN0YXRlLmRpcmVjdGlvbn0gb25DaGFuZ2U9e3RoaXMuY2hhbmdlT3BlcmF0aW9uRGlyZWN0aW9ufT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wZXJhdGlvbkRpcmVjdGlvbikubWFwKGRpcmVjdGlvbiA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e2RpcmVjdGlvbn0gdmFsdWU9e2RpcmVjdGlvbn0+e29wZXJhdGlvbkRpcmVjdGlvbltkaXJlY3Rpb25dfTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCB0aXRsZVwiIHBsYWNlaG9sZGVyPVwi0J3QsNC30LLQsNC90LjQtSDQv9C+0LrRg9C/0LrQuCwg0L/QvtGB0YLRg9C/0LvQtdC90LjRj1wiIG5hbWU9XCJ0aXRsZVwiIHZhbHVlPXt0aGlzLnN0YXRlLnRpdGxlfSBvbkNoYW5nZT17dGhpcy5jaGFuZ2VPcGVyYXRpb25UaXRsZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj4kPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIHN1bW1cIiBuYW1lPVwic3VtbVwiIHZhbHVlPXt0aGlzLnN0YXRlLnN1bW19IG9uQ2hhbmdlPXt0aGlzLmNoYW5nZU9wZXJhdGlvblN1bW19IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmRpcmVjdGlvbiA9PSAnZXhwZW5zZXMnICYmXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cIlwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIG5hbWU9XCJ0eXBlXCIgZGVmYXVsdFZhbHVlPXt0aGlzLnN0YXRlLnR5cGV8fCdvdGhlcid9IG9uQ2hhbmdlPXt0aGlzLmNoYW5nZU9wZXJhdGlvblR5cGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXhwZW5zZXNUeXBlcykubWFwKHR5cGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PXt0eXBlfSB2YWx1ZT17dHlwZX0+e2V4cGVuc2VzVHlwZXNbdHlwZV19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3NOYW1lPVwiYnRuIGJ0bi1kZWZhdWx0XCIgb25DbGljaz17dGhpcy5oYW5kbGVPcGVyYXRpb25BZGR9PtCh0L7RhdGA0LDQvdC40YLRjDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQWRkT3BlcmF0aW9uRm9ybTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL0FkZE9wZXJhdGlvbkZvcm0uanN4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Operation = __webpack_require__(37);\n\nvar _Operation2 = _interopRequireDefault(_Operation);\n\nvar _Utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar OperationList = function (_React$Component) {\n    _inherits(OperationList, _React$Component);\n\n    function OperationList(props) {\n        _classCallCheck(this, OperationList);\n\n        var _this = _possibleConstructorReturn(this, (OperationList.__proto__ || Object.getPrototypeOf(OperationList)).call(this, props));\n\n        _this.onOperationDelete = function (e) {\n            e.preventDefault();\n            _this.props.handleDelete(_this.props.id);\n        };\n\n        _this.onOperationDelete = _this.onOperationDelete.bind(_this);\n        return _this;\n    }\n\n    _createClass(OperationList, [{\n        key: 'render',\n        value: function render() {\n            var _this2 = this;\n\n            var operations = this.props.operations;\n\n            return _react2.default.createElement(\n                'div',\n                { className: 'app_operationList' },\n                _react2.default.createElement(\n                    'ul',\n                    { className: 'list-group' },\n                    operations.map(function (operation) {\n                        return _react2.default.createElement(_Operation2.default, {\n                            key: operation.id,\n                            id: operation.id,\n                            title: operation.title,\n                            date: operation.id,\n                            type: operation.type,\n                            summ: operation.summ,\n                            direction: operation.direction,\n                            handleDelete: _this2.props.onOperationDelete\n                        });\n                    })\n                )\n            );\n        }\n    }]);\n\n    return OperationList;\n}(_react2.default.Component);\n\n;\nexports.default = OperationList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9PcGVyYXRpb25MaXN0LmpzeD81MGJkIl0sIm5hbWVzIjpbIk9wZXJhdGlvbkxpc3QiLCJwcm9wcyIsIm9uT3BlcmF0aW9uRGVsZXRlIiwiZSIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlRGVsZXRlIiwiaWQiLCJiaW5kIiwib3BlcmF0aW9ucyIsIm1hcCIsIm9wZXJhdGlvbiIsInRpdGxlIiwidHlwZSIsInN1bW0iLCJkaXJlY3Rpb24iLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7O0lBRU1BLGE7OztBQUNGLDJCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsa0lBQ1RBLEtBRFM7O0FBQUEsY0FLbkJDLGlCQUxtQixHQUtDLGFBQUs7QUFDckJDLGNBQUVDLGNBQUY7QUFDQSxrQkFBS0gsS0FBTCxDQUFXSSxZQUFYLENBQXdCLE1BQUtKLEtBQUwsQ0FBV0ssRUFBbkM7QUFDSCxTQVJrQjs7QUFHZixjQUFLSixpQkFBTCxHQUF5QixNQUFLQSxpQkFBTCxDQUF1QkssSUFBdkIsT0FBekI7QUFIZTtBQUlsQjs7OztpQ0FLUTtBQUFBOztBQUFBLGdCQUVEQyxVQUZDLEdBR0QsS0FBS1AsS0FISixDQUVETyxVQUZDOztBQUlMLG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFVLG1CQUFmO0FBQ0k7QUFBQTtBQUFBLHNCQUFJLFdBQVUsWUFBZDtBQUVHQSwrQkFBV0MsR0FBWCxDQUFlO0FBQUEsK0JBQ1g7QUFDSSxpQ0FBS0MsVUFBVUosRUFEbkI7QUFFSSxnQ0FBSUksVUFBVUosRUFGbEI7QUFHSSxtQ0FBT0ksVUFBVUMsS0FIckI7QUFJSSxrQ0FBTUQsVUFBVUosRUFKcEI7QUFLSSxrQ0FBTUksVUFBVUUsSUFMcEI7QUFNSSxrQ0FBTUYsVUFBVUcsSUFOcEI7QUFPSSx1Q0FBV0gsVUFBVUksU0FQekI7QUFRSSwwQ0FBYyxPQUFLYixLQUFMLENBQVdDO0FBUjdCLDBCQURXO0FBQUEscUJBQWY7QUFGSDtBQURKLGFBREo7QUFvQkg7Ozs7RUFsQ3VCLGdCQUFNYSxTOztBQW1DakM7a0JBQ2NmLGEiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL09wZXJhdGlvbi5qc3gnO1xuXG5pbXBvcnQgeyBjb250ZW50QmxvY2tzLCBvcGVyYXRpb25EaXJlY3Rpb24sIHNvcnRWYXJpYW50cywgZXhwZW5zZXNUeXBlcyB9IGZyb20gJy4vVXRpbHMuanMnO1xuXG5jbGFzcyBPcGVyYXRpb25MaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5vbk9wZXJhdGlvbkRlbGV0ZSA9IHRoaXMub25PcGVyYXRpb25EZWxldGUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgb25PcGVyYXRpb25EZWxldGUgPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnByb3BzLmhhbmRsZURlbGV0ZSh0aGlzLnByb3BzLmlkKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcGVyYXRpb25zXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhcHBfb3BlcmF0aW9uTGlzdFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJsaXN0LWdyb3VwXCI+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMubWFwKG9wZXJhdGlvbiA9PlxuICAgICAgICAgICAgICAgICAgICAgICA8T3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e29wZXJhdGlvbi5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtvcGVyYXRpb24uaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17b3BlcmF0aW9uLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZT17b3BlcmF0aW9uLmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT17b3BlcmF0aW9uLnR5cGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1tPXtvcGVyYXRpb24uc3VtbX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbj17b3BlcmF0aW9uLmRpcmVjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZURlbGV0ZT17dGhpcy5wcm9wcy5vbk9wZXJhdGlvbkRlbGV0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgT3BlcmF0aW9uTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL09wZXJhdGlvbkxpc3QuanN4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Operation = function (_React$Component) {\n    _inherits(Operation, _React$Component);\n\n    function Operation(props) {\n        _classCallCheck(this, Operation);\n\n        var _this = _possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).call(this, props));\n\n        _this.handleDelete = function (e) {\n            e.preventDefault();\n            _this.props.handleDelete(_this.props.id);\n        };\n\n        _this.handleDelete = _this.handleDelete.bind(_this);\n        return _this;\n    }\n\n    _createClass(Operation, [{\n        key: 'getDaysAgo',\n        value: function getDaysAgo() {\n            var res = Math.floor((Date.now() - this.props.date) / (24 * 60 * 60 * 1000));\n            res = res == 0 ? 'Сегодня' : res + ' дней назад';\n            return res;\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _props = this.props,\n                id = _props.id,\n                date = _props.date,\n                title = _props.title,\n                direction = _props.direction,\n                type = _props.type,\n                summ = _props.summ;\n\n            return _react2.default.createElement(\n                'li',\n                { id: id, className: 'app_operation list-group-item operation-' + direction },\n                _react2.default.createElement(\n                    'i',\n                    { className: 'material-icons close', onClick: this.handleDelete },\n                    'close'\n                ),\n                _react2.default.createElement(\n                    'div',\n                    { className: 'summ pull-right' },\n                    direction == 'expenses' ? _react2.default.createElement(\n                        'i',\n                        { className: 'material-icons' },\n                        'remove'\n                    ) : _react2.default.createElement(\n                        'i',\n                        { className: 'material-icons' },\n                        'add'\n                    ),\n                    direction == 'expenses' ? -1 * summ : summ\n                ),\n                title || (direction == 'expenses' ? 'secret buy' : 'secret income'),\n                _react2.default.createElement(\n                    'div',\n                    { className: 'operation-footer' },\n                    this.getDaysAgo(),\n                    ' \\xA0',\n                    direction == 'expenses' && _react2.default.createElement(\n                        'span',\n                        null,\n                        '/ ',\n                        _Utils.expensesTypes[type]\n                    )\n                )\n            );\n        }\n    }]);\n\n    return Operation;\n}(_react2.default.Component);\n\n;\n\nexports.default = Operation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9PcGVyYXRpb24uanN4PzlkYTYiXSwibmFtZXMiOlsiT3BlcmF0aW9uIiwicHJvcHMiLCJoYW5kbGVEZWxldGUiLCJlIiwicHJldmVudERlZmF1bHQiLCJpZCIsImJpbmQiLCJyZXMiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiZGF0ZSIsInRpdGxlIiwiZGlyZWN0aW9uIiwidHlwZSIsInN1bW0iLCJnZXREYXlzQWdvIiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBRUE7Ozs7Ozs7Ozs7SUFFTUEsUzs7O0FBQ0YsdUJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSwwSEFDVEEsS0FEUzs7QUFBQSxjQUtuQkMsWUFMbUIsR0FLSixhQUFLO0FBQ2hCQyxjQUFFQyxjQUFGO0FBQ0Esa0JBQUtILEtBQUwsQ0FBV0MsWUFBWCxDQUF3QixNQUFLRCxLQUFMLENBQVdJLEVBQW5DO0FBQ0gsU0FSa0I7O0FBR2YsY0FBS0gsWUFBTCxHQUFvQixNQUFLQSxZQUFMLENBQWtCSSxJQUFsQixPQUFwQjtBQUhlO0FBSWxCOzs7O3FDQUtZO0FBQ1QsZ0JBQUlDLE1BQU1DLEtBQUtDLEtBQUwsQ0FBVyxDQUFDQyxLQUFLQyxHQUFMLEtBQWEsS0FBS1YsS0FBTCxDQUFXVyxJQUF6QixLQUFnQyxLQUFHLEVBQUgsR0FBTSxFQUFOLEdBQVMsSUFBekMsQ0FBWCxDQUFWO0FBQ0FMLGtCQUFPQSxPQUFPLENBQVIsR0FBVyxTQUFYLEdBQXFCQSxNQUFJLGFBQS9CO0FBQ0EsbUJBQU9BLEdBQVA7QUFDSDs7O2lDQUNRO0FBQUEseUJBUUQsS0FBS04sS0FSSjtBQUFBLGdCQUVESSxFQUZDLFVBRURBLEVBRkM7QUFBQSxnQkFHRE8sSUFIQyxVQUdEQSxJQUhDO0FBQUEsZ0JBSURDLEtBSkMsVUFJREEsS0FKQztBQUFBLGdCQUtEQyxTQUxDLFVBS0RBLFNBTEM7QUFBQSxnQkFNREMsSUFOQyxVQU1EQSxJQU5DO0FBQUEsZ0JBT0RDLElBUEMsVUFPREEsSUFQQzs7QUFTTCxtQkFDSTtBQUFBO0FBQUEsa0JBQUksSUFBSVgsRUFBUixFQUFZLHdEQUFzRFMsU0FBbEU7QUFDSTtBQUFBO0FBQUEsc0JBQUcsV0FBVSxzQkFBYixFQUFvQyxTQUFTLEtBQUtaLFlBQWxEO0FBQUE7QUFBQSxpQkFESjtBQUVJO0FBQUE7QUFBQSxzQkFBSyxXQUFVLGlCQUFmO0FBRVNZLGlDQUFhLFVBQWQsR0FBMEI7QUFBQTtBQUFBLDBCQUFHLFdBQVUsZ0JBQWI7QUFBQTtBQUFBLHFCQUExQixHQUFtRTtBQUFBO0FBQUEsMEJBQUcsV0FBVSxnQkFBYjtBQUFBO0FBQUEscUJBRjNFO0FBSU1BLGlDQUFhLFVBQWQsR0FBMEIsQ0FBQyxDQUFELEdBQUdFLElBQTdCLEdBQWtDQTtBQUp2QyxpQkFGSjtBQVFLSCwwQkFBU0MsYUFBYSxVQUFkLEdBQTBCLFlBQTFCLEdBQXVDLGVBQS9DLENBUkw7QUFTSTtBQUFBO0FBQUEsc0JBQUssV0FBVSxrQkFBZjtBQUNLLHlCQUFLRyxVQUFMLEVBREw7QUFBQTtBQUVNSCxpQ0FBYSxVQUFkLElBQ0c7QUFBQTtBQUFBO0FBQUE7QUFBUyw2Q0FBY0MsSUFBZDtBQUFUO0FBSFI7QUFUSixhQURKO0FBa0JIOzs7O0VBMUNtQixnQkFBTUcsUzs7QUEyQzdCOztrQkFFY2xCLFMiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBjb250ZW50QmxvY2tzLCBvcGVyYXRpb25EaXJlY3Rpb24sIHNvcnRWYXJpYW50cywgZXhwZW5zZXNUeXBlcyB9IGZyb20gJy4vVXRpbHMuanMnO1xuXG5jbGFzcyBPcGVyYXRpb24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLmhhbmRsZURlbGV0ZSA9IHRoaXMuaGFuZGxlRGVsZXRlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGhhbmRsZURlbGV0ZSA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucHJvcHMuaGFuZGxlRGVsZXRlKHRoaXMucHJvcHMuaWQpO1xuICAgIH1cbiAgICBnZXREYXlzQWdvKCkge1xuICAgICAgICBsZXQgcmVzID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIHRoaXMucHJvcHMuZGF0ZSkvKDI0KjYwKjYwKjEwMDApKTtcbiAgICAgICAgcmVzID0gKHJlcyA9PSAwKT8n0KHQtdCz0L7QtNC90Y8nOnJlcysnINC00L3QtdC5INC90LDQt9Cw0LQnO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHN1bW1cbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGkgaWQ9e2lkfSBjbGFzc05hbWU9e2BhcHBfb3BlcmF0aW9uIGxpc3QtZ3JvdXAtaXRlbSBvcGVyYXRpb24tJHtkaXJlY3Rpb259YH0+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwibWF0ZXJpYWwtaWNvbnMgY2xvc2VcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZURlbGV0ZX0+Y2xvc2U8L2k+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzdW1tIHB1bGwtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGlvbiA9PSAnZXhwZW5zZXMnKT88aSBjbGFzc05hbWU9XCJtYXRlcmlhbC1pY29uc1wiPnJlbW92ZTwvaT46PGkgY2xhc3NOYW1lPVwibWF0ZXJpYWwtaWNvbnNcIj5hZGQ8L2k+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeyhkaXJlY3Rpb24gPT0gJ2V4cGVuc2VzJyk/LTEqc3VtbTpzdW1tfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHt0aXRsZXx8KChkaXJlY3Rpb24gPT0gJ2V4cGVuc2VzJyk/J3NlY3JldCBidXknOidzZWNyZXQgaW5jb21lJyl9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvcGVyYXRpb24tZm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLmdldERheXNBZ28oKX0gJm5ic3A7XG4gICAgICAgICAgICAgICAgICAgIHsoZGlyZWN0aW9uID09ICdleHBlbnNlcycpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4vIHtleHBlbnNlc1R5cGVzW3R5cGVdfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgKVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9wZXJhdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL09wZXJhdGlvbi5qc3giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ReactHighcharts = __webpack_require__(39); // Expects that Highcharts was loaded in the code.\n\nvar config = {\n    chart: {\n        plotBackgroundColor: null,\n        plotBorderWidth: null,\n        plotShadow: false,\n        type: 'pie'\n    },\n    title: {\n        text: 'Соотношение доходов и расходов'\n    },\n    tooltip: {\n        pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'\n    },\n    plotOptions: {\n        pie: {\n            allowPointSelect: true,\n            cursor: 'pointer',\n            dataLabels: {\n                enabled: true,\n                format: '<b>{point.name}</b>: {point.percentage:.1f} %',\n                style: {\n                    color: ReactHighcharts.theme && ReactHighcharts.theme.contrastTextColor || 'black'\n                }\n            }\n        }\n    },\n    series: [{\n        name: 'Соотношение доходов и расходов',\n        colorByPoint: true,\n        data: []\n    }]\n};\n\nvar Chart = function (_React$Component) {\n    _inherits(Chart, _React$Component);\n\n    function Chart() {\n        _classCallCheck(this, Chart);\n\n        return _possibleConstructorReturn(this, (Chart.__proto__ || Object.getPrototypeOf(Chart)).apply(this, arguments));\n    }\n\n    _createClass(Chart, [{\n        key: 'render',\n        value: function render() {\n            var operations = this.props.operations;\n\n\n            var ratio = operations.reduce(function (a, b, i, arr) {\n                if (b.direction == 'incomes') {\n                    a.incomes += Number(b.summ);\n                }\n                if (b.direction == 'expenses') {\n                    a.expenses -= Number(b.summ);\n                }\n                return a;\n            }, { expenses: 0, incomes: 0 });\n\n            var incomes_percents = ratio.incomes / (ratio.incomes + ratio.expenses) || 0;\n            var expenses_percents = ratio.expenses / (ratio.incomes + ratio.expenses) || 0;\n\n            config.series[0].data = [{\n                name: 'Доходы',\n                y: incomes_percents\n            }, {\n                name: 'Расходы',\n                y: expenses_percents\n            }];\n\n            return _react2.default.createElement(\n                'div',\n                { className: 'app_chart' },\n                (incomes_percents || expenses_percents) && _react2.default.createElement(ReactHighcharts, { config: config }) || _react2.default.createElement(\n                    'p',\n                    null,\n                    '\\u0412\\u043D\\u0435\\u0441\\u0438\\u0442\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435 \\u0434\\u043B\\u044F \\u0442\\u043E\\u0433\\u043E \\u0447\\u0442\\u043E\\u0431\\u044B \\u0443\\u0432\\u0438\\u0434\\u0435\\u0442\\u044C \\u0433\\u0440\\u0430\\u0444\\u0438\\u043A'\n                )\n            );\n        }\n    }]);\n\n    return Chart;\n}(_react2.default.Component);\n\n;\nexports.default = Chart;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DaGFydC5qc3g/Mzc2NSJdLCJuYW1lcyI6WyJSZWFjdEhpZ2hjaGFydHMiLCJyZXF1aXJlIiwiY29uZmlnIiwiY2hhcnQiLCJwbG90QmFja2dyb3VuZENvbG9yIiwicGxvdEJvcmRlcldpZHRoIiwicGxvdFNoYWRvdyIsInR5cGUiLCJ0aXRsZSIsInRleHQiLCJ0b29sdGlwIiwicG9pbnRGb3JtYXQiLCJwbG90T3B0aW9ucyIsInBpZSIsImFsbG93UG9pbnRTZWxlY3QiLCJjdXJzb3IiLCJkYXRhTGFiZWxzIiwiZW5hYmxlZCIsImZvcm1hdCIsInN0eWxlIiwiY29sb3IiLCJ0aGVtZSIsImNvbnRyYXN0VGV4dENvbG9yIiwic2VyaWVzIiwibmFtZSIsImNvbG9yQnlQb2ludCIsImRhdGEiLCJDaGFydCIsIm9wZXJhdGlvbnMiLCJwcm9wcyIsInJhdGlvIiwicmVkdWNlIiwiYSIsImIiLCJpIiwiYXJyIiwiZGlyZWN0aW9uIiwiaW5jb21lcyIsIk51bWJlciIsInN1bW0iLCJleHBlbnNlcyIsImluY29tZXNfcGVyY2VudHMiLCJleHBlbnNlc19wZXJjZW50cyIsInkiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7Ozs7Ozs7OztBQUVBLElBQU1BLGtCQUFrQixtQkFBQUMsQ0FBUSxFQUFSLENBQXhCLEMsQ0FBcUQ7O0FBRXJELElBQU1DLFNBQVM7QUFDWEMsV0FBTztBQUNIQyw2QkFBcUIsSUFEbEI7QUFFSEMseUJBQWlCLElBRmQ7QUFHSEMsb0JBQVksS0FIVDtBQUlIQyxjQUFNO0FBSkgsS0FESTtBQU9YQyxXQUFPO0FBQ0hDLGNBQU07QUFESCxLQVBJO0FBVVhDLGFBQVM7QUFDTEMscUJBQWE7QUFEUixLQVZFO0FBYVhDLGlCQUFhO0FBQ1RDLGFBQUs7QUFDREMsOEJBQWtCLElBRGpCO0FBRURDLG9CQUFRLFNBRlA7QUFHREMsd0JBQVk7QUFDUkMseUJBQVMsSUFERDtBQUVSQyx3QkFBUSwrQ0FGQTtBQUdSQyx1QkFBTztBQUNIQywyQkFBUXBCLGdCQUFnQnFCLEtBQWhCLElBQXlCckIsZ0JBQWdCcUIsS0FBaEIsQ0FBc0JDLGlCQUFoRCxJQUFzRTtBQUQxRTtBQUhDO0FBSFg7QUFESSxLQWJGO0FBMEJYQyxZQUFRLENBQUM7QUFDTEMsY0FBTSxnQ0FERDtBQUVMQyxzQkFBYyxJQUZUO0FBR0xDLGNBQU07QUFIRCxLQUFEO0FBMUJHLENBQWY7O0lBa0NNQyxLOzs7Ozs7Ozs7OztpQ0FDTztBQUFBLGdCQUVEQyxVQUZDLEdBR0QsS0FBS0MsS0FISixDQUVERCxVQUZDOzs7QUFLTCxnQkFBTUUsUUFBUUYsV0FBV0csTUFBWCxDQUFrQixVQUFDQyxDQUFELEVBQUdDLENBQUgsRUFBS0MsQ0FBTCxFQUFPQyxHQUFQLEVBQWU7QUFDM0Msb0JBQUlGLEVBQUVHLFNBQUYsSUFBZSxTQUFuQixFQUNBO0FBQ0lKLHNCQUFFSyxPQUFGLElBQWFDLE9BQU9MLEVBQUVNLElBQVQsQ0FBYjtBQUNIO0FBQ0Qsb0JBQUlOLEVBQUVHLFNBQUYsSUFBZSxVQUFuQixFQUNBO0FBQ0lKLHNCQUFFUSxRQUFGLElBQWNGLE9BQU9MLEVBQUVNLElBQVQsQ0FBZDtBQUNIO0FBQ0QsdUJBQU9QLENBQVA7QUFDSCxhQVZhLEVBVVgsRUFBQ1EsVUFBVSxDQUFYLEVBQWNILFNBQVMsQ0FBdkIsRUFWVyxDQUFkOztBQVlBLGdCQUFNSSxtQkFBb0JYLE1BQU1PLE9BQU4sSUFBaUJQLE1BQU1PLE9BQU4sR0FBY1AsTUFBTVUsUUFBckMsQ0FBRCxJQUFrRCxDQUEzRTtBQUNBLGdCQUFNRSxvQkFBcUJaLE1BQU1VLFFBQU4sSUFBa0JWLE1BQU1PLE9BQU4sR0FBY1AsTUFBTVUsUUFBdEMsQ0FBRCxJQUFtRCxDQUE3RTs7QUFFQXRDLG1CQUFPcUIsTUFBUCxDQUFjLENBQWQsRUFBaUJHLElBQWpCLEdBQXdCLENBQUM7QUFDR0Ysc0JBQU0sUUFEVDtBQUVHbUIsbUJBQUdGO0FBRk4sYUFBRCxFQUdHO0FBQ0NqQixzQkFBTSxTQURQO0FBRUNtQixtQkFBR0Q7QUFGSixhQUhILENBQXhCOztBQVFBLG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxXQUFVLFdBQWY7QUFDSyxpQkFBQ0Qsb0JBQW9CQyxpQkFBckIsS0FDRyw4QkFBQyxlQUFELElBQWlCLFFBQVF4QyxNQUF6QixHQURILElBR0c7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUpSLGFBREo7QUFRRjs7OztFQXJDYyxnQkFBTTBDLFM7O0FBc0N6QjtrQkFDY2pCLEsiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBjb250ZW50QmxvY2tzLCBvcGVyYXRpb25EaXJlY3Rpb24sIHNvcnRWYXJpYW50cywgZXhwZW5zZXNUeXBlcyB9IGZyb20gJy4vVXRpbHMuanMnO1xuXG5jb25zdCBSZWFjdEhpZ2hjaGFydHMgPSByZXF1aXJlKCdyZWFjdC1oaWdoY2hhcnRzJyk7IC8vIEV4cGVjdHMgdGhhdCBIaWdoY2hhcnRzIHdhcyBsb2FkZWQgaW4gdGhlIGNvZGUuXG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgICBjaGFydDoge1xuICAgICAgICBwbG90QmFja2dyb3VuZENvbG9yOiBudWxsLFxuICAgICAgICBwbG90Qm9yZGVyV2lkdGg6IG51bGwsXG4gICAgICAgIHBsb3RTaGFkb3c6IGZhbHNlLFxuICAgICAgICB0eXBlOiAncGllJ1xuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogJ9Ch0L7QvtGC0L3QvtGI0LXQvdC40LUg0LTQvtGF0L7QtNC+0LIg0Lgg0YDQsNGB0YXQvtC00L7QsidcbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgICAgcG9pbnRGb3JtYXQ6ICd7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQucGVyY2VudGFnZTouMWZ9JTwvYj4nXG4gICAgfSxcbiAgICBwbG90T3B0aW9uczoge1xuICAgICAgICBwaWU6IHtcbiAgICAgICAgICAgIGFsbG93UG9pbnRTZWxlY3Q6IHRydWUsXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJzxiPntwb2ludC5uYW1lfTwvYj46IHtwb2ludC5wZXJjZW50YWdlOi4xZn0gJScsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IChSZWFjdEhpZ2hjaGFydHMudGhlbWUgJiYgUmVhY3RIaWdoY2hhcnRzLnRoZW1lLmNvbnRyYXN0VGV4dENvbG9yKSB8fCAnYmxhY2snXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXJpZXM6IFt7XG4gICAgICAgIG5hbWU6ICfQodC+0L7RgtC90L7RiNC10L3QuNC1INC00L7RhdC+0LTQvtCyINC4INGA0LDRgdGF0L7QtNC+0LInLFxuICAgICAgICBjb2xvckJ5UG9pbnQ6IHRydWUsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgfV1cbn07XG5cblxuY2xhc3MgQ2hhcnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3BlcmF0aW9uc1xuICAgICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCByYXRpbyA9IG9wZXJhdGlvbnMucmVkdWNlKChhLGIsaSxhcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChiLmRpcmVjdGlvbiA9PSAnaW5jb21lcycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYS5pbmNvbWVzICs9IE51bWJlcihiLnN1bW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIuZGlyZWN0aW9uID09ICdleHBlbnNlcycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYS5leHBlbnNlcyAtPSBOdW1iZXIoYi5zdW1tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LCB7ZXhwZW5zZXM6IDAsIGluY29tZXM6IDB9KVxuXG4gICAgICAgIGNvbnN0IGluY29tZXNfcGVyY2VudHMgPSAocmF0aW8uaW5jb21lcyAvIChyYXRpby5pbmNvbWVzK3JhdGlvLmV4cGVuc2VzKSl8fDA7XG4gICAgICAgIGNvbnN0IGV4cGVuc2VzX3BlcmNlbnRzID0gKHJhdGlvLmV4cGVuc2VzIC8gKHJhdGlvLmluY29tZXMrcmF0aW8uZXhwZW5zZXMpKXx8MDtcblxuICAgICAgICBjb25maWcuc2VyaWVzWzBdLmRhdGEgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ9CU0L7RhdC+0LTRiycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmNvbWVzX3BlcmNlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAn0KDQsNGB0YXQvtC00YsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZXhwZW5zZXNfcGVyY2VudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcF9jaGFydFwiPlxuICAgICAgICAgICAgICAgIHsoaW5jb21lc19wZXJjZW50cyB8fCBleHBlbnNlc19wZXJjZW50cykgJiZcbiAgICAgICAgICAgICAgICAgICAgPFJlYWN0SGlnaGNoYXJ0cyBjb25maWc9e2NvbmZpZ30+PC9SZWFjdEhpZ2hjaGFydHM+XG4gICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgPHA+0JLQvdC10YHQuNGC0LUg0LTQsNC90L3Ri9C1INC00LvRjyDRgtC+0LPQviDRh9GC0L7QsdGLINGD0LLQuNC00LXRgtGMINCz0YDQsNGE0LjQujwvcD5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICApfVxufTtcbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2hhcnQuanN4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(0), __webpack_require__(40));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"highcharts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactHighcharts\"] = factory(require(\"react\"), require(\"highcharts\"));\n\telse\n\t\troot[\"ReactHighcharts\"] = factory(root[\"React\"], root[\"Highcharts\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_17__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 18);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar _assign = __webpack_require__(6);\n\nvar emptyObject = __webpack_require__(9);\nvar _invariant = __webpack_require__(1);\n\nif (process.env.NODE_ENV !== 'production') {\n  var warning = __webpack_require__(3);\n}\n\nvar MIXINS_KEY = 'mixins';\n\n// Helper function to allow the creation of anonymous functions which do not\n// have .name set to the name of the variable being assigned to.\nfunction identity(fn) {\n  return fn;\n}\n\nvar ReactPropTypeLocationNames;\nif (process.env.NODE_ENV !== 'production') {\n  ReactPropTypeLocationNames = {\n    prop: 'prop',\n    context: 'context',\n    childContext: 'child context'\n  };\n} else {\n  ReactPropTypeLocationNames = {};\n}\n\nfunction factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {\n  /**\n   * Policies that describe methods in `ReactClassInterface`.\n   */\n\n  var injectedMixins = [];\n\n  /**\n   * Composite components are higher-level components that compose other composite\n   * or host components.\n   *\n   * To create a new type of `ReactClass`, pass a specification of\n   * your new class to `React.createClass`. The only requirement of your class\n   * specification is that you implement a `render` method.\n   *\n   *   var MyComponent = React.createClass({\n   *     render: function() {\n   *       return <div>Hello World</div>;\n   *     }\n   *   });\n   *\n   * The class specification supports a specific protocol of methods that have\n   * special meaning (e.g. `render`). See `ReactClassInterface` for\n   * more the comprehensive protocol. Any other properties and methods in the\n   * class specification will be available on the prototype.\n   *\n   * @interface ReactClassInterface\n   * @internal\n   */\n  var ReactClassInterface = {\n    /**\n     * An array of Mixin objects to include when defining your component.\n     *\n     * @type {array}\n     * @optional\n     */\n    mixins: 'DEFINE_MANY',\n\n    /**\n     * An object containing properties and methods that should be defined on\n     * the component's constructor instead of its prototype (static methods).\n     *\n     * @type {object}\n     * @optional\n     */\n    statics: 'DEFINE_MANY',\n\n    /**\n     * Definition of prop types for this component.\n     *\n     * @type {object}\n     * @optional\n     */\n    propTypes: 'DEFINE_MANY',\n\n    /**\n     * Definition of context types for this component.\n     *\n     * @type {object}\n     * @optional\n     */\n    contextTypes: 'DEFINE_MANY',\n\n    /**\n     * Definition of context types this component sets for its children.\n     *\n     * @type {object}\n     * @optional\n     */\n    childContextTypes: 'DEFINE_MANY',\n\n    // ==== Definition methods ====\n\n    /**\n     * Invoked when the component is mounted. Values in the mapping will be set on\n     * `this.props` if that prop is not specified (i.e. using an `in` check).\n     *\n     * This method is invoked before `getInitialState` and therefore cannot rely\n     * on `this.state` or use `this.setState`.\n     *\n     * @return {object}\n     * @optional\n     */\n    getDefaultProps: 'DEFINE_MANY_MERGED',\n\n    /**\n     * Invoked once before the component is mounted. The return value will be used\n     * as the initial value of `this.state`.\n     *\n     *   getInitialState: function() {\n     *     return {\n     *       isOn: false,\n     *       fooBaz: new BazFoo()\n     *     }\n     *   }\n     *\n     * @return {object}\n     * @optional\n     */\n    getInitialState: 'DEFINE_MANY_MERGED',\n\n    /**\n     * @return {object}\n     * @optional\n     */\n    getChildContext: 'DEFINE_MANY_MERGED',\n\n    /**\n     * Uses props from `this.props` and state from `this.state` to render the\n     * structure of the component.\n     *\n     * No guarantees are made about when or how often this method is invoked, so\n     * it must not have side effects.\n     *\n     *   render: function() {\n     *     var name = this.props.name;\n     *     return <div>Hello, {name}!</div>;\n     *   }\n     *\n     * @return {ReactComponent}\n     * @required\n     */\n    render: 'DEFINE_ONCE',\n\n    // ==== Delegate methods ====\n\n    /**\n     * Invoked when the component is initially created and about to be mounted.\n     * This may have side effects, but any external subscriptions or data created\n     * by this method must be cleaned up in `componentWillUnmount`.\n     *\n     * @optional\n     */\n    componentWillMount: 'DEFINE_MANY',\n\n    /**\n     * Invoked when the component has been mounted and has a DOM representation.\n     * However, there is no guarantee that the DOM node is in the document.\n     *\n     * Use this as an opportunity to operate on the DOM when the component has\n     * been mounted (initialized and rendered) for the first time.\n     *\n     * @param {DOMElement} rootNode DOM element representing the component.\n     * @optional\n     */\n    componentDidMount: 'DEFINE_MANY',\n\n    /**\n     * Invoked before the component receives new props.\n     *\n     * Use this as an opportunity to react to a prop transition by updating the\n     * state using `this.setState`. Current props are accessed via `this.props`.\n     *\n     *   componentWillReceiveProps: function(nextProps, nextContext) {\n     *     this.setState({\n     *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n     *     });\n     *   }\n     *\n     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n     * transition may cause a state change, but the opposite is not true. If you\n     * need it, you are probably looking for `componentWillUpdate`.\n     *\n     * @param {object} nextProps\n     * @optional\n     */\n    componentWillReceiveProps: 'DEFINE_MANY',\n\n    /**\n     * Invoked while deciding if the component should be updated as a result of\n     * receiving new props, state and/or context.\n     *\n     * Use this as an opportunity to `return false` when you're certain that the\n     * transition to the new props/state/context will not require a component\n     * update.\n     *\n     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n     *     return !equal(nextProps, this.props) ||\n     *       !equal(nextState, this.state) ||\n     *       !equal(nextContext, this.context);\n     *   }\n     *\n     * @param {object} nextProps\n     * @param {?object} nextState\n     * @param {?object} nextContext\n     * @return {boolean} True if the component should update.\n     * @optional\n     */\n    shouldComponentUpdate: 'DEFINE_ONCE',\n\n    /**\n     * Invoked when the component is about to update due to a transition from\n     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n     * and `nextContext`.\n     *\n     * Use this as an opportunity to perform preparation before an update occurs.\n     *\n     * NOTE: You **cannot** use `this.setState()` in this method.\n     *\n     * @param {object} nextProps\n     * @param {?object} nextState\n     * @param {?object} nextContext\n     * @param {ReactReconcileTransaction} transaction\n     * @optional\n     */\n    componentWillUpdate: 'DEFINE_MANY',\n\n    /**\n     * Invoked when the component's DOM representation has been updated.\n     *\n     * Use this as an opportunity to operate on the DOM when the component has\n     * been updated.\n     *\n     * @param {object} prevProps\n     * @param {?object} prevState\n     * @param {?object} prevContext\n     * @param {DOMElement} rootNode DOM element representing the component.\n     * @optional\n     */\n    componentDidUpdate: 'DEFINE_MANY',\n\n    /**\n     * Invoked when the component is about to be removed from its parent and have\n     * its DOM representation destroyed.\n     *\n     * Use this as an opportunity to deallocate any external resources.\n     *\n     * NOTE: There is no `componentDidUnmount` since your component will have been\n     * destroyed by that point.\n     *\n     * @optional\n     */\n    componentWillUnmount: 'DEFINE_MANY',\n\n    // ==== Advanced methods ====\n\n    /**\n     * Updates the component's currently mounted DOM representation.\n     *\n     * By default, this implements React's rendering and reconciliation algorithm.\n     * Sophisticated clients may wish to override this.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     * @overridable\n     */\n    updateComponent: 'OVERRIDE_BASE'\n  };\n\n  /**\n   * Mapping from class specification keys to special processing functions.\n   *\n   * Although these are declared like instance properties in the specification\n   * when defining classes using `React.createClass`, they are actually static\n   * and are accessible on the constructor instead of the prototype. Despite\n   * being static, they must be defined outside of the \"statics\" key under\n   * which all other static methods are defined.\n   */\n  var RESERVED_SPEC_KEYS = {\n    displayName: function(Constructor, displayName) {\n      Constructor.displayName = displayName;\n    },\n    mixins: function(Constructor, mixins) {\n      if (mixins) {\n        for (var i = 0; i < mixins.length; i++) {\n          mixSpecIntoComponent(Constructor, mixins[i]);\n        }\n      }\n    },\n    childContextTypes: function(Constructor, childContextTypes) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateTypeDef(Constructor, childContextTypes, 'childContext');\n      }\n      Constructor.childContextTypes = _assign(\n        {},\n        Constructor.childContextTypes,\n        childContextTypes\n      );\n    },\n    contextTypes: function(Constructor, contextTypes) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateTypeDef(Constructor, contextTypes, 'context');\n      }\n      Constructor.contextTypes = _assign(\n        {},\n        Constructor.contextTypes,\n        contextTypes\n      );\n    },\n    /**\n     * Special case getDefaultProps which should move into statics but requires\n     * automatic merging.\n     */\n    getDefaultProps: function(Constructor, getDefaultProps) {\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps = createMergedResultFunction(\n          Constructor.getDefaultProps,\n          getDefaultProps\n        );\n      } else {\n        Constructor.getDefaultProps = getDefaultProps;\n      }\n    },\n    propTypes: function(Constructor, propTypes) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateTypeDef(Constructor, propTypes, 'prop');\n      }\n      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\n    },\n    statics: function(Constructor, statics) {\n      mixStaticSpecIntoComponent(Constructor, statics);\n    },\n    autobind: function() {}\n  };\n\n  function validateTypeDef(Constructor, typeDef, location) {\n    for (var propName in typeDef) {\n      if (typeDef.hasOwnProperty(propName)) {\n        // use a warning instead of an _invariant so components\n        // don't show up in prod but only in __DEV__\n        if (process.env.NODE_ENV !== 'production') {\n          warning(\n            typeof typeDef[propName] === 'function',\n            '%s: %s type `%s` is invalid; it must be a function, usually from ' +\n              'React.PropTypes.',\n            Constructor.displayName || 'ReactClass',\n            ReactPropTypeLocationNames[location],\n            propName\n          );\n        }\n      }\n    }\n  }\n\n  function validateMethodOverride(isAlreadyDefined, name) {\n    var specPolicy = ReactClassInterface.hasOwnProperty(name)\n      ? ReactClassInterface[name]\n      : null;\n\n    // Disallow overriding of base class methods unless explicitly allowed.\n    if (ReactClassMixin.hasOwnProperty(name)) {\n      _invariant(\n        specPolicy === 'OVERRIDE_BASE',\n        'ReactClassInterface: You are attempting to override ' +\n          '`%s` from your class specification. Ensure that your method names ' +\n          'do not overlap with React methods.',\n        name\n      );\n    }\n\n    // Disallow defining methods more than once unless explicitly allowed.\n    if (isAlreadyDefined) {\n      _invariant(\n        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',\n        'ReactClassInterface: You are attempting to define ' +\n          '`%s` on your component more than once. This conflict may be due ' +\n          'to a mixin.',\n        name\n      );\n    }\n  }\n\n  /**\n   * Mixin helper which handles policy validation and reserved\n   * specification keys when building React classes.\n   */\n  function mixSpecIntoComponent(Constructor, spec) {\n    if (!spec) {\n      if (process.env.NODE_ENV !== 'production') {\n        var typeofSpec = typeof spec;\n        var isMixinValid = typeofSpec === 'object' && spec !== null;\n\n        if (process.env.NODE_ENV !== 'production') {\n          warning(\n            isMixinValid,\n            \"%s: You're attempting to include a mixin that is either null \" +\n              'or not an object. Check the mixins included by the component, ' +\n              'as well as any mixins they include themselves. ' +\n              'Expected object but got %s.',\n            Constructor.displayName || 'ReactClass',\n            spec === null ? null : typeofSpec\n          );\n        }\n      }\n\n      return;\n    }\n\n    _invariant(\n      typeof spec !== 'function',\n      \"ReactClass: You're attempting to \" +\n        'use a component class or function as a mixin. Instead, just use a ' +\n        'regular object.'\n    );\n    _invariant(\n      !isValidElement(spec),\n      \"ReactClass: You're attempting to \" +\n        'use a component as a mixin. Instead, just use a regular object.'\n    );\n\n    var proto = Constructor.prototype;\n    var autoBindPairs = proto.__reactAutoBindPairs;\n\n    // By handling mixins before any other properties, we ensure the same\n    // chaining order is applied to methods with DEFINE_MANY policy, whether\n    // mixins are listed before or after these methods in the spec.\n    if (spec.hasOwnProperty(MIXINS_KEY)) {\n      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n    }\n\n    for (var name in spec) {\n      if (!spec.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (name === MIXINS_KEY) {\n        // We have already handled mixins in a special case above.\n        continue;\n      }\n\n      var property = spec[name];\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      validateMethodOverride(isAlreadyDefined, name);\n\n      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n        RESERVED_SPEC_KEYS[name](Constructor, property);\n      } else {\n        // Setup methods on prototype:\n        // The following member methods should not be automatically bound:\n        // 1. Expected ReactClass methods (in the \"interface\").\n        // 2. Overridden methods (that were mixed in).\n        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n        var isFunction = typeof property === 'function';\n        var shouldAutoBind =\n          isFunction &&\n          !isReactClassMethod &&\n          !isAlreadyDefined &&\n          spec.autobind !== false;\n\n        if (shouldAutoBind) {\n          autoBindPairs.push(name, property);\n          proto[name] = property;\n        } else {\n          if (isAlreadyDefined) {\n            var specPolicy = ReactClassInterface[name];\n\n            // These cases should already be caught by validateMethodOverride.\n            _invariant(\n              isReactClassMethod &&\n                (specPolicy === 'DEFINE_MANY_MERGED' ||\n                  specPolicy === 'DEFINE_MANY'),\n              'ReactClass: Unexpected spec policy %s for key %s ' +\n                'when mixing in component specs.',\n              specPolicy,\n              name\n            );\n\n            // For methods which are defined more than once, call the existing\n            // methods before calling the new property, merging if appropriate.\n            if (specPolicy === 'DEFINE_MANY_MERGED') {\n              proto[name] = createMergedResultFunction(proto[name], property);\n            } else if (specPolicy === 'DEFINE_MANY') {\n              proto[name] = createChainedFunction(proto[name], property);\n            }\n          } else {\n            proto[name] = property;\n            if (process.env.NODE_ENV !== 'production') {\n              // Add verbose displayName to the function, which helps when looking\n              // at profiling tools.\n              if (typeof property === 'function' && spec.displayName) {\n                proto[name].displayName = spec.displayName + '_' + name;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function mixStaticSpecIntoComponent(Constructor, statics) {\n    if (!statics) {\n      return;\n    }\n    for (var name in statics) {\n      var property = statics[name];\n      if (!statics.hasOwnProperty(name)) {\n        continue;\n      }\n\n      var isReserved = name in RESERVED_SPEC_KEYS;\n      _invariant(\n        !isReserved,\n        'ReactClass: You are attempting to define a reserved ' +\n          'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' +\n          'as an instance property instead; it will still be accessible on the ' +\n          'constructor.',\n        name\n      );\n\n      var isInherited = name in Constructor;\n      _invariant(\n        !isInherited,\n        'ReactClass: You are attempting to define ' +\n          '`%s` on your component more than once. This conflict may be ' +\n          'due to a mixin.',\n        name\n      );\n      Constructor[name] = property;\n    }\n  }\n\n  /**\n   * Merge two objects, but throw if both contain the same key.\n   *\n   * @param {object} one The first object, which is mutated.\n   * @param {object} two The second object\n   * @return {object} one after it has been mutated to contain everything in two.\n   */\n  function mergeIntoWithNoDuplicateKeys(one, two) {\n    _invariant(\n      one && two && typeof one === 'object' && typeof two === 'object',\n      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'\n    );\n\n    for (var key in two) {\n      if (two.hasOwnProperty(key)) {\n        _invariant(\n          one[key] === undefined,\n          'mergeIntoWithNoDuplicateKeys(): ' +\n            'Tried to merge two objects with the same key: `%s`. This conflict ' +\n            'may be due to a mixin; in particular, this may be caused by two ' +\n            'getInitialState() or getDefaultProps() methods returning objects ' +\n            'with clashing keys.',\n          key\n        );\n        one[key] = two[key];\n      }\n    }\n    return one;\n  }\n\n  /**\n   * Creates a function that invokes two functions and merges their return values.\n   *\n   * @param {function} one Function to invoke first.\n   * @param {function} two Function to invoke second.\n   * @return {function} Function that invokes the two argument functions.\n   * @private\n   */\n  function createMergedResultFunction(one, two) {\n    return function mergedResult() {\n      var a = one.apply(this, arguments);\n      var b = two.apply(this, arguments);\n      if (a == null) {\n        return b;\n      } else if (b == null) {\n        return a;\n      }\n      var c = {};\n      mergeIntoWithNoDuplicateKeys(c, a);\n      mergeIntoWithNoDuplicateKeys(c, b);\n      return c;\n    };\n  }\n\n  /**\n   * Creates a function that invokes two functions and ignores their return vales.\n   *\n   * @param {function} one Function to invoke first.\n   * @param {function} two Function to invoke second.\n   * @return {function} Function that invokes the two argument functions.\n   * @private\n   */\n  function createChainedFunction(one, two) {\n    return function chainedFunction() {\n      one.apply(this, arguments);\n      two.apply(this, arguments);\n    };\n  }\n\n  /**\n   * Binds a method to the component.\n   *\n   * @param {object} component Component whose method is going to be bound.\n   * @param {function} method Method to be bound.\n   * @return {function} The bound method.\n   */\n  function bindAutoBindMethod(component, method) {\n    var boundMethod = method.bind(component);\n    if (process.env.NODE_ENV !== 'production') {\n      boundMethod.__reactBoundContext = component;\n      boundMethod.__reactBoundMethod = method;\n      boundMethod.__reactBoundArguments = null;\n      var componentName = component.constructor.displayName;\n      var _bind = boundMethod.bind;\n      boundMethod.bind = function(newThis) {\n        for (\n          var _len = arguments.length,\n            args = Array(_len > 1 ? _len - 1 : 0),\n            _key = 1;\n          _key < _len;\n          _key++\n        ) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        // User is trying to bind() an autobound method; we effectively will\n        // ignore the value of \"this\" that the user is trying to use, so\n        // let's warn.\n        if (newThis !== component && newThis !== null) {\n          if (process.env.NODE_ENV !== 'production') {\n            warning(\n              false,\n              'bind(): React component methods may only be bound to the ' +\n                'component instance. See %s',\n              componentName\n            );\n          }\n        } else if (!args.length) {\n          if (process.env.NODE_ENV !== 'production') {\n            warning(\n              false,\n              'bind(): You are binding a component method to the component. ' +\n                'React does this for you automatically in a high-performance ' +\n                'way, so you can safely remove this call. See %s',\n              componentName\n            );\n          }\n          return boundMethod;\n        }\n        var reboundMethod = _bind.apply(boundMethod, arguments);\n        reboundMethod.__reactBoundContext = component;\n        reboundMethod.__reactBoundMethod = method;\n        reboundMethod.__reactBoundArguments = args;\n        return reboundMethod;\n      };\n    }\n    return boundMethod;\n  }\n\n  /**\n   * Binds all auto-bound methods in a component.\n   *\n   * @param {object} component Component whose method is going to be bound.\n   */\n  function bindAutoBindMethods(component) {\n    var pairs = component.__reactAutoBindPairs;\n    for (var i = 0; i < pairs.length; i += 2) {\n      var autoBindKey = pairs[i];\n      var method = pairs[i + 1];\n      component[autoBindKey] = bindAutoBindMethod(component, method);\n    }\n  }\n\n  var IsMountedPreMixin = {\n    componentDidMount: function() {\n      this.__isMounted = true;\n    }\n  };\n\n  var IsMountedPostMixin = {\n    componentWillUnmount: function() {\n      this.__isMounted = false;\n    }\n  };\n\n  /**\n   * Add more to the ReactClass base class. These are all legacy features and\n   * therefore not already part of the modern ReactComponent.\n   */\n  var ReactClassMixin = {\n    /**\n     * TODO: This will be deprecated because state should always keep a consistent\n     * type signature and the only use case for this, is to avoid that.\n     */\n    replaceState: function(newState, callback) {\n      this.updater.enqueueReplaceState(this, newState, callback);\n    },\n\n    /**\n     * Checks whether or not this composite component is mounted.\n     * @return {boolean} True if mounted, false otherwise.\n     * @protected\n     * @final\n     */\n    isMounted: function() {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          this.__didWarnIsMounted,\n          '%s: isMounted is deprecated. Instead, make sure to clean up ' +\n            'subscriptions and pending requests in componentWillUnmount to ' +\n            'prevent memory leaks.',\n          (this.constructor && this.constructor.displayName) ||\n            this.name ||\n            'Component'\n        );\n        this.__didWarnIsMounted = true;\n      }\n      return !!this.__isMounted;\n    }\n  };\n\n  var ReactClassComponent = function() {};\n  _assign(\n    ReactClassComponent.prototype,\n    ReactComponent.prototype,\n    ReactClassMixin\n  );\n\n  /**\n   * Creates a composite component class given a class specification.\n   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  function createClass(spec) {\n    // To keep our warnings more understandable, we'll use a little hack here to\n    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n    // unnecessarily identify a class without displayName as 'Constructor'.\n    var Constructor = identity(function(props, context, updater) {\n      // This constructor gets overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted.\n\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          this instanceof Constructor,\n          'Something is calling a React component directly. Use a factory or ' +\n            'JSX instead. See: https://fb.me/react-legacyfactory'\n        );\n      }\n\n      // Wire up auto-binding\n      if (this.__reactAutoBindPairs.length) {\n        bindAutoBindMethods(this);\n      }\n\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n\n      this.state = null;\n\n      // ReactClasses doesn't have constructors. Instead, they use the\n      // getInitialState and componentWillMount methods for initialization.\n\n      var initialState = this.getInitialState ? this.getInitialState() : null;\n      if (process.env.NODE_ENV !== 'production') {\n        // We allow auto-mocks to proceed as if they're returning null.\n        if (\n          initialState === undefined &&\n          this.getInitialState._isMockFunction\n        ) {\n          // This is probably bad practice. Consider warning here and\n          // deprecating this convenience.\n          initialState = null;\n        }\n      }\n      _invariant(\n        typeof initialState === 'object' && !Array.isArray(initialState),\n        '%s.getInitialState(): must return an object or null',\n        Constructor.displayName || 'ReactCompositeComponent'\n      );\n\n      this.state = initialState;\n    });\n    Constructor.prototype = new ReactClassComponent();\n    Constructor.prototype.constructor = Constructor;\n    Constructor.prototype.__reactAutoBindPairs = [];\n\n    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n\n    mixSpecIntoComponent(Constructor, IsMountedPreMixin);\n    mixSpecIntoComponent(Constructor, spec);\n    mixSpecIntoComponent(Constructor, IsMountedPostMixin);\n\n    // Initialize the defaultProps property after all mixins have been merged.\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This is a tag to indicate that the use of these method names is ok,\n      // since it's used with createClass. If it's not, then it's likely a\n      // mistake so we'll warn you to use the static property, property\n      // initializer or constructor respectively.\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps.isReactClassApproved = {};\n      }\n      if (Constructor.prototype.getInitialState) {\n        Constructor.prototype.getInitialState.isReactClassApproved = {};\n      }\n    }\n\n    _invariant(\n      Constructor.prototype.render,\n      'createClass(...): Class specification must implement a `render` method.'\n    );\n\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        !Constructor.prototype.componentShouldUpdate,\n        '%s has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.',\n        spec.displayName || 'A component'\n      );\n      warning(\n        !Constructor.prototype.componentWillRecieveProps,\n        '%s has a method called ' +\n          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n        spec.displayName || 'A component'\n      );\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactClassInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    return Constructor;\n  }\n\n  return createClass;\n}\n\nmodule.exports = factory;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar React = __webpack_require__(5);\nvar factory = __webpack_require__(7);\n\nif (typeof React === 'undefined') {\n  throw Error(\n    'create-react-class could not find the React object. If you are using script tags, ' +\n      'make sure that React is being loaded before create-react-class.'\n  );\n}\n\n// Hack to grab NoopUpdateQueue from isomorphic React\nvar ReactNoopUpdateQueue = new React.Component().updater;\n\nmodule.exports = factory(\n  React.Component,\n  React.isValidElement,\n  ReactNoopUpdateQueue\n);\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar React = __webpack_require__(5);\nvar createReactClass = __webpack_require__(8);\nvar PropTypes = __webpack_require__(14);\nvar win = typeof global === 'undefined' ? window : global;\n\nmodule.exports = function (chartType, Highcharts) {\n  var displayName = 'Highcharts' + chartType;\n  var result = createReactClass({\n    displayName: displayName,\n\n    propTypes: {\n      config: PropTypes.object,\n      isPureConfig: PropTypes.bool,\n      neverReflow: PropTypes.bool,\n      callback: PropTypes.func,\n      domProps: PropTypes.object\n    },\n    getDefaultProps: function getDefaultProps() {\n      return {\n        callback: function callback() {},\n        domProps: {}\n      };\n    },\n    setChartRef: function setChartRef(chartRef) {\n      this.chartRef = chartRef;\n    },\n    renderChart: function renderChart(config) {\n      var _this = this;\n\n      if (!config) {\n        throw new Error('Config must be specified for the ' + displayName + ' component');\n      }\n      var chartConfig = config.chart;\n      this.chart = new Highcharts[chartType](_extends({}, config, {\n        chart: _extends({}, chartConfig, {\n          renderTo: this.chartRef\n        })\n      }), this.props.callback);\n\n      if (!this.props.neverReflow) {\n        win && win.requestAnimationFrame && requestAnimationFrame(function () {\n          _this.chart && _this.chart.options && _this.chart.reflow();\n        });\n      }\n    },\n\n    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {\n      if (nextProps.neverReflow || nextProps.isPureConfig && this.props.config === nextProps.config) {\n        return true;\n      }\n      this.renderChart(nextProps.config);\n      return false;\n    },\n\n\n    getChart: function getChart() {\n      if (!this.chart) {\n        throw new Error('getChart() should not be called before the component is mounted');\n      }\n      return this.chart;\n    },\n\n    componentDidMount: function componentDidMount() {\n      this.renderChart(this.props.config);\n    },\n\n    componentWillUnmount: function componentWillUnmount() {\n      this.chart.destroy();\n    },\n\n\n    render: function render() {\n      return React.createElement('div', _extends({ ref: this.setChartRef }, this.props.domProps));\n    }\n  });\n\n  result.Highcharts = Highcharts;\n  result.withHighcharts = function (Highcharts) {\n    return module.exports(chartType, Highcharts);\n  };\n  return result;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (process.env.NODE_ENV !== 'production') {\n  var invariant = __webpack_require__(1);\n  var warning = __webpack_require__(3);\n  var ReactPropTypesSecret = __webpack_require__(4);\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\nvar invariant = __webpack_require__(1);\nvar ReactPropTypesSecret = __webpack_require__(4);\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    invariant(\n      false,\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\nvar invariant = __webpack_require__(1);\nvar warning = __webpack_require__(3);\nvar assign = __webpack_require__(6);\n\nvar ReactPropTypesSecret = __webpack_require__(4);\nvar checkPropTypes = __webpack_require__(11);\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (process.env.NODE_ENV !== 'production') {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(13)(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(12)();\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(10)('Chart', __webpack_require__(17));\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_17__;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(16);\n\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGNoYXJ0cy9kaXN0L1JlYWN0SGlnaGNoYXJ0cy5qcz8yN2E2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7QUFHdEMsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esa0RBQWtELHdCQUF3QjtBQUMxRTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsImZpbGUiOiIzOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwiaGlnaGNoYXJ0c1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiLCBcImhpZ2hjaGFydHNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmVhY3RIaWdoY2hhcnRzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJoaWdoY2hhcnRzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSZWFjdEhpZ2hjaGFydHNcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIkhpZ2hjaGFydHNcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTdfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE4KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cblxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG5cbnZhciBfYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIGVtcHR5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbnZhciBfaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xufVxuXG52YXIgTUlYSU5TX0tFWSA9ICdtaXhpbnMnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGFub255bW91cyBmdW5jdGlvbnMgd2hpY2ggZG8gbm90XG4vLyBoYXZlIC5uYW1lIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgYmVpbmcgYXNzaWduZWQgdG8uXG5mdW5jdGlvbiBpZGVudGl0eShmbikge1xuICByZXR1cm4gZm47XG59XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn0gZWxzZSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkoUmVhY3RDb21wb25lbnQsIGlzVmFsaWRFbGVtZW50LCBSZWFjdE5vb3BVcGRhdGVRdWV1ZSkge1xuICAvKipcbiAgICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAgICovXG5cbiAgdmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbiAgLyoqXG4gICAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gICAqIG9yIGhvc3QgY29tcG9uZW50cy5cbiAgICpcbiAgICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICAgKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gICAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICAgKlxuICAgKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gICAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gICAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICAgKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIG1peGluczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgc3RhdGljczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAgICpcbiAgICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiB7XG4gICAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldEluaXRpYWxTdGF0ZTogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAgICogQHJlcXVpcmVkXG4gICAgICovXG4gICAgcmVuZGVyOiAnREVGSU5FX09OQ0UnLFxuXG4gICAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICAgKlxuICAgICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgICAqICAgICB9KTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAgICogdXBkYXRlLlxuICAgICAqXG4gICAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGU6ICdERUZJTkVfT05DRScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgICAqIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBvdmVycmlkYWJsZVxuICAgICAqL1xuICAgIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICAgKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gICAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gICAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gICAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAgICovXG4gIHZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gICAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIG1peGluczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgICAgaWYgKG1peGlucykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCAnY2hpbGRDb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgY2hpbGRDb250ZXh0VHlwZXNcbiAgICAgICk7XG4gICAgfSxcbiAgICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCAnY29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gX2Fzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyxcbiAgICAgICAgY29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKFxuICAgICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyxcbiAgICAgICAgICBnZXREZWZhdWx0UHJvcHNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsICdwcm9wJyk7XG4gICAgICB9XG4gICAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiBmdW5jdGlvbihDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICAgIH0sXG4gICAgYXV0b2JpbmQ6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBfaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgdHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArXG4gICAgICAgICAgICAgICdSZWFjdC5Qcm9wVHlwZXMuJyxcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJyxcbiAgICAgICAgICAgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSxcbiAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdXG4gICAgICA6IG51bGw7XG5cbiAgICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICAgIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdPVkVSUklERV9CQVNFJyxcbiAgICAgICAgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICtcbiAgICAgICAgICAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArXG4gICAgICAgICAgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyxcbiAgICAgICAgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArXG4gICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICtcbiAgICAgICAgICAndG8gYSBtaXhpbi4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAgICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAgICovXG4gIGZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gICAgaWYgKCFzcGVjKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBpc01peGluVmFsaWQsXG4gICAgICAgICAgICBcIiVzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCBcIiArXG4gICAgICAgICAgICAgICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgK1xuICAgICAgICAgICAgICAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICtcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfaW52YXJpYW50KFxuICAgICAgdHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicsXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhICcgK1xuICAgICAgICAncmVndWxhciBvYmplY3QuJ1xuICAgICk7XG4gICAgX2ludmFyaWFudChcbiAgICAgICFpc1ZhbGlkRWxlbWVudChzcGVjKSxcbiAgICAgIFwiUmVhY3RDbGFzczogWW91J3JlIGF0dGVtcHRpbmcgdG8gXCIgK1xuICAgICAgICAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJ1xuICAgICk7XG5cbiAgICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAgIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAgIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAgIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICAgIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPVxuICAgICAgICAgIGlzRnVuY3Rpb24gJiZcbiAgICAgICAgICAhaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgIWlzQWxyZWFkeURlZmluZWQgJiZcbiAgICAgICAgICBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgICBfaW52YXJpYW50KFxuICAgICAgICAgICAgICBpc1JlYWN0Q2xhc3NNZXRob2QgJiZcbiAgICAgICAgICAgICAgICAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcgfHxcbiAgICAgICAgICAgICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpLFxuICAgICAgICAgICAgICAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgK1xuICAgICAgICAgICAgICAgICd3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJyxcbiAgICAgICAgICAgICAgc3BlY1BvbGljeSxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIGlmICghc3RhdGljcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICAhaXNSZXNlcnZlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICtcbiAgICAgICAgICAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgK1xuICAgICAgICAgICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgK1xuICAgICAgICAgICdjb25zdHJ1Y3Rvci4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuXG4gICAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgIWlzSW5oZXJpdGVkLFxuICAgICAgICAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgICAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArXG4gICAgICAgICAgJ2R1ZSB0byBhIG1peGluLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICAgX2ludmFyaWFudChcbiAgICAgIG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsXG4gICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJ1xuICAgICk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgK1xuICAgICAgICAgICAgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgK1xuICAgICAgICAgICAgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICtcbiAgICAgICAgICAgICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgK1xuICAgICAgICAgICAgJ3dpdGggY2xhc2hpbmcga2V5cy4nLFxuICAgICAgICAgIGtleVxuICAgICAgICApO1xuICAgICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHt9O1xuICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gICAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24obmV3VGhpcykge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgK1xuICAgICAgICAgICAgICAgICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICtcbiAgICAgICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICAgIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgICB9XG4gIH1cblxuICB2YXIgSXNNb3VudGVkUHJlTWl4aW4gPSB7XG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBJc01vdW50ZWRQb3N0TWl4aW4gPSB7XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gICAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc01peGluID0ge1xuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICAgKi9cbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCxcbiAgICAgICAgICAnJXM6IGlzTW91bnRlZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgJyArXG4gICAgICAgICAgICAnc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiBjb21wb25lbnRXaWxsVW5tb3VudCB0byAnICtcbiAgICAgICAgICAgICdwcmV2ZW50IG1lbW9yeSBsZWFrcy4nLFxuICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yICYmIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHx8XG4gICAgICAgICAgICB0aGlzLm5hbWUgfHxcbiAgICAgICAgICAgICdDb21wb25lbnQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX19kaWRXYXJuSXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXRoaXMuX19pc01vdW50ZWQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7fTtcbiAgX2Fzc2lnbihcbiAgICBSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSxcbiAgICBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDbGFzc01peGluXG4gICk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3Moc3BlYykge1xuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBDb25zdHJ1Y3Rvci5uYW1lICE9PSAnQ29uc3RydWN0b3InLiBUaGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3RcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsXG4gICAgICAgICAgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgK1xuICAgICAgICAgICAgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSxcbiAgICAgICAgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfSk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFByZU1peGluKTtcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFBvc3RNaXhpbik7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIsXG4gICAgICAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nXG4gICAgKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgK1xuICAgICAgICAgICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArXG4gICAgICAgICAgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDbGFzcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG52YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGZhY3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5pZiAodHlwZW9mIFJlYWN0ID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBFcnJvcihcbiAgICAnY3JlYXRlLXJlYWN0LWNsYXNzIGNvdWxkIG5vdCBmaW5kIHRoZSBSZWFjdCBvYmplY3QuIElmIHlvdSBhcmUgdXNpbmcgc2NyaXB0IHRhZ3MsICcgK1xuICAgICAgJ21ha2Ugc3VyZSB0aGF0IFJlYWN0IGlzIGJlaW5nIGxvYWRlZCBiZWZvcmUgY3JlYXRlLXJlYWN0LWNsYXNzLidcbiAgKTtcbn1cblxuLy8gSGFjayB0byBncmFiIE5vb3BVcGRhdGVRdWV1ZSBmcm9tIGlzb21vcnBoaWMgUmVhY3RcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS51cGRhdGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gIFJlYWN0LkNvbXBvbmVudCxcbiAgUmVhY3QuaXNWYWxpZEVsZW1lbnQsXG4gIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXG4pO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjcmVhdGVSZWFjdENsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBQcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbnZhciB3aW4gPSB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhcnRUeXBlLCBIaWdoY2hhcnRzKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9ICdIaWdoY2hhcnRzJyArIGNoYXJ0VHlwZTtcbiAgdmFyIHJlc3VsdCA9IGNyZWF0ZVJlYWN0Q2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgY29uZmlnOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgaXNQdXJlQ29uZmlnOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIG5ldmVyUmVmbG93OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIGNhbGxiYWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgIGRvbVByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gICAgfSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjaygpIHt9LFxuICAgICAgICBkb21Qcm9wczoge31cbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXRDaGFydFJlZjogZnVuY3Rpb24gc2V0Q2hhcnRSZWYoY2hhcnRSZWYpIHtcbiAgICAgIHRoaXMuY2hhcnRSZWYgPSBjaGFydFJlZjtcbiAgICB9LFxuICAgIHJlbmRlckNoYXJ0OiBmdW5jdGlvbiByZW5kZXJDaGFydChjb25maWcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlnIG11c3QgYmUgc3BlY2lmaWVkIGZvciB0aGUgJyArIGRpc3BsYXlOYW1lICsgJyBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFydENvbmZpZyA9IGNvbmZpZy5jaGFydDtcbiAgICAgIHRoaXMuY2hhcnQgPSBuZXcgSGlnaGNoYXJ0c1tjaGFydFR5cGVdKF9leHRlbmRzKHt9LCBjb25maWcsIHtcbiAgICAgICAgY2hhcnQ6IF9leHRlbmRzKHt9LCBjaGFydENvbmZpZywge1xuICAgICAgICAgIHJlbmRlclRvOiB0aGlzLmNoYXJ0UmVmXG4gICAgICAgIH0pXG4gICAgICB9KSwgdGhpcy5wcm9wcy5jYWxsYmFjayk7XG5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5uZXZlclJlZmxvdykge1xuICAgICAgICB3aW4gJiYgd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmNoYXJ0ICYmIF90aGlzLmNoYXJ0Lm9wdGlvbnMgJiYgX3RoaXMuY2hhcnQucmVmbG93KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMubmV2ZXJSZWZsb3cgfHwgbmV4dFByb3BzLmlzUHVyZUNvbmZpZyAmJiB0aGlzLnByb3BzLmNvbmZpZyA9PT0gbmV4dFByb3BzLmNvbmZpZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQobmV4dFByb3BzLmNvbmZpZyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuXG4gICAgZ2V0Q2hhcnQ6IGZ1bmN0aW9uIGdldENoYXJ0KCkge1xuICAgICAgaWYgKCF0aGlzLmNoYXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0Q2hhcnQoKSBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jaGFydDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnByb3BzLmNvbmZpZyk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xuICAgIH0sXG5cblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIF9leHRlbmRzKHsgcmVmOiB0aGlzLnNldENoYXJ0UmVmIH0sIHRoaXMucHJvcHMuZG9tUHJvcHMpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlc3VsdC5IaWdoY2hhcnRzID0gSGlnaGNoYXJ0cztcbiAgcmVzdWx0LndpdGhIaWdoY2hhcnRzID0gZnVuY3Rpb24gKEhpZ2hjaGFydHMpIHtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMoY2hhcnRUeXBlLCBIaWdoY2hhcnRzKTtcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpKVxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpKCk7XG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApKCdDaGFydCcsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTdfXztcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWhpZ2hjaGFydHMvZGlzdC9SZWFjdEhpZ2hjaGFydHMuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

eval("/*\n Highcharts JS v5.0.14 (2017-07-28)\n\n (c) 2009-2016 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function(M,S){\"object\"===typeof module&&module.exports?module.exports=M.document?S(M):S:M.Highcharts=S(M)})(\"undefined\"!==typeof window?window:this,function(M){M=function(){var a=window,C=a.document,A=a.navigator&&a.navigator.userAgent||\"\",F=C&&C.createElementNS&&!!C.createElementNS(\"http://www.w3.org/2000/svg\",\"svg\").createSVGRect,E=/(edge|msie|trident)/i.test(A)&&!window.opera,m=!F,f=/Firefox/.test(A),l=f&&4>parseInt(A.split(\"Firefox/\")[1],10);return a.Highcharts?a.Highcharts.error(16,!0):{product:\"Highcharts\",\nversion:\"5.0.14\",deg2rad:2*Math.PI/360,doc:C,hasBidiBug:l,hasTouch:C&&void 0!==C.documentElement.ontouchstart,isMS:E,isWebKit:/AppleWebKit/.test(A),isFirefox:f,isTouchDevice:/(Mobile|Android|Windows Phone)/.test(A),SVG_NS:\"http://www.w3.org/2000/svg\",chartCount:0,seriesTypes:{},symbolSizes:{},svg:F,vml:m,win:a,marginNames:[\"plotTop\",\"marginRight\",\"marginBottom\",\"plotLeft\"],noop:function(){},charts:[]}}();(function(a){var C=[],A=a.charts,F=a.doc,E=a.win;a.error=function(m,f){m=a.isNumber(m)?\"Highcharts error #\"+\nm+\": www.highcharts.com/errors/\"+m:m;if(f)throw Error(m);E.console&&console.log(m)};a.Fx=function(a,f,l){this.options=f;this.elem=a;this.prop=l};a.Fx.prototype={dSetter:function(){var a=this.paths[0],f=this.paths[1],l=[],r=this.now,u=a.length,t;if(1===r)l=this.toD;else if(u===f.length&&1>r)for(;u--;)t=parseFloat(a[u]),l[u]=isNaN(t)?a[u]:r*parseFloat(f[u]-t)+t;else l=f;this.elem.attr(\"d\",l,null,!0)},update:function(){var a=this.elem,f=this.prop,l=this.now,r=this.options.step;if(this[f+\"Setter\"])this[f+\n\"Setter\"]();else a.attr?a.element&&a.attr(f,l,null,!0):a.style[f]=l+this.unit;r&&r.call(a,l,this)},run:function(a,f,l){var r=this,m=function(a){return m.stopped?!1:r.step(a)},t;this.startTime=+new Date;this.start=a;this.end=f;this.unit=l;this.now=this.start;this.pos=0;m.elem=this.elem;m.prop=this.prop;m()&&1===C.push(m)&&(m.timerId=setInterval(function(){for(t=0;t<C.length;t++)C[t]()||C.splice(t--,1);C.length||clearInterval(m.timerId)},13))},step:function(m){var f=+new Date,l,r=this.options,u=this.elem,\nt=r.complete,g=r.duration,d=r.curAnim;u.attr&&!u.element?m=!1:m||f>=g+this.startTime?(this.now=this.end,this.pos=1,this.update(),l=d[this.prop]=!0,a.objectEach(d,function(a){!0!==a&&(l=!1)}),l&&t&&t.call(u),m=!1):(this.pos=r.easing((f-this.startTime)/g),this.now=this.start+(this.end-this.start)*this.pos,this.update(),m=!0);return m},initPath:function(m,f,l){function r(a){var c,e;for(n=a.length;n--;)c=\"M\"===a[n]||\"L\"===a[n],e=/[a-zA-Z]/.test(a[n+3]),c&&e&&a.splice(n+1,0,a[n+1],a[n+2],a[n+1],a[n+2])}\nfunction u(a,c){for(;a.length<v;){a[0]=c[v-a.length];var b=a.slice(0,e);[].splice.apply(a,[0,0].concat(b));D&&(b=a.slice(a.length-e),[].splice.apply(a,[a.length,0].concat(b)),n--)}a[0]=\"M\"}function t(a,c){for(var q=(v-a.length)/e;0<q&&q--;)y=a.slice().splice(a.length/J-e,e*J),y[0]=c[v-e-q*e],b&&(y[e-6]=y[e-2],y[e-5]=y[e-1]),[].splice.apply(a,[a.length/J,0].concat(y)),D&&q--}f=f||\"\";var g,d=m.startX,k=m.endX,b=-1<f.indexOf(\"C\"),e=b?7:3,v,y,n;f=f.split(\" \");l=l.slice();var D=m.isArea,J=D?2:1,c;b&&(r(f),\nr(l));if(d&&k){for(n=0;n<d.length;n++)if(d[n]===k[0]){g=n;break}else if(d[0]===k[k.length-d.length+n]){g=n;c=!0;break}void 0===g&&(f=[])}f.length&&a.isNumber(g)&&(v=l.length+g*J*e,c?(u(f,l),t(l,f)):(u(l,f),t(f,l)));return[f,l]}};a.Fx.prototype.fillSetter=a.Fx.prototype.strokeSetter=function(){this.elem.attr(this.prop,a.color(this.start).tweenTo(a.color(this.end),this.pos),null,!0)};a.extend=function(a,f){var m;a||(a={});for(m in f)a[m]=f[m];return a};a.merge=function(){var m,f=arguments,l,r={},u=\nfunction(f,g){\"object\"!==typeof f&&(f={});a.objectEach(g,function(d,k){!a.isObject(d,!0)||a.isClass(d)||a.isDOMElement(d)?f[k]=g[k]:f[k]=u(f[k]||{},d)});return f};!0===f[0]&&(r=f[1],f=Array.prototype.slice.call(f,2));l=f.length;for(m=0;m<l;m++)r=u(r,f[m]);return r};a.pInt=function(a,f){return parseInt(a,f||10)};a.isString=function(a){return\"string\"===typeof a};a.isArray=function(a){a=Object.prototype.toString.call(a);return\"[object Array]\"===a||\"[object Array Iterator]\"===a};a.isObject=function(m,\nf){return!!m&&\"object\"===typeof m&&(!f||!a.isArray(m))};a.isDOMElement=function(m){return a.isObject(m)&&\"number\"===typeof m.nodeType};a.isClass=function(m){var f=m&&m.constructor;return!(!a.isObject(m,!0)||a.isDOMElement(m)||!f||!f.name||\"Object\"===f.name)};a.isNumber=function(a){return\"number\"===typeof a&&!isNaN(a)};a.erase=function(a,f){for(var m=a.length;m--;)if(a[m]===f){a.splice(m,1);break}};a.defined=function(a){return void 0!==a&&null!==a};a.attr=function(m,f,l){var r;a.isString(f)?a.defined(l)?\nm.setAttribute(f,l):m&&m.getAttribute&&(r=m.getAttribute(f)):a.defined(f)&&a.isObject(f)&&a.objectEach(f,function(a,f){m.setAttribute(f,a)});return r};a.splat=function(m){return a.isArray(m)?m:[m]};a.syncTimeout=function(a,f,l){if(f)return setTimeout(a,f,l);a.call(0,l)};a.pick=function(){var a=arguments,f,l,r=a.length;for(f=0;f<r;f++)if(l=a[f],void 0!==l&&null!==l)return l};a.css=function(m,f){a.isMS&&!a.svg&&f&&void 0!==f.opacity&&(f.filter=\"alpha(opacity\\x3d\"+100*f.opacity+\")\");a.extend(m.style,\nf)};a.createElement=function(m,f,l,r,u){m=F.createElement(m);var t=a.css;f&&a.extend(m,f);u&&t(m,{padding:0,border:\"none\",margin:0});l&&t(m,l);r&&r.appendChild(m);return m};a.extendClass=function(m,f){var l=function(){};l.prototype=new m;a.extend(l.prototype,f);return l};a.pad=function(a,f,l){return Array((f||2)+1-String(a).length).join(l||0)+a};a.relativeLength=function(a,f,l){return/%$/.test(a)?f*parseFloat(a)/100+(l||0):parseFloat(a)};a.wrap=function(a,f,l){var r=a[f];a[f]=function(){var a=Array.prototype.slice.call(arguments),\nf=arguments,g=this;g.proceed=function(){r.apply(g,arguments.length?arguments:f)};a.unshift(r);a=l.apply(this,a);g.proceed=null;return a}};a.getTZOffset=function(m){var f=a.Date;return 6E4*(f.hcGetTimezoneOffset&&f.hcGetTimezoneOffset(m)||f.hcTimezoneOffset||0)};a.dateFormat=function(m,f,l){if(!a.defined(f)||isNaN(f))return a.defaultOptions.lang.invalidDate||\"\";m=a.pick(m,\"%Y-%m-%d %H:%M:%S\");var r=a.Date,u=new r(f-a.getTZOffset(f)),t=u[r.hcGetHours](),g=u[r.hcGetDay](),d=u[r.hcGetDate](),k=u[r.hcGetMonth](),\nb=u[r.hcGetFullYear](),e=a.defaultOptions.lang,v=e.weekdays,y=e.shortWeekdays,n=a.pad,r=a.extend({a:y?y[g]:v[g].substr(0,3),A:v[g],d:n(d),e:n(d,2,\" \"),w:g,b:e.shortMonths[k],B:e.months[k],m:n(k+1),y:b.toString().substr(2,2),Y:b,H:n(t),k:t,I:n(t%12||12),l:t%12||12,M:n(u[r.hcGetMinutes]()),p:12>t?\"AM\":\"PM\",P:12>t?\"am\":\"pm\",S:n(u.getSeconds()),L:n(Math.round(f%1E3),3)},a.dateFormats);a.objectEach(r,function(a,e){for(;-1!==m.indexOf(\"%\"+e);)m=m.replace(\"%\"+e,\"function\"===typeof a?a(f):a)});return l?m.substr(0,\n1).toUpperCase()+m.substr(1):m};a.formatSingle=function(m,f){var l=/\\.([0-9])/,r=a.defaultOptions.lang;/f$/.test(m)?(l=(l=m.match(l))?l[1]:-1,null!==f&&(f=a.numberFormat(f,l,r.decimalPoint,-1<m.indexOf(\",\")?r.thousandsSep:\"\"))):f=a.dateFormat(m,f);return f};a.format=function(m,f){for(var l=\"{\",r=!1,u,t,g,d,k=[],b;m;){l=m.indexOf(l);if(-1===l)break;u=m.slice(0,l);if(r){u=u.split(\":\");t=u.shift().split(\".\");d=t.length;b=f;for(g=0;g<d;g++)b=b[t[g]];u.length&&(b=a.formatSingle(u.join(\":\"),b));k.push(b)}else k.push(u);\nm=m.slice(l+1);l=(r=!r)?\"}\":\"{\"}k.push(m);return k.join(\"\")};a.getMagnitude=function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))};a.normalizeTickInterval=function(m,f,l,r,u){var t,g=m;l=a.pick(l,1);t=m/l;f||(f=u?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===r&&(1===l?f=a.grep(f,function(a){return 0===a%1}):.1>=l&&(f=[1/l])));for(r=0;r<f.length&&!(g=f[r],u&&g*l>=m||!u&&t<=(f[r]+(f[r+1]||f[r]))/2);r++);return g=a.correctFloat(g*l,-Math.round(Math.log(.001)/Math.LN10))};a.stableSort=\nfunction(a,f){var l=a.length,r,m;for(m=0;m<l;m++)a[m].safeI=m;a.sort(function(a,g){r=f(a,g);return 0===r?a.safeI-g.safeI:r});for(m=0;m<l;m++)delete a[m].safeI};a.arrayMin=function(a){for(var f=a.length,l=a[0];f--;)a[f]<l&&(l=a[f]);return l};a.arrayMax=function(a){for(var f=a.length,l=a[0];f--;)a[f]>l&&(l=a[f]);return l};a.destroyObjectProperties=function(m,f){a.objectEach(m,function(a,r){a&&a!==f&&a.destroy&&a.destroy();delete m[r]})};a.discardElement=function(m){var f=a.garbageBin;f||(f=a.createElement(\"div\"));\nm&&f.appendChild(m);f.innerHTML=\"\"};a.correctFloat=function(a,f){return parseFloat(a.toPrecision(f||14))};a.setAnimation=function(m,f){f.renderer.globalAnimation=a.pick(m,f.options.chart.animation,!0)};a.animObject=function(m){return a.isObject(m)?a.merge(m):{duration:m?500:0}};a.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5};a.numberFormat=function(m,f,l,r){m=+m||0;f=+f;var u=a.defaultOptions.lang,t=(m.toString().split(\".\")[1]||\"\").split(\"e\")[0].length,\ng,d,k=m.toString().split(\"e\");-1===f?f=Math.min(t,20):a.isNumber(f)||(f=2);d=(Math.abs(k[1]?k[0]:m)+Math.pow(10,-Math.max(f,t)-1)).toFixed(f);t=String(a.pInt(d));g=3<t.length?t.length%3:0;l=a.pick(l,u.decimalPoint);r=a.pick(r,u.thousandsSep);m=(0>m?\"-\":\"\")+(g?t.substr(0,g)+r:\"\");m+=t.substr(g).replace(/(\\d{3})(?=\\d)/g,\"$1\"+r);f&&(m+=l+d.slice(-f));k[1]&&(m+=\"e\"+k[1]);return m};Math.easeInOutSine=function(a){return-.5*(Math.cos(Math.PI*a)-1)};a.getStyle=function(m,f,l){if(\"width\"===f)return Math.min(m.offsetWidth,\nm.scrollWidth)-a.getStyle(m,\"padding-left\")-a.getStyle(m,\"padding-right\");if(\"height\"===f)return Math.min(m.offsetHeight,m.scrollHeight)-a.getStyle(m,\"padding-top\")-a.getStyle(m,\"padding-bottom\");if(m=E.getComputedStyle(m,void 0))m=m.getPropertyValue(f),a.pick(l,!0)&&(m=a.pInt(m));return m};a.inArray=function(a,f){return f.indexOf?f.indexOf(a):[].indexOf.call(f,a)};a.grep=function(a,f){return[].filter.call(a,f)};a.find=function(a,f){return[].find.call(a,f)};a.map=function(a,f){for(var l=[],r=0,m=\na.length;r<m;r++)l[r]=f.call(a[r],a[r],r,a);return l};a.offset=function(a){var f=F.documentElement;a=a.getBoundingClientRect();return{top:a.top+(E.pageYOffset||f.scrollTop)-(f.clientTop||0),left:a.left+(E.pageXOffset||f.scrollLeft)-(f.clientLeft||0)}};a.stop=function(a,f){for(var l=C.length;l--;)C[l].elem!==a||f&&f!==C[l].prop||(C[l].stopped=!0)};a.each=function(a,f,l){return Array.prototype.forEach.call(a,f,l)};a.objectEach=function(a,f,l){for(var r in a)a.hasOwnProperty(r)&&f.call(l,a[r],r,a)};\na.addEvent=function(m,f,l){function r(a){a.target=a.srcElement||E;l.call(m,a)}var u=m.hcEvents=m.hcEvents||{};m.addEventListener?m.addEventListener(f,l,!1):m.attachEvent&&(m.hcEventsIE||(m.hcEventsIE={}),l.hcGetKey||(l.hcGetKey=a.uniqueKey()),m.hcEventsIE[l.hcGetKey]=r,m.attachEvent(\"on\"+f,r));u[f]||(u[f]=[]);u[f].push(l);return function(){a.removeEvent(m,f,l)}};a.removeEvent=function(m,f,l){function r(a,b){m.removeEventListener?m.removeEventListener(a,b,!1):m.attachEvent&&(b=m.hcEventsIE[b.hcGetKey],\nm.detachEvent(\"on\"+a,b))}function u(){var d,b;m.nodeName&&(f?(d={},d[f]=!0):d=g,a.objectEach(d,function(a,d){if(g[d])for(b=g[d].length;b--;)r(d,g[d][b])}))}var t,g=m.hcEvents,d;g&&(f?(t=g[f]||[],l?(d=a.inArray(l,t),-1<d&&(t.splice(d,1),g[f]=t),r(f,l)):(u(),g[f]=[])):(u(),m.hcEvents={}))};a.fireEvent=function(m,f,l,r){var u;u=m.hcEvents;var t,g;l=l||{};if(F.createEvent&&(m.dispatchEvent||m.fireEvent))u=F.createEvent(\"Events\"),u.initEvent(f,!0,!0),a.extend(u,l),m.dispatchEvent?m.dispatchEvent(u):m.fireEvent(f,\nu);else if(u)for(u=u[f]||[],t=u.length,l.target||a.extend(l,{preventDefault:function(){l.defaultPrevented=!0},target:m,type:f}),f=0;f<t;f++)(g=u[f])&&!1===g.call(m,l)&&l.preventDefault();r&&!l.defaultPrevented&&r(l)};a.animate=function(m,f,l){var r,u=\"\",t,g,d;a.isObject(l)||(d=arguments,l={duration:d[2],easing:d[3],complete:d[4]});a.isNumber(l.duration)||(l.duration=400);l.easing=\"function\"===typeof l.easing?l.easing:Math[l.easing]||Math.easeInOutSine;l.curAnim=a.merge(f);a.objectEach(f,function(d,\nb){a.stop(m,b);g=new a.Fx(m,l,b);t=null;\"d\"===b?(g.paths=g.initPath(m,m.d,f.d),g.toD=f.d,r=0,t=1):m.attr?r=m.attr(b):(r=parseFloat(a.getStyle(m,b))||0,\"opacity\"!==b&&(u=\"px\"));t||(t=d);t&&t.match&&t.match(\"px\")&&(t=t.replace(/px/g,\"\"));g.run(r,t,u)})};a.seriesType=function(m,f,l,r,u){var t=a.getOptions(),g=a.seriesTypes;t.plotOptions[m]=a.merge(t.plotOptions[f],l);g[m]=a.extendClass(g[f]||function(){},r);g[m].prototype.type=m;u&&(g[m].prototype.pointClass=a.extendClass(a.Point,u));return g[m]};a.uniqueKey=\nfunction(){var a=Math.random().toString(36).substring(2,9),f=0;return function(){return\"highcharts-\"+a+\"-\"+f++}}();E.jQuery&&(E.jQuery.fn.highcharts=function(){var m=[].slice.call(arguments);if(this[0])return m[0]?(new (a[a.isString(m[0])?m.shift():\"Chart\"])(this[0],m[0],m[1]),this):A[a.attr(this[0],\"data-highcharts-chart\")]});F&&!F.defaultView&&(a.getStyle=function(m,f){var l={width:\"clientWidth\",height:\"clientHeight\"}[f];if(m.style[f])return a.pInt(m.style[f]);\"opacity\"===f&&(f=\"filter\");if(l)return m.style.zoom=\n1,Math.max(m[l]-2*a.getStyle(m,\"padding\"),0);m=m.currentStyle[f.replace(/\\-(\\w)/g,function(a,f){return f.toUpperCase()})];\"filter\"===f&&(m=m.replace(/alpha\\(opacity=([0-9]+)\\)/,function(a,f){return f/100}));return\"\"===m?1:a.pInt(m)});Array.prototype.forEach||(a.each=function(a,f,l){for(var r=0,m=a.length;r<m;r++)if(!1===f.call(l,a[r],r,a))return r});Array.prototype.indexOf||(a.inArray=function(a,f){var l,r=0;if(f)for(l=f.length;r<l;r++)if(f[r]===a)return r;return-1});Array.prototype.filter||(a.grep=\nfunction(a,f){for(var l=[],r=0,m=a.length;r<m;r++)f(a[r],r)&&l.push(a[r]);return l});Array.prototype.find||(a.find=function(a,f){var l,r=a.length;for(l=0;l<r;l++)if(f(a[l],l))return a[l]})})(M);(function(a){var C=a.each,A=a.isNumber,F=a.map,E=a.merge,m=a.pInt;a.Color=function(f){if(!(this instanceof a.Color))return new a.Color(f);this.init(f)};a.Color.prototype={parsers:[{regex:/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,parse:function(a){return[m(a[1]),\nm(a[2]),m(a[3]),parseFloat(a[4],10)]}},{regex:/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,parse:function(a){return[m(a[1]),m(a[2]),m(a[3]),1]}}],names:{none:\"rgba(255,255,255,0)\",white:\"#ffffff\",black:\"#000000\"},init:function(f){var l,r,m,t;if((this.input=f=this.names[f&&f.toLowerCase?f.toLowerCase():\"\"]||f)&&f.stops)this.stops=F(f.stops,function(g){return new a.Color(g[1])});else if(f&&\"#\"===f.charAt()&&(l=f.length,f=parseInt(f.substr(1),16),7===l?r=[(f&16711680)>>16,(f&65280)>>\n8,f&255,1]:4===l&&(r=[(f&3840)>>4|(f&3840)>>8,(f&240)>>4|f&240,(f&15)<<4|f&15,1])),!r)for(m=this.parsers.length;m--&&!r;)t=this.parsers[m],(l=t.regex.exec(f))&&(r=t.parse(l));this.rgba=r||[]},get:function(a){var f=this.input,r=this.rgba,m;this.stops?(m=E(f),m.stops=[].concat(m.stops),C(this.stops,function(f,g){m.stops[g]=[m.stops[g][0],f.get(a)]})):m=r&&A(r[0])?\"rgb\"===a||!a&&1===r[3]?\"rgb(\"+r[0]+\",\"+r[1]+\",\"+r[2]+\")\":\"a\"===a?r[3]:\"rgba(\"+r.join(\",\")+\")\":f;return m},brighten:function(a){var f,r=this.rgba;\nif(this.stops)C(this.stops,function(f){f.brighten(a)});else if(A(a)&&0!==a)for(f=0;3>f;f++)r[f]+=m(255*a),0>r[f]&&(r[f]=0),255<r[f]&&(r[f]=255);return this},setOpacity:function(a){this.rgba[3]=a;return this},tweenTo:function(a,l){var f,m;a.rgba.length?(f=this.rgba,a=a.rgba,m=1!==a[3]||1!==f[3],a=(m?\"rgba(\":\"rgb(\")+Math.round(a[0]+(f[0]-a[0])*(1-l))+\",\"+Math.round(a[1]+(f[1]-a[1])*(1-l))+\",\"+Math.round(a[2]+(f[2]-a[2])*(1-l))+(m?\",\"+(a[3]+(f[3]-a[3])*(1-l)):\"\")+\")\"):a=a.input||\"none\";return a}};a.color=\nfunction(f){return new a.Color(f)}})(M);(function(a){var C,A,F=a.addEvent,E=a.animate,m=a.attr,f=a.charts,l=a.color,r=a.css,u=a.createElement,t=a.defined,g=a.deg2rad,d=a.destroyObjectProperties,k=a.doc,b=a.each,e=a.extend,v=a.erase,y=a.grep,n=a.hasTouch,D=a.inArray,J=a.isArray,c=a.isFirefox,G=a.isMS,q=a.isObject,B=a.isString,K=a.isWebKit,p=a.merge,z=a.noop,I=a.objectEach,L=a.pick,h=a.pInt,w=a.removeEvent,P=a.stop,H=a.svg,O=a.SVG_NS,Q=a.symbolSizes,R=a.win;C=a.SVGElement=function(){return this};e(C.prototype,\n{opacity:1,SVG_NS:O,textProps:\"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline\".split(\" \"),init:function(a,h){this.element=\"span\"===h?u(h):k.createElementNS(this.SVG_NS,h);this.renderer=a},animate:function(x,h,c){h=a.animObject(L(h,this.renderer.globalAnimation,!0));0!==h.duration?(c&&(h.complete=c),E(this,x,h)):(this.attr(x,null,c),h.step&&h.step.call(this));return this},colorGradient:function(x,h,c){var w=this.renderer,\ne,q,N,d,n,g,k,H,G,v,z=[],f;x.radialGradient?q=\"radialGradient\":x.linearGradient&&(q=\"linearGradient\");q&&(N=x[q],n=w.gradients,k=x.stops,v=c.radialReference,J(N)&&(x[q]=N={x1:N[0],y1:N[1],x2:N[2],y2:N[3],gradientUnits:\"userSpaceOnUse\"}),\"radialGradient\"===q&&v&&!t(N.gradientUnits)&&(d=N,N=p(N,w.getRadialAttr(v,d),{gradientUnits:\"userSpaceOnUse\"})),I(N,function(a,x){\"id\"!==x&&z.push(x,a)}),I(k,function(a){z.push(a)}),z=z.join(\",\"),n[z]?v=n[z].attr(\"id\"):(N.id=v=a.uniqueKey(),n[z]=g=w.createElement(q).attr(N).add(w.defs),\ng.radAttr=d,g.stops=[],b(k,function(x){0===x[1].indexOf(\"rgba\")?(e=a.color(x[1]),H=e.get(\"rgb\"),G=e.get(\"a\")):(H=x[1],G=1);x=w.createElement(\"stop\").attr({offset:x[0],\"stop-color\":H,\"stop-opacity\":G}).add(g);g.stops.push(x)})),f=\"url(\"+w.url+\"#\"+v+\")\",c.setAttribute(h,f),c.gradient=z,x.toString=function(){return f})},applyTextOutline:function(x){var h=this.element,c,w,p,e,q;-1!==x.indexOf(\"contrast\")&&(x=x.replace(/contrast/g,this.renderer.getContrast(h.style.fill)));x=x.split(\" \");w=x[x.length-1];\nif((p=x[0])&&\"none\"!==p&&a.svg){this.fakeTS=!0;x=[].slice.call(h.getElementsByTagName(\"tspan\"));this.ySetter=this.xSetter;p=p.replace(/(^[\\d\\.]+)(.*?)$/g,function(a,x,h){return 2*x+h});for(q=x.length;q--;)c=x[q],\"highcharts-text-outline\"===c.getAttribute(\"class\")&&v(x,h.removeChild(c));e=h.firstChild;b(x,function(a,x){0===x&&(a.setAttribute(\"x\",h.getAttribute(\"x\")),x=h.getAttribute(\"y\"),a.setAttribute(\"y\",x||0),null===x&&h.setAttribute(\"y\",0));a=a.cloneNode(1);m(a,{\"class\":\"highcharts-text-outline\",\nfill:w,stroke:w,\"stroke-width\":p,\"stroke-linejoin\":\"round\"});h.insertBefore(a,e)})}},attr:function(a,h,c,w){var x,p=this.element,e,q=this,b,N;\"string\"===typeof a&&void 0!==h&&(x=a,a={},a[x]=h);\"string\"===typeof a?q=(this[a+\"Getter\"]||this._defaultGetter).call(this,a,p):(I(a,function(x,h){b=!1;w||P(this,h);this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(h)&&(e||(this.symbolAttr(a),e=!0),b=!0);!this.rotation||\"x\"!==h&&\"y\"!==h||(this.doTransform=!0);b||(N=this[h+\"Setter\"]||\nthis._defaultSetter,N.call(this,x,h,p),this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(h)&&this.updateShadows(h,x,N))},this),this.afterSetters());c&&c();return q},afterSetters:function(){this.doTransform&&(this.updateTransform(),this.doTransform=!1)},updateShadows:function(a,h,c){for(var x=this.shadows,w=x.length;w--;)c.call(x[w],\"height\"===a?Math.max(h-(x[w].cutHeight||0),0):\"d\"===a?this.d:h,a,x[w])},addClass:function(a,h){var x=this.attr(\"class\")||\"\";-1===x.indexOf(a)&&\n(h||(a=(x+(x?\" \":\"\")+a).replace(\"  \",\" \")),this.attr(\"class\",a));return this},hasClass:function(a){return-1!==D(a,(this.attr(\"class\")||\"\").split(\" \"))},removeClass:function(a){return this.attr(\"class\",(this.attr(\"class\")||\"\").replace(a,\"\"))},symbolAttr:function(a){var x=this;b(\"x y r start end width height innerR anchorX anchorY\".split(\" \"),function(h){x[h]=L(a[h],x[h])});x.attr({d:x.renderer.symbols[x.symbolName](x.x,x.y,x.width,x.height,x)})},clip:function(a){return this.attr(\"clip-path\",a?\"url(\"+\nthis.renderer.url+\"#\"+a.id+\")\":\"none\")},crisp:function(a,h){var x=this,c={},w;h=h||a.strokeWidth||0;w=Math.round(h)%2/2;a.x=Math.floor(a.x||x.x||0)+w;a.y=Math.floor(a.y||x.y||0)+w;a.width=Math.floor((a.width||x.width||0)-2*w);a.height=Math.floor((a.height||x.height||0)-2*w);t(a.strokeWidth)&&(a.strokeWidth=h);I(a,function(a,h){x[h]!==a&&(x[h]=c[h]=a)});return c},css:function(a){var x=this.styles,c={},w=this.element,p,q=\"\",b,d=!x,n=[\"textOutline\",\"textOverflow\",\"width\"];a&&a.color&&(a.fill=a.color);\nx&&I(a,function(a,h){a!==x[h]&&(c[h]=a,d=!0)});d&&(x&&(a=e(x,c)),p=this.textWidth=a&&a.width&&\"auto\"!==a.width&&\"text\"===w.nodeName.toLowerCase()&&h(a.width),this.styles=a,p&&!H&&this.renderer.forExport&&delete a.width,G&&!H?r(this.element,a):(b=function(a,x){return\"-\"+x.toLowerCase()},I(a,function(a,x){-1===D(x,n)&&(q+=x.replace(/([A-Z])/g,b)+\":\"+a+\";\")}),q&&m(w,\"style\",q)),this.added&&(\"text\"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline)));\nreturn this},strokeWidth:function(){return this[\"stroke-width\"]||0},on:function(a,h){var x=this,c=x.element;n&&\"click\"===a?(c.ontouchstart=function(a){x.touchEventFired=Date.now();a.preventDefault();h.call(c,a)},c.onclick=function(a){(-1===R.navigator.userAgent.indexOf(\"Android\")||1100<Date.now()-(x.touchEventFired||0))&&h.call(c,a)}):c[\"on\"+a]=h;return this},setRadialReference:function(a){var x=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;x&&x.radAttr&&x.animate(this.renderer.getRadialAttr(a,\nx.radAttr));return this},translate:function(a,h){return this.attr({translateX:a,translateY:h})},invert:function(a){this.inverted=a;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,h=this.translateY||0,c=this.scaleX,w=this.scaleY,p=this.inverted,e=this.rotation,q=this.element;p&&(a+=this.width,h+=this.height);a=[\"translate(\"+a+\",\"+h+\")\"];p?a.push(\"rotate(90) scale(-1,1)\"):e&&a.push(\"rotate(\"+e+\" \"+(q.getAttribute(\"x\")||0)+\" \"+(q.getAttribute(\"y\")||0)+\")\");(t(c)||\nt(w))&&a.push(\"scale(\"+L(c,1)+\" \"+L(w,1)+\")\");a.length&&q.setAttribute(\"transform\",a.join(\" \"))},toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,h,c){var x,w,p,e,q={};w=this.renderer;p=w.alignedObjects;var b,d;if(a){if(this.alignOptions=a,this.alignByTranslate=h,!c||B(c))this.alignTo=x=c||\"renderer\",v(p,this),p.push(this),c=null}else a=this.alignOptions,h=this.alignByTranslate,x=this.alignTo;c=L(c,w[x],w);x=a.align;w=a.verticalAlign;p=(c.x||0)+(a.x||\n0);e=(c.y||0)+(a.y||0);\"right\"===x?b=1:\"center\"===x&&(b=2);b&&(p+=(c.width-(a.width||0))/b);q[h?\"translateX\":\"x\"]=Math.round(p);\"bottom\"===w?d=1:\"middle\"===w&&(d=2);d&&(e+=(c.height-(a.height||0))/d);q[h?\"translateY\":\"y\"]=Math.round(e);this[this.placed?\"animate\":\"attr\"](q);this.placed=!0;this.alignAttr=q;return this},getBBox:function(a,h){var x,c=this.renderer,w,p=this.element,q=this.styles,d,n=this.textStr,k,N=c.cache,H=c.cacheKeys,G;h=L(h,this.rotation);w=h*g;d=q&&q.fontSize;void 0!==n&&(G=n.toString(),\n-1===G.indexOf(\"\\x3c\")&&(G=G.replace(/[0-9]/g,\"0\")),G+=[\"\",h||0,d,q&&q.width,q&&q.textOverflow].join());G&&!a&&(x=N[G]);if(!x){if(p.namespaceURI===this.SVG_NS||c.forExport){try{(k=this.fakeTS&&function(a){b(p.querySelectorAll(\".highcharts-text-outline\"),function(x){x.style.display=a})})&&k(\"none\"),x=p.getBBox?e({},p.getBBox()):{width:p.offsetWidth,height:p.offsetHeight},k&&k(\"\")}catch(W){}if(!x||0>x.width)x={width:0,height:0}}else x=this.htmlGetBBox();c.isSVG&&(a=x.width,c=x.height,q&&\"11px\"===q.fontSize&&\n17===Math.round(c)&&(x.height=c=14),h&&(x.width=Math.abs(c*Math.sin(w))+Math.abs(a*Math.cos(w)),x.height=Math.abs(c*Math.cos(w))+Math.abs(a*Math.sin(w))));if(G&&0<x.height){for(;250<H.length;)delete N[H.shift()];N[G]||H.push(G);N[G]=x}}return x},show:function(a){return this.attr({visibility:a?\"inherit\":\"visible\"})},hide:function(){return this.attr({visibility:\"hidden\"})},fadeOut:function(a){var x=this;x.animate({opacity:0},{duration:a||150,complete:function(){x.attr({y:-9999})}})},add:function(a){var x=\nthis.renderer,h=this.element,c;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;void 0!==this.textStr&&x.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)c=this.zIndexSetter();c||(a?a.element:x.box).appendChild(h);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var x=a.parentNode;x&&x.removeChild(a)},destroy:function(){var a=this,h=a.element||{},c=a.renderer.isSVG&&\"SPAN\"===h.nodeName&&a.parentGroup,w=h.ownerSVGElement;h.onclick=h.onmouseout=h.onmouseover=h.onmousemove=\nh.point=null;P(a);a.clipPath&&w&&(b(w.querySelectorAll(\"[clip-path]\"),function(x){-1<x.getAttribute(\"clip-path\").indexOf(a.clipPath.element.id+\")\")&&x.removeAttribute(\"clip-path\")}),a.clipPath=a.clipPath.destroy());if(a.stops){for(w=0;w<a.stops.length;w++)a.stops[w]=a.stops[w].destroy();a.stops=null}a.safeRemoveChild(h);for(a.destroyShadows();c&&c.div&&0===c.div.childNodes.length;)h=c.parentGroup,a.safeRemoveChild(c.div),delete c.div,c=h;a.alignTo&&v(a.renderer.alignedObjects,a);I(a,function(x,h){delete a[h]});\nreturn null},shadow:function(a,h,c){var x=[],w,p,q=this.element,e,b,d,n;if(!a)this.destroyShadows();else if(!this.shadows){b=L(a.width,3);d=(a.opacity||.15)/b;n=this.parentInverted?\"(-1,-1)\":\"(\"+L(a.offsetX,1)+\", \"+L(a.offsetY,1)+\")\";for(w=1;w<=b;w++)p=q.cloneNode(0),e=2*b+1-2*w,m(p,{isShadow:\"true\",stroke:a.color||\"#000000\",\"stroke-opacity\":d*w,\"stroke-width\":e,transform:\"translate\"+n,fill:\"none\"}),c&&(m(p,\"height\",Math.max(m(p,\"height\")-e,0)),p.cutHeight=e),h?h.element.appendChild(p):q.parentNode.insertBefore(p,\nq),x.push(p);this.shadows=x}return this},destroyShadows:function(){b(this.shadows||[],function(a){this.safeRemoveChild(a)},this);this.shadows=void 0},xGetter:function(a){\"circle\"===this.element.nodeName&&(\"x\"===a?a=\"cx\":\"y\"===a&&(a=\"cy\"));return this._defaultGetter(a)},_defaultGetter:function(a){a=L(this[a],this.element?this.element.getAttribute(a):null,0);/^[\\-0-9\\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,h,c){a&&a.join&&(a=a.join(\" \"));/(NaN| {2}|^$)/.test(a)&&(a=\"M 0 0\");this[h]!==\na&&(c.setAttribute(h,a),this[h]=a)},dashstyleSetter:function(a){var x,c=this[\"stroke-width\"];\"inherit\"===c&&(c=1);if(a=a&&a.toLowerCase()){a=a.replace(\"shortdashdotdot\",\"3,1,1,1,1,1,\").replace(\"shortdashdot\",\"3,1,1,1\").replace(\"shortdot\",\"1,1,\").replace(\"shortdash\",\"3,1,\").replace(\"longdash\",\"8,3,\").replace(/dot/g,\"1,3,\").replace(\"dash\",\"4,3,\").replace(/,$/,\"\").split(\",\");for(x=a.length;x--;)a[x]=h(a[x])*c;a=a.join(\",\").replace(/NaN/g,\"none\");this.element.setAttribute(\"stroke-dasharray\",a)}},alignSetter:function(a){this.element.setAttribute(\"text-anchor\",\n{left:\"start\",center:\"middle\",right:\"end\"}[a])},opacitySetter:function(a,h,c){this[h]=a;c.setAttribute(h,a)},titleSetter:function(a){var h=this.element.getElementsByTagName(\"title\")[0];h||(h=k.createElementNS(this.SVG_NS,\"title\"),this.element.appendChild(h));h.firstChild&&h.removeChild(h.firstChild);h.appendChild(k.createTextNode(String(L(a),\"\").replace(/<[^>]*>/g,\"\")))},textSetter:function(a){a!==this.textStr&&(delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this))},fillSetter:function(a,\nh,c){\"string\"===typeof a?c.setAttribute(h,a):a&&this.colorGradient(a,h,c)},visibilitySetter:function(a,h,c){\"inherit\"===a?c.removeAttribute(h):this[h]!==a&&c.setAttribute(h,a);this[h]=a},zIndexSetter:function(a,c){var x=this.renderer,w=this.parentGroup,p=(w||x).element||x.box,q,e=this.element,b;q=this.added;var d;t(a)&&(e.zIndex=a,a=+a,this[c]===a&&(q=!1),this[c]=a);if(q){(a=this.zIndex)&&w&&(w.handleZ=!0);c=p.childNodes;for(d=0;d<c.length&&!b;d++)w=c[d],q=w.zIndex,w!==e&&(h(q)>a||!t(a)&&t(q)||0>\na&&!t(q)&&p!==x.box)&&(p.insertBefore(e,w),b=!0);b||p.appendChild(e)}return b},_defaultSetter:function(a,h,c){c.setAttribute(h,a)}});C.prototype.yGetter=C.prototype.xGetter;C.prototype.translateXSetter=C.prototype.translateYSetter=C.prototype.rotationSetter=C.prototype.verticalAlignSetter=C.prototype.scaleXSetter=C.prototype.scaleYSetter=function(a,h){this[h]=a;this.doTransform=!0};C.prototype[\"stroke-widthSetter\"]=C.prototype.strokeSetter=function(a,h,c){this[h]=a;this.stroke&&this[\"stroke-width\"]?\n(C.prototype.fillSetter.call(this,this.stroke,\"stroke\",c),c.setAttribute(\"stroke-width\",this[\"stroke-width\"]),this.hasStroke=!0):\"stroke-width\"===h&&0===a&&this.hasStroke&&(c.removeAttribute(\"stroke\"),this.hasStroke=!1)};A=a.SVGRenderer=function(){this.init.apply(this,arguments)};e(A.prototype,{Element:C,SVG_NS:O,init:function(a,h,w,p,q,e){var x;p=this.createElement(\"svg\").attr({version:\"1.1\",\"class\":\"highcharts-root\"}).css(this.getStyle(p));x=p.element;a.appendChild(x);-1===a.innerHTML.indexOf(\"xmlns\")&&\nm(x,\"xmlns\",this.SVG_NS);this.isSVG=!0;this.box=x;this.boxWrapper=p;this.alignedObjects=[];this.url=(c||K)&&k.getElementsByTagName(\"base\").length?R.location.href.replace(/#.*?$/,\"\").replace(/<[^>]*>/g,\"\").replace(/([\\('\\)])/g,\"\\\\$1\").replace(/ /g,\"%20\"):\"\";this.createElement(\"desc\").add().element.appendChild(k.createTextNode(\"Created with Highcharts 5.0.14\"));this.defs=this.createElement(\"defs\").add();this.allowHTML=e;this.forExport=q;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=\n0;this.setSize(h,w,!1);var b;c&&a.getBoundingClientRect&&(h=function(){r(a,{left:0,top:0});b=a.getBoundingClientRect();r(a,{left:Math.ceil(b.left)-b.left+\"px\",top:Math.ceil(b.top)-b.top+\"px\"})},h(),this.unSubPixelFix=F(R,\"resize\",h))},getStyle:function(a){return this.style=e({fontFamily:'\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',fontSize:\"12px\"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=\nthis.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();d(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var h=new this.Element;h.init(this,a);return h},draw:z,getRadialAttr:function(a,h){return{cx:a[0]-a[2]/2+h.cx*a[2],cy:a[1]-a[2]/2+h.cy*a[2],r:h.r*a[2]}},getSpanWidth:function(a,h){var c=a.getBBox(!0).width;!H&&this.forExport&&(c=this.measureSpanWidth(h.firstChild.data,\na.styles));return c},applyEllipsis:function(a,h,c,w){var x=a.rotation,p=c,q,e=0,b=c.length,d=function(a){h.removeChild(h.firstChild);a&&h.appendChild(k.createTextNode(a))},n;a.rotation=0;p=this.getSpanWidth(a,h);if(n=p>w){for(;e<=b;)q=Math.ceil((e+b)/2),p=c.substring(0,q)+\"\\u2026\",d(p),p=this.getSpanWidth(a,h),e===b?e=b+1:p>w?b=q-1:e=q;0===b&&d(\"\")}a.rotation=x;return n},buildText:function(a){var c=a.element,w=this,x=w.forExport,p=L(a.textStr,\"\").toString(),q=-1!==p.indexOf(\"\\x3c\"),e=c.childNodes,\nd,n,g,G,v=m(c,\"x\"),z=a.styles,f=a.textWidth,I=z&&z.lineHeight,B=z&&z.textOutline,D=z&&\"ellipsis\"===z.textOverflow,l=z&&\"nowrap\"===z.whiteSpace,P=z&&z.fontSize,t,J,u=e.length,z=f&&!a.added&&this.box,K=function(a){var x;x=/(px|em)$/.test(a&&a.style.fontSize)?a.style.fontSize:P||w.style.fontSize||12;return I?h(I):w.fontMetrics(x,a.getAttribute(\"style\")?a:c).h};t=[p,D,l,I,B,P,f].join();if(t!==a.textCache){for(a.textCache=t;u--;)c.removeChild(e[u]);q||B||D||f||-1!==p.indexOf(\" \")?(d=/<.*class=\"([^\"]+)\".*>/,\nn=/<.*style=\"([^\"]+)\".*>/,g=/<.*href=\"([^\"]+)\".*>/,z&&z.appendChild(c),p=q?p.replace(/<(b|strong)>/g,'\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g,'\\x3cspan style\\x3d\"font-style:italic\"\\x3e').replace(/<a/g,\"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g,\"\\x3c/span\\x3e\").split(/<br.*?>/g):[p],p=y(p,function(a){return\"\"!==a}),b(p,function(h,p){var q,e=0;h=h.replace(/^\\s+|\\s+$/g,\"\").replace(/<span/g,\"|||\\x3cspan\").replace(/<\\/span>/g,\"\\x3c/span\\x3e|||\");q=h.split(\"|||\");b(q,function(h){if(\"\"!==\nh||1===q.length){var b={},z=k.createElementNS(w.SVG_NS,\"tspan\"),y,I;d.test(h)&&(y=h.match(d)[1],m(z,\"class\",y));n.test(h)&&(I=h.match(n)[1].replace(/(;| |^)color([ :])/,\"$1fill$2\"),m(z,\"style\",I));g.test(h)&&!x&&(m(z,\"onclick\",'location.href\\x3d\"'+h.match(g)[1]+'\"'),r(z,{cursor:\"pointer\"}));h=(h.replace(/<(.|\\n)*?>/g,\"\")||\" \").replace(/&lt;/g,\"\\x3c\").replace(/&gt;/g,\"\\x3e\");if(\" \"!==h){z.appendChild(k.createTextNode(h));e?b.dx=0:p&&null!==v&&(b.x=v);m(z,b);c.appendChild(z);!e&&J&&(!H&&x&&r(z,{display:\"block\"}),\nm(z,\"dy\",K(z)));if(f){b=h.replace(/([^\\^])-/g,\"$1- \").split(\" \");y=1<q.length||p||1<b.length&&!l;var B=[],N,P=K(z),t=a.rotation;for(D&&(G=w.applyEllipsis(a,z,h,f));!D&&y&&(b.length||B.length);)a.rotation=0,N=w.getSpanWidth(a,z),h=N>f,void 0===G&&(G=h),h&&1!==b.length?(z.removeChild(z.firstChild),B.unshift(b.pop())):(b=B,B=[],b.length&&!l&&(z=k.createElementNS(O,\"tspan\"),m(z,{dy:P,x:v}),I&&m(z,\"style\",I),c.appendChild(z)),N>f&&(f=N)),b.length&&z.appendChild(k.createTextNode(b.join(\" \").replace(/- /g,\n\"-\")));a.rotation=t}e++}}});J=J||c.childNodes.length}),G&&a.attr(\"title\",a.textStr),z&&z.removeChild(c),B&&a.applyTextOutline&&a.applyTextOutline(B)):c.appendChild(k.createTextNode(p.replace(/&lt;/g,\"\\x3c\").replace(/&gt;/g,\"\\x3e\")))}},getContrast:function(a){a=l(a).rgba;return 510<a[0]+a[1]+a[2]?\"#000000\":\"#FFFFFF\"},button:function(a,h,c,w,q,b,d,n,g){var x=this.label(a,h,c,g,null,null,null,null,\"button\"),k=0;x.attr(p({padding:8,r:2},q));var z,H,v,f;q=p({fill:\"#f7f7f7\",stroke:\"#cccccc\",\"stroke-width\":1,\nstyle:{color:\"#333333\",cursor:\"pointer\",fontWeight:\"normal\"}},q);z=q.style;delete q.style;b=p(q,{fill:\"#e6e6e6\"},b);H=b.style;delete b.style;d=p(q,{fill:\"#e6ebf5\",style:{color:\"#000000\",fontWeight:\"bold\"}},d);v=d.style;delete d.style;n=p(q,{style:{color:\"#cccccc\"}},n);f=n.style;delete n.style;F(x.element,G?\"mouseover\":\"mouseenter\",function(){3!==k&&x.setState(1)});F(x.element,G?\"mouseout\":\"mouseleave\",function(){3!==k&&x.setState(k)});x.setState=function(a){1!==a&&(x.state=k=a);x.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\"+\n[\"normal\",\"hover\",\"pressed\",\"disabled\"][a||0]);x.attr([q,b,d,n][a||0]).css([z,H,v,f][a||0])};x.attr(q).css(e({cursor:\"default\"},z));return x.on(\"click\",function(a){3!==k&&w.call(x,a)})},crispLine:function(a,h){a[1]===a[4]&&(a[1]=a[4]=Math.round(a[1])-h%2/2);a[2]===a[5]&&(a[2]=a[5]=Math.round(a[2])+h%2/2);return a},path:function(a){var h={fill:\"none\"};J(a)?h.d=a:q(a)&&e(h,a);return this.createElement(\"path\").attr(h)},circle:function(a,h,c){a=q(a)?a:{x:a,y:h,r:c};h=this.createElement(\"circle\");h.xSetter=\nh.ySetter=function(a,h,c){c.setAttribute(\"c\"+h,a)};return h.attr(a)},arc:function(a,h,c,w,p,b){q(a)?(w=a,h=w.y,c=w.r,a=w.x):w={innerR:w,start:p,end:b};a=this.symbol(\"arc\",a,h,c,c,w);a.r=c;return a},rect:function(a,h,c,w,p,b){p=q(a)?a.r:p;var x=this.createElement(\"rect\");a=q(a)?a:void 0===a?{}:{x:a,y:h,width:Math.max(c,0),height:Math.max(w,0)};void 0!==b&&(a.strokeWidth=b,a=x.crisp(a));a.fill=\"none\";p&&(a.r=p);x.rSetter=function(a,h,c){m(c,{rx:a,ry:a})};return x.attr(a)},setSize:function(a,h,c){var w=\nthis.alignedObjects,p=w.length;this.width=a;this.height=h;for(this.boxWrapper.animate({width:a,height:h},{step:function(){this.attr({viewBox:\"0 0 \"+this.attr(\"width\")+\" \"+this.attr(\"height\")})},duration:L(c,!0)?void 0:0});p--;)w[p].align()},g:function(a){var h=this.createElement(\"g\");return a?h.attr({\"class\":\"highcharts-\"+a}):h},image:function(a,h,c,w,p){var x={preserveAspectRatio:\"none\"};1<arguments.length&&e(x,{x:h,y:c,width:w,height:p});x=this.createElement(\"image\").attr(x);x.element.setAttributeNS?\nx.element.setAttributeNS(\"http://www.w3.org/1999/xlink\",\"href\",a):x.element.setAttribute(\"hc-svg-href\",a);return x},symbol:function(a,h,c,w,p,q){var x=this,d,n=/^url\\((.*?)\\)$/,g=n.test(a),z=!g&&(this.symbols[a]?a:\"circle\"),G=z&&this.symbols[z],H=t(h)&&G&&G.call(this.symbols,Math.round(h),Math.round(c),w,p,q),v,y;G?(d=this.path(H),d.attr(\"fill\",\"none\"),e(d,{symbolName:z,x:h,y:c,width:w,height:p}),q&&e(d,q)):g&&(v=a.match(n)[1],d=this.image(v),d.imgwidth=L(Q[v]&&Q[v].width,q&&q.width),d.imgheight=\nL(Q[v]&&Q[v].height,q&&q.height),y=function(){d.attr({width:d.width,height:d.height})},b([\"width\",\"height\"],function(a){d[a+\"Setter\"]=function(a,h){var c={},w=this[\"img\"+h],p=\"width\"===h?\"translateX\":\"translateY\";this[h]=a;t(w)&&(this.element&&this.element.setAttribute(h,w),this.alignByTranslate||(c[p]=((this[h]||0)-w)/2,this.attr(c)))}}),t(h)&&d.attr({x:h,y:c}),d.isImg=!0,t(d.imgwidth)&&t(d.imgheight)?y():(d.attr({width:0,height:0}),u(\"img\",{onload:function(){var a=f[x.chartIndex];0===this.width&&\n(r(this,{position:\"absolute\",top:\"-999em\"}),k.body.appendChild(this));Q[v]={width:this.width,height:this.height};d.imgwidth=this.width;d.imgheight=this.height;d.element&&y();this.parentNode&&this.parentNode.removeChild(this);x.imgCount--;if(!x.imgCount&&a&&a.onload)a.onload()},src:v}),this.imgCount++));return d},symbols:{circle:function(a,h,c,w){return this.arc(a+c/2,h+w/2,c/2,w/2,{start:0,end:2*Math.PI,open:!1})},square:function(a,h,c,w){return[\"M\",a,h,\"L\",a+c,h,a+c,h+w,a,h+w,\"Z\"]},triangle:function(a,\nh,c,w){return[\"M\",a+c/2,h,\"L\",a+c,h+w,a,h+w,\"Z\"]},\"triangle-down\":function(a,h,c,w){return[\"M\",a,h,\"L\",a+c,h,a+c/2,h+w,\"Z\"]},diamond:function(a,h,c,w){return[\"M\",a+c/2,h,\"L\",a+c,h+w/2,a+c/2,h+w,a,h+w/2,\"Z\"]},arc:function(a,h,c,w,p){var q=p.start,b=p.r||c,x=p.r||w||c,e=p.end-.001;c=p.innerR;w=L(p.open,.001>Math.abs(p.end-p.start-2*Math.PI));var d=Math.cos(q),n=Math.sin(q),g=Math.cos(e),e=Math.sin(e);p=.001>p.end-q-Math.PI?0:1;b=[\"M\",a+b*d,h+x*n,\"A\",b,x,0,p,1,a+b*g,h+x*e];t(c)&&b.push(w?\"M\":\"L\",a+c*\ng,h+c*e,\"A\",c,c,0,p,0,a+c*d,h+c*n);b.push(w?\"\":\"Z\");return b},callout:function(a,h,c,w,p){var q=Math.min(p&&p.r||0,c,w),b=q+6,e=p&&p.anchorX;p=p&&p.anchorY;var d;d=[\"M\",a+q,h,\"L\",a+c-q,h,\"C\",a+c,h,a+c,h,a+c,h+q,\"L\",a+c,h+w-q,\"C\",a+c,h+w,a+c,h+w,a+c-q,h+w,\"L\",a+q,h+w,\"C\",a,h+w,a,h+w,a,h+w-q,\"L\",a,h+q,\"C\",a,h,a,h,a+q,h];e&&e>c?p>h+b&&p<h+w-b?d.splice(13,3,\"L\",a+c,p-6,a+c+6,p,a+c,p+6,a+c,h+w-q):d.splice(13,3,\"L\",a+c,w/2,e,p,a+c,w/2,a+c,h+w-q):e&&0>e?p>h+b&&p<h+w-b?d.splice(33,3,\"L\",a,p+6,a-6,p,a,p-6,\na,h+q):d.splice(33,3,\"L\",a,w/2,e,p,a,w/2,a,h+q):p&&p>w&&e>a+b&&e<a+c-b?d.splice(23,3,\"L\",e+6,h+w,e,h+w+6,e-6,h+w,a+q,h+w):p&&0>p&&e>a+b&&e<a+c-b&&d.splice(3,3,\"L\",e-6,h,e,h-6,e+6,h,c-q,h);return d}},clipRect:function(h,c,w,p){var q=a.uniqueKey(),b=this.createElement(\"clipPath\").attr({id:q}).add(this.defs);h=this.rect(h,c,w,p,0).add(b);h.id=q;h.clipPath=b;h.count=0;return h},text:function(a,h,c,w){var p=!H&&this.forExport,q={};if(w&&(this.allowHTML||!this.forExport))return this.html(a,h,c);q.x=Math.round(h||\n0);c&&(q.y=Math.round(c));if(a||0===a)q.text=a;a=this.createElement(\"text\").attr(q);p&&a.css({position:\"absolute\"});w||(a.xSetter=function(a,h,c){var w=c.getElementsByTagName(\"tspan\"),p,q=c.getAttribute(h),b;for(b=0;b<w.length;b++)p=w[b],p.getAttribute(h)===q&&p.setAttribute(h,a);c.setAttribute(h,a)});return a},fontMetrics:function(a,c){a=a||c&&c.style&&c.style.fontSize||this.style&&this.style.fontSize;a=/px/.test(a)?h(a):/em/.test(a)?parseFloat(a)*(c?this.fontMetrics(null,c.parentNode).f:16):12;\nc=24>a?a+3:Math.round(1.2*a);return{h:c,b:Math.round(.8*c),f:a}},rotCorr:function(a,h,c){var w=a;h&&c&&(w=Math.max(w*Math.cos(h*g),4));return{x:-a/3*Math.sin(h*g),y:w}},label:function(h,c,q,d,n,g,k,z,G){var x=this,H=x.g(\"button\"!==G&&\"label\"),v=H.text=x.text(\"\",0,0,k).attr({zIndex:1}),f,y,I=0,B=3,D=0,r,l,P,m,J,O={},L,u,N=/^url\\((.*?)\\)$/.test(d),K=N,U,T,Q,R;G&&H.addClass(\"highcharts-\"+G);K=N;U=function(){return(L||0)%2/2};T=function(){var a=v.element.style,h={};y=(void 0===r||void 0===l||J)&&t(v.textStr)&&\nv.getBBox();H.width=(r||y.width||0)+2*B+D;H.height=(l||y.height||0)+2*B;u=B+x.fontMetrics(a&&a.fontSize,v).b;K&&(f||(H.box=f=x.symbols[d]||N?x.symbol(d):x.rect(),f.addClass((\"button\"===G?\"\":\"highcharts-label-box\")+(G?\" highcharts-\"+G+\"-box\":\"\")),f.add(H),a=U(),h.x=a,h.y=(z?-u:0)+a),h.width=Math.round(H.width),h.height=Math.round(H.height),f.attr(e(h,O)),O={})};Q=function(){var a=D+B,h;h=z?0:u;t(r)&&y&&(\"center\"===J||\"right\"===J)&&(a+={center:.5,right:1}[J]*(r-y.width));if(a!==v.x||h!==v.y)v.attr(\"x\",\na),void 0!==h&&v.attr(\"y\",h);v.x=a;v.y=h};R=function(a,h){f?f.attr(a,h):O[a]=h};H.onAdd=function(){v.add(H);H.attr({text:h||0===h?h:\"\",x:c,y:q});f&&t(n)&&H.attr({anchorX:n,anchorY:g})};H.widthSetter=function(h){r=a.isNumber(h)?h:null};H.heightSetter=function(a){l=a};H[\"text-alignSetter\"]=function(a){J=a};H.paddingSetter=function(a){t(a)&&a!==B&&(B=H.padding=a,Q())};H.paddingLeftSetter=function(a){t(a)&&a!==D&&(D=a,Q())};H.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==I&&(I=a,y&&H.attr({x:P}))};\nH.textSetter=function(a){void 0!==a&&v.textSetter(a);T();Q()};H[\"stroke-widthSetter\"]=function(a,h){a&&(K=!0);L=this[\"stroke-width\"]=a;R(h,a)};H.strokeSetter=H.fillSetter=H.rSetter=function(a,h){\"r\"!==h&&(\"fill\"===h&&a&&(K=!0),H[h]=a);R(h,a)};H.anchorXSetter=function(a,h){n=H.anchorX=a;R(h,Math.round(a)-U()-P)};H.anchorYSetter=function(a,h){g=H.anchorY=a;R(h,a-m)};H.xSetter=function(a){H.x=a;I&&(a-=I*((r||y.width)+2*B));P=Math.round(a);H.attr(\"translateX\",P)};H.ySetter=function(a){m=H.y=Math.round(a);\nH.attr(\"translateY\",m)};var V=H.css;return e(H,{css:function(a){if(a){var h={};a=p(a);b(H.textProps,function(c){void 0!==a[c]&&(h[c]=a[c],delete a[c])});v.css(h)}return V.call(H,a)},getBBox:function(){return{width:y.width+2*B,height:y.height+2*B,x:y.x-B,y:y.y-B}},shadow:function(a){a&&(T(),f&&f.shadow(a));return H},destroy:function(){w(H.element,\"mouseenter\");w(H.element,\"mouseleave\");v&&(v=v.destroy());f&&(f=f.destroy());C.prototype.destroy.call(H);H=x=T=Q=R=null}})}});a.Renderer=A})(M);(function(a){var C=\na.attr,A=a.createElement,F=a.css,E=a.defined,m=a.each,f=a.extend,l=a.isFirefox,r=a.isMS,u=a.isWebKit,t=a.pInt,g=a.SVGRenderer,d=a.win,k=a.wrap;f(a.SVGElement.prototype,{htmlCss:function(a){var b=this.element;if(b=a&&\"SPAN\"===b.tagName&&a.width)delete a.width,this.textWidth=b,this.updateTransform();a&&\"ellipsis\"===a.textOverflow&&(a.whiteSpace=\"nowrap\",a.overflow=\"hidden\");this.styles=f(this.styles,a);F(this.element,a);return this},htmlGetBBox:function(){var a=this.element;\"text\"===a.nodeName&&(a.style.position=\n\"absolute\");return{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,e=this.element,d=this.translateX||0,g=this.translateY||0,n=this.x||0,k=this.y||0,f=this.textAlign||\"left\",c={left:0,center:.5,right:1}[f],G=this.styles;F(e,{marginLeft:d,marginTop:g});this.shadows&&m(this.shadows,function(a){F(a,{marginLeft:d+1,marginTop:g+1})});this.inverted&&m(e.childNodes,function(c){a.invertChild(c,e)});if(\"SPAN\"===e.tagName){var q=\nthis.rotation,B=t(this.textWidth),r=G&&G.whiteSpace,p=[q,f,e.innerHTML,this.textWidth,this.textAlign].join();p!==this.cTT&&(G=a.fontMetrics(e.style.fontSize).b,E(q)&&this.setSpanRotation(q,c,G),F(e,{width:\"\",whiteSpace:r||\"nowrap\"}),e.offsetWidth>B&&/[ \\-]/.test(e.textContent||e.innerText)&&F(e,{width:B+\"px\",display:\"block\",whiteSpace:r||\"normal\"}),this.getSpanCorrection(e.offsetWidth,G,c,q,f));F(e,{left:n+(this.xCorr||0)+\"px\",top:k+(this.yCorr||0)+\"px\"});u&&(G=e.offsetHeight);this.cTT=p}}else this.alignOnAdd=\n!0},setSpanRotation:function(a,e,g){var b={},n=r?\"-ms-transform\":u?\"-webkit-transform\":l?\"MozTransform\":d.opera?\"-o-transform\":\"\";b[n]=b.transform=\"rotate(\"+a+\"deg)\";b[n+(l?\"Origin\":\"-origin\")]=b.transformOrigin=100*e+\"% \"+g+\"px\";F(this.element,b)},getSpanCorrection:function(a,e,d){this.xCorr=-a*d;this.yCorr=-e}});f(g.prototype,{html:function(a,e,d){var b=this.createElement(\"span\"),n=b.element,g=b.renderer,v=g.isSVG,c=function(a,c){m([\"opacity\",\"visibility\"],function(q){k(a,q+\"Setter\",function(a,\np,q,b){a.call(this,p,q,b);c[q]=p})})};b.textSetter=function(a){a!==n.innerHTML&&delete this.bBox;n.innerHTML=this.textStr=a;b.htmlUpdateTransform()};v&&c(b,b.element.style);b.xSetter=b.ySetter=b.alignSetter=b.rotationSetter=function(a,c){\"align\"===c&&(c=\"textAlign\");b[c]=a;b.htmlUpdateTransform()};b.attr({text:a,x:Math.round(e),y:Math.round(d)}).css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize,position:\"absolute\"});n.style.whiteSpace=\"nowrap\";b.css=b.htmlCss;v&&(b.add=function(a){var q,\ne=g.box.parentNode,d=[];if(this.parentGroup=a){if(q=a.div,!q){for(;a;)d.push(a),a=a.parentGroup;m(d.reverse(),function(a){var p,n=C(a.element,\"class\");n&&(n={className:n});q=a.div=a.div||A(\"div\",n,{position:\"absolute\",left:(a.translateX||0)+\"px\",top:(a.translateY||0)+\"px\",display:a.display,opacity:a.opacity,pointerEvents:a.styles&&a.styles.pointerEvents},q||e);p=q.style;f(a,{classSetter:function(a){this.element.setAttribute(\"class\",a);q.className=a},on:function(){d[0].div&&b.on.apply({element:d[0].div},\narguments);return a},translateXSetter:function(c,h){p.left=c+\"px\";a[h]=c;a.doTransform=!0},translateYSetter:function(c,h){p.top=c+\"px\";a[h]=c;a.doTransform=!0}});c(a,p)})}}else q=e;q.appendChild(n);b.added=!0;b.alignOnAdd&&b.htmlUpdateTransform();return b});return b}})})(M);(function(a){var C,A,F=a.createElement,E=a.css,m=a.defined,f=a.deg2rad,l=a.discardElement,r=a.doc,u=a.each,t=a.erase,g=a.extend;C=a.extendClass;var d=a.isArray,k=a.isNumber,b=a.isObject,e=a.merge;A=a.noop;var v=a.pick,y=a.pInt,\nn=a.SVGElement,D=a.SVGRenderer,J=a.win;a.svg||(A={docMode8:r&&8===r.documentMode,init:function(a,b){var c=[\"\\x3c\",b,' filled\\x3d\"f\" stroked\\x3d\"f\"'],e=[\"position: \",\"absolute\",\";\"],d=\"div\"===b;(\"shape\"===b||d)&&e.push(\"left:0;top:0;width:1px;height:1px;\");e.push(\"visibility: \",d?\"hidden\":\"visible\");c.push(' style\\x3d\"',e.join(\"\"),'\"/\\x3e');b&&(c=d||\"span\"===b||\"img\"===b?c.join(\"\"):a.prepVML(c),this.element=F(c));this.renderer=a},add:function(a){var c=this.renderer,b=this.element,e=c.box,d=a&&a.inverted,\ne=a?a.element||a:e;a&&(this.parentGroup=a);d&&c.invertChild(b,e);e.appendChild(b);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();if(this.onAdd)this.onAdd();this.className&&this.attr(\"class\",this.className);return this},updateTransform:n.prototype.htmlUpdateTransform,setSpanRotation:function(){var a=this.rotation,b=Math.cos(a*f),q=Math.sin(a*f);E(this.element,{filter:a?[\"progid:DXImageTransform.Microsoft.Matrix(M11\\x3d\",b,\", M12\\x3d\",-q,\", M21\\x3d\",q,\", M22\\x3d\",\nb,\", sizingMethod\\x3d'auto expand')\"].join(\"\"):\"none\"})},getSpanCorrection:function(a,b,q,e,d){var c=e?Math.cos(e*f):1,n=e?Math.sin(e*f):0,g=v(this.elemHeight,this.element.offsetHeight),k;this.xCorr=0>c&&-a;this.yCorr=0>n&&-g;k=0>c*n;this.xCorr+=n*b*(k?1-q:q);this.yCorr-=c*b*(e?k?q:1-q:1);d&&\"left\"!==d&&(this.xCorr-=a*q*(0>c?-1:1),e&&(this.yCorr-=g*q*(0>n?-1:1)),E(this.element,{textAlign:d}))},pathToVML:function(a){for(var c=a.length,b=[];c--;)k(a[c])?b[c]=Math.round(10*a[c])-5:\"Z\"===a[c]?b[c]=\"x\":\n(b[c]=a[c],!a.isArc||\"wa\"!==a[c]&&\"at\"!==a[c]||(b[c+5]===b[c+7]&&(b[c+7]+=a[c+7]>a[c+5]?1:-1),b[c+6]===b[c+8]&&(b[c+8]+=a[c+8]>a[c+6]?1:-1)));return b.join(\" \")||\"x\"},clip:function(a){var c=this,b;a?(b=a.members,t(b,c),b.push(c),c.destroyClip=function(){t(b,c)},a=a.getCSS(c)):(c.destroyClip&&c.destroyClip(),a={clip:c.docMode8?\"inherit\":\"rect(auto)\"});return c.css(a)},css:n.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&l(a)},destroy:function(){this.destroyClip&&this.destroyClip();return n.prototype.destroy.apply(this)},\non:function(a,b){this.element[\"on\"+a]=function(){var a=J.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,b){var c;a=a.split(/[ ,]/);c=a.length;if(9===c||11===c)a[c-4]=a[c-2]=y(a[c-2])-10*b;return a.join(\" \")},shadow:function(a,b,e){var c=[],q,p=this.element,d=this.renderer,n,g=p.style,h,w=p.path,k,H,f,D;w&&\"string\"!==typeof w.value&&(w=\"x\");H=w;if(a){f=v(a.width,3);D=(a.opacity||.15)/f;for(q=1;3>=q;q++)k=2*f+1-2*q,e&&(H=this.cutOffPath(w.value,k+.5)),h=['\\x3cshape isShadow\\x3d\"true\" strokeweight\\x3d\"',\nk,'\" filled\\x3d\"false\" path\\x3d\"',H,'\" coordsize\\x3d\"10 10\" style\\x3d\"',p.style.cssText,'\" /\\x3e'],n=F(d.prepVML(h),null,{left:y(g.left)+v(a.offsetX,1),top:y(g.top)+v(a.offsetY,1)}),e&&(n.cutOff=k+1),h=['\\x3cstroke color\\x3d\"',a.color||\"#000000\",'\" opacity\\x3d\"',D*q,'\"/\\x3e'],F(d.prepVML(h),null,null,n),b?b.element.appendChild(n):p.parentNode.insertBefore(n,p),c.push(n);this.shadows=c}return this},updateShadows:A,setAttr:function(a,b){this.docMode8?this.element[a]=b:this.element.setAttribute(a,b)},\nclassSetter:function(a){(this.added?this.element:this).className=a},dashstyleSetter:function(a,b,e){(e.getElementsByTagName(\"stroke\")[0]||F(this.renderer.prepVML([\"\\x3cstroke/\\x3e\"]),null,null,e))[b]=a||\"solid\";this[b]=a},dSetter:function(a,b,e){var c=this.shadows;a=a||[];this.d=a.join&&a.join(\" \");e.path=a=this.pathToVML(a);if(c)for(e=c.length;e--;)c[e].path=c[e].cutOff?this.cutOffPath(a,c[e].cutOff):a;this.setAttr(b,a)},fillSetter:function(a,b,e){var c=e.nodeName;\"SPAN\"===c?e.style.color=a:\"IMG\"!==\nc&&(e.filled=\"none\"!==a,this.setAttr(\"fillcolor\",this.renderer.color(a,e,b,this)))},\"fill-opacitySetter\":function(a,b,e){F(this.renderer.prepVML([\"\\x3c\",b.split(\"-\")[0],' opacity\\x3d\"',a,'\"/\\x3e']),null,null,e)},opacitySetter:A,rotationSetter:function(a,b,e){e=e.style;this[b]=e[b]=a;e.left=-Math.round(Math.sin(a*f)+1)+\"px\";e.top=Math.round(Math.cos(a*f))+\"px\"},strokeSetter:function(a,b,e){this.setAttr(\"strokecolor\",this.renderer.color(a,e,b,this))},\"stroke-widthSetter\":function(a,b,e){e.stroked=!!a;\nthis[b]=a;k(a)&&(a+=\"px\");this.setAttr(\"strokeweight\",a)},titleSetter:function(a,b){this.setAttr(b,a)},visibilitySetter:function(a,b,e){\"inherit\"===a&&(a=\"visible\");this.shadows&&u(this.shadows,function(c){c.style[b]=a});\"DIV\"===e.nodeName&&(a=\"hidden\"===a?\"-999em\":0,this.docMode8||(e.style[b]=a?\"visible\":\"hidden\"),b=\"top\");e.style[b]=a},xSetter:function(a,b,e){this[b]=a;\"x\"===b?b=\"left\":\"y\"===b&&(b=\"top\");this.updateClipping?(this[b]=a,this.updateClipping()):e.style[b]=a},zIndexSetter:function(a,\nb,e){e.style[b]=a}},A[\"stroke-opacitySetter\"]=A[\"fill-opacitySetter\"],a.VMLElement=A=C(n,A),A.prototype.ySetter=A.prototype.widthSetter=A.prototype.heightSetter=A.prototype.xSetter,A={Element:A,isIE8:-1<J.navigator.userAgent.indexOf(\"MSIE 8.0\"),init:function(a,b,e){var c,d;this.alignedObjects=[];c=this.createElement(\"div\").css({position:\"relative\"});d=c.element;a.appendChild(c.element);this.isVML=!0;this.box=d;this.boxWrapper=c;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,\ne,!1);if(!r.namespaces.hcv){r.namespaces.add(\"hcv\",\"urn:schemas-microsoft-com:vml\");try{r.createStyleSheet().cssText=\"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \"}catch(p){r.styleSheets[0].cssText+=\"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \"}}},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,e,d,n){var c=this.createElement(),p=b(a);return g(c,{members:[],\ncount:0,left:(p?a.x:a)+1,top:(p?a.y:e)+1,width:(p?a.width:d)-1,height:(p?a.height:n)-1,getCSS:function(a){var c=a.element,b=c.nodeName,h=a.inverted,w=this.top-(\"shape\"===b?c.offsetTop:0),p=this.left,c=p+this.width,e=w+this.height,w={clip:\"rect(\"+Math.round(h?p:w)+\"px,\"+Math.round(h?e:c)+\"px,\"+Math.round(h?c:e)+\"px,\"+Math.round(h?w:p)+\"px)\"};!h&&a.docMode8&&\"DIV\"===b&&g(w,{width:c+\"px\",height:e+\"px\"});return w},updateClipping:function(){u(c.members,function(a){a.element&&a.css(c.getCSS(a))})}})},color:function(c,\nb,e,d){var q=this,p,n=/^rgba/,g,k,h=\"none\";c&&c.linearGradient?k=\"gradient\":c&&c.radialGradient&&(k=\"pattern\");if(k){var w,v,H=c.linearGradient||c.radialGradient,f,D,y,x,r,B=\"\";c=c.stops;var l,G=[],m=function(){g=['\\x3cfill colors\\x3d\"'+G.join(\",\")+'\" opacity\\x3d\"',y,'\" o:opacity2\\x3d\"',D,'\" type\\x3d\"',k,'\" ',B,'focus\\x3d\"100%\" method\\x3d\"any\" /\\x3e'];F(q.prepVML(g),null,null,b)};f=c[0];l=c[c.length-1];0<f[0]&&c.unshift([0,f[1]]);1>l[0]&&c.push([1,l[1]]);u(c,function(h,c){n.test(h[1])?(p=a.color(h[1]),\nw=p.get(\"rgb\"),v=p.get(\"a\")):(w=h[1],v=1);G.push(100*h[0]+\"% \"+w);c?(y=v,x=w):(D=v,r=w)});if(\"fill\"===e)if(\"gradient\"===k)e=H.x1||H[0]||0,c=H.y1||H[1]||0,f=H.x2||H[2]||0,H=H.y2||H[3]||0,B='angle\\x3d\"'+(90-180*Math.atan((H-c)/(f-e))/Math.PI)+'\"',m();else{var h=H.r,t=2*h,J=2*h,A=H.cx,C=H.cy,E=b.radialReference,M,h=function(){E&&(M=d.getBBox(),A+=(E[0]-M.x)/M.width-.5,C+=(E[1]-M.y)/M.height-.5,t*=E[2]/M.width,J*=E[2]/M.height);B='src\\x3d\"'+a.getOptions().global.VMLRadialGradientURL+'\" size\\x3d\"'+t+\",\"+\nJ+'\" origin\\x3d\"0.5,0.5\" position\\x3d\"'+A+\",\"+C+'\" color2\\x3d\"'+r+'\" ';m()};d.added?h():d.onAdd=h;h=x}else h=w}else n.test(c)&&\"IMG\"!==b.tagName?(p=a.color(c),d[e+\"-opacitySetter\"](p.get(\"a\"),e,b),h=p.get(\"rgb\")):(h=b.getElementsByTagName(e),h.length&&(h[0].opacity=1,h[0].type=\"solid\"),h=c);return h},prepVML:function(a){var c=this.isIE8;a=a.join(\"\");c?(a=a.replace(\"/\\x3e\",' xmlns\\x3d\"urn:schemas-microsoft-com:vml\" /\\x3e'),a=-1===a.indexOf('style\\x3d\"')?a.replace(\"/\\x3e\",' style\\x3d\"display:inline-block;behavior:url(#default#VML);\" /\\x3e'):\na.replace('style\\x3d\"','style\\x3d\"display:inline-block;behavior:url(#default#VML);')):a=a.replace(\"\\x3c\",\"\\x3chcv:\");return a},text:D.prototype.html,path:function(a){var c={coordsize:\"10 10\"};d(a)?c.d=a:b(a)&&g(c,a);return this.createElement(\"shape\").attr(c)},circle:function(a,e,d){var c=this.symbol(\"circle\");b(a)&&(d=a.r,e=a.y,a=a.x);c.isCircle=!0;c.r=d;return c.attr({x:a,y:e})},g:function(a){var c;a&&(c={className:\"highcharts-\"+a,\"class\":\"highcharts-\"+a});return this.createElement(\"div\").attr(c)},\nimage:function(a,b,e,d,n){var c=this.createElement(\"img\").attr({src:a});1<arguments.length&&c.attr({x:b,y:e,width:d,height:n});return c},createElement:function(a){return\"rect\"===a?this.symbol(a):D.prototype.createElement.call(this,a)},invertChild:function(a,b){var c=this;b=b.style;var e=\"IMG\"===a.tagName&&a.style;E(a,{flip:\"x\",left:y(b.width)-(e?y(e.top):1),top:y(b.height)-(e?y(e.left):1),rotation:-90});u(a.childNodes,function(b){c.invertChild(b,a)})},symbols:{arc:function(a,b,e,d,n){var c=n.start,\nq=n.end,g=n.r||e||d;e=n.innerR;d=Math.cos(c);var k=Math.sin(c),h=Math.cos(q),w=Math.sin(q);if(0===q-c)return[\"x\"];c=[\"wa\",a-g,b-g,a+g,b+g,a+g*d,b+g*k,a+g*h,b+g*w];n.open&&!e&&c.push(\"e\",\"M\",a,b);c.push(\"at\",a-e,b-e,a+e,b+e,a+e*h,b+e*w,a+e*d,b+e*k,\"x\",\"e\");c.isArc=!0;return c},circle:function(a,b,e,d,n){n&&m(n.r)&&(e=d=2*n.r);n&&n.isCircle&&(a-=e/2,b-=d/2);return[\"wa\",a,b,a+e,b+d,a+e,b+d/2,a+e,b+d/2,\"e\"]},rect:function(a,b,e,d,n){return D.prototype.symbols[m(n)&&n.r?\"callout\":\"square\"].call(0,a,b,\ne,d,n)}}},a.VMLRenderer=C=function(){this.init.apply(this,arguments)},C.prototype=e(D.prototype,A),a.Renderer=C);D.prototype.measureSpanWidth=function(a,b){var c=r.createElement(\"span\");a=r.createTextNode(a);c.appendChild(a);E(c,b);this.box.appendChild(c);b=c.offsetWidth;l(c);return b}})(M);(function(a){function C(){var f=a.defaultOptions.global,l=r.moment;if(f.timezone){if(l)return function(a){return-l.tz(a,f.timezone).utcOffset()};a.error(25)}return f.useUTC&&f.getTimezoneOffset}function A(){var f=\na.defaultOptions.global,t,g=f.useUTC,d=g?\"getUTC\":\"get\",k=g?\"setUTC\":\"set\";a.Date=t=f.Date||r.Date;t.hcTimezoneOffset=g&&f.timezoneOffset;t.hcGetTimezoneOffset=C();t.hcMakeTime=function(a,e,d,k,n,f){var b;g?(b=t.UTC.apply(0,arguments),b+=m(b)):b=(new t(a,e,l(d,1),l(k,0),l(n,0),l(f,0))).getTime();return b};E(\"Minutes Hours Day Date Month FullYear\".split(\" \"),function(a){t[\"hcGet\"+a]=d+a});E(\"Milliseconds Seconds Minutes Hours Date Month FullYear\".split(\" \"),function(a){t[\"hcSet\"+a]=k+a})}var F=a.color,\nE=a.each,m=a.getTZOffset,f=a.merge,l=a.pick,r=a.win;a.defaultOptions={colors:\"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),symbols:[\"circle\",\"diamond\",\"square\",\"triangle\",\"triangle-down\"],lang:{loading:\"Loading...\",months:\"January February March April May June July August September October November December\".split(\" \"),shortMonths:\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),weekdays:\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\ndecimalPoint:\".\",numericSymbols:\"kMGTPE\".split(\"\"),resetZoom:\"Reset zoom\",resetZoomTitle:\"Reset zoom level 1:1\",thousandsSep:\" \"},global:{useUTC:!0,VMLRadialGradientURL:\"http://code.highcharts.com/5.0.14/gfx/vml-radial-gradient.png\"},chart:{borderRadius:0,defaultSeriesType:\"line\",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:20},position:{align:\"right\",x:-10,y:10}},width:null,height:null,borderColor:\"#335cad\",backgroundColor:\"#ffffff\",plotBorderColor:\"#cccccc\"},title:{text:\"Chart title\",\nalign:\"center\",margin:15,widthAdjust:-44},subtitle:{text:\"\",align:\"center\",widthAdjust:-44},plotOptions:{},labels:{style:{position:\"absolute\",color:\"#333333\"}},legend:{enabled:!0,align:\"center\",layout:\"horizontal\",labelFormatter:function(){return this.name},borderColor:\"#999999\",borderRadius:0,navigation:{activeColor:\"#003399\",inactiveColor:\"#cccccc\"},itemStyle:{color:\"#333333\",fontSize:\"12px\",fontWeight:\"bold\",textOverflow:\"ellipsis\"},itemHoverStyle:{color:\"#000000\"},itemHiddenStyle:{color:\"#cccccc\"},\nshadow:!1,itemCheckboxStyle:{position:\"absolute\",width:\"13px\",height:\"13px\"},squareSymbol:!0,symbolPadding:5,verticalAlign:\"bottom\",x:0,y:0,title:{style:{fontWeight:\"bold\"}}},loading:{labelStyle:{fontWeight:\"bold\",position:\"relative\",top:\"45%\"},style:{position:\"absolute\",backgroundColor:\"#ffffff\",opacity:.5,textAlign:\"center\"}},tooltip:{enabled:!0,animation:a.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:\"%A, %b %e, %H:%M:%S.%L\",second:\"%A, %b %e, %H:%M:%S\",minute:\"%A, %b %e, %H:%M\",hour:\"%A, %b %e, %H:%M\",\nday:\"%A, %b %e, %Y\",week:\"Week from %A, %b %e, %Y\",month:\"%B %Y\",year:\"%Y\"},footerFormat:\"\",padding:8,snap:a.isTouchDevice?25:10,backgroundColor:F(\"#f7f7f7\").setOpacity(.85).get(),borderWidth:1,headerFormat:'\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',pointFormat:'\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e {series.name}: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e',shadow:!0,style:{color:\"#333333\",cursor:\"default\",fontSize:\"12px\",pointerEvents:\"none\",\nwhiteSpace:\"nowrap\"}},credits:{enabled:!0,href:\"http://www.highcharts.com\",position:{align:\"right\",x:-10,verticalAlign:\"bottom\",y:-5},style:{cursor:\"pointer\",color:\"#999999\",fontSize:\"9px\"},text:\"Highcharts.com\"}};a.setOptions=function(r){a.defaultOptions=f(!0,a.defaultOptions,r);A();return a.defaultOptions};a.getOptions=function(){return a.defaultOptions};a.defaultPlotOptions=a.defaultOptions.plotOptions;A()})(M);(function(a){var C=a.correctFloat,A=a.defined,F=a.destroyObjectProperties,E=a.isNumber,\nm=a.merge,f=a.pick,l=a.deg2rad;a.Tick=function(a,f,l,g){this.axis=a;this.pos=f;this.type=l||\"\";this.isNewLabel=this.isNew=!0;l||g||this.addLabel()};a.Tick.prototype={addLabel:function(){var a=this.axis,l=a.options,t=a.chart,g=a.categories,d=a.names,k=this.pos,b=l.labels,e=a.tickPositions,v=k===e[0],y=k===e[e.length-1],d=g?f(g[k],d[k],k):k,g=this.label,e=e.info,n;a.isDatetimeAxis&&e&&(n=l.dateTimeLabelFormats[e.higherRanks[k]||e.unitName]);this.isFirst=v;this.isLast=y;l=a.labelFormatter.call({axis:a,\nchart:t,isFirst:v,isLast:y,dateTimeLabelFormat:n,value:a.isLog?C(a.lin2log(d)):d,pos:k});A(g)?g&&g.attr({text:l}):(this.labelLength=(this.label=g=A(l)&&b.enabled?t.renderer.text(l,0,0,b.useHTML).css(m(b.style)).add(a.labelGroup):null)&&g.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?\"height\":\"width\"]:0},handleOverflow:function(a){var r=this.axis,m=a.x,g=r.chart.chartWidth,d=r.chart.spacing,k=f(r.labelLeft,Math.min(r.pos,d[3])),d=f(r.labelRight,\nMath.max(r.pos+r.len,g-d[1])),b=this.label,e=this.rotation,v={left:0,center:.5,right:1}[r.labelAlign],y=b.getBBox().width,n=r.getSlotWidth(),D=n,J=1,c,G={};if(e)0>e&&m-v*y<k?c=Math.round(m/Math.cos(e*l)-k):0<e&&m+v*y>d&&(c=Math.round((g-m)/Math.cos(e*l)));else if(g=m+(1-v)*y,m-v*y<k?D=a.x+D*(1-v)-k:g>d&&(D=d-a.x+D*v,J=-1),D=Math.min(n,D),D<n&&\"center\"===r.labelAlign&&(a.x+=J*(n-D-v*(n-Math.min(y,D)))),y>D||r.autoRotation&&(b.styles||{}).width)c=D;c&&(G.width=c,(r.options.labels.style||{}).textOverflow||\n(G.textOverflow=\"ellipsis\"),b.css(G))},getPosition:function(a,f,l,g){var d=this.axis,k=d.chart,b=g&&k.oldChartHeight||k.chartHeight;return{x:a?d.translate(f+l,null,null,g)+d.transB:d.left+d.offset+(d.opposite?(g&&k.oldChartWidth||k.chartWidth)-d.right-d.left:0),y:a?b-d.bottom+d.offset-(d.opposite?d.height:0):b-d.translate(f+l,null,null,g)-d.transB}},getLabelPosition:function(a,f,m,g,d,k,b,e){var v=this.axis,y=v.transA,n=v.reversed,D=v.staggerLines,r=v.tickRotCorr||{x:0,y:0},c=d.y;A(c)||(c=0===v.side?\nm.rotation?-8:-m.getBBox().height:2===v.side?r.y+8:Math.cos(m.rotation*l)*(r.y-m.getBBox(!1,0).height/2));a=a+d.x+r.x-(k&&g?k*y*(n?-1:1):0);f=f+c-(k&&!g?k*y*(n?1:-1):0);D&&(m=b/(e||1)%D,v.opposite&&(m=D-m-1),f+=v.labelOffset/D*m);return{x:a,y:Math.round(f)}},getMarkPath:function(a,f,l,g,d,k){return k.crispLine([\"M\",a,f,\"L\",a+(d?0:-l),f+(d?l:0)],g)},renderGridLine:function(a,f,l){var g=this.axis,d=g.options,k=this.gridLine,b={},e=this.pos,v=this.type,y=g.tickmarkOffset,n=g.chart.renderer,D=v?v+\"Grid\":\n\"grid\",r=d[D+\"LineWidth\"],c=d[D+\"LineColor\"],d=d[D+\"LineDashStyle\"];k||(b.stroke=c,b[\"stroke-width\"]=r,d&&(b.dashstyle=d),v||(b.zIndex=1),a&&(b.opacity=0),this.gridLine=k=n.path().attr(b).addClass(\"highcharts-\"+(v?v+\"-\":\"\")+\"grid-line\").add(g.gridGroup));if(!a&&k&&(a=g.getPlotLinePath(e+y,k.strokeWidth()*l,a,!0)))k[this.isNew?\"attr\":\"animate\"]({d:a,opacity:f})},renderMark:function(a,l,m){var g=this.axis,d=g.options,k=g.chart.renderer,b=this.type,e=b?b+\"Tick\":\"tick\",v=g.tickSize(e),y=this.mark,n=!y,\nD=a.x;a=a.y;var r=f(d[e+\"Width\"],!b&&g.isXAxis?1:0),d=d[e+\"Color\"];v&&(g.opposite&&(v[0]=-v[0]),n&&(this.mark=y=k.path().addClass(\"highcharts-\"+(b?b+\"-\":\"\")+\"tick\").add(g.axisGroup),y.attr({stroke:d,\"stroke-width\":r})),y[n?\"attr\":\"animate\"]({d:this.getMarkPath(D,a,v[0],y.strokeWidth()*m,g.horiz,k),opacity:l}))},renderLabel:function(a,l,m,g){var d=this.axis,k=d.horiz,b=d.options,e=this.label,v=b.labels,y=v.step,n=d.tickmarkOffset,D=!0,r=a.x;a=a.y;e&&E(r)&&(e.xy=a=this.getLabelPosition(r,a,e,k,v,n,\ng,y),this.isFirst&&!this.isLast&&!f(b.showFirstLabel,1)||this.isLast&&!this.isFirst&&!f(b.showLastLabel,1)?D=!1:!k||d.isRadial||v.step||v.rotation||l||0===m||this.handleOverflow(a),y&&g%y&&(D=!1),D&&E(a.y)?(a.opacity=m,e[this.isNewLabel?\"attr\":\"animate\"](a),this.isNewLabel=!1):(e.attr(\"y\",-9999),this.isNewLabel=!0),this.isNew=!1)},render:function(a,l,m){var g=this.axis,d=g.horiz,k=this.getPosition(d,this.pos,g.tickmarkOffset,l),b=k.x,e=k.y,g=d&&b===g.pos+g.len||!d&&e===g.pos?-1:1;m=f(m,1);this.isActive=\n!0;this.renderGridLine(l,m,g);this.renderMark(k,m,g);this.renderLabel(k,l,m,a)},destroy:function(){F(this,this.axis)}}})(M);var S=function(a){var C=a.addEvent,A=a.animObject,F=a.arrayMax,E=a.arrayMin,m=a.color,f=a.correctFloat,l=a.defaultOptions,r=a.defined,u=a.deg2rad,t=a.destroyObjectProperties,g=a.each,d=a.extend,k=a.fireEvent,b=a.format,e=a.getMagnitude,v=a.grep,y=a.inArray,n=a.isArray,D=a.isNumber,J=a.isString,c=a.merge,G=a.normalizeTickInterval,q=a.objectEach,B=a.pick,K=a.removeEvent,p=a.splat,\nz=a.syncTimeout,I=a.Tick,L=function(){this.init.apply(this,arguments)};a.extend(L.prototype,{defaultOptions:{dateTimeLabelFormats:{millisecond:\"%H:%M:%S.%L\",second:\"%H:%M:%S\",minute:\"%H:%M\",hour:\"%H:%M\",day:\"%e. %b\",week:\"%e. %b\",month:\"%b '%y\",year:\"%Y\"},endOnTick:!1,labels:{enabled:!0,style:{color:\"#666666\",cursor:\"default\",fontSize:\"11px\"},x:0},minPadding:.01,maxPadding:.01,minorTickLength:2,minorTickPosition:\"outside\",startOfWeek:1,startOnTick:!1,tickLength:10,tickmarkPlacement:\"between\",tickPixelInterval:100,\ntickPosition:\"outside\",title:{align:\"middle\",style:{color:\"#666666\"}},type:\"linear\",minorGridLineColor:\"#f2f2f2\",minorGridLineWidth:1,minorTickColor:\"#999999\",lineColor:\"#ccd6eb\",lineWidth:1,gridLineColor:\"#e6e6e6\",tickColor:\"#ccd6eb\"},defaultYAxisOptions:{endOnTick:!0,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},maxPadding:.05,minPadding:.05,startOnTick:!0,title:{rotation:270,text:\"Values\"},stackLabels:{allowOverlap:!1,enabled:!1,formatter:function(){return a.numberFormat(this.total,-1)},\nstyle:{fontSize:\"11px\",fontWeight:\"bold\",color:\"#000000\",textOutline:\"1px contrast\"}},gridLineWidth:1,lineWidth:0},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},init:function(a,c){var h=c.isX,b=this;b.chart=a;b.horiz=a.inverted&&!b.isZAxis?!h:h;b.isXAxis=h;b.coll=b.coll||(h?\n\"xAxis\":\"yAxis\");b.opposite=c.opposite;b.side=c.side||(b.horiz?b.opposite?0:2:b.opposite?1:3);b.setOptions(c);var w=this.options,e=w.type;b.labelFormatter=w.labels.formatter||b.defaultLabelFormatter;b.userOptions=c;b.minPixelPadding=0;b.reversed=w.reversed;b.visible=!1!==w.visible;b.zoomEnabled=!1!==w.zoomEnabled;b.hasNames=\"category\"===e||!0===w.categories;b.categories=w.categories||b.hasNames;b.names=b.names||[];b.plotLinesAndBandsGroups={};b.isLog=\"logarithmic\"===e;b.isDatetimeAxis=\"datetime\"===\ne;b.positiveValuesOnly=b.isLog&&!b.allowNegativeLog;b.isLinked=r(w.linkedTo);b.ticks={};b.labelEdge=[];b.minorTicks={};b.plotLinesAndBands=[];b.alternateBands={};b.len=0;b.minRange=b.userMinRange=w.minRange||w.maxZoom;b.range=w.range;b.offset=w.offset||0;b.stacks={};b.oldStacks={};b.stacksTouched=0;b.max=null;b.min=null;b.crosshair=B(w.crosshair,p(a.options.tooltip.crosshairs)[h?0:1],!1);c=b.options.events;-1===y(b,a.axes)&&(h?a.axes.splice(a.xAxis.length,0,b):a.axes.push(b),a[b.coll].push(b));b.series=\nb.series||[];a.inverted&&!b.isZAxis&&h&&void 0===b.reversed&&(b.reversed=!0);q(c,function(a,h){C(b,h,a)});b.lin2log=w.linearToLogConverter||b.lin2log;b.isLog&&(b.val2lin=b.log2lin,b.lin2val=b.lin2log)},setOptions:function(a){this.options=c(this.defaultOptions,\"yAxis\"===this.coll&&this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],c(l[this.coll],a))},defaultLabelFormatter:function(){var h=this.axis,\nc=this.value,e=h.categories,p=this.dateTimeLabelFormat,d=l.lang,n=d.numericSymbols,d=d.numericSymbolMagnitude||1E3,q=n&&n.length,x,g=h.options.labels.format,h=h.isLog?Math.abs(c):h.tickInterval;if(g)x=b(g,this);else if(e)x=c;else if(p)x=a.dateFormat(p,c);else if(q&&1E3<=h)for(;q--&&void 0===x;)e=Math.pow(d,q+1),h>=e&&0===10*c%e&&null!==n[q]&&0!==c&&(x=a.numberFormat(c/e,-1)+n[q]);void 0===x&&(x=1E4<=Math.abs(c)?a.numberFormat(c,-1):a.numberFormat(c,-1,void 0,\"\"));return x},getSeriesExtremes:function(){var a=\nthis,b=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();g(a.series,function(h){if(h.visible||!b.options.chart.ignoreHiddenSeries){var c=h.options,w=c.threshold,e;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=w&&(w=null);if(a.isXAxis)c=h.xData,c.length&&(h=E(c),D(h)||h instanceof Date||(c=v(c,function(a){return D(a)}),h=E(c)),a.dataMin=Math.min(B(a.dataMin,c[0]),h),a.dataMax=Math.max(B(a.dataMax,c[0]),F(c)));else if(h.getExtremes(),\ne=h.dataMax,h=h.dataMin,r(h)&&r(e)&&(a.dataMin=Math.min(B(a.dataMin,h),h),a.dataMax=Math.max(B(a.dataMax,e),e)),r(w)&&(a.threshold=w),!c.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})},translate:function(a,b,c,e,p,d){var h=this.linkedParent||this,w=1,n=0,q=e?h.oldTransA:h.transA;e=e?h.oldMin:h.min;var g=h.minPixelPadding;p=(h.isOrdinal||h.isBroken||h.isLog&&p)&&h.lin2val;q||(q=h.transA);c&&(w*=-1,n=h.len);h.reversed&&(w*=-1,n-=w*(h.sector||h.len));b?(a=(a*w+n-g)/q+e,p&&(a=h.lin2val(a))):\n(p&&(a=h.val2lin(a)),a=w*(a-e)*q+n+w*g+(D(d)?q*d:0));return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,!0)+(b?0:this.pos)},toValue:function(a,b){return this.translate(a-(b?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,b,c,e,p){var h=this.chart,w=this.left,d=this.top,n,q,g=c&&h.oldChartHeight||h.chartHeight,k=c&&h.oldChartWidth||h.chartWidth,f;n=this.transB;var v=function(a,h,b){if(a<h||a>b)e?a=Math.min(Math.max(h,a),b):f=!0;return a};p=B(p,this.translate(a,\nnull,null,c));a=c=Math.round(p+n);n=q=Math.round(g-p-n);D(p)?this.horiz?(n=d,q=g-this.bottom,a=c=v(a,w,w+this.width)):(a=w,c=k-this.right,n=q=v(n,d,d+this.height)):f=!0;return f&&!e?null:h.renderer.crispLine([\"M\",a,n,\"L\",c,q],b||1)},getLinearTickPositions:function(a,b,c){var h,w=f(Math.floor(b/a)*a);c=f(Math.ceil(c/a)*a);var e=[];if(this.single)return[b];for(b=w;b<=c;){e.push(b);b=f(b+a);if(b===h)break;h=b}return e},getMinorTickPositions:function(){var a=this,b=a.options,c=a.tickPositions,e=a.minorTickInterval,\np=[],d=a.pointRangePadding||0,n=a.min-d,d=a.max+d,q=d-n;if(q&&q/e<a.len/3)if(a.isLog)g(this.paddedTicks,function(h,b,c){b&&p.push.apply(p,a.getLogTickPositions(e,c[b-1],c[b],!0))});else if(a.isDatetimeAxis&&\"auto\"===b.minorTickInterval)p=p.concat(a.getTimeTicks(a.normalizeTimeTickInterval(e),n,d,b.startOfWeek));else for(b=n+(c[0]-n)%e;b<=d&&b!==p[0];b+=e)p.push(b);0!==p.length&&a.trimTicks(p);return p},adjustForMinRange:function(){var a=this.options,b=this.min,c=this.max,e,p,d,n,q,k,f,v;this.isXAxis&&\nvoid 0===this.minRange&&!this.isLog&&(r(a.min)||r(a.max)?this.minRange=null:(g(this.series,function(a){k=a.xData;for(n=f=a.xIncrement?1:k.length-1;0<n;n--)if(q=k[n]-k[n-1],void 0===d||q<d)d=q}),this.minRange=Math.min(5*d,this.dataMax-this.dataMin)));c-b<this.minRange&&(p=this.dataMax-this.dataMin>=this.minRange,v=this.minRange,e=(v-c+b)/2,e=[b-e,B(a.min,b-e)],p&&(e[2]=this.isLog?this.log2lin(this.dataMin):this.dataMin),b=F(e),c=[b+v,B(a.max,b+v)],p&&(c[2]=this.isLog?this.log2lin(this.dataMax):this.dataMax),\nc=E(c),c-b<v&&(e[0]=c-v,e[1]=B(a.min,c-v),b=F(e)));this.min=b;this.max=c},getClosest:function(){var a;this.categories?a=1:g(this.series,function(h){var b=h.closestPointRange,c=h.visible||!h.chart.options.chart.ignoreHiddenSeries;!h.noSharedTooltip&&r(b)&&c&&(a=r(a)?Math.min(a,b):b)});return a},nameToX:function(a){var h=n(this.categories),b=h?this.categories:this.names,c=a.options.x,e;a.series.requireSorting=!1;r(c)||(c=!1===this.options.uniqueNames?a.series.autoIncrement():y(a.name,b));-1===c?h||\n(e=b.length):e=c;void 0!==e&&(this.names[e]=a.name);return e},updateNames:function(){var a=this;0<this.names.length&&(this.names.length=0,this.minRange=this.userMinRange,g(this.series||[],function(h){h.xIncrement=null;if(!h.points||h.isDirtyData)h.processData(),h.generatePoints();g(h.points,function(b,c){var e;b.options&&(e=a.nameToX(b),void 0!==e&&e!==b.x&&(b.x=e,h.xData[c]=e))})}))},setAxisTranslation:function(a){var h=this,b=h.max-h.min,c=h.axisPointRange||0,e,p=0,d=0,n=h.linkedParent,q=!!h.categories,\nk=h.transA,f=h.isXAxis;if(f||q||c)e=h.getClosest(),n?(p=n.minPointOffset,d=n.pointRangePadding):g(h.series,function(a){var b=q?1:f?B(a.options.pointRange,e,0):h.axisPointRange||0;a=a.options.pointPlacement;c=Math.max(c,b);h.single||(p=Math.max(p,J(a)?0:b/2),d=Math.max(d,\"on\"===a?0:b))}),n=h.ordinalSlope&&e?h.ordinalSlope/e:1,h.minPointOffset=p*=n,h.pointRangePadding=d*=n,h.pointRange=Math.min(c,b),f&&(h.closestPointRange=e);a&&(h.oldTransA=k);h.translationSlope=h.transA=k=h.options.staticScale||h.len/\n(b+d||1);h.transB=h.horiz?h.left:h.bottom;h.minPixelPadding=k*p},minFromRange:function(){return this.max-this.range},setTickInterval:function(h){var b=this,c=b.chart,p=b.options,d=b.isLog,n=b.log2lin,q=b.isDatetimeAxis,x=b.isXAxis,v=b.isLinked,z=p.maxPadding,y=p.minPadding,l=p.tickInterval,I=p.tickPixelInterval,m=b.categories,J=b.threshold,t=b.softThreshold,L,u,K,A;q||m||v||this.getTickAmount();K=B(b.userMin,p.min);A=B(b.userMax,p.max);v?(b.linkedParent=c[b.coll][p.linkedTo],c=b.linkedParent.getExtremes(),\nb.min=B(c.min,c.dataMin),b.max=B(c.max,c.dataMax),p.type!==b.linkedParent.options.type&&a.error(11,1)):(!t&&r(J)&&(b.dataMin>=J?(L=J,y=0):b.dataMax<=J&&(u=J,z=0)),b.min=B(K,L,b.dataMin),b.max=B(A,u,b.dataMax));d&&(b.positiveValuesOnly&&!h&&0>=Math.min(b.min,B(b.dataMin,b.min))&&a.error(10,1),b.min=f(n(b.min),15),b.max=f(n(b.max),15));b.range&&r(b.max)&&(b.userMin=b.min=K=Math.max(b.dataMin,b.minFromRange()),b.userMax=A=b.max,b.range=null);k(b,\"foundExtremes\");b.beforePadding&&b.beforePadding();b.adjustForMinRange();\n!(m||b.axisPointRange||b.usePercentage||v)&&r(b.min)&&r(b.max)&&(n=b.max-b.min)&&(!r(K)&&y&&(b.min-=n*y),!r(A)&&z&&(b.max+=n*z));D(p.softMin)&&(b.min=Math.min(b.min,p.softMin));D(p.softMax)&&(b.max=Math.max(b.max,p.softMax));D(p.floor)&&(b.min=Math.max(b.min,p.floor));D(p.ceiling)&&(b.max=Math.min(b.max,p.ceiling));t&&r(b.dataMin)&&(J=J||0,!r(K)&&b.min<J&&b.dataMin>=J?b.min=J:!r(A)&&b.max>J&&b.dataMax<=J&&(b.max=J));b.tickInterval=b.min===b.max||void 0===b.min||void 0===b.max?1:v&&!l&&I===b.linkedParent.options.tickPixelInterval?\nl=b.linkedParent.tickInterval:B(l,this.tickAmount?(b.max-b.min)/Math.max(this.tickAmount-1,1):void 0,m?1:(b.max-b.min)*I/Math.max(b.len,I));x&&!h&&g(b.series,function(a){a.processData(b.min!==b.oldMin||b.max!==b.oldMax)});b.setAxisTranslation(!0);b.beforeSetTickPositions&&b.beforeSetTickPositions();b.postProcessTickInterval&&(b.tickInterval=b.postProcessTickInterval(b.tickInterval));b.pointRange&&!l&&(b.tickInterval=Math.max(b.pointRange,b.tickInterval));h=B(p.minTickInterval,b.isDatetimeAxis&&b.closestPointRange);\n!l&&b.tickInterval<h&&(b.tickInterval=h);q||d||l||(b.tickInterval=G(b.tickInterval,null,e(b.tickInterval),B(p.allowDecimals,!(.5<b.tickInterval&&5>b.tickInterval&&1E3<b.max&&9999>b.max)),!!this.tickAmount));this.tickAmount||(b.tickInterval=b.unsquish());this.setTickPositions()},setTickPositions:function(){var a=this.options,b,c=a.tickPositions,e=a.tickPositioner,p=a.startOnTick,d=a.endOnTick;this.tickmarkOffset=this.categories&&\"between\"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval=\n\"auto\"===a.minorTickInterval&&this.tickInterval?this.tickInterval/5:a.minorTickInterval;this.single=this.min===this.max&&r(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==a.allowDecimals);this.tickPositions=b=c&&c.slice();!b&&(b=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,\nthis.min,this.max),b.length>this.len&&(b=[b[0],b.pop()]),this.tickPositions=b,e&&(e=e.apply(this,[this.min,this.max])))&&(this.tickPositions=b=e);this.paddedTicks=b.slice(0);this.trimTicks(b,p,d);this.isLinked||(this.single&&2>b.length&&(this.min-=.5,this.max+=.5),c||e||this.adjustTickAmount())},trimTicks:function(a,b,c){var h=a[0],e=a[a.length-1],p=this.minPointOffset||0;if(!this.isLinked){if(b&&-Infinity!==h)this.min=h;else for(;this.min-p>a[0];)a.shift();if(c)this.max=e;else for(;this.max+p<a[a.length-\n1];)a.pop();0===a.length&&r(h)&&a.push((e+h)/2)}},alignToOthers:function(){var a={},b,c=this.options;!1===this.chart.options.chart.alignTicks||!1===c.alignTicks||this.isLog||g(this.chart[this.coll],function(h){var c=h.options,c=[h.horiz?c.left:c.top,c.width,c.height,c.pane].join();h.series.length&&(a[c]?b=!0:a[c]=1)});return b},getTickAmount:function(){var a=this.options,b=a.tickAmount,c=a.tickPixelInterval;!r(a.tickInterval)&&this.len<c&&!this.isRadial&&!this.isLog&&a.startOnTick&&a.endOnTick&&(b=\n2);!b&&this.alignToOthers()&&(b=Math.ceil(this.len/c)+1);4>b&&(this.finalTickAmt=b,b=5);this.tickAmount=b},adjustTickAmount:function(){var a=this.tickInterval,b=this.tickPositions,c=this.tickAmount,e=this.finalTickAmt,p=b&&b.length;if(p<c){for(;b.length<c;)b.push(f(b[b.length-1]+a));this.transA*=(p-1)/(c-1);this.max=b[b.length-1]}else p>c&&(this.tickInterval*=2,this.setTickPositions());if(r(e)){for(a=c=b.length;a--;)(3===e&&1===a%2||2>=e&&0<a&&a<c-1)&&b.splice(a,1);this.finalTickAmt=void 0}},setScale:function(){var a,\nb;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();b=this.len!==this.oldAxisLength;g(this.series,function(b){if(b.isDirtyData||b.isDirty||b.xAxis.isDirty)a=!0});b||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,this.isDirty||\n(this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax)):this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,b,c,e,p){var h=this,n=h.chart;c=B(c,!0);g(h.series,function(a){delete a.kdTree});p=d(p,{min:a,max:b});k(h,\"setExtremes\",p,function(){h.userMin=a;h.userMax=b;h.eventArgs=p;c&&n.redraw(e)})},zoom:function(a,b){var h=this.dataMin,c=this.dataMax,e=this.options,p=Math.min(h,B(e.min,h)),e=Math.max(c,B(e.max,c));if(a!==this.min||b!==this.max)this.allowZoomOutside||(r(h)&&(a<p&&(a=\np),a>e&&(a=e)),r(c)&&(b<p&&(b=p),b>e&&(b=e))),this.displayBtn=void 0!==a||void 0!==b,this.setExtremes(a,b,!1,void 0,{trigger:\"zoom\"});return!0},setAxisSize:function(){var b=this.chart,c=this.options,e=c.offsets||[0,0,0,0],p=this.horiz,d=this.width=Math.round(a.relativeLength(B(c.width,b.plotWidth-e[3]+e[1]),b.plotWidth)),n=this.height=Math.round(a.relativeLength(B(c.height,b.plotHeight-e[0]+e[2]),b.plotHeight)),q=this.top=Math.round(a.relativeLength(B(c.top,b.plotTop+e[0]),b.plotHeight,b.plotTop)),\nc=this.left=Math.round(a.relativeLength(B(c.left,b.plotLeft+e[3]),b.plotWidth,b.plotLeft));this.bottom=b.chartHeight-n-q;this.right=b.chartWidth-d-c;this.len=Math.max(p?d:n,0);this.pos=p?c:q},getExtremes:function(){var a=this.isLog,b=this.lin2log;return{min:a?f(b(this.min)):this.min,max:a?f(b(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,h=this.lin2log,c=b?h(this.min):this.min,b=b?h(this.max):this.max;\nnull===a?a=c:c>a?a=c:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(B(a,0)-90*this.side+720)%360;return 15<a&&165>a?\"right\":195<a&&345>a?\"left\":\"center\"},tickSize:function(a){var b=this.options,h=b[a+\"Length\"],c=B(b[a+\"Width\"],\"tick\"===a&&this.isXAxis?1:0);if(c&&h)return\"inside\"===b[a+\"Position\"]&&(h=-h),[h,c]},labelMetrics:function(){var a=this.tickPositions&&this.tickPositions[0]||0;return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,\nthis.ticks[a]&&this.ticks[a].label)},unsquish:function(){var a=this.options.labels,b=this.horiz,c=this.tickInterval,e=c,p=this.len/(((this.categories?1:0)+this.max-this.min)/c),d,n=a.rotation,q=this.labelMetrics(),k,f=Number.MAX_VALUE,v,z=function(a){a/=p||1;a=1<a?Math.ceil(a):1;return a*c};b?(v=!a.staggerLines&&!a.step&&(r(n)?[n]:p<B(a.autoRotationLimit,80)&&a.autoRotation))&&g(v,function(a){var b;if(a===n||a&&-90<=a&&90>=a)k=z(Math.abs(q.h/Math.sin(u*a))),b=k+Math.abs(a/360),b<f&&(f=b,d=a,e=k)}):\na.step||(e=z(q.h));this.autoRotation=v;this.labelRotation=B(d,n);return e},getSlotWidth:function(){var a=this.chart,b=this.horiz,c=this.options.labels,e=Math.max(this.tickPositions.length-(this.categories?0:1),1),p=a.margin[3];return b&&2>(c.step||0)&&!c.rotation&&(this.staggerLines||1)*this.len/e||!b&&(p&&p-a.spacing[3]||.33*a.chartWidth)},renderUnsquish:function(){var a=this.chart,b=a.renderer,e=this.tickPositions,p=this.ticks,d=this.options.labels,n=this.horiz,q=this.getSlotWidth(),k=Math.max(1,\nMath.round(q-2*(d.padding||5))),f={},v=this.labelMetrics(),z=d.style&&d.style.textOverflow,D,y=0,l,I;J(d.rotation)||(f.rotation=d.rotation||0);g(e,function(a){(a=p[a])&&a.labelLength>y&&(y=a.labelLength)});this.maxLabelLength=y;if(this.autoRotation)y>k&&y>v.h?f.rotation=this.labelRotation:this.labelRotation=0;else if(q&&(D={width:k+\"px\"},!z))for(D.textOverflow=\"clip\",l=e.length;!n&&l--;)if(I=e[l],k=p[I].label)k.styles&&\"ellipsis\"===k.styles.textOverflow?k.css({textOverflow:\"clip\"}):p[I].labelLength>\nq&&k.css({width:q+\"px\"}),k.getBBox().height>this.len/e.length-(v.h-v.f)&&(k.specCss={textOverflow:\"ellipsis\"});f.rotation&&(D={width:(y>.5*a.chartHeight?.33*a.chartHeight:a.chartHeight)+\"px\"},z||(D.textOverflow=\"ellipsis\"));if(this.labelAlign=d.align||this.autoLabelAlign(this.labelRotation))f.align=this.labelAlign;g(e,function(a){var b=(a=p[a])&&a.label;b&&(b.attr(f),D&&b.css(c(D,b.specCss)),delete b.specCss,a.rotation=f.rotation)});this.tickRotCorr=b.rotCorr(v.b,this.labelRotation||0,0!==this.side)},\nhasData:function(){return this.hasVisibleSeries||r(this.min)&&r(this.max)&&!!this.tickPositions},addTitle:function(a){var b=this.chart.renderer,c=this.horiz,h=this.opposite,e=this.options.title,p;this.axisTitle||((p=e.textAlign)||(p=(c?{low:\"left\",middle:\"center\",high:\"right\"}:{low:h?\"right\":\"left\",middle:\"center\",high:h?\"left\":\"right\"})[e.align]),this.axisTitle=b.text(e.text,0,0,e.useHTML).attr({zIndex:7,rotation:e.rotation||0,align:p}).addClass(\"highcharts-axis-title\").css(e.style).add(this.axisGroup),\nthis.axisTitle.isNew=!0);e.style.width||this.isRadial||this.axisTitle.css({width:this.len});this.axisTitle[a?\"show\":\"hide\"](!0)},generateTick:function(a){var b=this.ticks;b[a]?b[a].addLabel():b[a]=new I(this,a)},getOffset:function(){var a=this,b=a.chart,c=b.renderer,e=a.options,p=a.tickPositions,d=a.ticks,n=a.horiz,k=a.side,f=b.inverted&&!a.isZAxis?[1,0,3,2][k]:k,v,z,D=0,y,l=0,I=e.title,m=e.labels,G=0,J=b.axisOffset,b=b.clipOffset,t=[-1,1,1,-1][k],L=e.className,u=a.axisParent,K=this.tickSize(\"tick\");\nv=a.hasData();a.showAxis=z=v||B(e.showEmpty,!0);a.staggerLines=a.horiz&&m.staggerLines;a.axisGroup||(a.gridGroup=c.g(\"grid\").attr({zIndex:e.gridZIndex||1}).addClass(\"highcharts-\"+this.coll.toLowerCase()+\"-grid \"+(L||\"\")).add(u),a.axisGroup=c.g(\"axis\").attr({zIndex:e.zIndex||2}).addClass(\"highcharts-\"+this.coll.toLowerCase()+\" \"+(L||\"\")).add(u),a.labelGroup=c.g(\"axis-labels\").attr({zIndex:m.zIndex||7}).addClass(\"highcharts-\"+a.coll.toLowerCase()+\"-labels \"+(L||\"\")).add(u));v||a.isLinked?(g(p,function(b,\nc){a.generateTick(b,c)}),a.renderUnsquish(),!1===m.reserveSpace||0!==k&&2!==k&&{1:\"left\",3:\"right\"}[k]!==a.labelAlign&&\"center\"!==a.labelAlign||g(p,function(a){G=Math.max(d[a].getLabelSize(),G)}),a.staggerLines&&(G*=a.staggerLines,a.labelOffset=G*(a.opposite?-1:1))):q(d,function(a,b){a.destroy();delete d[b]});I&&I.text&&!1!==I.enabled&&(a.addTitle(z),z&&!1!==I.reserveSpace&&(a.titleOffset=D=a.axisTitle.getBBox()[n?\"height\":\"width\"],y=I.offset,l=r(y)?0:B(I.margin,n?5:10)));a.renderLine();a.offset=\nt*B(e.offset,J[k]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};c=0===k?-a.labelMetrics().h:2===k?a.tickRotCorr.y:0;l=Math.abs(G)+l;G&&(l=l-c+t*(n?B(m.y,a.tickRotCorr.y+8*t):m.x));a.axisTitleMargin=B(y,l);J[k]=Math.max(J[k],a.axisTitleMargin+D+t*a.offset,l,v&&p.length&&K?K[0]+t*a.offset:0);p=2*Math.floor(a.axisLine.strokeWidth()/2);0<e.offset&&(p-=2*e.offset);b[f]=Math.max(b[f]||p,p)},getLinePath:function(a){var b=this.chart,c=this.opposite,h=this.offset,e=this.horiz,p=this.left+(c?this.width:0)+h,h=b.chartHeight-\nthis.bottom-(c?this.height:0)+h;c&&(a*=-1);return b.renderer.crispLine([\"M\",e?this.left:p,e?h:this.top,\"L\",e?b.chartWidth-this.right:p,e?h:b.chartHeight-this.bottom],a)},renderLine:function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup),this.axisLine.attr({stroke:this.options.lineColor,\"stroke-width\":this.options.lineWidth,zIndex:7}))},getTitlePosition:function(){var a=this.horiz,b=this.left,c=this.top,e=this.len,p=this.options.title,\nd=a?b:c,n=this.opposite,q=this.offset,k=p.x||0,g=p.y||0,f=this.axisTitle,v=this.chart.renderer.fontMetrics(p.style&&p.style.fontSize,f),f=Math.max(f.getBBox(null,0).height-v.h-1,0),e={low:d+(a?0:e),middle:d+e/2,high:d+(a?e:0)}[p.align],b=(a?c+this.height:b)+(a?1:-1)*(n?-1:1)*this.axisTitleMargin+[-f,f,v.f,-f][this.side];return{x:a?e+k:b+(n?this.width:0)+q+k,y:a?b+g-(n?this.height:0)+q:e+g}},renderMinorTick:function(a){var b=this.chart.hasRendered&&D(this.oldMin),c=this.minorTicks;c[a]||(c[a]=new I(this,\na,\"minor\"));b&&c[a].isNew&&c[a].render(null,!0);c[a].render(null,!1,1)},renderTick:function(a,b){var c=this.isLinked,e=this.ticks,h=this.chart.hasRendered&&D(this.oldMin);if(!c||a>=this.min&&a<=this.max)e[a]||(e[a]=new I(this,a)),h&&e[a].isNew&&e[a].render(b,!0,.1),e[a].render(b)},render:function(){var b=this,c=b.chart,e=b.options,p=b.isLog,d=b.lin2log,n=b.isLinked,k=b.tickPositions,f=b.axisTitle,v=b.ticks,y=b.minorTicks,l=b.alternateBands,m=e.stackLabels,r=e.alternateGridColor,B=b.tickmarkOffset,\nG=b.axisLine,J=b.showAxis,t=A(c.renderer.globalAnimation),L,u;b.labelEdge.length=0;b.overlap=!1;g([v,y,l],function(a){q(a,function(a){a.isActive=!1})});if(b.hasData()||n)b.minorTickInterval&&!b.categories&&g(b.getMinorTickPositions(),function(a){b.renderMinorTick(a)}),k.length&&(g(k,function(a,c){b.renderTick(a,c)}),B&&(0===b.min||b.single)&&(v[-1]||(v[-1]=new I(b,-1,null,!0)),v[-1].render(-1))),r&&g(k,function(e,h){u=void 0!==k[h+1]?k[h+1]+B:b.max-B;0===h%2&&e<b.max&&u<=b.max+(c.polar?-B:B)&&(l[e]||\n(l[e]=new a.PlotLineOrBand(b)),L=e+B,l[e].options={from:p?d(L):L,to:p?d(u):u,color:r},l[e].render(),l[e].isActive=!0)}),b._addedPlotLB||(g((e.plotLines||[]).concat(e.plotBands||[]),function(a){b.addPlotBandOrLine(a)}),b._addedPlotLB=!0);g([v,y,l],function(a){var b,e=[],h=t.duration;q(a,function(a,b){a.isActive||(a.render(b,!1,0),a.isActive=!1,e.push(b))});z(function(){for(b=e.length;b--;)a[e[b]]&&!a[e[b]].isActive&&(a[e[b]].destroy(),delete a[e[b]])},a!==l&&c.hasRendered&&h?h:0)});G&&(G[G.isPlaced?\n\"animate\":\"attr\"]({d:this.getLinePath(G.strokeWidth())}),G.isPlaced=!0,G[J?\"show\":\"hide\"](!0));f&&J&&(e=b.getTitlePosition(),D(e.y)?(f[f.isNew?\"attr\":\"animate\"](e),f.isNew=!1):(f.attr(\"y\",-9999),f.isNew=!0));m&&m.enabled&&b.renderStackTotals();b.isDirty=!1},redraw:function(){this.visible&&(this.render(),g(this.plotLinesAndBands,function(a){a.render()}));g(this.series,function(a){a.isDirty=!0})},keepProps:\"extKey hcEvents names series userMax userMin\".split(\" \"),destroy:function(a){var b=this,c=b.stacks,\ne=b.plotLinesAndBands,h;a||K(b);q(c,function(a,b){t(a);c[b]=null});g([b.ticks,b.minorTicks,b.alternateBands],function(a){t(a)});if(e)for(a=e.length;a--;)e[a].destroy();g(\"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross\".split(\" \"),function(a){b[a]&&(b[a]=b[a].destroy())});for(h in b.plotLinesAndBandsGroups)b.plotLinesAndBandsGroups[h]=b.plotLinesAndBandsGroups[h].destroy();q(b,function(a,c){-1===y(c,b.keepProps)&&delete b[c]})},drawCrosshair:function(a,b){var c,e=this.crosshair,\nh=B(e.snap,!0),p,d=this.cross;a||(a=this.cross&&this.cross.e);this.crosshair&&!1!==(r(b)||!h)?(h?r(b)&&(p=this.isXAxis?b.plotX:this.len-b.plotY):p=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos),r(p)&&(c=this.getPlotLinePath(b&&(this.isXAxis?b.x:B(b.stackY,b.y)),null,null,null,p)||null),r(c)?(b=this.categories&&!this.isRadial,d||(this.cross=d=this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\"+(b?\"category \":\"thin \")+e.className).attr({zIndex:B(e.zIndex,2)}).add(),\nd.attr({stroke:e.color||(b?m(\"#ccd6eb\").setOpacity(.25).get():\"#cccccc\"),\"stroke-width\":B(e.width,1)}),e.dashStyle&&d.attr({dashstyle:e.dashStyle})),d.show().attr({d:c}),b&&!e.width&&d.attr({\"stroke-width\":this.transA}),this.cross.e=a):this.hideCrosshair()):this.hideCrosshair()},hideCrosshair:function(){this.cross&&this.cross.hide()}});return a.Axis=L}(M);(function(a){var C=a.Axis,A=a.Date,F=a.dateFormat,E=a.defaultOptions,m=a.defined,f=a.each,l=a.extend,r=a.getMagnitude,u=a.getTZOffset,t=a.normalizeTickInterval,\ng=a.pick,d=a.timeUnits;C.prototype.getTimeTicks=function(a,b,e,v){var k=[],n={},D=E.global.useUTC,r,c=new A(b-Math.max(u(b),u(e))),G=A.hcMakeTime,q=a.unitRange,B=a.count,t,p;if(m(b)){c[A.hcSetMilliseconds](q>=d.second?0:B*Math.floor(c.getMilliseconds()/B));if(q>=d.second)c[A.hcSetSeconds](q>=d.minute?0:B*Math.floor(c.getSeconds()/B));if(q>=d.minute)c[A.hcSetMinutes](q>=d.hour?0:B*Math.floor(c[A.hcGetMinutes]()/B));if(q>=d.hour)c[A.hcSetHours](q>=d.day?0:B*Math.floor(c[A.hcGetHours]()/B));if(q>=d.day)c[A.hcSetDate](q>=\nd.month?1:B*Math.floor(c[A.hcGetDate]()/B));q>=d.month&&(c[A.hcSetMonth](q>=d.year?0:B*Math.floor(c[A.hcGetMonth]()/B)),r=c[A.hcGetFullYear]());if(q>=d.year)c[A.hcSetFullYear](r-r%B);if(q===d.week)c[A.hcSetDate](c[A.hcGetDate]()-c[A.hcGetDay]()+g(v,1));r=c[A.hcGetFullYear]();v=c[A.hcGetMonth]();var z=c[A.hcGetDate](),I=c[A.hcGetHours]();if(A.hcTimezoneOffset||A.hcGetTimezoneOffset)p=(!D||!!A.hcGetTimezoneOffset)&&(e-b>4*d.month||u(b)!==u(e)),c=c.getTime(),t=u(c),c=new A(c+t);D=c.getTime();for(b=1;D<\ne;)k.push(D),D=q===d.year?G(r+b*B,0):q===d.month?G(r,v+b*B):!p||q!==d.day&&q!==d.week?p&&q===d.hour?G(r,v,z,I+b*B,0,0,t)-t:D+q*B:G(r,v,z+b*B*(q===d.day?1:7)),b++;k.push(D);q<=d.hour&&1E4>k.length&&f(k,function(a){0===a%18E5&&\"000000000\"===F(\"%H%M%S%L\",a)&&(n[a]=\"day\")})}k.info=l(a,{higherRanks:n,totalRange:q*B});return k};C.prototype.normalizeTimeTickInterval=function(a,b){var e=b||[[\"millisecond\",[1,2,5,10,20,25,50,100,200,500]],[\"second\",[1,2,5,10,15,30]],[\"minute\",[1,2,5,10,15,30]],[\"hour\",[1,\n2,3,4,6,8,12]],[\"day\",[1,2]],[\"week\",[1,2]],[\"month\",[1,2,3,4,6]],[\"year\",null]];b=e[e.length-1];var k=d[b[0]],g=b[1],n;for(n=0;n<e.length&&!(b=e[n],k=d[b[0]],g=b[1],e[n+1]&&a<=(k*g[g.length-1]+d[e[n+1][0]])/2);n++);k===d.year&&a<5*k&&(g=[1,2,5]);a=t(a/k,g,\"year\"===b[0]?Math.max(r(a/k),1):1);return{unitRange:k,count:a,unitName:b[0]}}})(M);(function(a){var C=a.Axis,A=a.getMagnitude,F=a.map,E=a.normalizeTickInterval,m=a.pick;C.prototype.getLogTickPositions=function(a,l,r,u){var f=this.options,g=this.len,\nd=this.lin2log,k=this.log2lin,b=[];u||(this._minorAutoInterval=null);if(.5<=a)a=Math.round(a),b=this.getLinearTickPositions(a,l,r);else if(.08<=a)for(var g=Math.floor(l),e,v,y,n,D,f=.3<a?[1,2,4]:.15<a?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];g<r+1&&!D;g++)for(v=f.length,e=0;e<v&&!D;e++)y=k(d(g)*f[e]),y>l&&(!u||n<=r)&&void 0!==n&&b.push(n),n>r&&(D=!0),n=y;else l=d(l),r=d(r),a=f[u?\"minorTickInterval\":\"tickInterval\"],a=m(\"auto\"===a?null:a,this._minorAutoInterval,f.tickPixelInterval/(u?5:1)*(r-l)/((u?g/this.tickPositions.length:\ng)||1)),a=E(a,null,A(a)),b=F(this.getLinearTickPositions(a,l,r),k),u||(this._minorAutoInterval=a/5);u||(this.tickInterval=a);return b};C.prototype.log2lin=function(a){return Math.log(a)/Math.LN10};C.prototype.lin2log=function(a){return Math.pow(10,a)}})(M);(function(a,C){var A=a.arrayMax,F=a.arrayMin,E=a.defined,m=a.destroyObjectProperties,f=a.each,l=a.erase,r=a.merge,u=a.pick;a.PlotLineOrBand=function(a,g){this.axis=a;g&&(this.options=g,this.id=g.id)};a.PlotLineOrBand.prototype={render:function(){var f=\nthis,g=f.axis,d=g.horiz,k=f.options,b=k.label,e=f.label,v=k.to,l=k.from,n=k.value,D=E(l)&&E(v),m=E(n),c=f.svgElem,G=!c,q=[],B=k.color,K=u(k.zIndex,0),p=k.events,q={\"class\":\"highcharts-plot-\"+(D?\"band \":\"line \")+(k.className||\"\")},z={},I=g.chart.renderer,L=D?\"bands\":\"lines\",h=g.log2lin;g.isLog&&(l=h(l),v=h(v),n=h(n));m?(q={stroke:B,\"stroke-width\":k.width},k.dashStyle&&(q.dashstyle=k.dashStyle)):D&&(B&&(q.fill=B),k.borderWidth&&(q.stroke=k.borderColor,q[\"stroke-width\"]=k.borderWidth));z.zIndex=K;L+=\n\"-\"+K;(B=g.plotLinesAndBandsGroups[L])||(g.plotLinesAndBandsGroups[L]=B=I.g(\"plot-\"+L).attr(z).add());G&&(f.svgElem=c=I.path().attr(q).add(B));if(m)q=g.getPlotLinePath(n,c.strokeWidth());else if(D)q=g.getPlotBandPath(l,v,k);else return;G&&q&&q.length?(c.attr({d:q}),p&&a.objectEach(p,function(a,b){c.on(b,function(a){p[b].apply(f,[a])})})):c&&(q?(c.show(),c.animate({d:q})):(c.hide(),e&&(f.label=e=e.destroy())));b&&E(b.text)&&q&&q.length&&0<g.width&&0<g.height&&!q.flat?(b=r({align:d&&D&&\"center\",x:d?\n!D&&4:10,verticalAlign:!d&&D&&\"middle\",y:d?D?16:10:D?6:-4,rotation:d&&!D&&90},b),this.renderLabel(b,q,D,K)):e&&e.hide();return f},renderLabel:function(a,g,d,k){var b=this.label,e=this.axis.chart.renderer;b||(b={align:a.textAlign||a.align,rotation:a.rotation,\"class\":\"highcharts-plot-\"+(d?\"band\":\"line\")+\"-label \"+(a.className||\"\")},b.zIndex=k,this.label=b=e.text(a.text,0,0,a.useHTML).attr(b).add(),b.css(a.style));k=[g[1],g[4],d?g[6]:g[1]];g=[g[2],g[5],d?g[7]:g[2]];d=F(k);e=F(g);b.align(a,!1,{x:d,y:e,\nwidth:A(k)-d,height:A(g)-e});b.show()},destroy:function(){l(this.axis.plotLinesAndBands,this);delete this.axis;m(this)}};a.extend(C.prototype,{getPlotBandPath:function(a,g){var d=this.getPlotLinePath(g,null,null,!0),k=this.getPlotLinePath(a,null,null,!0),b=this.horiz,e=1;a=a<this.min&&g<this.min||a>this.max&&g>this.max;k&&d?(a&&(k.flat=k.toString()===d.toString(),e=0),k.push(b&&d[4]===k[4]?d[4]+e:d[4],b||d[5]!==k[5]?d[5]:d[5]+e,b&&d[1]===k[1]?d[1]+e:d[1],b||d[2]!==k[2]?d[2]:d[2]+e)):k=null;return k},\naddPlotBand:function(a){return this.addPlotBandOrLine(a,\"plotBands\")},addPlotLine:function(a){return this.addPlotBandOrLine(a,\"plotLines\")},addPlotBandOrLine:function(f,g){var d=(new a.PlotLineOrBand(this,f)).render(),k=this.userOptions;d&&(g&&(k[g]=k[g]||[],k[g].push(f)),this.plotLinesAndBands.push(d));return d},removePlotBandOrLine:function(a){for(var g=this.plotLinesAndBands,d=this.options,k=this.userOptions,b=g.length;b--;)g[b].id===a&&g[b].destroy();f([d.plotLines||[],k.plotLines||[],d.plotBands||\n[],k.plotBands||[]],function(e){for(b=e.length;b--;)e[b].id===a&&l(e,e[b])})},removePlotBand:function(a){this.removePlotBandOrLine(a)},removePlotLine:function(a){this.removePlotBandOrLine(a)}})})(M,S);(function(a){var C=a.dateFormat,A=a.each,F=a.extend,E=a.format,m=a.isNumber,f=a.map,l=a.merge,r=a.pick,u=a.splat,t=a.syncTimeout,g=a.timeUnits;a.Tooltip=function(){this.init.apply(this,arguments)};a.Tooltip.prototype={init:function(a,k){this.chart=a;this.options=k;this.crosshairs=[];this.now={x:0,y:0};\nthis.isHidden=!0;this.split=k.split&&!a.inverted;this.shared=k.shared||this.split},cleanSplit:function(a){A(this.chart.series,function(d){var b=d&&d.tt;b&&(!b.isActive||a?d.tt=b.destroy():b.isActive=!1)})},getLabel:function(){var a=this.chart.renderer,k=this.options;this.label||(this.split?this.label=a.g(\"tooltip\"):(this.label=a.label(\"\",0,0,k.shape||\"callout\",null,null,k.useHTML,null,\"tooltip\").attr({padding:k.padding,r:k.borderRadius}),this.label.attr({fill:k.backgroundColor,\"stroke-width\":k.borderWidth}).css(k.style).shadow(k.shadow)),\nthis.label.attr({zIndex:8}).add());return this.label},update:function(a){this.destroy();l(!0,this.chart.options.tooltip.userOptions,a);this.init(this.chart,l(!0,this.options,a))},destroy:function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,k,b,e){var d=this,g=d.now,n=!1!==d.options.animation&&!d.isHidden&&(1<Math.abs(a-g.x)||1<Math.abs(k-\ng.y)),f=d.followPointer||1<d.len;F(g,{x:n?(2*g.x+a)/3:a,y:n?(g.y+k)/2:k,anchorX:f?void 0:n?(2*g.anchorX+b)/3:b,anchorY:f?void 0:n?(g.anchorY+e)/2:e});d.getLabel().attr(g);n&&(clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){d&&d.move(a,k,b,e)},32))},hide:function(a){var d=this;clearTimeout(this.hideTimer);a=r(a,this.options.hideDelay,500);this.isHidden||(this.hideTimer=t(function(){d.getLabel()[a?\"fadeOut\":\"hide\"]();d.isHidden=!0},a))},getAnchor:function(a,k){var b,e=this.chart,\nd=e.inverted,g=e.plotTop,n=e.plotLeft,l=0,m=0,c,r;a=u(a);b=a[0].tooltipPos;this.followPointer&&k&&(void 0===k.chartX&&(k=e.pointer.normalize(k)),b=[k.chartX-e.plotLeft,k.chartY-g]);b||(A(a,function(a){c=a.series.yAxis;r=a.series.xAxis;l+=a.plotX+(!d&&r?r.left-n:0);m+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!d&&c?c.top-g:0)}),l/=a.length,m/=a.length,b=[d?e.plotWidth-m:l,this.shared&&!d&&1<a.length&&k?k.chartY-g:d?e.plotHeight-l:m]);return f(b,Math.round)},getPosition:function(a,g,b){var e=this.chart,\nd=this.distance,k={},n=b.h||0,f,l=[\"y\",e.chartHeight,g,b.plotY+e.plotTop,e.plotTop,e.plotTop+e.plotHeight],c=[\"x\",e.chartWidth,a,b.plotX+e.plotLeft,e.plotLeft,e.plotLeft+e.plotWidth],m=!this.followPointer&&r(b.ttBelow,!e.inverted===!!b.negative),q=function(a,b,c,e,p,q){var h=c<e-d,g=e+d+c<b,f=e-d-c;e+=d;if(m&&g)k[a]=e;else if(!m&&h)k[a]=f;else if(h)k[a]=Math.min(q-c,0>f-n?f:f-n);else if(g)k[a]=Math.max(p,e+n+c>b?e:e+n);else return!1},B=function(a,b,c,e){var h;e<d||e>b-d?h=!1:k[a]=e<c/2?1:e>b-c/2?\nb-c-2:e-c/2;return h},t=function(a){var b=l;l=c;c=b;f=a},p=function(){!1!==q.apply(0,l)?!1!==B.apply(0,c)||f||(t(!0),p()):f?k.x=k.y=0:(t(!0),p())};(e.inverted||1<this.len)&&t();p();return k},defaultFormatter:function(a){var d=this.points||u(this),b;b=[a.tooltipFooterHeaderFormatter(d[0])];b=b.concat(a.bodyFormatter(d));b.push(a.tooltipFooterHeaderFormatter(d[0],!0));return b},refresh:function(a,g){var b,e=this.options,d,k=a,n,f={},l=[];b=e.formatter||this.defaultFormatter;var f=this.shared,c;e.enabled&&\n(clearTimeout(this.hideTimer),this.followPointer=u(k)[0].series.tooltipOptions.followPointer,n=this.getAnchor(k,g),g=n[0],d=n[1],!f||k.series&&k.series.noSharedTooltip?f=k.getLabelConfig():(A(k,function(a){a.setState(\"hover\");l.push(a.getLabelConfig())}),f={x:k[0].category,y:k[0].y},f.points=l,k=k[0]),this.len=l.length,f=b.call(f,this),c=k.series,this.distance=r(c.tooltipOptions.distance,16),!1===f?this.hide():(b=this.getLabel(),this.isHidden&&b.attr({opacity:1}).show(),this.split?this.renderSplit(f,\na):(e.style.width||b.css({width:this.chart.spacingBox.width}),b.attr({text:f&&f.join?f.join(\"\"):f}),b.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\"+r(k.colorIndex,c.colorIndex)),b.attr({stroke:e.borderColor||k.color||c.color||\"#666666\"}),this.updatePosition({plotX:g,plotY:d,negative:k.negative,ttBelow:k.ttBelow,h:n[2]||0})),this.isHidden=!1))},renderSplit:function(d,k){var b=this,e=[],g=this.chart,f=g.renderer,n=!0,l=this.options,m=0,c=this.getLabel();A(d.slice(0,k.length+1),\nfunction(a,d){if(!1!==a){d=k[d-1]||{isHeader:!0,plotX:k[0].plotX};var q=d.series||b,v=q.tt,p=d.series||{},z=\"highcharts-color-\"+r(d.colorIndex,p.colorIndex,\"none\");v||(q.tt=v=f.label(null,null,null,\"callout\").addClass(\"highcharts-tooltip-box \"+z).attr({padding:l.padding,r:l.borderRadius,fill:l.backgroundColor,stroke:l.borderColor||d.color||p.color||\"#333333\",\"stroke-width\":l.borderWidth}).add(c));v.isActive=!0;v.attr({text:a});v.css(l.style).shadow(l.shadow);a=v.getBBox();p=a.width+v.strokeWidth();\nd.isHeader?(m=a.height,p=Math.max(0,Math.min(d.plotX+g.plotLeft-p/2,g.chartWidth-p))):p=d.plotX+g.plotLeft-r(l.distance,16)-p;0>p&&(n=!1);a=(d.series&&d.series.yAxis&&d.series.yAxis.pos)+(d.plotY||0);a-=g.plotTop;e.push({target:d.isHeader?g.plotHeight+m:a,rank:d.isHeader?1:0,size:q.tt.getBBox().height+1,point:d,x:p,tt:v})}});this.cleanSplit();a.distribute(e,g.plotHeight+m);A(e,function(a){var b=a.point,c=b.series;a.tt.attr({visibility:void 0===a.pos?\"hidden\":\"inherit\",x:n||b.isHeader?a.x:b.plotX+\ng.plotLeft+r(l.distance,16),y:a.pos+g.plotTop,anchorX:b.isHeader?b.plotX+g.plotLeft:b.plotX+c.xAxis.pos,anchorY:b.isHeader?a.pos+g.plotTop-15:b.plotY+c.yAxis.pos})})},updatePosition:function(a){var d=this.chart,b=this.getLabel(),b=(this.options.positioner||this.getPosition).call(this,b.width,b.height,a);this.move(Math.round(b.x),Math.round(b.y||0),a.plotX+d.plotLeft,a.plotY+d.plotTop)},getDateFormat:function(a,k,b,e){var d=C(\"%m-%d %H:%M:%S.%L\",k),f,n,l={millisecond:15,second:12,minute:9,hour:6,day:3},\nm=\"millisecond\";for(n in g){if(a===g.week&&+C(\"%w\",k)===b&&\"00:00:00.000\"===d.substr(6)){n=\"week\";break}if(g[n]>a){n=m;break}if(l[n]&&d.substr(l[n])!==\"01-01 00:00:00.000\".substr(l[n]))break;\"week\"!==n&&(m=n)}n&&(f=e[n]);return f},getXDateFormat:function(a,g,b){g=g.dateTimeLabelFormats;var e=b&&b.closestPointRange;return(e?this.getDateFormat(e,a.x,b.options.startOfWeek,g):g.day)||g.year},tooltipFooterHeaderFormatter:function(a,g){var b=g?\"footer\":\"header\";g=a.series;var e=g.tooltipOptions,d=e.xDateFormat,\nk=g.xAxis,n=k&&\"datetime\"===k.options.type&&m(a.key),b=e[b+\"Format\"];n&&!d&&(d=this.getXDateFormat(a,e,k));n&&d&&(b=b.replace(\"{point.key}\",\"{point.key:\"+d+\"}\"));return E(b,{point:a,series:g})},bodyFormatter:function(a){return f(a,function(a){var b=a.series.tooltipOptions;return(b.pointFormatter||a.point.tooltipFormatter).call(a.point,b.pointFormat)})}}})(M);(function(a){var C=a.addEvent,A=a.attr,F=a.charts,E=a.color,m=a.css,f=a.defined,l=a.each,r=a.extend,u=a.find,t=a.fireEvent,g=a.isObject,d=a.offset,\nk=a.pick,b=a.removeEvent,e=a.splat,v=a.Tooltip,y=a.win;a.Pointer=function(a,b){this.init(a,b)};a.Pointer.prototype={init:function(a,b){this.options=b;this.chart=a;this.runChartClick=b.chart.events&&!!b.chart.events.click;this.pinchDown=[];this.lastValidTouch={};v&&(a.tooltip=new v(a,b.tooltip),this.followTouchMove=k(b.tooltip.followTouchMove,!0));this.setDOMEvents()},zoomOption:function(a){var b=this.chart,e=b.options.chart,c=e.zoomType||\"\",b=b.inverted;/touch/.test(a.type)&&(c=k(e.pinchType,c));\nthis.zoomX=a=/x/.test(c);this.zoomY=c=/y/.test(c);this.zoomHor=a&&!b||c&&b;this.zoomVert=c&&!b||a&&b;this.hasZoom=a||c},normalize:function(a,b){var e,c;a=a||y.event;a.target||(a.target=a.srcElement);c=a.touches?a.touches.length?a.touches.item(0):a.changedTouches[0]:a;b||(this.chartPosition=b=d(this.chart.container));void 0===c.pageX?(e=Math.max(a.x,a.clientX-b.left),b=a.y):(e=c.pageX-b.left,b=c.pageY-b.top);return r(a,{chartX:Math.round(e),chartY:Math.round(b)})},getCoordinates:function(a){var b=\n{xAxis:[],yAxis:[]};l(this.chart.axes,function(e){b[e.isXAxis?\"xAxis\":\"yAxis\"].push({axis:e,value:e.toValue(a[e.horiz?\"chartX\":\"chartY\"])})});return b},findNearestKDPoint:function(a,b,e){var c;l(a,function(a){var d=!(a.noSharedTooltip&&b)&&0>a.options.findNearestPointBy.indexOf(\"y\");a=a.searchPoint(e,d);if((d=g(a,!0))&&!(d=!g(c,!0)))var d=c.distX-a.distX,n=c.dist-a.dist,k=(a.series.group&&a.series.group.zIndex)-(c.series.group&&c.series.group.zIndex),d=0<(0!==d&&b?d:0!==n?n:0!==k?k:c.series.index>\na.series.index?-1:1);d&&(c=a)});return c},getPointFromEvent:function(a){a=a.target;for(var b;a&&!b;)b=a.point,a=a.parentNode;return b},getChartCoordinatesFromPoint:function(a,b){var e=a.series,c=e.xAxis,e=e.yAxis;if(c&&e)return b?{chartX:c.len+c.pos-a.clientX,chartY:e.len+e.pos-a.plotY}:{chartX:a.clientX+c.pos,chartY:a.plotY+e.pos}},getHoverData:function(b,e,d,c,f,q){var n,v=[];c=!(!c||!b);var p=e&&!e.stickyTracking?[e]:a.grep(d,function(a){return a.visible&&!(!f&&a.directTouch)&&k(a.options.enableMouseTracking,\n!0)&&a.stickyTracking});e=(n=c?b:this.findNearestKDPoint(p,f,q))&&n.series;n&&(f&&!e.noSharedTooltip?(p=a.grep(d,function(a){return a.visible&&!(!f&&a.directTouch)&&k(a.options.enableMouseTracking,!0)&&!a.noSharedTooltip}),l(p,function(a){a=u(a.points,function(a){return a.x===n.x});g(a)&&!a.isNull&&v.push(a)})):v.push(n));return{hoverPoint:n,hoverSeries:e,hoverPoints:v}},runPointActions:function(b,e){var d=this.chart,c=d.tooltip,g=c?c.shared:!1,n=e||d.hoverPoint,f=n&&n.series||d.hoverSeries,f=this.getHoverData(n,\nf,d.series,!!e||f&&f.directTouch&&this.isDirectTouch,g,b),v,n=f.hoverPoint;v=f.hoverPoints;e=(f=f.hoverSeries)&&f.tooltipOptions.followPointer;g=g&&f&&!f.noSharedTooltip;if(n&&(n!==d.hoverPoint||c&&c.isHidden)){l(d.hoverPoints||[],function(b){-1===a.inArray(b,v)&&b.setState()});l(v||[],function(a){a.setState(\"hover\")});if(d.hoverSeries!==f)f.onMouseOver();d.hoverPoint&&d.hoverPoint.firePointEvent(\"mouseOut\");n.firePointEvent(\"mouseOver\");d.hoverPoints=v;d.hoverPoint=n;c&&c.refresh(g?v:n,b)}else e&&\nc&&!c.isHidden&&(n=c.getAnchor([{}],b),c.updatePosition({plotX:n[0],plotY:n[1]}));this.unDocMouseMove||(this.unDocMouseMove=C(d.container.ownerDocument,\"mousemove\",function(b){var c=F[a.hoverChartIndex];if(c)c.pointer.onDocumentMouseMove(b)}));l(d.axes,function(c){var e=k(c.crosshair.snap,!0),p=e?a.find(v,function(a){return a.series[c.coll]===c}):void 0;p||!e?c.drawCrosshair(b,p):c.hideCrosshair()})},reset:function(a,b){var d=this.chart,c=d.hoverSeries,g=d.hoverPoint,n=d.hoverPoints,f=d.tooltip,k=\nf&&f.shared?n:g;a&&k&&l(e(k),function(b){b.series.isCartesian&&void 0===b.plotX&&(a=!1)});if(a)f&&k&&(f.refresh(k),g&&(g.setState(g.state,!0),l(d.axes,function(a){a.crosshair&&a.drawCrosshair(null,g)})));else{if(g)g.onMouseOut();n&&l(n,function(a){a.setState()});if(c)c.onMouseOut();f&&f.hide(b);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());l(d.axes,function(a){a.hideCrosshair()});this.hoverX=d.hoverPoints=d.hoverPoint=null}},scaleGroups:function(a,b){var e=this.chart,c;l(e.series,\nfunction(d){c=a||d.getPlotBox();d.xAxis&&d.xAxis.zoomEnabled&&d.group&&(d.group.attr(c),d.markerGroup&&(d.markerGroup.attr(c),d.markerGroup.clip(b?e.clipRect:null)),d.dataLabelsGroup&&d.dataLabelsGroup.attr(c))});e.clipRect.attr(b||e.clipBox)},dragStart:function(a){var b=this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,e=b.options.chart,c=a.chartX,d=a.chartY,g=this.zoomHor,n=this.zoomVert,\nf=b.plotLeft,p=b.plotTop,k=b.plotWidth,v=b.plotHeight,l,h=this.selectionMarker,w=this.mouseDownX,m=this.mouseDownY,r=e.panKey&&a[e.panKey+\"Key\"];h&&h.touch||(c<f?c=f:c>f+k&&(c=f+k),d<p?d=p:d>p+v&&(d=p+v),this.hasDragged=Math.sqrt(Math.pow(w-c,2)+Math.pow(m-d,2)),10<this.hasDragged&&(l=b.isInsidePlot(w-f,m-p),b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&l&&!r&&!h&&(this.selectionMarker=h=b.renderer.rect(f,p,g?1:k,n?1:v,0).attr({fill:e.selectionMarkerFill||E(\"#335cad\").setOpacity(.25).get(),\"class\":\"highcharts-selection-marker\",\nzIndex:7}).add()),h&&g&&(c-=w,h.attr({width:Math.abs(c),x:(0<c?0:c)+w})),h&&n&&(c=d-m,h.attr({height:Math.abs(c),y:(0<c?0:c)+m})),l&&!h&&e.panning&&b.pan(a,e.panning)))},drop:function(a){var b=this,e=this.chart,c=this.hasPinched;if(this.selectionMarker){var d={originalEvent:a,xAxis:[],yAxis:[]},g=this.selectionMarker,n=g.attr?g.attr(\"x\"):g.x,k=g.attr?g.attr(\"y\"):g.y,p=g.attr?g.attr(\"width\"):g.width,v=g.attr?g.attr(\"height\"):g.height,I;if(this.hasDragged||c)l(e.axes,function(e){if(e.zoomEnabled&&f(e.min)&&\n(c||b[{xAxis:\"zoomX\",yAxis:\"zoomY\"}[e.coll]])){var h=e.horiz,g=\"touchend\"===a.type?e.minPixelPadding:0,q=e.toValue((h?n:k)+g),h=e.toValue((h?n+p:k+v)-g);d[e.coll].push({axis:e,min:Math.min(q,h),max:Math.max(q,h)});I=!0}}),I&&t(e,\"selection\",d,function(a){e.zoom(r(a,c?{animation:!1}:null))});this.selectionMarker=this.selectionMarker.destroy();c&&this.scaleGroups()}e&&(m(e.container,{cursor:e._cursor}),e.cancelClick=10<this.hasDragged,e.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=\n[])},onContainerMouseDown:function(a){a=this.normalize(a);this.zoomOption(a);a.preventDefault&&a.preventDefault();this.dragStart(a)},onDocumentMouseUp:function(b){F[a.hoverChartIndex]&&F[a.hoverChartIndex].pointer.drop(b)},onDocumentMouseMove:function(a){var b=this.chart,e=this.chartPosition;a=this.normalize(a,e);!e||this.inClass(a.target,\"highcharts-tracker\")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||this.reset()},onContainerMouseLeave:function(b){var e=F[a.hoverChartIndex];e&&(b.relatedTarget||\nb.toElement)&&(e.pointer.reset(),e.pointer.chartPosition=null)},onContainerMouseMove:function(b){var e=this.chart;f(a.hoverChartIndex)&&F[a.hoverChartIndex]&&F[a.hoverChartIndex].mouseIsDown||(a.hoverChartIndex=e.index);b=this.normalize(b);b.returnValue=!1;\"mousedown\"===e.mouseIsDown&&this.drag(b);!this.inClass(b.target,\"highcharts-tracker\")&&!e.isInsidePlot(b.chartX-e.plotLeft,b.chartY-e.plotTop)||e.openMenu||this.runPointActions(b)},inClass:function(a,b){for(var e;a;){if(e=A(a,\"class\")){if(-1!==\ne.indexOf(b))return!0;if(-1!==e.indexOf(\"highcharts-container\"))return!1}a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries;a=a.relatedTarget||a.toElement;this.isDirectTouch=!1;if(!(!b||!a||b.stickyTracking||this.inClass(a,\"highcharts-tooltip\")||this.inClass(a,\"highcharts-series-\"+b.index)&&this.inClass(a,\"highcharts-tracker\")))b.onMouseOut()},onContainerClick:function(a){var b=this.chart,e=b.hoverPoint,c=b.plotLeft,d=b.plotTop;a=this.normalize(a);b.cancelClick||(e&&this.inClass(a.target,\n\"highcharts-tracker\")?(t(e.series,\"click\",r(a,{point:e})),b.hoverPoint&&e.firePointEvent(\"click\",a)):(r(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-c,a.chartY-d)&&t(b,\"click\",a)))},setDOMEvents:function(){var b=this,e=b.chart.container,d=e.ownerDocument;e.onmousedown=function(a){b.onContainerMouseDown(a)};e.onmousemove=function(a){b.onContainerMouseMove(a)};e.onclick=function(a){b.onContainerClick(a)};C(e,\"mouseleave\",b.onContainerMouseLeave);1===a.chartCount&&C(d,\"mouseup\",b.onDocumentMouseUp);\na.hasTouch&&(e.ontouchstart=function(a){b.onContainerTouchStart(a)},e.ontouchmove=function(a){b.onContainerTouchMove(a)},1===a.chartCount&&C(d,\"touchend\",b.onDocumentTouchEnd))},destroy:function(){var e=this,d=this.chart.container.ownerDocument;e.unDocMouseMove&&e.unDocMouseMove();b(e.chart.container,\"mouseleave\",e.onContainerMouseLeave);a.chartCount||(b(d,\"mouseup\",e.onDocumentMouseUp),a.hasTouch&&b(d,\"touchend\",e.onDocumentTouchEnd));clearInterval(e.tooltipTimeout);a.objectEach(e,function(a,b){e[b]=\nnull})}}})(M);(function(a){var C=a.charts,A=a.each,F=a.extend,E=a.map,m=a.noop,f=a.pick;F(a.Pointer.prototype,{pinchTranslate:function(a,f,m,t,g,d){this.zoomHor&&this.pinchTranslateDirection(!0,a,f,m,t,g,d);this.zoomVert&&this.pinchTranslateDirection(!1,a,f,m,t,g,d)},pinchTranslateDirection:function(a,f,m,t,g,d,k,b){var e=this.chart,v=a?\"x\":\"y\",l=a?\"X\":\"Y\",n=\"chart\"+l,r=a?\"width\":\"height\",u=e[\"plot\"+(a?\"Left\":\"Top\")],c,G,q=b||1,B=e.inverted,K=e.bounds[a?\"h\":\"v\"],p=1===f.length,z=f[0][n],I=m[0][n],\nL=!p&&f[1][n],h=!p&&m[1][n],w;m=function(){!p&&20<Math.abs(z-L)&&(q=b||Math.abs(I-h)/Math.abs(z-L));G=(u-I)/q+z;c=e[\"plot\"+(a?\"Width\":\"Height\")]/q};m();f=G;f<K.min?(f=K.min,w=!0):f+c>K.max&&(f=K.max-c,w=!0);w?(I-=.8*(I-k[v][0]),p||(h-=.8*(h-k[v][1])),m()):k[v]=[I,h];B||(d[v]=G-u,d[r]=c);d=B?1/q:q;g[r]=c;g[v]=f;t[B?a?\"scaleY\":\"scaleX\":\"scale\"+l]=q;t[\"translate\"+l]=d*u+(I-d*z)},pinch:function(a){var l=this,u=l.chart,t=l.pinchDown,g=a.touches,d=g.length,k=l.lastValidTouch,b=l.hasZoom,e=l.selectionMarker,\nv={},y=1===d&&(l.inClass(a.target,\"highcharts-tracker\")&&u.runTrackerClick||l.runChartClick),n={};1<d&&(l.initiated=!0);b&&l.initiated&&!y&&a.preventDefault();E(g,function(a){return l.normalize(a)});\"touchstart\"===a.type?(A(g,function(a,b){t[b]={chartX:a.chartX,chartY:a.chartY}}),k.x=[t[0].chartX,t[1]&&t[1].chartX],k.y=[t[0].chartY,t[1]&&t[1].chartY],A(u.axes,function(a){if(a.zoomEnabled){var b=u.bounds[a.horiz?\"h\":\"v\"],e=a.minPixelPadding,d=a.toPixels(f(a.options.min,a.dataMin)),g=a.toPixels(f(a.options.max,\na.dataMax)),k=Math.max(d,g);b.min=Math.min(a.pos,Math.min(d,g)-e);b.max=Math.max(a.pos+a.len,k+e)}}),l.res=!0):l.followTouchMove&&1===d?this.runPointActions(l.normalize(a)):t.length&&(e||(l.selectionMarker=e=F({destroy:m,touch:!0},u.plotBox)),l.pinchTranslate(t,g,v,e,n,k),l.hasPinched=b,l.scaleGroups(v,n),l.res&&(l.res=!1,this.reset(!1,0)))},touch:function(l,m){var r=this.chart,t,g;if(r.index!==a.hoverChartIndex)this.onContainerMouseLeave({relatedTarget:!0});a.hoverChartIndex=r.index;1===l.touches.length?\n(l=this.normalize(l),(g=r.isInsidePlot(l.chartX-r.plotLeft,l.chartY-r.plotTop))&&!r.openMenu?(m&&this.runPointActions(l),\"touchmove\"===l.type&&(m=this.pinchDown,t=m[0]?4<=Math.sqrt(Math.pow(m[0].chartX-l.chartX,2)+Math.pow(m[0].chartY-l.chartY,2)):!1),f(t,!0)&&this.pinch(l)):m&&this.reset()):2===l.touches.length&&this.pinch(l)},onContainerTouchStart:function(a){this.zoomOption(a);this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(f){C[a.hoverChartIndex]&&\nC[a.hoverChartIndex].pointer.drop(f)}})})(M);(function(a){var C=a.addEvent,A=a.charts,F=a.css,E=a.doc,m=a.extend,f=a.noop,l=a.Pointer,r=a.removeEvent,u=a.win,t=a.wrap;if(!a.hasTouch&&(u.PointerEvent||u.MSPointerEvent)){var g={},d=!!u.PointerEvent,k=function(){var b=[];b.item=function(a){return this[a]};a.objectEach(g,function(a){b.push({pageX:a.pageX,pageY:a.pageY,target:a.target})});return b},b=function(b,d,g,n){\"touch\"!==b.pointerType&&b.pointerType!==b.MSPOINTER_TYPE_TOUCH||!A[a.hoverChartIndex]||\n(n(b),n=A[a.hoverChartIndex].pointer,n[d]({type:g,target:b.currentTarget,preventDefault:f,touches:k()}))};m(l.prototype,{onContainerPointerDown:function(a){b(a,\"onContainerTouchStart\",\"touchstart\",function(a){g[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){b(a,\"onContainerTouchMove\",\"touchmove\",function(a){g[a.pointerId]={pageX:a.pageX,pageY:a.pageY};g[a.pointerId].target||(g[a.pointerId].target=a.currentTarget)})},onDocumentPointerUp:function(a){b(a,\n\"onDocumentTouchEnd\",\"touchend\",function(a){delete g[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,d?\"pointerdown\":\"MSPointerDown\",this.onContainerPointerDown);a(this.chart.container,d?\"pointermove\":\"MSPointerMove\",this.onContainerPointerMove);a(E,d?\"pointerup\":\"MSPointerUp\",this.onDocumentPointerUp)}});t(l.prototype,\"init\",function(a,b,d){a.call(this,b,d);this.hasZoom&&F(b.container,{\"-ms-touch-action\":\"none\",\"touch-action\":\"none\"})});t(l.prototype,\"setDOMEvents\",function(a){a.apply(this);\n(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(C)});t(l.prototype,\"destroy\",function(a){this.batchMSEvents(r);a.call(this)})}})(M);(function(a){var C=a.addEvent,A=a.css,F=a.discardElement,E=a.defined,m=a.each,f=a.isFirefox,l=a.marginNames,r=a.merge,u=a.pick,t=a.setAnimation,g=a.stableSort,d=a.win,k=a.wrap;a.Legend=function(a,e){this.init(a,e)};a.Legend.prototype={init:function(a,e){this.chart=a;this.setOptions(e);e.enabled&&(this.render(),C(this.chart,\"endResize\",function(){this.legend.positionCheckboxes()}))},\nsetOptions:function(a){var b=u(a.padding,8);this.options=a;this.itemStyle=a.itemStyle;this.itemHiddenStyle=r(this.itemStyle,a.itemHiddenStyle);this.itemMarginTop=a.itemMarginTop||0;this.padding=b;this.initialItemY=b-5;this.itemHeight=this.maxItemWidth=0;this.symbolWidth=u(a.symbolWidth,16);this.pages=[]},update:function(a,e){var b=this.chart;this.setOptions(r(!0,this.options,a));this.destroy();b.isDirtyLegend=b.isDirtyBox=!0;u(e,!0)&&b.redraw()},colorizeItem:function(a,e){a.legendGroup[e?\"removeClass\":\n\"addClass\"](\"highcharts-legend-item-hidden\");var b=this.options,d=a.legendItem,g=a.legendLine,f=a.legendSymbol,k=this.itemHiddenStyle.color,b=e?b.itemStyle.color:k,c=e?a.color||k:k,l=a.options&&a.options.marker,q={fill:c};d&&d.css({fill:b,color:b});g&&g.attr({stroke:c});f&&(l&&f.isMarker&&(q=a.pointAttribs(),e||(q.stroke=q.fill=k)),f.attr(q))},positionItem:function(a){var b=this.options,d=b.symbolPadding,b=!b.rtl,g=a._legendItemPos,f=g[0],g=g[1],k=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(b?\nf:this.legendWidth-f-2*d-4,g);k&&(k.x=f,k.y=g)},destroyItem:function(a){var b=a.checkbox;m([\"legendItem\",\"legendLine\",\"legendSymbol\",\"legendGroup\"],function(b){a[b]&&(a[b]=a[b].destroy())});b&&F(a.checkbox)},destroy:function(){function a(a){this[a]&&(this[a]=this[a].destroy())}m(this.getAllItems(),function(b){m([\"legendItem\",\"legendGroup\"],a,b)});m(\"clipRect up down pager nav box title group\".split(\" \"),a,this);this.display=null},positionCheckboxes:function(a){var b=this.group&&this.group.alignAttr,\nd,g=this.clipHeight||this.legendHeight,f=this.titleHeight;b&&(d=b.translateY,m(this.allItems,function(e){var k=e.checkbox,c;k&&(c=d+f+k.y+(a||0)+3,A(k,{left:b.translateX+e.checkboxOffset+k.x-20+\"px\",top:c+\"px\",display:c>d-6&&c<d+g-6?\"\":\"none\"}))}))},renderTitle:function(){var a=this.options,e=this.padding,d=a.title,g=0;d.text&&(this.title||(this.title=this.chart.renderer.label(d.text,e-3,e-4,null,null,null,a.useHTML,null,\"legend-title\").attr({zIndex:1}).css(d.style).add(this.group)),a=this.title.getBBox(),\ng=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:g}));this.titleHeight=g},setText:function(b){var e=this.options;b.legendItem.attr({text:e.labelFormat?a.format(e.labelFormat,b):e.labelFormatter.call(b)})},renderItem:function(a){var b=this.chart,d=b.renderer,g=this.options,f=\"horizontal\"===g.layout,k=this.symbolWidth,l=g.symbolPadding,c=this.itemStyle,m=this.itemHiddenStyle,q=this.padding,B=f?u(g.itemDistance,20):0,t=!g.rtl,p=g.width,z=g.itemMarginBottom||0,I=this.itemMarginTop,\nL=a.legendItem,h=!a.series,w=!h&&a.series.drawLegendSymbol?a.series:a,P=w.options,H=this.createCheckboxForItem&&P&&P.showCheckbox,P=k+l+B+(H?20:0),O=g.useHTML,A=a.options.className;L||(a.legendGroup=d.g(\"legend-item\").addClass(\"highcharts-\"+w.type+\"-series highcharts-color-\"+a.colorIndex+(A?\" \"+A:\"\")+(h?\" highcharts-series-\"+a.index:\"\")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=L=d.text(\"\",t?k+l:-l,this.baseline||0,O).css(r(a.visible?c:m)).attr({align:t?\"left\":\"right\",zIndex:2}).add(a.legendGroup),\nthis.baseline||(k=c.fontSize,this.fontMetrics=d.fontMetrics(k,L),this.baseline=this.fontMetrics.f+3+I,L.attr(\"y\",this.baseline)),this.symbolHeight=g.symbolHeight||this.fontMetrics.f,w.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,L,O),H&&this.createCheckboxForItem(a));this.colorizeItem(a,a.visible);c.width||L.css({width:(g.itemWidth||g.width||b.spacingBox.width)-P});this.setText(a);d=L.getBBox();c=a.checkboxOffset=g.itemWidth||a.legendItemWidth||d.width+P;this.itemHeight=d=Math.round(a.legendItemHeight||\nd.height||this.symbolHeight);f&&this.itemX-q+c>(p||b.spacingBox.width-2*q-g.x)&&(this.itemX=q,this.itemY+=I+this.lastLineHeight+z,this.lastLineHeight=0);this.maxItemWidth=Math.max(this.maxItemWidth,c);this.lastItemY=I+this.itemY+z;this.lastLineHeight=Math.max(d,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];f?this.itemX+=c:(this.itemY+=I+d+z,this.lastLineHeight=d);this.offsetWidth=p||Math.max((f?this.itemX-q-(a.checkbox?0:B):c)+q,this.offsetWidth)},getAllItems:function(){var a=[];m(this.chart.series,\nfunction(b){var e=b&&b.options;b&&u(e.showInLegend,E(e.linkedTo)?!1:void 0,!0)&&(a=a.concat(b.legendItems||(\"point\"===e.legendType?b.data:b)))});return a},adjustMargins:function(a,e){var b=this.chart,d=this.options,g=d.align.charAt(0)+d.verticalAlign.charAt(0)+d.layout.charAt(0);d.floating||m([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(f,k){f.test(g)&&!E(a[k])&&(b[l[k]]=Math.max(b[l[k]],b.legend[(k+1)%2?\"legendHeight\":\"legendWidth\"]+[1,-1,-1,1][k]*d[k%2?\"x\":\"y\"]+u(d.margin,\n12)+e[k]))})},render:function(){var a=this,e=a.chart,d=e.renderer,f=a.group,k,l,t,c,u=a.box,q=a.options,B=a.padding;a.itemX=B;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;f||(a.group=f=d.g(\"legend\").attr({zIndex:7}).add(),a.contentGroup=d.g().attr({zIndex:1}).add(f),a.scrollGroup=d.g().add(a.contentGroup));a.renderTitle();k=a.getAllItems();g(k,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});q.reversed&&k.reverse();a.allItems=k;a.display=l=\n!!k.length;a.lastLineHeight=0;m(k,function(b){a.renderItem(b)});t=(q.width||a.offsetWidth)+B;c=a.lastItemY+a.lastLineHeight+a.titleHeight;c=a.handleOverflow(c);c+=B;u||(a.box=u=d.rect().addClass(\"highcharts-legend-box\").attr({r:q.borderRadius}).add(f),u.isNew=!0);u.attr({stroke:q.borderColor,\"stroke-width\":q.borderWidth||0,fill:q.backgroundColor||\"none\"}).shadow(q.shadow);0<t&&0<c&&(u[u.isNew?\"attr\":\"animate\"](u.crisp({x:0,y:0,width:t,height:c},u.strokeWidth())),u.isNew=!1);u[l?\"show\":\"hide\"]();a.legendWidth=\nt;a.legendHeight=c;m(k,function(b){a.positionItem(b)});l&&f.align(r(q,{width:t,height:c}),!0,\"spacingBox\");e.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,d=this.chart,g=d.renderer,f=this.options,k=f.y,l=this.padding,d=d.spacingBox.height+(\"top\"===f.verticalAlign?-k:k)-l,k=f.maxHeight,c,r=this.clipRect,q=f.navigation,B=u(q.animation,!0),t=q.arrowSize||12,p=this.nav,z=this.pages,I,L=this.allItems,h=function(a){\"number\"===typeof a?r.attr({height:a}):r&&(b.clipRect=r.destroy(),\nb.contentGroup.clip());b.contentGroup.div&&(b.contentGroup.div.style.clip=a?\"rect(\"+l+\"px,9999px,\"+(l+a)+\"px,0)\":\"auto\")};\"horizontal\"!==f.layout||\"middle\"===f.verticalAlign||f.floating||(d/=2);k&&(d=Math.min(d,k));z.length=0;a>d&&!1!==q.enabled?(this.clipHeight=c=Math.max(d-20-this.titleHeight-l,0),this.currentPage=u(this.currentPage,1),this.fullHeight=a,m(L,function(a,b){var e=a._legendItemPos[1];a=Math.round(a.legendItem.getBBox().height);var d=z.length;if(!d||e-z[d-1]>c&&(I||e)!==z[d-1])z.push(I||\ne),d++;b===L.length-1&&e+a-z[d-1]>c&&z.push(e);e!==I&&(I=e)}),r||(r=b.clipRect=g.clipRect(0,l,9999,0),b.contentGroup.clip(r)),h(c),p||(this.nav=p=g.g().attr({zIndex:1}).add(this.group),this.up=g.symbol(\"triangle\",0,0,t,t).on(\"click\",function(){b.scroll(-1,B)}).add(p),this.pager=g.text(\"\",15,10).addClass(\"highcharts-legend-navigation\").css(q.style).add(p),this.down=g.symbol(\"triangle-down\",0,0,t,t).on(\"click\",function(){b.scroll(1,B)}).add(p)),b.scroll(0),a=d):p&&(h(),this.nav=p.destroy(),this.scrollGroup.attr({translateY:1}),\nthis.clipHeight=0);return a},scroll:function(a,e){var b=this.pages,d=b.length;a=this.currentPage+a;var g=this.clipHeight,f=this.options.navigation,k=this.pager,c=this.padding;a>d&&(a=d);0<a&&(void 0!==e&&t(e,this.chart),this.nav.attr({translateX:c,translateY:g+this.padding+7+this.titleHeight,visibility:\"visible\"}),this.up.attr({\"class\":1===a?\"highcharts-legend-nav-inactive\":\"highcharts-legend-nav-active\"}),k.attr({text:a+\"/\"+d}),this.down.attr({x:18+this.pager.getBBox().width,\"class\":a===d?\"highcharts-legend-nav-inactive\":\n\"highcharts-legend-nav-active\"}),this.up.attr({fill:1===a?f.inactiveColor:f.activeColor}).css({cursor:1===a?\"default\":\"pointer\"}),this.down.attr({fill:a===d?f.inactiveColor:f.activeColor}).css({cursor:a===d?\"default\":\"pointer\"}),e=-b[a-1]+this.initialItemY,this.scrollGroup.animate({translateY:e}),this.currentPage=a,this.positionCheckboxes(e))}};a.LegendSymbolMixin={drawRectangle:function(a,e){var b=a.symbolHeight,d=a.options.squareSymbol;e.legendSymbol=this.chart.renderer.rect(d?(a.symbolWidth-b)/\n2:0,a.baseline-b+1,d?b:a.symbolWidth,b,u(a.options.symbolRadius,b/2)).addClass(\"highcharts-point\").attr({zIndex:3}).add(e.legendGroup)},drawLineMarker:function(a){var b=this.options,d=b.marker,g=a.symbolWidth,f=a.symbolHeight,k=f/2,l=this.chart.renderer,c=this.legendGroup;a=a.baseline-Math.round(.3*a.fontMetrics.b);var m;m={\"stroke-width\":b.lineWidth||0};b.dashStyle&&(m.dashstyle=b.dashStyle);this.legendLine=l.path([\"M\",0,a,\"L\",g,a]).addClass(\"highcharts-graph\").attr(m).add(c);d&&!1!==d.enabled&&\n(b=Math.min(u(d.radius,k),k),0===this.symbol.indexOf(\"url\")&&(d=r(d,{width:f,height:f}),b=0),this.legendSymbol=d=l.symbol(this.symbol,g/2-b,a-b,2*b,2*b,d).addClass(\"highcharts-point\").add(c),d.isMarker=!0)}};(/Trident\\/7\\.0/.test(d.navigator.userAgent)||f)&&k(a.Legend.prototype,\"positionItem\",function(a,e){var b=this,d=function(){e._legendItemPos&&a.call(b,e)};d();setTimeout(d)})})(M);(function(a){var C=a.addEvent,A=a.animate,F=a.animObject,E=a.attr,m=a.doc,f=a.Axis,l=a.createElement,r=a.defaultOptions,\nu=a.discardElement,t=a.charts,g=a.css,d=a.defined,k=a.each,b=a.extend,e=a.find,v=a.fireEvent,y=a.getStyle,n=a.grep,D=a.isNumber,J=a.isObject,c=a.isString,G=a.Legend,q=a.marginNames,B=a.merge,K=a.objectEach,p=a.Pointer,z=a.pick,I=a.pInt,L=a.removeEvent,h=a.seriesTypes,w=a.splat,P=a.svg,H=a.syncTimeout,O=a.win,Q=a.Renderer,R=a.Chart=function(){this.getArgs.apply(this,arguments)};a.chart=function(a,b,c){return new R(a,b,c)};b(R.prototype,{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);\nif(c(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(b,c){var e,d,h=b.series,p=b.plotOptions||{};b.series=null;e=B(r,b);for(d in e.plotOptions)e.plotOptions[d].tooltip=p[d]&&B(p[d].tooltip)||void 0;e.tooltip.userOptions=b.chart&&b.chart.forExport&&b.tooltip.userOptions||b.tooltip;e.series=b.series=h;this.userOptions=b;b=e.chart;d=b.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.callback=c;this.isResizing=0;this.options=e;this.axes=[];this.series=\n[];this.hasCartesianSeries=b.showAxes;var g=this;g.index=t.length;t.push(g);a.chartCount++;d&&K(d,function(a,b){C(g,b,a)});g.xAxis=[];g.yAxis=[];g.pointCount=g.colorCounter=g.symbolCounter=0;g.firstRender()},initSeries:function(b){var c=this.options.chart;(c=h[b.type||c.type||c.defaultSeriesType])||a.error(17,!0);c=new c;c.init(this,b);return c},orderSeries:function(a){var b=this.series;for(a=a||0;a<b.length;a++)b[a]&&(b[a].index=a,b[a].name=b[a].name||\"Series \"+(b[a].index+1))},isInsidePlot:function(a,\nb,c){var e=c?b:a;a=c?a:b;return 0<=e&&e<=this.plotWidth&&0<=a&&a<=this.plotHeight},redraw:function(c){var e=this.axes,d=this.series,h=this.pointer,p=this.legend,g=this.isDirtyLegend,f,q,l=this.hasCartesianSeries,n=this.isDirtyBox,z,m=this.renderer,x=m.isHidden(),w=[];this.setResponsive&&this.setResponsive(!1);a.setAnimation(c,this);x&&this.temporaryDisplay();this.layOutTitles();for(c=d.length;c--;)if(z=d[c],z.options.stacking&&(f=!0,z.isDirty)){q=!0;break}if(q)for(c=d.length;c--;)z=d[c],z.options.stacking&&\n(z.isDirty=!0);k(d,function(a){a.isDirty&&\"point\"===a.options.legendType&&(a.updateTotals&&a.updateTotals(),g=!0);a.isDirtyData&&v(a,\"updatedData\")});g&&p.options.enabled&&(p.render(),this.isDirtyLegend=!1);f&&this.getStacks();l&&k(e,function(a){a.updateNames();a.setScale()});this.getMargins();l&&(k(e,function(a){a.isDirty&&(n=!0)}),k(e,function(a){var c=a.min+\",\"+a.max;a.extKey!==c&&(a.extKey=c,w.push(function(){v(a,\"afterSetExtremes\",b(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(n||f)&&\na.redraw()}));n&&this.drawChartBox();v(this,\"predraw\");k(d,function(a){(n||a.isDirty)&&a.visible&&a.redraw();a.isDirtyData=!1});h&&h.reset(!0);m.draw();v(this,\"redraw\");v(this,\"render\");x&&this.temporaryDisplay(!0);k(w,function(a){a.call()})},get:function(a){function b(b){return b.id===a||b.options&&b.options.id===a}var c,d=this.series,h;c=e(this.axes,b)||e(this.series,b);for(h=0;!c&&h<d.length;h++)c=e(d[h].points||[],b);return c},getAxes:function(){var a=this,b=this.options,c=b.xAxis=w(b.xAxis||\n{}),b=b.yAxis=w(b.yAxis||{});k(c,function(a,b){a.index=b;a.isX=!0});k(b,function(a,b){a.index=b});c=c.concat(b);k(c,function(b){new f(a,b)})},getSelectedPoints:function(){var a=[];k(this.series,function(b){a=a.concat(n(b.data||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return n(this.series,function(a){return a.selected})},setTitle:function(a,b,c){var e=this,d=e.options,h;h=d.title=B({style:{color:\"#333333\",fontSize:d.isStock?\"16px\":\"18px\"}},d.title,a);d=d.subtitle=\nB({style:{color:\"#666666\"}},d.subtitle,b);k([[\"title\",a,h],[\"subtitle\",b,d]],function(a,b){var c=a[0],d=e[c],h=a[1];a=a[2];d&&h&&(e[c]=d=d.destroy());a&&a.text&&!d&&(e[c]=e.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,\"class\":\"highcharts-\"+c,zIndex:a.zIndex||4}).add(),e[c].update=function(a){e.setTitle(!b&&a,b&&a)},e[c].css(a.style))});e.layOutTitles(c)},layOutTitles:function(a){var c=0,e,d=this.renderer,h=this.spacingBox;k([\"title\",\"subtitle\"],function(a){var e=this[a],p=this.options[a];\na=\"title\"===a?-3:p.verticalAlign?0:c+2;var g;e&&(g=p.style.fontSize,g=d.fontMetrics(g,e).b,e.css({width:(p.width||h.width+p.widthAdjust)+\"px\"}).align(b({y:a+g},p),!1,\"spacingBox\"),p.floating||p.verticalAlign||(c=Math.ceil(c+e.getBBox(p.useHTML).height)))},this);e=this.titleOffset!==c;this.titleOffset=c;!this.isDirtyBox&&e&&(this.isDirtyBox=e,this.hasRendered&&z(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var b=this.options.chart,c=b.width,b=b.height,e=this.renderTo;d(c)||(this.containerWidth=\ny(e,\"width\"));d(b)||(this.containerHeight=y(e,\"height\"));this.chartWidth=Math.max(0,c||this.containerWidth||600);this.chartHeight=Math.max(0,a.relativeLength(b,this.chartWidth)||this.containerHeight||400)},temporaryDisplay:function(b){var c=this.renderTo;if(b)for(;c&&c.style;)c.hcOrigStyle&&(a.css(c,c.hcOrigStyle),delete c.hcOrigStyle),c.hcOrigDetached&&(m.body.removeChild(c),c.hcOrigDetached=!1),c=c.parentNode;else for(;c&&c.style;){m.body.contains(c)||(c.hcOrigDetached=!0,m.body.appendChild(c));\nif(\"none\"===y(c,\"display\",!1)||c.hcOricDetached)c.hcOrigStyle={display:c.style.display,height:c.style.height,overflow:c.style.overflow},b={display:\"block\",overflow:\"hidden\"},c!==this.renderTo&&(b.height=0),a.css(c,b),c.offsetWidth||c.style.setProperty(\"display\",\"block\",\"important\");c=c.parentNode;if(c===m.body)break}},setClassName:function(a){this.container.className=\"highcharts-container \"+(a||\"\")},getContainer:function(){var e,d=this.options,h=d.chart,p,g;e=this.renderTo;var f=a.uniqueKey(),k;e||\n(this.renderTo=e=h.renderTo);c(e)&&(this.renderTo=e=m.getElementById(e));e||a.error(13,!0);p=I(E(e,\"data-highcharts-chart\"));D(p)&&t[p]&&t[p].hasRendered&&t[p].destroy();E(e,\"data-highcharts-chart\",this.index);e.innerHTML=\"\";h.skipClone||e.offsetWidth||this.temporaryDisplay();this.getChartSize();p=this.chartWidth;g=this.chartHeight;k=b({position:\"relative\",overflow:\"hidden\",width:p+\"px\",height:g+\"px\",textAlign:\"left\",lineHeight:\"normal\",zIndex:0,\"-webkit-tap-highlight-color\":\"rgba(0,0,0,0)\"},h.style);\nthis.container=e=l(\"div\",{id:f},k,e);this._cursor=e.style.cursor;this.renderer=new (a[h.renderer]||Q)(e,p,g,null,h.forExport,d.exporting&&d.exporting.allowHTML);this.setClassName(h.className);this.renderer.setStyle(h.style);this.renderer.chartIndex=this.index},getMargins:function(a){var b=this.spacing,c=this.margin,e=this.titleOffset;this.resetMargins();e&&!d(c[0])&&(this.plotTop=Math.max(this.plotTop,e+this.options.title.margin+b[0]));this.legend.display&&this.legend.adjustMargins(c,b);this.extraMargin&&\n(this[this.extraMargin.type]=(this[this.extraMargin.type]||0)+this.extraMargin.value);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],c=a.margin;a.hasCartesianSeries&&k(a.axes,function(a){a.visible&&a.getOffset()});k(q,function(e,h){d(c[h])||(a[e]+=b[h])});a.setChartSize()},reflow:function(a){var b=this,c=b.options.chart,e=b.renderTo,h=d(c.width)&&d(c.height),p=c.width||y(e,\"width\"),c=c.height||y(e,\"height\"),\ne=a?a.target:O;if(!h&&!b.isPrinting&&p&&c&&(e===O||e===m)){if(p!==b.containerWidth||c!==b.containerHeight)clearTimeout(b.reflowTimeout),b.reflowTimeout=H(function(){b.container&&b.setSize(void 0,void 0,!1)},a?100:0);b.containerWidth=p;b.containerHeight=c}},initReflow:function(){var a=this,b;b=C(O,\"resize\",function(b){a.reflow(b)});C(a,\"destroy\",b)},setSize:function(b,c,e){var d=this,h=d.renderer;d.isResizing+=1;a.setAnimation(e,d);d.oldChartHeight=d.chartHeight;d.oldChartWidth=d.chartWidth;void 0!==\nb&&(d.options.chart.width=b);void 0!==c&&(d.options.chart.height=c);d.getChartSize();b=h.globalAnimation;(b?A:g)(d.container,{width:d.chartWidth+\"px\",height:d.chartHeight+\"px\"},b);d.setChartSize(!0);h.setSize(d.chartWidth,d.chartHeight,e);k(d.axes,function(a){a.isDirty=!0;a.setScale()});d.isDirtyLegend=!0;d.isDirtyBox=!0;d.layOutTitles();d.getMargins();d.redraw(e);d.oldChartHeight=null;v(d,\"resize\");H(function(){d&&v(d,\"endResize\",null,function(){--d.isResizing})},F(b).duration)},setChartSize:function(a){function b(a){a=\nf[a]||0;return Math.max(m||a,a)/2}var c=this.inverted,e=this.renderer,d=this.chartWidth,h=this.chartHeight,p=this.options.chart,g=this.spacing,f=this.clipOffset,q,n,l,z,m;this.plotLeft=q=Math.round(this.plotLeft);this.plotTop=n=Math.round(this.plotTop);this.plotWidth=l=Math.max(0,Math.round(d-q-this.marginRight));this.plotHeight=z=Math.max(0,Math.round(h-n-this.marginBottom));this.plotSizeX=c?z:l;this.plotSizeY=c?l:z;this.plotBorderWidth=p.plotBorderWidth||0;this.spacingBox=e.spacingBox={x:g[3],y:g[0],\nwidth:d-g[3]-g[1],height:h-g[0]-g[2]};this.plotBox=e.plotBox={x:q,y:n,width:l,height:z};m=2*Math.floor(this.plotBorderWidth/2);c=Math.ceil(b(3));e=Math.ceil(b(0));this.clipBox={x:c,y:e,width:Math.floor(this.plotSizeX-b(1)-c),height:Math.max(0,Math.floor(this.plotSizeY-b(2)-e))};a||k(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this,b=a.options.chart;k([\"margin\",\"spacing\"],function(c){var e=b[c],d=J(e)?e:[e,e,e,e];k([\"Top\",\"Right\",\"Bottom\",\"Left\"],function(e,\nh){a[c][h]=z(b[c+e],d[h])})});k(q,function(b,c){a[b]=z(a.margin[c],a.spacing[c])});a.axisOffset=[0,0,0,0];a.clipOffset=[]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,c=this.chartWidth,e=this.chartHeight,d=this.chartBackground,h=this.plotBackground,p=this.plotBorder,g,f=this.plotBGImage,k=a.backgroundColor,q=a.plotBackgroundColor,l=a.plotBackgroundImage,n,z=this.plotLeft,m=this.plotTop,w=this.plotWidth,I=this.plotHeight,v=this.plotBox,r=this.clipRect,B=this.clipBox,y=\"animate\";\nd||(this.chartBackground=d=b.rect().addClass(\"highcharts-background\").add(),y=\"attr\");g=a.borderWidth||0;n=g+(a.shadow?8:0);k={fill:k||\"none\"};if(g||d[\"stroke-width\"])k.stroke=a.borderColor,k[\"stroke-width\"]=g;d.attr(k).shadow(a.shadow);d[y]({x:n/2,y:n/2,width:c-n-g%2,height:e-n-g%2,r:a.borderRadius});y=\"animate\";h||(y=\"attr\",this.plotBackground=h=b.rect().addClass(\"highcharts-plot-background\").add());h[y](v);h.attr({fill:q||\"none\"}).shadow(a.plotShadow);l&&(f?f.animate(v):this.plotBGImage=b.image(l,\nz,m,w,I).add());r?r.animate({width:B.width,height:B.height}):this.clipRect=b.clipRect(B);y=\"animate\";p||(y=\"attr\",this.plotBorder=p=b.rect().addClass(\"highcharts-plot-border\").attr({zIndex:1}).add());p.attr({stroke:a.plotBorderColor,\"stroke-width\":a.plotBorderWidth||0,fill:\"none\"});p[y](p.crisp({x:z,y:m,width:w,height:I},-p.strokeWidth()));this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,c,e=a.options.series,d,p;k([\"inverted\",\"angular\",\"polar\"],function(g){c=h[b.type||b.defaultSeriesType];\np=b[g]||c&&c.prototype[g];for(d=e&&e.length;!p&&d--;)(c=h[e[d].type])&&c.prototype[g]&&(p=!0);a[g]=p})},linkSeries:function(){var a=this,b=a.series;k(b,function(a){a.linkedSeries.length=0});k(b,function(b){var e=b.options.linkedTo;c(e)&&(e=\":previous\"===e?a.series[b.index-1]:a.get(e))&&e.linkedParent!==b&&(e.linkedSeries.push(b),b.linkedParent=e,b.visible=z(b.options.visible,e.options.visible,b.visible))})},renderSeries:function(){k(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=\nthis,c=a.options.labels;c.items&&k(c.items,function(e){var d=b(c.style,e.style),h=I(d.left)+a.plotLeft,p=I(d.top)+a.plotTop+12;delete d.left;delete d.top;a.renderer.text(e.html,h,p).attr({zIndex:2}).css(d).add()})},render:function(){var a=this.axes,b=this.renderer,c=this.options,e,d,h;this.setTitle();this.legend=new G(this,c.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();c=this.plotWidth;e=this.plotHeight-=21;k(a,function(a){a.setScale()});this.getAxisMargins();d=\n1.1<c/this.plotWidth;h=1.05<e/this.plotHeight;if(d||h)k(a,function(a){(a.horiz&&d||!a.horiz&&h)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&k(a,function(a){a.visible&&a.render()});this.seriesGroup||(this.seriesGroup=b.g(\"series-group\").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0},addCredits:function(a){var b=this;a=B(!0,this.options.credits,a);a.enabled&&!this.credits&&\n(this.credits=this.renderer.text(a.text+(this.mapCredits||\"\"),0,0).addClass(\"highcharts-credits\").on(\"click\",function(){a.href&&(O.location.href=a.href)}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position),this.credits.update=function(a){b.credits=b.credits.destroy();b.addCredits(a)})},destroy:function(){var b=this,c=b.axes,e=b.series,d=b.container,h,p=d&&d.parentNode;v(b,\"destroy\");b.renderer.forExport?a.erase(t,b):t[b.index]=void 0;a.chartCount--;b.renderTo.removeAttribute(\"data-highcharts-chart\");\nL(b);for(h=c.length;h--;)c[h]=c[h].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(h=e.length;h--;)e[h]=e[h].destroy();k(\"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \"),function(a){var c=b[a];c&&c.destroy&&(b[a]=c.destroy())});d&&(d.innerHTML=\"\",L(d),p&&u(d));K(b,function(a,c){delete b[c]})},isReadyToRender:function(){var a=this;return P||O!=O.top||\n\"complete\"===m.readyState?!0:(m.attachEvent(\"onreadystatechange\",function(){m.detachEvent(\"onreadystatechange\",a.firstRender);\"complete\"===m.readyState&&a.firstRender()}),!1)},firstRender:function(){var a=this,b=a.options;if(a.isReadyToRender()){a.getContainer();v(a,\"init\");a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();k(b.series||[],function(b){a.initSeries(b)});a.linkSeries();v(a,\"beforeRender\");p&&(a.pointer=new p(a,b));a.render();if(!a.renderer.imgCount&&a.onload)a.onload();\na.temporaryDisplay(!0)}},onload:function(){k([this.callback].concat(this.callbacks),function(a){a&&void 0!==this.index&&a.apply(this,[this])},this);v(this,\"load\");v(this,\"render\");d(this.index)&&!1!==this.options.chart.reflow&&this.initReflow();this.onload=null}})})(M);(function(a){var C,A=a.each,F=a.extend,E=a.erase,m=a.fireEvent,f=a.format,l=a.isArray,r=a.isNumber,u=a.pick,t=a.removeEvent;a.Point=C=function(){};a.Point.prototype={init:function(a,d,f){this.series=a;this.color=a.color;this.applyOptions(d,\nf);a.options.colorByPoint?(d=a.options.colors||a.chart.options.colors,this.color=this.color||d[a.colorCounter],d=d.length,f=a.colorCounter,a.colorCounter++,a.colorCounter===d&&(a.colorCounter=0)):f=a.colorIndex;this.colorIndex=u(this.colorIndex,f);a.chart.pointCount++;return this},applyOptions:function(a,d){var g=this.series,b=g.options.pointValKey||g.pointValKey;a=C.prototype.optionsToObject.call(this,a);F(this,a);this.options=this.options?F(this.options,a):a;a.group&&delete this.group;b&&(this.y=\nthis[b]);this.isNull=u(this.isValid&&!this.isValid(),null===this.x||!r(this.y,!0));this.selected&&(this.state=\"select\");\"name\"in this&&void 0===d&&g.xAxis&&g.xAxis.hasNames&&(this.x=g.xAxis.nameToX(this));void 0===this.x&&g&&(this.x=void 0===d?g.autoIncrement(this):d);return this},optionsToObject:function(a){var d={},g=this.series,b=g.options.keys,e=b||g.pointArrayMap||[\"y\"],f=e.length,m=0,n=0;if(r(a)||null===a)d[e[0]]=a;else if(l(a))for(!b&&a.length>f&&(g=typeof a[0],\"string\"===g?d.name=a[0]:\"number\"===\ng&&(d.x=a[0]),m++);n<f;)b&&void 0===a[m]||(d[e[n]]=a[m]),m++,n++;else\"object\"===typeof a&&(d=a,a.dataLabels&&(g._hasPointLabels=!0),a.marker&&(g._hasPointMarkers=!0));return d},getClassName:function(){return\"highcharts-point\"+(this.selected?\" highcharts-point-select\":\"\")+(this.negative?\" highcharts-negative\":\"\")+(this.isNull?\" highcharts-null-point\":\"\")+(void 0!==this.colorIndex?\" highcharts-color-\"+this.colorIndex:\"\")+(this.options.className?\" \"+this.options.className:\"\")+(this.zone&&this.zone.className?\n\" \"+this.zone.className.replace(\"highcharts-negative\",\"\"):\"\")},getZone:function(){var a=this.series,d=a.zones,a=a.zoneAxis||\"y\",f=0,b;for(b=d[f];this[a]>=b.value;)b=d[++f];b&&b.color&&!this.options.color&&(this.color=b.color);return b},destroy:function(){var a=this.series.chart,d=a.hoverPoints,f;a.pointCount--;d&&(this.setState(),E(d,this),d.length||(a.hoverPoints=null));if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)t(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);\nfor(f in this)this[f]=null},destroyElements:function(){for(var a=[\"graphic\",\"dataLabel\",\"dataLabelUpper\",\"connector\",\"shadowGroup\"],d,f=6;f--;)d=a[f],this[d]&&(this[d]=this[d].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var d=this.series,g=d.tooltipOptions,b=u(g.valueDecimals,\"\"),\ne=g.valuePrefix||\"\",l=g.valueSuffix||\"\";A(d.pointArrayMap||[\"y\"],function(d){d=\"{point.\"+d;if(e||l)a=a.replace(d+\"}\",e+d+\"}\"+l);a=a.replace(d+\"}\",d+\":,.\"+b+\"f}\")});return f(a,{point:this,series:this.series})},firePointEvent:function(a,d,f){var b=this,e=this.series.options;(e.point.events[a]||b.options&&b.options.events&&b.options.events[a])&&this.importEvents();\"click\"===a&&e.allowPointSelect&&(f=function(a){b.select&&b.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});m(this,a,d,f)},visible:!0}})(M);\n(function(a){var C=a.addEvent,A=a.animObject,F=a.arrayMax,E=a.arrayMin,m=a.correctFloat,f=a.Date,l=a.defaultOptions,r=a.defaultPlotOptions,u=a.defined,t=a.each,g=a.erase,d=a.extend,k=a.fireEvent,b=a.grep,e=a.isArray,v=a.isNumber,y=a.isString,n=a.merge,D=a.objectEach,J=a.pick,c=a.removeEvent,G=a.splat,q=a.SVGElement,B=a.syncTimeout,K=a.win;a.Series=a.seriesType(\"line\",null,{lineWidth:2,allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{lineWidth:0,lineColor:\"#ffffff\",radius:4,\nstates:{hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:\"#cccccc\",lineColor:\"#000000\",lineWidth:2}}},point:{events:{}},dataLabels:{align:\"center\",formatter:function(){return null===this.y?\"\":a.numberFormat(this.y,-1)},style:{fontSize:\"11px\",fontWeight:\"bold\",color:\"contrast\",textOutline:\"1px contrast\"},verticalAlign:\"bottom\",x:0,y:0,padding:5},cropThreshold:300,pointRange:0,softThreshold:!0,states:{hover:{animation:{duration:50},lineWidthPlus:1,marker:{},\nhalo:{size:10,opacity:.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:\"x\"},{isCartesian:!0,pointClass:a.Point,sorted:!0,requireSorting:!0,directTouch:!1,axisTypes:[\"xAxis\",\"yAxis\"],colorCounter:0,parallelArrays:[\"x\",\"y\"],coll:\"series\",init:function(a,b){var c=this,e,h=a.series,p;c.chart=a;c.options=b=c.setOptions(b);c.linkedSeries=[];c.bindAxes();d(c,{name:b.name,state:\"\",visible:!1!==b.visible,selected:!0===b.selected});e=b.events;D(e,function(a,b){C(c,b,a)});if(e&&\ne.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;c.getColor();c.getSymbol();t(c.parallelArrays,function(a){c[a+\"Data\"]=[]});c.setData(b.data,!1);c.isCartesian&&(a.hasCartesianSeries=!0);h.length&&(p=h[h.length-1]);c._i=J(p&&p._i,-1)+1;a.orderSeries(this.insert(h))},insert:function(a){var b=this.options.index,c;if(v(b)){for(c=a.length;c--;)if(b>=J(a[c].options.index,a[c]._i)){a.splice(c+1,0,this);break}-1===c&&a.unshift(this);c+=1}else a.push(this);return J(c,\na.length-1)},bindAxes:function(){var b=this,c=b.options,e=b.chart,d;t(b.axisTypes||[],function(h){t(e[h],function(a){d=a.options;if(c[h]===d.index||void 0!==c[h]&&c[h]===d.id||void 0===c[h]&&0===d.index)b.insert(a.series),b[h]=a,a.isDirty=!0});b[h]||b.optionalAxis===h||a.error(18,!0)})},updateParallelArrays:function(a,b){var c=a.series,e=arguments,d=v(b)?function(e){var d=\"y\"===e&&c.toYData?c.toYData(a):a[e];c[e+\"Data\"][b]=d}:function(a){Array.prototype[b].apply(c[a+\"Data\"],Array.prototype.slice.call(e,\n2))};t(c.parallelArrays,d)},autoIncrement:function(){var a=this.options,b=this.xIncrement,c,e=a.pointIntervalUnit,b=J(b,a.pointStart,0);this.pointInterval=c=J(this.pointInterval,a.pointInterval,1);e&&(a=new f(b),\"day\"===e?a=+a[f.hcSetDate](a[f.hcGetDate]()+c):\"month\"===e?a=+a[f.hcSetMonth](a[f.hcGetMonth]()+c):\"year\"===e&&(a=+a[f.hcSetFullYear](a[f.hcGetFullYear]()+c)),c=a-b);this.xIncrement=b+c;return b},setOptions:function(a){var b=this.chart,c=b.options,e=c.plotOptions,d=(b.userOptions||{}).plotOptions||\n{},p=e[this.type];this.userOptions=a;b=n(p,e.series,a);this.tooltipOptions=n(l.tooltip,l.plotOptions.series&&l.plotOptions.series.tooltip,l.plotOptions[this.type].tooltip,c.tooltip.userOptions,e.series&&e.series.tooltip,e[this.type].tooltip,a.tooltip);this.stickyTracking=J(a.stickyTracking,d[this.type]&&d[this.type].stickyTracking,d.series&&d.series.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?!0:b.stickyTracking);null===p.marker&&delete b.marker;this.zoneAxis=b.zoneAxis;a=this.zones=\n(b.zones||[]).slice();!b.negativeColor&&!b.negativeFillColor||b.zones||a.push({value:b[this.zoneAxis+\"Threshold\"]||b.threshold||0,className:\"highcharts-negative\",color:b.negativeColor,fillColor:b.negativeFillColor});a.length&&u(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return b},getCyclic:function(a,b,c){var e,d=this.chart,p=this.userOptions,f=a+\"Index\",g=a+\"Counter\",k=c?c.length:J(d.options.chart[a+\"Count\"],d[a+\"Count\"]);b||(e=J(p[f],p[\"_\"+f]),u(e)||(d.series.length||\n(d[g]=0),p[\"_\"+f]=e=d[g]%k,d[g]+=1),c&&(b=c[e]));void 0!==e&&(this[f]=e);this[a]=b},getColor:function(){this.options.colorByPoint?this.options.color=null:this.getCyclic(\"color\",this.options.color||r[this.type].color,this.chart.options.colors)},getSymbol:function(){this.getCyclic(\"symbol\",this.options.marker.symbol,this.chart.options.symbols)},drawLegendSymbol:a.LegendSymbolMixin.drawLineMarker,setData:function(b,c,d,f){var h=this,p=h.points,g=p&&p.length||0,k,q=h.options,l=h.chart,n=null,m=h.xAxis,\nz=q.turboThreshold,r=this.xData,B=this.yData,I=(k=h.pointArrayMap)&&k.length;b=b||[];k=b.length;c=J(c,!0);if(!1!==f&&k&&g===k&&!h.cropped&&!h.hasGroupedData&&h.visible)t(b,function(a,b){p[b].update&&a!==q.data[b]&&p[b].update(a,!1,null,!1)});else{h.xIncrement=null;h.colorCounter=0;t(this.parallelArrays,function(a){h[a+\"Data\"].length=0});if(z&&k>z){for(d=0;null===n&&d<k;)n=b[d],d++;if(v(n))for(d=0;d<k;d++)r[d]=this.autoIncrement(),B[d]=b[d];else if(e(n))if(I)for(d=0;d<k;d++)n=b[d],r[d]=n[0],B[d]=n.slice(1,\nI+1);else for(d=0;d<k;d++)n=b[d],r[d]=n[0],B[d]=n[1];else a.error(12)}else for(d=0;d<k;d++)void 0!==b[d]&&(n={series:h},h.pointClass.prototype.applyOptions.apply(n,[b[d]]),h.updateParallelArrays(n,d));y(B[0])&&a.error(14,!0);h.data=[];h.options.data=h.userOptions.data=b;for(d=g;d--;)p[d]&&p[d].destroy&&p[d].destroy();m&&(m.minRange=m.userMinRange);h.isDirty=l.isDirtyBox=!0;h.isDirtyData=!!p;d=!1}\"point\"===q.legendType&&(this.processData(),this.generatePoints());c&&l.redraw(d)},processData:function(b){var c=\nthis.xData,e=this.yData,d=c.length,h;h=0;var p,f,g=this.xAxis,k,q=this.options;k=q.cropThreshold;var n=this.getExtremesFromAll||q.getExtremesFromAll,l=this.isCartesian,q=g&&g.val2lin,m=g&&g.isLog,v,r;if(l&&!this.isDirty&&!g.isDirty&&!this.yAxis.isDirty&&!b)return!1;g&&(b=g.getExtremes(),v=b.min,r=b.max);if(l&&this.sorted&&!n&&(!k||d>k||this.forceCrop))if(c[d-1]<v||c[0]>r)c=[],e=[];else if(c[0]<v||c[d-1]>r)h=this.cropData(this.xData,this.yData,v,r),c=h.xData,e=h.yData,h=h.start,p=!0;for(k=c.length||\n1;--k;)d=m?q(c[k])-q(c[k-1]):c[k]-c[k-1],0<d&&(void 0===f||d<f)?f=d:0>d&&this.requireSorting&&a.error(15);this.cropped=p;this.cropStart=h;this.processedXData=c;this.processedYData=e;this.closestPointRange=f},cropData:function(a,b,c,e){var d=a.length,p=0,g=d,f=J(this.cropShoulder,1),k;for(k=0;k<d;k++)if(a[k]>=c){p=Math.max(0,k-f);break}for(c=k;c<d;c++)if(a[c]>e){g=c+f;break}return{xData:a.slice(p,g),yData:b.slice(p,g),start:p,end:g}},generatePoints:function(){var a=this.options,b=a.data,c=this.data,\ne,d=this.processedXData,g=this.processedYData,f=this.pointClass,k=d.length,q=this.cropStart||0,n,l=this.hasGroupedData,a=a.keys,m,v=[],r;c||l||(c=[],c.length=b.length,c=this.data=c);a&&l&&(this.options.keys=!1);for(r=0;r<k;r++)n=q+r,l?(m=(new f).init(this,[d[r]].concat(G(g[r]))),m.dataGroup=this.groupMap[r]):(m=c[n])||void 0===b[n]||(c[n]=m=(new f).init(this,b[n],d[r])),m&&(m.index=n,v[r]=m);this.options.keys=a;if(c&&(k!==(e=c.length)||l))for(r=0;r<e;r++)r!==q||l||(r+=k),c[r]&&(c[r].destroyElements(),\nc[r].plotX=void 0);this.data=c;this.points=v},getExtremes:function(a){var b=this.yAxis,c=this.processedXData,d,h=[],p=0;d=this.xAxis.getExtremes();var g=d.min,f=d.max,k,q,n,l;a=a||this.stackedYData||this.processedYData||[];d=a.length;for(l=0;l<d;l++)if(q=c[l],n=a[l],k=(v(n,!0)||e(n))&&(!b.positiveValuesOnly||n.length||0<n),q=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(c[l]||q)>=g&&(c[l]||q)<=f,k&&q)if(k=n.length)for(;k--;)null!==n[k]&&(h[p++]=n[k]);else h[p++]=n;this.dataMin=\nE(h);this.dataMax=F(h)},translate:function(){this.processedXData||this.processData();this.generatePoints();var a=this.options,b=a.stacking,c=this.xAxis,e=c.categories,d=this.yAxis,g=this.points,f=g.length,k=!!this.modifyValue,q=a.pointPlacement,n=\"between\"===q||v(q),l=a.threshold,r=a.startFromThreshold?l:0,B,y,t,G,D=Number.MAX_VALUE;\"between\"===q&&(q=.5);v(q)&&(q*=J(a.pointRange||c.pointRange));for(a=0;a<f;a++){var K=g[a],A=K.x,C=K.y;y=K.low;var E=b&&d.stacks[(this.negStacks&&C<(r?0:l)?\"-\":\"\")+this.stackKey],\nF;d.positiveValuesOnly&&null!==C&&0>=C&&(K.isNull=!0);K.plotX=B=m(Math.min(Math.max(-1E5,c.translate(A,0,0,0,1,q,\"flags\"===this.type)),1E5));b&&this.visible&&!K.isNull&&E&&E[A]&&(G=this.getStackIndicator(G,A,this.index),F=E[A],C=F.points[G.key],y=C[0],C=C[1],y===r&&G.key===E[A].base&&(y=J(l,d.min)),d.positiveValuesOnly&&0>=y&&(y=null),K.total=K.stackTotal=F.total,K.percentage=F.total&&K.y/F.total*100,K.stackY=C,F.setOffset(this.pointXOffset||0,this.barW||0));K.yBottom=u(y)?d.translate(y,0,1,0,1):\nnull;k&&(C=this.modifyValue(C,K));K.plotY=y=\"number\"===typeof C&&Infinity!==C?Math.min(Math.max(-1E5,d.translate(C,0,1,0,1)),1E5):void 0;K.isInside=void 0!==y&&0<=y&&y<=d.len&&0<=B&&B<=c.len;K.clientX=n?m(c.translate(A,0,0,0,1,q)):B;K.negative=K.y<(l||0);K.category=e&&void 0!==e[K.x]?e[K.x]:K.x;K.isNull||(void 0!==t&&(D=Math.min(D,Math.abs(B-t))),t=B);K.zone=this.zones.length&&K.getZone()}this.closestPointRangePx=D},getValidPoints:function(a,c){var e=this.chart;return b(a||this.points||[],function(a){return c&&\n!e.isInsidePlot(a.plotX,a.plotY,e.inverted)?!1:!a.isNull})},setClip:function(a){var b=this.chart,c=this.options,e=b.renderer,d=b.inverted,p=this.clipBox,g=p||b.clipBox,f=this.sharedClipKey||[\"_sharedClip\",a&&a.duration,a&&a.easing,g.height,c.xAxis,c.yAxis].join(),k=b[f],q=b[f+\"m\"];k||(a&&(g.width=0,b[f+\"m\"]=q=e.clipRect(-99,d?-b.plotLeft:-b.plotTop,99,d?b.chartWidth:b.chartHeight)),b[f]=k=e.clipRect(g),k.count={length:0});a&&!k.count[this.index]&&(k.count[this.index]=!0,k.count.length+=1);!1!==c.clip&&\n(this.group.clip(a||p?k:b.clipRect),this.markerGroup.clip(q),this.sharedClipKey=f);a||(k.count[this.index]&&(delete k.count[this.index],--k.count.length),0===k.count.length&&f&&b[f]&&(p||(b[f]=b[f].destroy()),b[f+\"m\"]&&(b[f+\"m\"]=b[f+\"m\"].destroy())))},animate:function(a){var b=this.chart,c=A(this.options.animation),e;a?this.setClip(c):(e=this.sharedClipKey,(a=b[e])&&a.animate({width:b.plotSizeX},c),b[e+\"m\"]&&b[e+\"m\"].animate({width:b.plotSizeX+99},c),this.animate=null)},afterAnimate:function(){this.setClip();\nk(this,\"afterAnimate\");this.finishedAnimating=!0},drawPoints:function(){var a=this.points,b=this.chart,c,e,d,f,g=this.options.marker,k,q,n,l,m=this[this.specialGroup]||this.markerGroup,r=J(g.enabled,this.xAxis.isRadial?!0:null,this.closestPointRangePx>=2*g.radius);if(!1!==g.enabled||this._hasPointMarkers)for(e=0;e<a.length;e++)d=a[e],c=d.plotY,f=d.graphic,k=d.marker||{},q=!!d.marker,n=r&&void 0===k.enabled||k.enabled,l=d.isInside,n&&v(c)&&null!==d.y?(c=J(k.symbol,this.symbol),d.hasImage=0===c.indexOf(\"url\"),\nn=this.markerAttribs(d,d.selected&&\"select\"),f?f[l?\"show\":\"hide\"](!0).animate(n):l&&(0<n.width||d.hasImage)&&(d.graphic=f=b.renderer.symbol(c,n.x,n.y,n.width,n.height,q?k:g).add(m)),f&&f.attr(this.pointAttribs(d,d.selected&&\"select\")),f&&f.addClass(d.getClassName(),!0)):f&&(d.graphic=f.destroy())},markerAttribs:function(a,b){var c=this.options.marker,e=a.marker||{},d=J(e.radius,c.radius);b&&(c=c.states[b],b=e.states&&e.states[b],d=J(b&&b.radius,c&&c.radius,d+(c&&c.radiusPlus||0)));a.hasImage&&(d=\n0);a={x:Math.floor(a.plotX)-d,y:a.plotY-d};d&&(a.width=a.height=2*d);return a},pointAttribs:function(a,b){var c=this.options.marker,e=a&&a.options,d=e&&e.marker||{},f=this.color,g=e&&e.color,p=a&&a.color,e=J(d.lineWidth,c.lineWidth);a=a&&a.zone&&a.zone.color;f=g||a||p||f;a=d.fillColor||c.fillColor||f;f=d.lineColor||c.lineColor||f;b&&(c=c.states[b],b=d.states&&d.states[b]||{},e=J(b.lineWidth,c.lineWidth,e+J(b.lineWidthPlus,c.lineWidthPlus,0)),a=b.fillColor||c.fillColor||a,f=b.lineColor||c.lineColor||\nf);return{stroke:f,\"stroke-width\":e,fill:a}},destroy:function(){var a=this,b=a.chart,e=/AppleWebKit\\/533/.test(K.navigator.userAgent),d,h,f=a.data||[],n,l;k(a,\"destroy\");c(a);t(a.axisTypes||[],function(b){(l=a[b])&&l.series&&(g(l.series,a),l.isDirty=l.forceRedraw=!0)});a.legendItem&&a.chart.legend.destroyItem(a);for(h=f.length;h--;)(n=f[h])&&n.destroy&&n.destroy();a.points=null;clearTimeout(a.animationTimeout);D(a,function(a,b){a instanceof q&&!a.survive&&(d=e&&\"group\"===b?\"hide\":\"destroy\",a[d]())});\nb.hoverSeries===a&&(b.hoverSeries=null);g(b.series,a);b.orderSeries();D(a,function(b,c){delete a[c]})},getGraphPath:function(a,b,c){var e=this,d=e.options,f=d.step,g,p=[],k=[],q;a=a||e.points;(g=a.reversed)&&a.reverse();(f={right:1,center:2}[f]||f&&3)&&g&&(f=4-f);!d.connectNulls||b||c||(a=this.getValidPoints(a));t(a,function(h,g){var n=h.plotX,l=h.plotY,m=a[g-1];(h.leftCliff||m&&m.rightCliff)&&!c&&(q=!0);h.isNull&&!u(b)&&0<g?q=!d.connectNulls:h.isNull&&!b?q=!0:(0===g||q?g=[\"M\",h.plotX,h.plotY]:e.getPointSpline?\ng=e.getPointSpline(a,h,g):f?(g=1===f?[\"L\",m.plotX,l]:2===f?[\"L\",(m.plotX+n)/2,m.plotY,\"L\",(m.plotX+n)/2,l]:[\"L\",n,m.plotY],g.push(\"L\",n,l)):g=[\"L\",n,l],k.push(h.x),f&&k.push(h.x),p.push.apply(p,g),q=!1)});p.xMap=k;return e.graphPath=p},drawGraph:function(){var a=this,b=this.options,c=(this.gappedPath||this.getGraphPath).call(this),e=[[\"graph\",\"highcharts-graph\",b.lineColor||this.color,b.dashStyle]];t(this.zones,function(c,d){e.push([\"zone-graph-\"+d,\"highcharts-graph highcharts-zone-graph-\"+d+\" \"+\n(c.className||\"\"),c.color||a.color,c.dashStyle||b.dashStyle])});t(e,function(e,d){var h=e[0],f=a[h];f?(f.endX=c.xMap,f.animate({d:c})):c.length&&(a[h]=a.chart.renderer.path(c).addClass(e[1]).attr({zIndex:1}).add(a.group),f={stroke:e[2],\"stroke-width\":b.lineWidth,fill:a.fillGraph&&a.color||\"none\"},e[3]?f.dashstyle=e[3]:\"square\"!==b.linecap&&(f[\"stroke-linecap\"]=f[\"stroke-linejoin\"]=\"round\"),f=a[h].attr(f).shadow(2>d&&b.shadow));f&&(f.startX=c.xMap,f.isArea=c.isArea)})},applyZones:function(){var a=\nthis,b=this.chart,c=b.renderer,e=this.zones,d,f,g=this.clips||[],k,q=this.graph,n=this.area,l=Math.max(b.chartWidth,b.chartHeight),m=this[(this.zoneAxis||\"y\")+\"Axis\"],r,v,B=b.inverted,y,u,G,D,K=!1;e.length&&(q||n)&&m&&void 0!==m.min&&(v=m.reversed,y=m.horiz,q&&q.hide(),n&&n.hide(),r=m.getExtremes(),t(e,function(e,h){d=v?y?b.plotWidth:0:y?0:m.toPixels(r.min);d=Math.min(Math.max(J(f,d),0),l);f=Math.min(Math.max(Math.round(m.toPixels(J(e.value,r.max),!0)),0),l);K&&(d=f=m.toPixels(r.max));u=Math.abs(d-\nf);G=Math.min(d,f);D=Math.max(d,f);m.isXAxis?(k={x:B?D:G,y:0,width:u,height:l},y||(k.x=b.plotHeight-k.x)):(k={x:0,y:B?D:G,width:l,height:u},y&&(k.y=b.plotWidth-k.y));B&&c.isVML&&(k=m.isXAxis?{x:0,y:v?G:D,height:k.width,width:b.chartWidth}:{x:k.y-b.plotLeft-b.spacingBox.x,y:0,width:k.height,height:b.chartHeight});g[h]?g[h].animate(k):(g[h]=c.clipRect(k),q&&a[\"zone-graph-\"+h].clip(g[h]),n&&a[\"zone-area-\"+h].clip(g[h]));K=e.value>r.max}),this.clips=g)},invertGroups:function(a){function b(){t([\"group\",\n\"markerGroup\"],function(b){c[b]&&(e.renderer.isVML&&c[b].attr({width:c.yAxis.len,height:c.xAxis.len}),c[b].width=c.yAxis.len,c[b].height=c.xAxis.len,c[b].invert(a))})}var c=this,e=c.chart,d;c.xAxis&&(d=C(e,\"resize\",b),C(c,\"destroy\",d),b(a),c.invertGroups=b)},plotGroup:function(a,b,c,e,d){var h=this[a],f=!h;f&&(this[a]=h=this.chart.renderer.g().attr({zIndex:e||.1}).add(d));h.addClass(\"highcharts-\"+b+\" highcharts-series-\"+this.index+\" highcharts-\"+this.type+\"-series highcharts-color-\"+this.colorIndex+\n\" \"+(this.options.className||\"\"),!0);h.attr({visibility:c})[f?\"attr\":\"animate\"](this.getPlotBox());return h},getPlotBox:function(){var a=this.chart,b=this.xAxis,c=this.yAxis;a.inverted&&(b=c,c=this.xAxis);return{translateX:b?b.left:a.plotLeft,translateY:c?c.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=this,b=a.chart,c,e=a.options,d=!!a.animate&&b.renderer.isSVG&&A(e.animation).duration,f=a.visible?\"inherit\":\"hidden\",g=e.zIndex,k=a.hasRendered,q=b.seriesGroup,n=b.inverted;c=a.plotGroup(\"group\",\n\"series\",f,g,q);a.markerGroup=a.plotGroup(\"markerGroup\",\"markers\",f,g,q);d&&a.animate(!0);c.inverted=a.isCartesian?n:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(n);!1===e.clip||a.sharedClipKey||k||c.clip(b.clipRect);d&&a.animate();k||(a.animationTimeout=B(function(){a.afterAnimate()},d));a.isDirty=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,\nb=this.isDirty||this.isDirtyData,c=this.group,e=this.xAxis,d=this.yAxis;c&&(a.inverted&&c.attr({width:a.plotWidth,height:a.plotHeight}),c.animate({translateX:J(e&&e.left,a.plotLeft),translateY:J(d&&d.top,a.plotTop)}));this.translate();this.render();b&&delete this.kdTree},kdAxisArray:[\"clientX\",\"plotY\"],searchPoint:function(a,b){var c=this.xAxis,e=this.yAxis,d=this.chart.inverted;return this.searchKDTree({clientX:d?c.len-a.chartY+c.pos:a.chartX-c.pos,plotY:d?e.len-a.chartX+e.pos:a.chartY-e.pos},b)},\nbuildKDTree:function(){function a(c,e,d){var h,f;if(f=c&&c.length)return h=b.kdAxisArray[e%d],c.sort(function(a,b){return a[h]-b[h]}),f=Math.floor(f/2),{point:c[f],left:a(c.slice(0,f),e+1,d),right:a(c.slice(f+1),e+1,d)}}this.buildingKdTree=!0;var b=this,c=-1<b.options.findNearestPointBy.indexOf(\"y\")?2:1;delete b.kdTree;B(function(){b.kdTree=a(b.getValidPoints(null,!b.directTouch),c,c);b.buildingKdTree=!1},b.options.kdNow?0:1)},searchKDTree:function(a,b){function c(a,b,h,k){var p=b.point,q=e.kdAxisArray[h%\nk],n,l,m=p;l=u(a[d])&&u(p[d])?Math.pow(a[d]-p[d],2):null;n=u(a[f])&&u(p[f])?Math.pow(a[f]-p[f],2):null;n=(l||0)+(n||0);p.dist=u(n)?Math.sqrt(n):Number.MAX_VALUE;p.distX=u(l)?Math.sqrt(l):Number.MAX_VALUE;q=a[q]-p[q];n=0>q?\"left\":\"right\";l=0>q?\"right\":\"left\";b[n]&&(n=c(a,b[n],h+1,k),m=n[g]<m[g]?n:p);b[l]&&Math.sqrt(q*q)<m[g]&&(a=c(a,b[l],h+1,k),m=a[g]<m[g]?a:m);return m}var e=this,d=this.kdAxisArray[0],f=this.kdAxisArray[1],g=b?\"distX\":\"dist\";b=-1<e.options.findNearestPointBy.indexOf(\"y\")?2:1;this.kdTree||\nthis.buildingKdTree||this.buildKDTree();if(this.kdTree)return c(a,this.kdTree,b,b)}})})(M);(function(a){var C=a.Axis,A=a.Chart,F=a.correctFloat,E=a.defined,m=a.destroyObjectProperties,f=a.each,l=a.format,r=a.objectEach,u=a.pick,t=a.Series;a.StackItem=function(a,d,f,b,e){var g=a.chart.inverted;this.axis=a;this.isNegative=f;this.options=d;this.x=b;this.total=null;this.points={};this.stack=e;this.rightCliff=this.leftCliff=0;this.alignOptions={align:d.align||(g?f?\"left\":\"right\":\"center\"),verticalAlign:d.verticalAlign||\n(g?\"middle\":f?\"bottom\":\"top\"),y:u(d.y,g?4:f?14:-6),x:u(d.x,g?f?-6:6:0)};this.textAlign=d.textAlign||(g?f?\"right\":\"left\":\"center\")};a.StackItem.prototype={destroy:function(){m(this,this.axis)},render:function(a){var d=this.options,f=d.format,f=f?l(f,this):d.formatter.call(this);this.label?this.label.attr({text:f,visibility:\"hidden\"}):this.label=this.axis.chart.renderer.text(f,null,null,d.useHTML).css(d.style).attr({align:this.textAlign,rotation:d.rotation,visibility:\"hidden\"}).add(a)},setOffset:function(a,\nd){var f=this.axis,b=f.chart,e=f.translate(f.usePercentage?100:this.total,0,0,0,1),f=f.translate(0),f=Math.abs(e-f);a=b.xAxis[0].translate(this.x)+a;e=this.getStackBox(b,this,a,e,d,f);if(d=this.label)d.align(this.alignOptions,null,e),e=d.alignAttr,d[!1===this.options.crop||b.isInsidePlot(e.x,e.y)?\"show\":\"hide\"](!0)},getStackBox:function(a,d,f,b,e,l){var g=d.axis.reversed,k=a.inverted;a=a.plotHeight;d=d.isNegative&&!g||!d.isNegative&&g;return{x:k?d?b:b-l:f,y:k?a-f-e:d?a-b-l:a-b,width:k?l:e,height:k?\ne:l}}};A.prototype.getStacks=function(){var a=this;f(a.yAxis,function(a){a.stacks&&a.hasVisibleSeries&&(a.oldStacks=a.stacks)});f(a.series,function(d){!d.options.stacking||!0!==d.visible&&!1!==a.options.chart.ignoreHiddenSeries||(d.stackKey=d.type+u(d.options.stack,\"\"))})};C.prototype.buildStacks=function(){var a=this.series,d=u(this.options.reversedStacks,!0),f=a.length,b;if(!this.isXAxis){this.usePercentage=!1;for(b=f;b--;)a[d?b:f-b-1].setStackedPoints();if(this.usePercentage)for(b=0;b<f;b++)a[b].setPercentStacks()}};\nC.prototype.renderStackTotals=function(){var a=this.chart,d=a.renderer,f=this.stacks,b=this.stackTotalGroup;b||(this.stackTotalGroup=b=d.g(\"stack-labels\").attr({visibility:\"visible\",zIndex:6}).add());b.translate(a.plotLeft,a.plotTop);r(f,function(a){r(a,function(a){a.render(b)})})};C.prototype.resetStacks=function(){var a=this,d=a.stacks;a.isXAxis||r(d,function(d){r(d,function(b,e){b.touched<a.stacksTouched?(b.destroy(),delete d[e]):(b.total=null,b.cum=null)})})};C.prototype.cleanStacks=function(){var a;\nthis.isXAxis||(this.oldStacks&&(a=this.stacks=this.oldStacks),r(a,function(a){r(a,function(a){a.cum=a.total})}))};t.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var f=this.processedXData,d=this.processedYData,k=[],b=d.length,e=this.options,l=e.threshold,m=e.startFromThreshold?l:0,n=e.stack,e=e.stacking,r=this.stackKey,t=\"-\"+r,c=this.negStacks,G=this.yAxis,q=G.stacks,B=G.oldStacks,K,p,z,I,A,h,w;G.stacksTouched+=\n1;for(A=0;A<b;A++)h=f[A],w=d[A],K=this.getStackIndicator(K,h,this.index),I=K.key,z=(p=c&&w<(m?0:l))?t:r,q[z]||(q[z]={}),q[z][h]||(B[z]&&B[z][h]?(q[z][h]=B[z][h],q[z][h].total=null):q[z][h]=new a.StackItem(G,G.options.stackLabels,p,h,n)),z=q[z][h],null!==w&&(z.points[I]=z.points[this.index]=[u(z.cum,m)],E(z.cum)||(z.base=I),z.touched=G.stacksTouched,0<K.index&&!1===this.singleStacks&&(z.points[I][0]=z.points[this.index+\",\"+h+\",0\"][0])),\"percent\"===e?(p=p?r:t,c&&q[p]&&q[p][h]?(p=q[p][h],z.total=p.total=\nMath.max(p.total,z.total)+Math.abs(w)||0):z.total=F(z.total+(Math.abs(w)||0))):z.total=F(z.total+(w||0)),z.cum=u(z.cum,m)+(w||0),null!==w&&(z.points[I].push(z.cum),k[A]=z.cum);\"percent\"===e&&(G.usePercentage=!0);this.stackedYData=k;G.oldStacks={}}};t.prototype.setPercentStacks=function(){var a=this,d=a.stackKey,k=a.yAxis.stacks,b=a.processedXData,e;f([d,\"-\"+d],function(d){for(var f=b.length,g,l;f--;)if(g=b[f],e=a.getStackIndicator(e,g,a.index,d),g=(l=k[d]&&k[d][g])&&l.points[e.key])l=l.total?100/\nl.total:0,g[0]=F(g[0]*l),g[1]=F(g[1]*l),a.stackedYData[f]=g[1]})};t.prototype.getStackIndicator=function(a,d,f,b){!E(a)||a.x!==d||b&&a.key!==b?a={x:d,index:0,key:b}:a.index++;a.key=[f,d,a.index].join();return a}})(M);(function(a){var C=a.addEvent,A=a.animate,F=a.Axis,E=a.createElement,m=a.css,f=a.defined,l=a.each,r=a.erase,u=a.extend,t=a.fireEvent,g=a.inArray,d=a.isNumber,k=a.isObject,b=a.isArray,e=a.merge,v=a.objectEach,y=a.pick,n=a.Point,D=a.Series,J=a.seriesTypes,c=a.setAnimation,G=a.splat;u(a.Chart.prototype,\n{addSeries:function(a,b,c){var e,d=this;a&&(b=y(b,!0),t(d,\"addSeries\",{options:a},function(){e=d.initSeries(a);d.isDirtyLegend=!0;d.linkSeries();b&&d.redraw(c)}));return e},addAxis:function(a,b,c,d){var f=b?\"xAxis\":\"yAxis\",g=this.options;a=e(a,{index:this[f].length,isX:b});b=new F(this,a);g[f]=G(g[f]||{});g[f].push(a);y(c,!0)&&this.redraw(d);return b},showLoading:function(a){var b=this,c=b.options,e=b.loadingDiv,d=c.loading,f=function(){e&&m(e,{left:b.plotLeft+\"px\",top:b.plotTop+\"px\",width:b.plotWidth+\n\"px\",height:b.plotHeight+\"px\"})};e||(b.loadingDiv=e=E(\"div\",{className:\"highcharts-loading highcharts-loading-hidden\"},null,b.container),b.loadingSpan=E(\"span\",{className:\"highcharts-loading-inner\"},null,e),C(b,\"redraw\",f));e.className=\"highcharts-loading\";b.loadingSpan.innerHTML=a||c.lang.loading;m(e,u(d.style,{zIndex:10}));m(b.loadingSpan,d.labelStyle);b.loadingShown||(m(e,{opacity:0,display:\"\"}),A(e,{opacity:d.style.opacity||.5},{duration:d.showDuration||0}));b.loadingShown=!0;f()},hideLoading:function(){var a=\nthis.options,b=this.loadingDiv;b&&(b.className=\"highcharts-loading highcharts-loading-hidden\",A(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){m(b,{display:\"none\"})}}));this.loadingShown=!1},propsRequireDirtyBox:\"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\npropsRequireUpdateSeries:\"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions tooltip\".split(\" \"),update:function(a,b,c){var k=this,n={credits:\"addCredits\",title:\"setTitle\",subtitle:\"setSubtitle\"},q=a.chart,m,h,r=[];if(q){e(!0,k.options.chart,q);\"className\"in q&&k.setClassName(q.className);if(\"inverted\"in q||\"polar\"in q)k.propFromSeries(),m=!0;\"alignTicks\"in q&&(m=!0);v(q,function(a,b){-1!==g(\"chart.\"+b,k.propsRequireUpdateSeries)&&(h=!0);-1!==g(b,k.propsRequireDirtyBox)&&\n(k.isDirtyBox=!0)});\"style\"in q&&k.renderer.setStyle(q.style)}a.colors&&(this.options.colors=a.colors);a.plotOptions&&e(!0,this.options.plotOptions,a.plotOptions);v(a,function(a,b){if(k[b]&&\"function\"===typeof k[b].update)k[b].update(a,!1);else if(\"function\"===typeof k[n[b]])k[n[b]](a);\"chart\"!==b&&-1!==g(b,k.propsRequireUpdateSeries)&&(h=!0)});l(\"xAxis yAxis zAxis series colorAxis pane\".split(\" \"),function(b){a[b]&&(l(G(a[b]),function(a,e){(e=f(a.id)&&k.get(a.id)||k[b][e])&&e.coll===b&&(e.update(a,\n!1),c&&(e.touched=!0));if(!e&&c)if(\"series\"===b)k.addSeries(a,!1).touched=!0;else if(\"xAxis\"===b||\"yAxis\"===b)k.addAxis(a,\"xAxis\"===b,!1).touched=!0}),c&&l(k[b],function(a){a.touched?delete a.touched:r.push(a)}))});l(r,function(a){a.remove(!1)});m&&l(k.axes,function(a){a.update({},!1)});h&&l(k.series,function(a){a.update({},!1)});a.loading&&e(!0,k.options.loading,a.loading);m=q&&q.width;q=q&&q.height;d(m)&&m!==k.chartWidth||d(q)&&q!==k.chartHeight?k.setSize(m,q):y(b,!0)&&k.redraw()},setSubtitle:function(a){this.setTitle(void 0,\na)}});u(n.prototype,{update:function(a,b,c,e){function d(){f.applyOptions(a);null===f.y&&h&&(f.graphic=h.destroy());k(a,!0)&&(h&&h.element&&a&&a.marker&&void 0!==a.marker.symbol&&(f.graphic=h.destroy()),a&&a.dataLabels&&f.dataLabel&&(f.dataLabel=f.dataLabel.destroy()));p=f.index;g.updateParallelArrays(f,p);q.data[p]=k(q.data[p],!0)||k(a,!0)?f.options:a;g.isDirty=g.isDirtyData=!0;!g.fixedBox&&g.hasCartesianSeries&&(l.isDirtyBox=!0);\"point\"===q.legendType&&(l.isDirtyLegend=!0);b&&l.redraw(c)}var f=\nthis,g=f.series,h=f.graphic,p,l=g.chart,q=g.options;b=y(b,!0);!1===e?d():f.firePointEvent(\"update\",{options:a},d)},remove:function(a,b){this.series.removePoint(g(this,this.series.data),a,b)}});u(D.prototype,{addPoint:function(a,b,c,e){var d=this.options,f=this.data,g=this.chart,h=this.xAxis,h=h&&h.hasNames&&h.names,k=d.data,p,l,q=this.xData,n,m;b=y(b,!0);p={series:this};this.pointClass.prototype.applyOptions.apply(p,[a]);m=p.x;n=q.length;if(this.requireSorting&&m<q[n-1])for(l=!0;n&&q[n-1]>m;)n--;\nthis.updateParallelArrays(p,\"splice\",n,0,0);this.updateParallelArrays(p,n);h&&p.name&&(h[m]=p.name);k.splice(n,0,a);l&&(this.data.splice(n,0,null),this.processData());\"point\"===d.legendType&&this.generatePoints();c&&(f[0]&&f[0].remove?f[0].remove(!1):(f.shift(),this.updateParallelArrays(p,\"shift\"),k.shift()));this.isDirtyData=this.isDirty=!0;b&&g.redraw(e)},removePoint:function(a,b,e){var d=this,f=d.data,g=f[a],k=d.points,h=d.chart,l=function(){k&&k.length===f.length&&k.splice(a,1);f.splice(a,1);\nd.options.data.splice(a,1);d.updateParallelArrays(g||{series:d},\"splice\",a,1);g&&g.destroy();d.isDirty=!0;d.isDirtyData=!0;b&&h.redraw()};c(e,h);b=y(b,!0);g?g.firePointEvent(\"remove\",null,l):l()},remove:function(a,b,c){function e(){d.destroy();f.isDirtyLegend=f.isDirtyBox=!0;f.linkSeries();y(a,!0)&&f.redraw(b)}var d=this,f=d.chart;!1!==c?t(d,\"remove\",null,e):e()},update:function(a,b){var c=this,d=c.chart,f=c.userOptions,g=c.oldType||c.type,k=a.type||f.type||d.options.chart.type,h=J[g].prototype,n,\nq=[\"group\",\"markerGroup\",\"dataLabelsGroup\",\"navigatorSeries\",\"baseSeries\"],m=c.finishedAnimating&&{animation:!1};if(Object.keys&&\"data\"===Object.keys(a).toString())return this.setData(a.data,b);if(k&&k!==g||void 0!==a.zIndex)q.length=0;l(q,function(a){q[a]=c[a];delete c[a]});a=e(f,m,{index:c.index,pointStart:c.xData[0]},{data:c.options.data},a);c.remove(!1,null,!1);for(n in h)c[n]=void 0;u(c,J[k||g].prototype);l(q,function(a){c[a]=q[a]});c.init(d,a);c.oldType=g;d.linkSeries();y(b,!0)&&d.redraw(!1)}});\nu(F.prototype,{update:function(a,b){var c=this.chart;a=c.options[this.coll][this.options.index]=e(this.userOptions,a);this.destroy(!0);this.init(c,u(a,{events:void 0}));c.isDirtyBox=!0;y(b,!0)&&c.redraw()},remove:function(a){for(var c=this.chart,e=this.coll,d=this.series,f=d.length;f--;)d[f]&&d[f].remove(!1);r(c.axes,this);r(c[e],this);b(c.options[e])?c.options[e].splice(this.options.index,1):delete c.options[e];l(c[e],function(a,b){a.options.index=b});this.destroy();c.isDirtyBox=!0;y(a,!0)&&c.redraw()},\nsetTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,b){this.update({categories:a},b)}})})(M);(function(a){var C=a.color,A=a.each,F=a.map,E=a.pick,m=a.Series,f=a.seriesType;f(\"area\",\"line\",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(f){var l=[],m=[],t=this.xAxis,g=this.yAxis,d=g.stacks[this.stackKey],k={},b=this.index,e=g.series,v=e.length,y,n=E(g.options.reversedStacks,!0)?1:-1,D;f=f||this.points;if(this.options.stacking){for(D=0;D<f.length;D++)k[f[D].x]=\nf[D];a.objectEach(d,function(a,b){null!==a.total&&m.push(b)});m.sort(function(a,b){return a-b});y=F(e,function(){return this.visible});A(m,function(a,c){var e=0,f,r;if(k[a]&&!k[a].isNull)l.push(k[a]),A([-1,1],function(e){var g=1===e?\"rightNull\":\"leftNull\",l=0,q=d[m[c+e]];if(q)for(D=b;0<=D&&D<v;)f=q.points[D],f||(D===b?k[a][g]=!0:y[D]&&(r=d[a].points[D])&&(l-=r[1]-r[0])),D+=n;k[a][1===e?\"rightCliff\":\"leftCliff\"]=l});else{for(D=b;0<=D&&D<v;){if(f=d[a].points[D]){e=f[1];break}D+=n}e=g.translate(e,0,\n1,0,1);l.push({isNull:!0,plotX:t.translate(a,0,0,0,1),x:a,plotY:e,yBottom:e})}})}return l},getGraphPath:function(a){var f=m.prototype.getGraphPath,l=this.options,t=l.stacking,g=this.yAxis,d,k,b=[],e=[],v=this.index,y,n=g.stacks[this.stackKey],D=l.threshold,A=g.getThreshold(l.threshold),c,l=l.connectNulls||\"percent\"===t,G=function(c,d,f){var k=a[c];c=t&&n[k.x].points[v];var l=k[f+\"Null\"]||0;f=k[f+\"Cliff\"]||0;var q,m,k=!0;f||l?(q=(l?c[0]:c[1])+f,m=c[0]+f,k=!!l):!t&&a[d]&&a[d].isNull&&(q=m=D);void 0!==\nq&&(e.push({plotX:y,plotY:null===q?A:g.getThreshold(q),isNull:k,isCliff:!0}),b.push({plotX:y,plotY:null===m?A:g.getThreshold(m),doCurve:!1}))};a=a||this.points;t&&(a=this.getStackPoints(a));for(d=0;d<a.length;d++)if(k=a[d].isNull,y=E(a[d].rectPlotX,a[d].plotX),c=E(a[d].yBottom,A),!k||l)l||G(d,d-1,\"left\"),k&&!t&&l||(e.push(a[d]),b.push({x:d,plotX:y,plotY:c})),l||G(d,d+1,\"right\");d=f.call(this,e,!0,!0);b.reversed=!0;k=f.call(this,b,!0,!0);k.length&&(k[0]=\"L\");k=d.concat(k);f=f.call(this,e,!1,l);k.xMap=\nd.xMap;this.areaPath=k;return f},drawGraph:function(){this.areaPath=[];m.prototype.drawGraph.apply(this);var a=this,f=this.areaPath,u=this.options,t=[[\"area\",\"highcharts-area\",this.color,u.fillColor]];A(this.zones,function(f,d){t.push([\"zone-area-\"+d,\"highcharts-area highcharts-zone-area-\"+d+\" \"+f.className,f.color||a.color,f.fillColor||u.fillColor])});A(t,function(g){var d=g[0],k=a[d];k?(k.endX=f.xMap,k.animate({d:f})):(k=a[d]=a.chart.renderer.path(f).addClass(g[1]).attr({fill:E(g[3],C(g[2]).setOpacity(E(u.fillOpacity,\n.75)).get()),zIndex:0}).add(a.group),k.isArea=!0);k.startX=f.xMap;k.shiftUnit=u.step?2:1})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(M);(function(a){var C=a.pick;a=a.seriesType;a(\"spline\",\"line\",{},{getPointSpline:function(a,F,E){var m=F.plotX,f=F.plotY,l=a[E-1];E=a[E+1];var r,u,t,g;if(l&&!l.isNull&&!1!==l.doCurve&&!F.isCliff&&E&&!E.isNull&&!1!==E.doCurve&&!F.isCliff){a=l.plotY;t=E.plotX;E=E.plotY;var d=0;r=(1.5*m+l.plotX)/2.5;u=(1.5*f+a)/2.5;t=(1.5*m+t)/2.5;g=(1.5*f+E)/2.5;t!==r&&(d=\n(g-u)*(t-m)/(t-r)+f-g);u+=d;g+=d;u>a&&u>f?(u=Math.max(a,f),g=2*f-u):u<a&&u<f&&(u=Math.min(a,f),g=2*f-u);g>E&&g>f?(g=Math.max(E,f),u=2*f-g):g<E&&g<f&&(g=Math.min(E,f),u=2*f-g);F.rightContX=t;F.rightContY=g}F=[\"C\",C(l.rightContX,l.plotX),C(l.rightContY,l.plotY),C(r,m),C(u,f),m,f];l.rightContX=l.rightContY=null;return F}})})(M);(function(a){var C=a.seriesTypes.area.prototype,A=a.seriesType;A(\"areaspline\",\"spline\",a.defaultPlotOptions.area,{getStackPoints:C.getStackPoints,getGraphPath:C.getGraphPath,\ndrawGraph:C.drawGraph,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(M);(function(a){var C=a.animObject,A=a.color,F=a.each,E=a.extend,m=a.isNumber,f=a.merge,l=a.pick,r=a.Series,u=a.seriesType,t=a.svg;u(\"column\",\"line\",{borderRadius:0,crisp:!0,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1,shadow:!1},select:{color:\"#cccccc\",borderColor:\"#000000\",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},\nsoftThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:\"#ffffff\"},{cropShoulder:0,directTouch:!0,trackerGroups:[\"group\",\"dataLabelsGroup\"],negStacks:!0,init:function(){r.prototype.init.apply(this,arguments);var a=this,d=a.chart;d.hasRendered&&F(d.series,function(d){d.type===a.type&&(d.isDirty=!0)})},getColumnMetrics:function(){var a=this,d=a.options,f=a.xAxis,b=a.yAxis,e=f.reversed,m,r={},n=0;!1===d.grouping?n=1:F(a.chart.series,function(c){var e=c.options,\nd=c.yAxis,f;c.type!==a.type||!c.visible&&a.chart.options.chart.ignoreHiddenSeries||b.len!==d.len||b.pos!==d.pos||(e.stacking?(m=c.stackKey,void 0===r[m]&&(r[m]=n++),f=r[m]):!1!==e.grouping&&(f=n++),c.columnIndex=f)});var t=Math.min(Math.abs(f.transA)*(f.ordinalSlope||d.pointRange||f.closestPointRange||f.tickInterval||1),f.len),u=t*d.groupPadding,c=(t-2*u)/(n||1),d=Math.min(d.maxPointWidth||f.len,l(d.pointWidth,c*(1-2*d.pointPadding)));a.columnMetrics={width:d,offset:(c-d)/2+(u+((a.columnIndex||0)+\n(e?1:0))*c-t/2)*(e?-1:1)};return a.columnMetrics},crispCol:function(a,d,f,b){var e=this.chart,g=this.borderWidth,k=-(g%2?.5:0),g=g%2?.5:1;e.inverted&&e.renderer.isVML&&(g+=1);this.options.crisp&&(f=Math.round(a+f)+k,a=Math.round(a)+k,f-=a);b=Math.round(d+b)+g;k=.5>=Math.abs(d)&&.5<b;d=Math.round(d)+g;b-=d;k&&b&&(--d,b+=1);return{x:a,y:d,width:f,height:b}},translate:function(){var a=this,d=a.chart,f=a.options,b=a.dense=2>a.closestPointRange*a.xAxis.transA,b=a.borderWidth=l(f.borderWidth,b?0:1),e=a.yAxis,\nm=a.translatedThreshold=e.getThreshold(f.threshold),t=l(f.minPointLength,5),n=a.getColumnMetrics(),u=n.width,A=a.barW=Math.max(u,1+2*b),c=a.pointXOffset=n.offset;d.inverted&&(m-=.5);f.pointPadding&&(A=Math.ceil(A));r.prototype.translate.apply(a);F(a.points,function(b){var f=l(b.yBottom,m),g=999+Math.abs(f),g=Math.min(Math.max(-g,b.plotY),e.len+g),k=b.plotX+c,n=A,r=Math.min(g,f),v,y=Math.max(g,f)-r;Math.abs(y)<t&&t&&(y=t,v=!e.reversed&&!b.negative||e.reversed&&b.negative,r=Math.abs(r-m)>t?f-t:m-(v?\nt:0));b.barX=k;b.pointWidth=u;b.tooltipPos=d.inverted?[e.len+e.pos-d.plotLeft-g,a.xAxis.len-k-n/2,y]:[k+n/2,g+e.pos-d.plotTop,y];b.shapeType=\"rect\";b.shapeArgs=a.crispCol.apply(a,b.isNull?[k,m,n,0]:[k,r,n,y])})},getSymbol:a.noop,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,drawGraph:function(){this.group[this.dense?\"addClass\":\"removeClass\"](\"highcharts-dense-data\")},pointAttribs:function(a,d){var g=this.options,b,e=this.pointAttrToOptions||{};b=e.stroke||\"borderColor\";var l=e[\"stroke-width\"]||\n\"borderWidth\",m=a&&a.color||this.color,n=a[b]||g[b]||this.color||m,r=a[l]||g[l]||this[l]||0,e=g.dashStyle;a&&this.zones.length&&(m=a.getZone(),m=a.options.color||m&&m.color||this.color);d&&(a=f(g.states[d],a.options.states&&a.options.states[d]||{}),d=a.brightness,m=a.color||void 0!==d&&A(m).brighten(a.brightness).get()||m,n=a[b]||n,r=a[l]||r,e=a.dashStyle||e);b={fill:m,stroke:n,\"stroke-width\":r};e&&(b.dashstyle=e);return b},drawPoints:function(){var a=this,d=this.chart,k=a.options,b=d.renderer,e=\nk.animationLimit||250,l;F(a.points,function(g){var n=g.graphic;if(m(g.plotY)&&null!==g.y){l=g.shapeArgs;if(n)n[d.pointCount<e?\"animate\":\"attr\"](f(l));else g.graphic=n=b[g.shapeType](l).add(g.group||a.group);k.borderRadius&&n.attr({r:k.borderRadius});n.attr(a.pointAttribs(g,g.selected&&\"select\")).shadow(k.shadow,null,k.stacking&&!k.borderRadius);n.addClass(g.getClassName(),!0)}else n&&(g.graphic=n.destroy())})},animate:function(a){var d=this,f=this.yAxis,b=d.options,e=this.chart.inverted,g={};t&&(a?\n(g.scaleY=.001,a=Math.min(f.pos+f.len,Math.max(f.pos,f.toPixels(b.threshold))),e?g.translateX=a-f.len:g.translateY=a,d.group.attr(g)):(g[e?\"translateX\":\"translateY\"]=f.pos,d.group.animate(g,E(C(d.options.animation),{step:function(a,b){d.group.attr({scaleY:Math.max(.001,b.pos)})}})),d.animate=null))},remove:function(){var a=this,d=a.chart;d.hasRendered&&F(d.series,function(d){d.type===a.type&&(d.isDirty=!0)});r.prototype.remove.apply(a,arguments)}})})(M);(function(a){a=a.seriesType;a(\"bar\",\"column\",\nnull,{inverted:!0})})(M);(function(a){var C=a.Series;a=a.seriesType;a(\"scatter\",\"line\",{lineWidth:0,findNearestPointBy:\"xy\",marker:{enabled:!0},tooltip:{headerFormat:'\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e \\x3cspan style\\x3d\"font-size: 0.85em\"\\x3e {series.name}\\x3c/span\\x3e\\x3cbr/\\x3e',pointFormat:\"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"}},{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:[\"group\",\"markerGroup\",\"dataLabelsGroup\"],\ntakeOrdinalPosition:!1,drawGraph:function(){this.options.lineWidth&&C.prototype.drawGraph.call(this)}})})(M);(function(a){var C=a.pick,A=a.relativeLength;a.CenteredSeriesMixin={getCenter:function(){var a=this.options,E=this.chart,m=2*(a.slicedOffset||0),f=E.plotWidth-2*m,E=E.plotHeight-2*m,l=a.center,l=[C(l[0],\"50%\"),C(l[1],\"50%\"),a.size||\"100%\",a.innerSize||0],r=Math.min(f,E),u,t;for(u=0;4>u;++u)t=l[u],a=2>u||2===u&&/%$/.test(t),l[u]=A(t,[f,E,r,l[2]][u])+(a?m:0);l[3]>l[2]&&(l[3]=l[2]);return l}}})(M);\n(function(a){var C=a.addEvent,A=a.defined,F=a.each,E=a.extend,m=a.inArray,f=a.noop,l=a.pick,r=a.Point,u=a.Series,t=a.seriesType,g=a.setAnimation;t(\"pie\",\"line\",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:\"point\",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:\"#ffffff\",borderWidth:1,states:{hover:{brightness:.1,\nshadow:!1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:[\"group\",\"dataLabelsGroup\"],axisTypes:[],pointAttribs:a.seriesTypes.column.prototype.pointAttribs,animate:function(a){var d=this,b=d.points,e=d.startAngleRad;a||(F(b,function(a){var b=a.graphic,f=a.shapeArgs;b&&(b.attr({r:a.startR||d.center[3]/2,start:e,end:e}),b.animate({r:f.r,start:f.start,end:f.end},d.options.animation))}),d.animate=null)},updateTotals:function(){var a,f=0,b=this.points,e=b.length,g,\nl=this.options.ignoreHiddenPoint;for(a=0;a<e;a++)g=b[a],f+=l&&!g.visible?0:g.isNull?0:g.y;this.total=f;for(a=0;a<e;a++)g=b[a],g.percentage=0<f&&(g.visible||!l)?g.y/f*100:0,g.total=f},generatePoints:function(){u.prototype.generatePoints.call(this);this.updateTotals()},translate:function(a){this.generatePoints();var d=0,b=this.options,e=b.slicedOffset,f=e+(b.borderWidth||0),g,n,m,r=b.startAngle||0,c=this.startAngleRad=Math.PI/180*(r-90),r=(this.endAngleRad=Math.PI/180*(l(b.endAngle,r+360)-90))-c,t=\nthis.points,q,B=b.dataLabels.distance,b=b.ignoreHiddenPoint,u,p=t.length,z;a||(this.center=a=this.getCenter());this.getX=function(b,c,e){m=Math.asin(Math.min((b-a[1])/(a[2]/2+e.labelDistance),1));return a[0]+(c?-1:1)*Math.cos(m)*(a[2]/2+e.labelDistance)};for(u=0;u<p;u++){z=t[u];z.labelDistance=l(z.options.dataLabels&&z.options.dataLabels.distance,B);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,z.labelDistance);g=c+d*r;if(!b||z.visible)d+=z.percentage/100;n=c+d*r;z.shapeType=\"arc\";z.shapeArgs=\n{x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:Math.round(1E3*g)/1E3,end:Math.round(1E3*n)/1E3};m=(n+g)/2;m>1.5*Math.PI?m-=2*Math.PI:m<-Math.PI/2&&(m+=2*Math.PI);z.slicedTranslation={translateX:Math.round(Math.cos(m)*e),translateY:Math.round(Math.sin(m)*e)};n=Math.cos(m)*a[2]/2;q=Math.sin(m)*a[2]/2;z.tooltipPos=[a[0]+.7*n,a[1]+.7*q];z.half=m<-Math.PI/2||m>Math.PI/2?1:0;z.angle=m;g=Math.min(f,z.labelDistance/5);z.labelPos=[a[0]+n+Math.cos(m)*z.labelDistance,a[1]+q+Math.sin(m)*z.labelDistance,a[0]+n+Math.cos(m)*\ng,a[1]+q+Math.sin(m)*g,a[0]+n,a[1]+q,0>z.labelDistance?\"center\":z.half?\"right\":\"left\",m]}},drawGraph:null,drawPoints:function(){var a=this,f=a.chart.renderer,b,e,g,l,n=a.options.shadow;n&&!a.shadowGroup&&(a.shadowGroup=f.g(\"shadow\").add(a.group));F(a.points,function(d){if(!d.isNull){e=d.graphic;l=d.shapeArgs;b=d.getTranslate();var k=d.shadowGroup;n&&!k&&(k=d.shadowGroup=f.g(\"shadow\").add(a.shadowGroup));k&&k.attr(b);g=a.pointAttribs(d,d.selected&&\"select\");e?e.setRadialReference(a.center).attr(g).animate(E(l,\nb)):(d.graphic=e=f[d.shapeType](l).setRadialReference(a.center).attr(b).add(a.group),d.visible||e.attr({visibility:\"hidden\"}),e.attr(g).attr({\"stroke-linejoin\":\"round\"}).shadow(n,k));e.addClass(d.getClassName())}})},searchPoint:f,sortByAngle:function(a,f){a.sort(function(a,e){return void 0!==a.angle&&(e.angle-a.angle)*f})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,getCenter:a.CenteredSeriesMixin.getCenter,getSymbol:f},{init:function(){r.prototype.init.apply(this,arguments);var a=this,f;a.name=\nl(a.name,\"Slice\");f=function(b){a.slice(\"select\"===b.type)};C(a,\"select\",f);C(a,\"unselect\",f);return a},isValid:function(){return a.isNumber(this.y,!0)&&0<=this.y},setVisible:function(a,f){var b=this,e=b.series,d=e.chart,g=e.options.ignoreHiddenPoint;f=l(f,g);a!==b.visible&&(b.visible=b.options.visible=a=void 0===a?!b.visible:a,e.options.data[m(b,e.data)]=b.options,F([\"graphic\",\"dataLabel\",\"connector\",\"shadowGroup\"],function(e){if(b[e])b[e][a?\"show\":\"hide\"](!0)}),b.legendItem&&d.legend.colorizeItem(b,\na),a||\"hover\"!==b.state||b.setState(\"\"),g&&(e.isDirty=!0),f&&d.redraw())},slice:function(a,f,b){var e=this.series;g(b,e.chart);l(f,!0);this.sliced=this.options.sliced=A(a)?a:!this.sliced;e.options.data[m(this,e.data)]=this.options;this.graphic.animate(this.getTranslate());this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(a){var d=this.shapeArgs;return this.sliced||!this.visible?\n[]:this.series.chart.renderer.symbols.arc(d.x,d.y,d.r+a,d.r+a,{innerR:this.shapeArgs.r,start:d.start,end:d.end})}})})(M);(function(a){var C=a.addEvent,A=a.arrayMax,F=a.defined,E=a.each,m=a.extend,f=a.format,l=a.map,r=a.merge,u=a.noop,t=a.pick,g=a.relativeLength,d=a.Series,k=a.seriesTypes,b=a.stableSort;a.distribute=function(a,d){function e(a,b){return a.target-b.target}var f,g=!0,k=a,c=[],m;m=0;for(f=a.length;f--;)m+=a[f].size;if(m>d){b(a,function(a,b){return(b.rank||0)-(a.rank||0)});for(m=f=0;m<=\nd;)m+=a[f].size,f++;c=a.splice(f-1,a.length)}b(a,e);for(a=l(a,function(a){return{size:a.size,targets:[a.target]}});g;){for(f=a.length;f--;)g=a[f],m=(Math.min.apply(0,g.targets)+Math.max.apply(0,g.targets))/2,g.pos=Math.min(Math.max(0,m-g.size/2),d-g.size);f=a.length;for(g=!1;f--;)0<f&&a[f-1].pos+a[f-1].size>a[f].pos&&(a[f-1].size+=a[f].size,a[f-1].targets=a[f-1].targets.concat(a[f].targets),a[f-1].pos+a[f-1].size>d&&(a[f-1].pos=d-a[f-1].size),a.splice(f,1),g=!0)}f=0;E(a,function(a){var b=0;E(a.targets,\nfunction(){k[f].pos=a.pos+b;b+=k[f].size;f++})});k.push.apply(k,c);b(k,e)};d.prototype.drawDataLabels=function(){var b=this,d=b.options,g=d.dataLabels,k=b.points,l,m,c=b.hasRendered||0,u,q,B=t(g.defer,!!d.animation),A=b.chart.renderer;if(g.enabled||b._hasPointLabels)b.dlProcessOptions&&b.dlProcessOptions(g),q=b.plotGroup(\"dataLabelsGroup\",\"data-labels\",B&&!c?\"hidden\":\"visible\",g.zIndex||6),B&&(q.attr({opacity:+c}),c||C(b,\"afterAnimate\",function(){b.visible&&q.show(!0);q[d.animation?\"animate\":\"attr\"]({opacity:1},\n{duration:200})})),m=g,E(k,function(c){var e,k=c.dataLabel,n,h,p=c.connector,v=!k,B;l=c.dlOptions||c.options&&c.options.dataLabels;if(e=t(l&&l.enabled,m.enabled)&&null!==c.y)g=r(m,l),n=c.getLabelConfig(),u=g.format?f(g.format,n):g.formatter.call(n,g),B=g.style,n=g.rotation,B.color=t(g.color,B.color,b.color,\"#000000\"),\"contrast\"===B.color&&(c.contrastColor=A.getContrast(c.color||b.color),B.color=g.inside||0>t(c.labelDistance,g.distance)||d.stacking?c.contrastColor:\"#000000\"),d.cursor&&(B.cursor=d.cursor),\nh={fill:g.backgroundColor,stroke:g.borderColor,\"stroke-width\":g.borderWidth,r:g.borderRadius||0,rotation:n,padding:g.padding,zIndex:1},a.objectEach(h,function(a,b){void 0===a&&delete h[b]});!k||e&&F(u)?e&&F(u)&&(k?h.text=u:(k=c.dataLabel=A[n?\"text\":\"label\"](u,0,-9999,g.shape,null,null,g.useHTML,null,\"data-label\"),k.addClass(\"highcharts-data-label-color-\"+c.colorIndex+\" \"+(g.className||\"\")+(g.useHTML?\"highcharts-tracker\":\"\"))),k.attr(h),k.css(B).shadow(g.shadow),k.added||k.add(q),b.alignDataLabel(c,\nk,g,null,v)):(c.dataLabel=k=k.destroy(),p&&(c.connector=p.destroy()))})};d.prototype.alignDataLabel=function(a,b,d,f,g){var e=this.chart,c=e.inverted,k=t(a.plotX,-9999),l=t(a.plotY,-9999),n=b.getBBox(),r,p=d.rotation,v=d.align,u=this.visible&&(a.series.forceDL||e.isInsidePlot(k,Math.round(l),c)||f&&e.isInsidePlot(k,c?f.x+1:f.y+f.height-1,c)),y=\"justify\"===t(d.overflow,\"justify\");if(u&&(r=d.style.fontSize,r=e.renderer.fontMetrics(r,b).b,f=m({x:c?this.yAxis.len-l:k,y:Math.round(c?this.xAxis.len-k:l),\nwidth:0,height:0},f),m(d,{width:n.width,height:n.height}),p?(y=!1,k=e.renderer.rotCorr(r,p),k={x:f.x+d.x+f.width/2+k.x,y:f.y+d.y+{top:0,middle:.5,bottom:1}[d.verticalAlign]*f.height},b[g?\"attr\":\"animate\"](k).attr({align:v}),l=(p+720)%360,l=180<l&&360>l,\"left\"===v?k.y-=l?n.height:0:\"center\"===v?(k.x-=n.width/2,k.y-=n.height/2):\"right\"===v&&(k.x-=n.width,k.y-=l?0:n.height)):(b.align(d,null,f),k=b.alignAttr),y?a.isLabelJustified=this.justifyDataLabel(b,d,k,n,f,g):t(d.crop,!0)&&(u=e.isInsidePlot(k.x,\nk.y)&&e.isInsidePlot(k.x+n.width,k.y+n.height)),d.shape&&!p))b[g?\"attr\":\"animate\"]({anchorX:c?e.plotWidth-a.plotY:a.plotX,anchorY:c?e.plotHeight-a.plotX:a.plotY});u||(b.attr({y:-9999}),b.placed=!1)};d.prototype.justifyDataLabel=function(a,b,d,f,g,k){var c=this.chart,e=b.align,l=b.verticalAlign,m,n,p=a.box?0:a.padding||0;m=d.x+p;0>m&&(\"right\"===e?b.align=\"left\":b.x=-m,n=!0);m=d.x+f.width-p;m>c.plotWidth&&(\"left\"===e?b.align=\"right\":b.x=c.plotWidth-m,n=!0);m=d.y+p;0>m&&(\"bottom\"===l?b.verticalAlign=\n\"top\":b.y=-m,n=!0);m=d.y+f.height-p;m>c.plotHeight&&(\"top\"===l?b.verticalAlign=\"bottom\":b.y=c.plotHeight-m,n=!0);n&&(a.placed=!k,a.align(b,null,g));return n};k.pie&&(k.pie.prototype.drawDataLabels=function(){var b=this,f=b.data,g,k=b.chart,l=b.options.dataLabels,m=t(l.connectorPadding,10),c=t(l.connectorWidth,1),r=k.plotWidth,q=k.plotHeight,u,C=b.center,p=C[2]/2,z=C[1],I,L,h,w,M=[[],[]],H,O,Q,R,x=[0,0,0,0];b.visible&&(l.enabled||b._hasPointLabels)&&(E(f,function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&\n(a.dataLabel.attr({width:\"auto\"}).css({width:\"auto\",textOverflow:\"clip\"}),a.dataLabel.shortened=!1)}),d.prototype.drawDataLabels.apply(b),E(f,function(a){a.dataLabel&&a.visible&&(M[a.half].push(a),a.dataLabel._pos=null)}),E(M,function(c,d){var e,f,n=c.length,v=[],u;if(n)for(b.sortByAngle(c,d-.5),0<b.maxLabelDistance&&(e=Math.max(0,z-p-b.maxLabelDistance),f=Math.min(z+p+b.maxLabelDistance,k.plotHeight),E(c,function(a){0<a.labelDistance&&a.dataLabel&&(a.top=Math.max(0,z-p-a.labelDistance),a.bottom=\nMath.min(z+p+a.labelDistance,k.plotHeight),u=a.dataLabel.getBBox().height||21,a.positionsIndex=v.push({target:a.labelPos[1]-a.top+u/2,size:u,rank:a.y})-1)}),a.distribute(v,f+u-e)),R=0;R<n;R++)g=c[R],f=g.positionsIndex,h=g.labelPos,I=g.dataLabel,Q=!1===g.visible?\"hidden\":\"inherit\",e=h[1],v&&F(v[f])?void 0===v[f].pos?Q=\"hidden\":(w=v[f].size,O=g.top+v[f].pos):O=e,delete g.positionIndex,H=l.justify?C[0]+(d?-1:1)*(p+g.labelDistance):b.getX(O<g.top+2||O>g.bottom-2?e:O,d,g),I._attr={visibility:Q,align:h[6]},\nI._pos={x:H+l.x+({left:m,right:-m}[h[6]]||0),y:O+l.y-10},h.x=H,h.y=O,t(l.crop,!0)&&(L=I.getBBox().width,e=null,H-L<m?(e=Math.round(L-H+m),x[3]=Math.max(e,x[3])):H+L>r-m&&(e=Math.round(H+L-r+m),x[1]=Math.max(e,x[1])),0>O-w/2?x[0]=Math.max(Math.round(-O+w/2),x[0]):O+w/2>q&&(x[2]=Math.max(Math.round(O+w/2-q),x[2])),I.sideOverflow=e)}),0===A(x)||this.verifyDataLabelOverflow(x))&&(this.placeDataLabels(),c&&E(this.points,function(a){var e;u=a.connector;if((I=a.dataLabel)&&I._pos&&a.visible&&0<a.labelDistance){Q=\nI._attr.visibility;if(e=!u)a.connector=u=k.renderer.path().addClass(\"highcharts-data-label-connector highcharts-color-\"+a.colorIndex).add(b.dataLabelsGroup),u.attr({\"stroke-width\":c,stroke:l.connectorColor||a.color||\"#666666\"});u[e?\"attr\":\"animate\"]({d:b.connectorPath(a.labelPos)});u.attr(\"visibility\",Q)}else u&&(a.connector=u.destroy())}))},k.pie.prototype.connectorPath=function(a){var b=a.x,d=a.y;return t(this.options.dataLabels.softConnector,!0)?[\"M\",b+(\"left\"===a[6]?5:-5),d,\"C\",b,d,2*a[2]-a[4],\n2*a[3]-a[5],a[2],a[3],\"L\",a[4],a[5]]:[\"M\",b+(\"left\"===a[6]?5:-5),d,\"L\",a[2],a[3],\"L\",a[4],a[5]]},k.pie.prototype.placeDataLabels=function(){E(this.points,function(a){var b=a.dataLabel;b&&a.visible&&((a=b._pos)?(b.sideOverflow&&(b._attr.width=b.getBBox().width-b.sideOverflow,b.css({width:b._attr.width+\"px\",textOverflow:\"ellipsis\"}),b.shortened=!0),b.attr(b._attr),b[b.moved?\"animate\":\"attr\"](a),b.moved=!0):b&&b.attr({y:-9999}))},this)},k.pie.prototype.alignDataLabel=u,k.pie.prototype.verifyDataLabelOverflow=\nfunction(a){var b=this.center,d=this.options,e=d.center,f=d.minSize||80,k,c=null!==d.size;c||(null!==e[0]?k=Math.max(b[2]-Math.max(a[1],a[3]),f):(k=Math.max(b[2]-a[1]-a[3],f),b[0]+=(a[3]-a[1])/2),null!==e[1]?k=Math.max(Math.min(k,b[2]-Math.max(a[0],a[2])),f):(k=Math.max(Math.min(k,b[2]-a[0]-a[2]),f),b[1]+=(a[0]-a[2])/2),k<b[2]?(b[2]=k,b[3]=Math.min(g(d.innerSize||0,k),k),this.translate(b),this.drawDataLabels&&this.drawDataLabels()):c=!0);return c});k.column&&(k.column.prototype.alignDataLabel=function(a,\nb,f,g,k){var e=this.chart.inverted,c=a.series,l=a.dlBox||a.shapeArgs,m=t(a.below,a.plotY>t(this.translatedThreshold,c.yAxis.len)),n=t(f.inside,!!this.options.stacking);l&&(g=r(l),0>g.y&&(g.height+=g.y,g.y=0),l=g.y+g.height-c.yAxis.len,0<l&&(g.height-=l),e&&(g={x:c.yAxis.len-g.y-g.height,y:c.xAxis.len-g.x-g.width,width:g.height,height:g.width}),n||(e?(g.x+=m?0:g.width,g.width=0):(g.y+=m?g.height:0,g.height=0)));f.align=t(f.align,!e||n?\"center\":m?\"right\":\"left\");f.verticalAlign=t(f.verticalAlign,e||\nn?\"middle\":m?\"top\":\"bottom\");d.prototype.alignDataLabel.call(this,a,b,f,g,k);a.isLabelJustified&&a.contrastColor&&a.dataLabel.css({color:a.contrastColor})})})(M);(function(a){var C=a.Chart,A=a.each,F=a.objectEach,E=a.pick,m=a.addEvent;C.prototype.callbacks.push(function(a){function f(){var f=[];A(a.yAxis||[],function(a){a.options.stackLabels&&!a.options.stackLabels.allowOverlap&&F(a.stacks,function(a){F(a,function(a){f.push(a.label)})})});A(a.series||[],function(a){var l=a.options.dataLabels,g=a.dataLabelCollections||\n[\"dataLabel\"];(l.enabled||a._hasPointLabels)&&!l.allowOverlap&&a.visible&&A(g,function(d){A(a.points,function(a){a[d]&&(a[d].labelrank=E(a.labelrank,a.shapeArgs&&a.shapeArgs.height),f.push(a[d]))})})});a.hideOverlappingLabels(f)}f();m(a,\"redraw\",f)});C.prototype.hideOverlappingLabels=function(a){var f=a.length,m,u,t,g,d,k,b,e,v,y=function(a,b,d,c,e,f,g,k){return!(e>a+d||e+g<a||f>b+c||f+k<b)};for(u=0;u<f;u++)if(m=a[u])m.oldOpacity=m.opacity,m.newOpacity=1,m.width||(t=m.getBBox(),m.width=t.width,m.height=\nt.height);a.sort(function(a,b){return(b.labelrank||0)-(a.labelrank||0)});for(u=0;u<f;u++)for(t=a[u],m=u+1;m<f;++m)if(g=a[m],t&&g&&t!==g&&t.placed&&g.placed&&0!==t.newOpacity&&0!==g.newOpacity&&(d=t.alignAttr,k=g.alignAttr,b=t.parentGroup,e=g.parentGroup,v=2*(t.box?0:t.padding||0),d=y(d.x+b.translateX,d.y+b.translateY,t.width-v,t.height-v,k.x+e.translateX,k.y+e.translateY,g.width-v,g.height-v)))(t.labelrank<g.labelrank?t:g).newOpacity=0;A(a,function(a){var b,d;a&&(d=a.newOpacity,a.oldOpacity!==d&&\na.placed&&(d?a.show(!0):b=function(){a.hide()},a.alignAttr.opacity=d,a[a.isOld?\"animate\":\"attr\"](a.alignAttr,null,b)),a.isOld=!0)})}})(M);(function(a){var C=a.addEvent,A=a.Chart,F=a.createElement,E=a.css,m=a.defaultOptions,f=a.defaultPlotOptions,l=a.each,r=a.extend,u=a.fireEvent,t=a.hasTouch,g=a.inArray,d=a.isObject,k=a.Legend,b=a.merge,e=a.pick,v=a.Point,y=a.Series,n=a.seriesTypes,D=a.svg,J;J=a.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart.pointer,d=function(a){var c=b.getPointFromEvent(a);\nvoid 0!==c&&(b.isDirectTouch=!0,c.onMouseOver(a))};l(a.points,function(a){a.graphic&&(a.graphic.element.point=a);a.dataLabel&&(a.dataLabel.div?a.dataLabel.div.point=a:a.dataLabel.element.point=a)});a._hasTracking||(l(a.trackerGroups,function(c){if(a[c]){a[c].addClass(\"highcharts-tracker\").on(\"mouseover\",d).on(\"mouseout\",function(a){b.onTrackerMouseOut(a)});if(t)a[c].on(\"touchstart\",d);a.options.cursor&&a[c].css(E).css({cursor:a.options.cursor})}}),a._hasTracking=!0)},drawTrackerGraph:function(){var a=\nthis,b=a.options,d=b.trackByArea,e=[].concat(d?a.areaPath:a.graphPath),f=e.length,g=a.chart,k=g.pointer,m=g.renderer,n=g.options.tooltip.snap,h=a.tracker,r,u=function(){if(g.hoverSeries!==a)a.onMouseOver()},v=\"rgba(192,192,192,\"+(D?.0001:.002)+\")\";if(f&&!d)for(r=f+1;r--;)\"M\"===e[r]&&e.splice(r+1,0,e[r+1]-n,e[r+2],\"L\"),(r&&\"M\"===e[r]||r===f)&&e.splice(r,0,\"L\",e[r-2]+n,e[r-1]);h?h.attr({d:e}):a.graph&&(a.tracker=m.path(e).attr({\"stroke-linejoin\":\"round\",visibility:a.visible?\"visible\":\"hidden\",stroke:v,\nfill:d?v:\"none\",\"stroke-width\":a.graph.strokeWidth()+(d?0:2*n),zIndex:2}).add(a.group),l([a.tracker,a.markerGroup],function(a){a.addClass(\"highcharts-tracker\").on(\"mouseover\",u).on(\"mouseout\",function(a){k.onTrackerMouseOut(a)});b.cursor&&a.css({cursor:b.cursor});if(t)a.on(\"touchstart\",u)}))}};n.column&&(n.column.prototype.drawTracker=J.drawTrackerPoint);n.pie&&(n.pie.prototype.drawTracker=J.drawTrackerPoint);n.scatter&&(n.scatter.prototype.drawTracker=J.drawTrackerPoint);r(k.prototype,{setItemEvents:function(a,\nd,e){var c=this,f=c.chart.renderer.boxWrapper,g=\"highcharts-legend-\"+(a.series?\"point\":\"series\")+\"-active\";(e?d:a.legendGroup).on(\"mouseover\",function(){a.setState(\"hover\");f.addClass(g);d.css(c.options.itemHoverStyle)}).on(\"mouseout\",function(){d.css(b(a.visible?c.itemStyle:c.itemHiddenStyle));f.removeClass(g);a.setState()}).on(\"click\",function(b){var c=function(){a.setVisible&&a.setVisible()};b={browserEvent:b};a.firePointEvent?a.firePointEvent(\"legendItemClick\",b,c):u(a,\"legendItemClick\",b,c)})},\ncreateCheckboxForItem:function(a){a.checkbox=F(\"input\",{type:\"checkbox\",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);C(a.checkbox,\"click\",function(b){u(a.series||a,\"checkboxClick\",{checked:b.target.checked,item:a},function(){a.select()})})}});m.legend.itemStyle.cursor=\"pointer\";r(A.prototype,{showResetZoom:function(){var a=this,b=m.lang,d=a.options.chart.resetZoomButton,e=d.theme,f=e.states,g=\"chart\"===d.relativeTo?null:\"plotBox\";this.resetZoomButton=\na.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},e,f&&f.hover).attr({align:d.position.align,title:b.resetZoomTitle}).addClass(\"highcharts-reset-zoom\").add().align(d.position,!1,g)},zoomOut:function(){var a=this;u(a,\"selection\",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var b,c=this.pointer,f=!1,g;!a||a.resetSelection?(l(this.axes,function(a){b=a.zoom()}),c.initiated=!1):l(a.xAxis.concat(a.yAxis),function(a){var d=a.axis;c[d.isXAxis?\"zoomX\":\"zoomY\"]&&(b=d.zoom(a.min,\na.max),d.displayBtn&&(f=!0))});g=this.resetZoomButton;f&&!g?this.showResetZoom():!f&&d(g)&&(this.resetZoomButton=g.destroy());b&&this.redraw(e(this.options.chart.animation,a&&a.animation,100>this.pointCount))},pan:function(a,b){var c=this,d=c.hoverPoints,e;d&&l(d,function(a){a.setState()});l(\"xy\"===b?[1,0]:[1],function(b){b=c[b?\"xAxis\":\"yAxis\"][0];var d=b.horiz,f=a[d?\"chartX\":\"chartY\"],d=d?\"mouseDownX\":\"mouseDownY\",g=c[d],h=(b.pointRange||0)/2,k=b.getExtremes(),l=b.toValue(g-f,!0)+h,h=b.toValue(g+\nb.len-f,!0)-h,m=h<l,g=m?h:l,l=m?l:h,h=Math.min(k.dataMin,b.toValue(b.toPixels(k.min)-b.minPixelPadding)),m=Math.max(k.dataMax,b.toValue(b.toPixels(k.max)+b.minPixelPadding)),n;n=h-g;0<n&&(l+=n,g=h);n=l-m;0<n&&(l=m,g-=n);b.series.length&&g!==k.min&&l!==k.max&&(b.setExtremes(g,l,!1,!1,{trigger:\"pan\"}),e=!0);c[d]=f});e&&c.redraw(!1);E(c.container,{cursor:\"move\"})}});r(v.prototype,{select:function(a,b){var c=this,d=c.series,f=d.chart;a=e(a,!c.selected);c.firePointEvent(a?\"select\":\"unselect\",{accumulate:b},\nfunction(){c.selected=c.options.selected=a;d.options.data[g(c,d.data)]=c.options;c.setState(a&&\"select\");b||l(f.getSelectedPoints(),function(a){a.selected&&a!==c&&(a.selected=a.options.selected=!1,d.options.data[g(a,d.data)]=a.options,a.setState(\"\"),a.firePointEvent(\"unselect\"))})})},onMouseOver:function(a){var b=this.series.chart,c=b.pointer;a=a?c.normalize(a):c.getChartCoordinatesFromPoint(this,b.inverted);c.runPointActions(a,this)},onMouseOut:function(){var a=this.series.chart;this.firePointEvent(\"mouseOut\");\nl(a.hoverPoints||[],function(a){a.setState()});a.hoverPoints=a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var c=this,d=b(c.series.options.point,c.options).events;c.events=d;a.objectEach(d,function(a,b){C(c,b,a)});this.hasImportedEvents=!0}},setState:function(a,b){var c=Math.floor(this.plotX),d=this.plotY,g=this.series,k=g.options.states[a]||{},l=f[g.type].marker&&g.options.marker,m=l&&!1===l.enabled,n=l&&l.states&&l.states[a]||{},h=!1===n.enabled,t=g.stateMarkerGraphic,u=\nthis.marker||{},v=g.chart,y=g.halo,A,C=l&&g.markerAttribs;a=a||\"\";if(!(a===this.state&&!b||this.selected&&\"select\"!==a||!1===k.enabled||a&&(h||m&&!1===n.enabled)||a&&u.states&&u.states[a]&&!1===u.states[a].enabled)){C&&(A=g.markerAttribs(this,a));if(this.graphic)this.state&&this.graphic.removeClass(\"highcharts-point-\"+this.state),a&&this.graphic.addClass(\"highcharts-point-\"+a),this.graphic.animate(g.pointAttribs(this,a),e(v.options.chart.animation,k.animation)),A&&this.graphic.animate(A,e(v.options.chart.animation,\nn.animation,l.animation)),t&&t.hide();else{if(a&&n){l=u.symbol||g.symbol;t&&t.currentSymbol!==l&&(t=t.destroy());if(t)t[b?\"animate\":\"attr\"]({x:A.x,y:A.y});else l&&(g.stateMarkerGraphic=t=v.renderer.symbol(l,A.x,A.y,A.width,A.height).add(g.markerGroup),t.currentSymbol=l);t&&t.attr(g.pointAttribs(this,a))}t&&(t[a&&v.isInsidePlot(c,d,v.inverted)?\"show\":\"hide\"](),t.element.point=this)}(c=k.halo)&&c.size?(y||(g.halo=y=v.renderer.path().add((this.graphic||t).parentGroup)),y[b?\"animate\":\"attr\"]({d:this.haloPath(c.size)}),\ny.attr({\"class\":\"highcharts-halo highcharts-color-\"+e(this.colorIndex,g.colorIndex)}),y.point=this,y.attr(r({fill:this.color||g.color,\"fill-opacity\":c.opacity,zIndex:-1},c.attributes))):y&&y.point&&y.point.haloPath&&y.animate({d:y.point.haloPath(0)});this.state=a}},haloPath:function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-a,this.plotY-a,2*a,2*a)}});r(y.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&\nu(this,\"mouseOver\");this.setState(\"hover\");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,d=b.tooltip,e=b.hoverPoint;b.hoverSeries=null;if(e)e.onMouseOut();this&&a.events.mouseOut&&u(this,\"mouseOut\");!d||this.stickyTracking||d.shared&&!this.noSharedTooltip||d.hide();this.setState()},setState:function(a){var b=this,c=b.options,d=b.graph,f=c.states,g=c.lineWidth,c=0;a=a||\"\";if(b.state!==a&&(l([b.group,b.markerGroup,b.dataLabelsGroup],function(c){c&&(b.state&&c.removeClass(\"highcharts-series-\"+\nb.state),a&&c.addClass(\"highcharts-series-\"+a))}),b.state=a,!f[a]||!1!==f[a].enabled)&&(a&&(g=f[a].lineWidth||g+(f[a].lineWidthPlus||0)),d&&!d.dashstyle))for(g={\"stroke-width\":g},d.animate(g,e(b.chart.options.chart.animation,f[a]&&f[a].animation));b[\"zone-graph-\"+c];)b[\"zone-graph-\"+c].attr(g),c+=1},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,f,g=d.options.chart.ignoreHiddenSeries,k=c.visible;f=(c.visible=a=c.options.visible=c.userOptions.visible=void 0===a?!k:a)?\"show\":\"hide\";l([\"group\",\n\"dataLabelsGroup\",\"markerGroup\",\"tracker\",\"tt\"],function(a){if(c[a])c[a][f]()});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();e&&d.legend.colorizeItem(c,a);c.isDirty=!0;c.options.stacking&&l(d.series,function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});l(c.linkedSeries,function(b){b.setVisible(a,!1)});g&&(d.isDirtyBox=!0);!1!==b&&d.redraw();u(c,f)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=void 0===\na?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);u(this,a?\"select\":\"unselect\")},drawTracker:J.drawTrackerGraph})})(M);(function(a){var C=a.Chart,A=a.each,F=a.inArray,E=a.isArray,m=a.isObject,f=a.pick,l=a.splat;C.prototype.setResponsive=function(f){var l=this.options.responsive,m=[],g=this.currentResponsive;l&&l.rules&&A(l.rules,function(d){void 0===d._id&&(d._id=a.uniqueKey());this.matchResponsiveRule(d,m,f)},this);var d=a.merge.apply(0,a.map(m,function(d){return a.find(l.rules,function(a){return a._id===\nd}).chartOptions})),m=m.toString()||void 0;m!==(g&&g.ruleIds)&&(g&&this.update(g.undoOptions,f),m?(this.currentResponsive={ruleIds:m,mergedOptions:d,undoOptions:this.currentOptions(d)},this.update(d,f)):this.currentResponsive=void 0)};C.prototype.matchResponsiveRule=function(a,l){var m=a.condition;(m.callback||function(){return this.chartWidth<=f(m.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=f(m.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=f(m.minWidth,0)&&this.chartHeight>=f(m.minHeight,0)}).call(this)&&\nl.push(a._id)};C.prototype.currentOptions=function(f){function r(f,d,k,b){var e;a.objectEach(f,function(a,g){if(!b&&-1<F(g,[\"series\",\"xAxis\",\"yAxis\"]))for(f[g]=l(f[g]),k[g]=[],e=0;e<f[g].length;e++)d[g][e]&&(k[g][e]={},r(a[e],d[g][e],k[g][e],b+1));else m(a)?(k[g]=E(a)?[]:{},r(a,d[g]||{},k[g],b+1)):k[g]=d[g]||null})}var t={};r(f,this.options,t,0);return t}})(M);return M});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGNoYXJ0cy9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9oaWdoY2hhcnRzLmpzP2RkMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSw0RkFBNEYsc0RBQXNELGFBQWEscVJBQXFSLCtDQUErQztBQUNsZixzUkFBc1IsZUFBZSxvR0FBb0csWUFBWSxHQUFHLGFBQWEsb0NBQW9DLHNCQUFzQjtBQUMvZCxxQ0FBcUMsb0JBQW9CLDJCQUEyQixxQkFBcUIsZUFBZSxZQUFZLGFBQWEsZ0JBQWdCLG1CQUFtQixpRUFBaUUsb0JBQW9CLCtCQUErQixJQUFJLDhEQUE4RCxTQUFTLDhCQUE4QixtQkFBbUIsMkRBQTJEO0FBQy9kLFlBQVksa0VBQWtFLG9CQUFvQixxQkFBcUIseUJBQXlCLDhCQUE4QixHQUFHLHlCQUF5QixhQUFhLFdBQVcsWUFBWSxvQkFBb0IsV0FBVyxpQkFBaUIsaUJBQWlCLHNEQUFzRCxRQUFRLFdBQVcsNEJBQTRCLG1DQUFtQyxNQUFNLGtCQUFrQjtBQUMvYyxzQ0FBc0Msd0lBQXdJLGVBQWUsd0lBQXdJLFNBQVMsMEJBQTBCLGNBQWMsUUFBUSxlQUFlLElBQUk7QUFDalosZ0JBQWdCLEtBQUssV0FBVyxFQUFFLG1CQUFtQixtQkFBbUIsbUNBQW1DLHlFQUF5RSxTQUFTLGdCQUFnQix5QkFBeUIsU0FBUywwSUFBMEksUUFBUSw0REFBNEQsZUFBZSxZQUFZLHlCQUF5QjtBQUNqZixNQUFNLFNBQVMsUUFBUSxXQUFXLG9CQUFvQixJQUFJLE1BQU0sdUNBQXVDLElBQUksS0FBSyxNQUFNLG1CQUFtQiw4RUFBOEUsY0FBYyxpRUFBaUUsMkZBQTJGLHVCQUF1QixNQUFNLFFBQVEsRUFBRSxxQkFBcUIsVUFBVSxtQkFBbUIsd0JBQXdCO0FBQ2xmLGNBQWMsMEJBQTBCLEVBQUUsNkJBQTZCLDRFQUE0RSxJQUFJLEVBQUUsVUFBVSxzREFBc0QsV0FBVyxRQUFRLElBQUksZ0JBQWdCLFVBQVUscUJBQXFCLDBCQUEwQix1QkFBdUIsMkJBQTJCLHNCQUFzQixvQ0FBb0MsMkRBQTJEO0FBQ2hlLEdBQUcscURBQXFELDJCQUEyQixvREFBb0Qsc0JBQXNCLHVCQUF1QiwrRUFBK0UsdUJBQXVCLHNDQUFzQyxzQkFBc0IsbUJBQW1CLElBQUksY0FBYyxjQUFjLFFBQVEsc0JBQXNCLDZCQUE2Qix1QkFBdUIsTUFBTTtBQUNqZSx1SEFBdUgsb0JBQW9CLEVBQUUsVUFBVSxvQkFBb0IsMkJBQTJCLDhCQUE4Qiw4QkFBOEIsYUFBYSxrQkFBa0IsK0JBQStCLFFBQVEsSUFBSSw2Q0FBNkMsb0JBQW9CLHdGQUF3RjtBQUNyZSxJQUFJLG9DQUFvQyxxQkFBcUIsWUFBWSxpQkFBaUIsUUFBUSxpQ0FBaUMsRUFBRSxVQUFVLG9CQUFvQixVQUFVLDRCQUE0QixtQkFBbUIsa0JBQWtCLHdCQUF3QixVQUFVLHNCQUFzQixzREFBc0QsaUNBQWlDLDZEQUE2RCx1QkFBdUIsV0FBVyxnQkFBZ0I7QUFDNWUsbUJBQW1CLHFCQUFxQix5Q0FBeUMsYUFBYSxrQkFBa0IsZUFBZSxXQUFXLDBCQUEwQixhQUFhLHFGQUFxRiw2QkFBNkIsd0VBQXdFLGdDQUFnQztBQUMzWSxrR0FBa0csOFFBQThRLGdCQUFnQiw2QkFBNkIsS0FBSyxzQkFBc0IsaURBQWlELEVBQUU7QUFDM2UsZ0NBQWdDLDZCQUE2QiwwQ0FBMEMsaUpBQWlKLFVBQVUsdUJBQXVCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxlQUFlLGdCQUFnQixlQUFlLE1BQU0sZUFBZSx1QkFBdUIsV0FBVyxJQUFJLFFBQVEsSUFBSSxjQUFjLDRDQUE0QyxVQUFVO0FBQ3hmLGVBQWUsV0FBVyxJQUFJLEVBQUUsVUFBVSxtQkFBbUIsMkJBQTJCLHVEQUF1RCw0Q0FBNEMsVUFBVSxjQUFjLE1BQU0sNEZBQTRGLGVBQWUscUJBQXFCLFFBQVEsZ0VBQWdFLEtBQUssb0VBQW9FO0FBQzFlLGNBQWMsbUJBQW1CLFFBQVEsSUFBSSxpQkFBaUIscUJBQXFCLFNBQVMsK0JBQStCLEVBQUUsUUFBUSxJQUFJLHVCQUF1Qix1QkFBdUIsMEJBQTBCLElBQUksa0JBQWtCLFVBQVUsdUJBQXVCLDBCQUEwQixJQUFJLGtCQUFrQixVQUFVLHdDQUF3Qyw2QkFBNkIsaUNBQWlDLFlBQVksR0FBRyw2QkFBNkIsbUJBQW1CO0FBQ3ZlLG9CQUFvQixnQkFBZ0IsNkJBQTZCLHlDQUF5Qyw2QkFBNkIsbUVBQW1FLHlCQUF5QixpQ0FBaUMsbUJBQW1CLGFBQWEsaUdBQWlHLGlDQUFpQyxRQUFRLEtBQUs7QUFDbmIsOEJBQThCLDZDQUE2QyxtRUFBbUUsb0JBQW9CLDBCQUEwQiwyQkFBMkIsMkJBQTJCLHNDQUFzQyw0QkFBNEIsRUFBRSxrQkFBa0Isc0JBQXNCLG9CQUFvQixVQUFVLCtCQUErQixtQ0FBbUMsMkJBQTJCO0FBQ3pkLDBFQUEwRSwwSEFBMEgsc0ZBQXNGLFVBQVUsd0JBQXdCLG9EQUFvRCxxQkFBcUIsMkJBQTJCLHFCQUFxQix5QkFBeUIsb0JBQW9CO0FBQ2xlLFNBQVMsSUFBSSwrQkFBK0IsVUFBVSxxQkFBcUIsd0JBQXdCLDRCQUE0QixPQUFPLHNIQUFzSCxxQkFBcUIsbUJBQW1CLElBQUkscURBQXFELHVCQUF1Qiw0Q0FBNEMsNkJBQTZCO0FBQzdiLDJCQUEyQixjQUFjLHlCQUF5QixZQUFZLGdDQUFnQyw0RkFBNEYsNkZBQTZGLGdCQUFnQixhQUFhLGtCQUFrQix1QkFBdUIsOEJBQThCLGdCQUFnQjtBQUMzWix5QkFBeUIsYUFBYSxRQUFRLG9CQUFvQiwyQ0FBMkMsMEJBQTBCLElBQUksY0FBYyxHQUFHLHFCQUFxQiw0R0FBNEcsSUFBSSw4QkFBOEIsTUFBTSxhQUFhLFFBQVEsUUFBUTtBQUNsVyxHQUFHLDBEQUEwRCwwQkFBMEIsc0JBQXNCLGlCQUFpQixNQUFNLElBQUksbURBQW1ELDhCQUE4QiwwQkFBMEIsaUJBQWlCLCtCQUErQix3Q0FBd0MsRUFBRSx5Q0FBeUMsa0ZBQWtGLHFCQUFxQjtBQUM3ZCxHQUFHLFlBQVksa0JBQWtCLE9BQU8sd0lBQXdJLFNBQVMsbURBQW1ELGFBQWEsR0FBRyxpQ0FBaUMscUNBQXFDLDZDQUE2QyxxQ0FBcUMsSUFBSSxzQkFBc0Isd0RBQXdELGFBQWE7QUFDbmYsV0FBVyxvREFBb0Qsa0JBQWtCLCtCQUErQixHQUFHLDZDQUE2QywrQkFBK0Isd0lBQXdJLEVBQUUsNkNBQTZDLE9BQU8sMENBQTBDLElBQUksd0NBQXdDLDRCQUE0QjtBQUMvZSw2Q0FBNkMsbURBQW1ELHVCQUF1QixHQUFHLHFFQUFxRSxhQUFhLEdBQUcseUJBQXlCLEVBQUUsaURBQWlELHVCQUF1QixJQUFJLHdDQUF3QyxFQUFFLGtEQUFrRCxVQUFVLG9CQUFvQixJQUFJLHlCQUF5QixTQUFTLEVBQUU7QUFDeGQsY0FBYyw0QkFBNEIsSUFBSSw0QkFBNEIsU0FBUyxFQUFFLDRDQUE0QyxpQkFBaUIsUUFBUSxJQUFJLDZCQUE2QixFQUFFLEtBQUssYUFBYSxxREFBcUQsb0JBQW9CLG9EQUFvRCxjQUFjLG1CQUFtQixVQUFVLHVCQUF1QixJQUFJLGVBQWUsSUFBSSxlQUFlLElBQUksc0RBQXNEO0FBQzllLHNDQUFzQyxFQUFFLHNCQUFzQixJQUFJLGVBQWUsSUFBSSxlQUFlLElBQUksMEJBQTBCLG1DQUFtQyxTQUFTLDJEQUEyRCxrQkFBa0IsWUFBWSwrR0FBK0cseUJBQXlCLEVBQUU7QUFDalosZ0hBQWdILFFBQVEsdURBQXVELGdCQUFnQixpQkFBaUIsK0JBQStCLHlFQUF5RSxvQ0FBb0MsaUhBQWlILFNBQVMsc0JBQXNCO0FBQzVlLHVDQUF1QyxjQUFjLEVBQUUsNEJBQTRCLElBQUkseURBQXlELFlBQVksd0JBQXdCLGVBQWUsWUFBWSx1QkFBdUIsUUFBUSwwUEFBMFAsV0FBVztBQUNuZixZQUFZLHVCQUF1QixLQUFLLGFBQWEsdVpBQXVaLDBCQUEwQixhQUFhO0FBQ25mLENBQUMseUxBQXlMLDhEQUE4RCxnQkFBZ0IseUJBQXlCLHNEQUFzRCwrRkFBK0YsWUFBWSwrQkFBK0I7QUFDamUsMkJBQTJCLDJFQUEyRSxzRUFBc0UsK0RBQStELGlGQUFpRiwrQkFBK0IscUJBQXFCLHNCQUFzQixrQkFBa0IsVUFBVTtBQUNsYSx1Q0FBdUMsb0ZBQW9GLGdDQUFnQyw0Q0FBNEMsU0FBUyxnQkFBZ0IsbUZBQW1GLFNBQVMsRUFBRSw4QkFBOEIsNkJBQTZCLCtGQUErRixlQUFlO0FBQ3ZlLGdDQUFnQyxlQUFlLGlEQUFpRCwwQkFBMEIsZ0RBQWdELGFBQWEsRUFBRSxlQUFlLElBQUksbUZBQW1GLGVBQWUsa0JBQWtCLGdJQUFnSSxpQkFBaUIsS0FBSztBQUN0ZCwyREFBMkQsRUFBRSxvQkFBb0IsR0FBRyx3QkFBd0Isa0NBQWtDLDBDQUEwQyxTQUFTLGdHQUFnRyxLQUFLLGFBQWEsd0hBQXdILHdEQUF3RDtBQUNuZSwrSUFBK0ksNEJBQTRCLE9BQU8sU0FBUyx5QkFBeUIsK0RBQStELCtCQUErQixrQ0FBa0MsSUFBSSxxRkFBcUYsd0JBQXdCLDZCQUE2QjtBQUNsZSxpRUFBaUUsWUFBWSxzQkFBc0Isb0RBQW9ELHlCQUF5QixpRUFBaUUsd0JBQXdCLFdBQVcsK0VBQStFLGtCQUFrQixFQUFFLFFBQVEsK0RBQStELEVBQUUsa0JBQWtCO0FBQ2xkLHVDQUF1QyxxQkFBcUIsZUFBZSxHQUFHLHNCQUFzQixvQkFBb0IsOEJBQThCLDhCQUE4Qiw4Q0FBOEMsaURBQWlELG9DQUFvQyxrQkFBa0Isd0JBQXdCLEVBQUUsU0FBUyxpQkFBaUIsc0JBQXNCLHVFQUF1RTtBQUMxZCxxQkFBcUIsd0JBQXdCLEVBQUUscU5BQXFOLDBCQUEwQixtQkFBbUIsaURBQWlELEdBQUc7QUFDclcsWUFBWSx3QkFBd0IsK0JBQStCLGtCQUFrQix1QkFBdUIsMkNBQTJDLDZCQUE2QixtQkFBbUIsWUFBWSx1QkFBdUIscUdBQXFHLGNBQWMsWUFBWSxnQ0FBZ0MscURBQXFELCtCQUErQjtBQUM3ZCxZQUFZLFlBQVkseUJBQXlCLGtCQUFrQiwwQkFBMEIsRUFBRSxvQkFBb0IsZ0JBQWdCLHVCQUF1QixZQUFZLDRCQUE0Qix5SEFBeUgsa0NBQWtDLDZCQUE2Qix3SEFBd0g7QUFDbGYsOENBQThDLGtEQUFrRCxvQkFBb0IsbUJBQW1CLDRCQUE0QixZQUFZLHVCQUF1QixpQkFBaUIsZ0JBQWdCLG1CQUFtQixRQUFRLE1BQU0sbUhBQW1ILGdFQUFnRSxjQUFjLFVBQVUsa0JBQWtCO0FBQ3JlLEdBQUcsb0JBQW9CLG9DQUFvQyxpQ0FBaUMsb0NBQW9DLHFDQUFxQyxtQ0FBbUMsb0NBQW9DLHNDQUFzQyxlQUFlLGlCQUFpQixZQUFZLHVCQUF1QixrR0FBa0cscUJBQXFCLE1BQU0sZ0JBQWdCO0FBQ2xlLHdHQUF3RyxnQkFBZ0IsT0FBTyw4Q0FBOEMsSUFBSSw0QkFBNEIsNkRBQTZELGtCQUFrQixFQUFFLDZCQUE2QixlQUFlLDBDQUEwQyxVQUFVLFVBQVUsb0JBQW9CLGtCQUFrQiwwQkFBMEI7QUFDeGMsMkpBQTJKLGtCQUFrQixLQUFLLGFBQWEscUJBQXFCLGdCQUFnQixRQUFRLFNBQVMsa0JBQWtCLGtCQUFrQixpQ0FBaUMsRUFBRSxpQkFBaUIsa0JBQWtCLG9CQUFvQixFQUFFLHFCQUFxQixXQUFXLFdBQVcsVUFBVSxFQUFFLG9DQUFvQyxRQUFRLFFBQVEsR0FBRyxFQUFFLGlCQUFpQjtBQUN0ZiwrQkFBK0Isd0JBQXdCLGtDQUFrQyx5Q0FBeUMsY0FBYyxvREFBb0Qsc0NBQXNDLDJCQUEyQixZQUFZLDZCQUE2QixtQkFBbUIsb0JBQW9CLG9CQUFvQiwwQkFBMEIsNEVBQTRFO0FBQy9jLGFBQWEsS0FBSyxnRUFBZ0Usa0dBQWtHLG1DQUFtQyxZQUFZLFFBQVEsaUJBQWlCLG9DQUFvQyxhQUFhLHFCQUFxQix1QkFBdUIsc0NBQXNDLDJEQUEyRCwwQ0FBMEMsa0JBQWtCLFlBQVk7QUFDbGdCLFlBQVksd0JBQXdCLG9DQUFvQyw0QkFBNEIsdUJBQXVCLGVBQWUscUJBQXFCLDJFQUEyRSxRQUFRLEtBQUssc0NBQXNDLG9IQUFvSDtBQUNqWixhQUFhLGVBQWUsWUFBWSwyQkFBMkIsK0JBQStCLHdCQUF3QixPQUFPLG9CQUFvQixxQkFBcUIscUVBQXFFLDhCQUE4Qiw0QkFBNEIsOERBQThELDBDQUEwQyxTQUFTLHlCQUF5QiwyQkFBMkIsUUFBUSxFQUFFLDJCQUEyQjtBQUNuZixtQ0FBbUMsNkJBQTZCLDZCQUE2QixxQkFBcUIseUJBQXlCLDRPQUE0TyxlQUFlLElBQUksZ0JBQWdCLHFDQUFxQyxpREFBaUQseUJBQXlCO0FBQ3pnQixDQUFDLHlDQUF5QyxLQUFLLCtCQUErQixVQUFVLG9CQUFvQix5QkFBeUIsb0RBQW9ELDBFQUEwRSwwQ0FBMEMsd0VBQXdFLHdCQUF3Qiw4RkFBOEY7QUFDM2UsS0FBSyxxRUFBcUUsa0NBQWtDLG9FQUFvRSxVQUFVLDRCQUE0QixrRkFBa0YsYUFBYSxNQUFNLHNEQUFzRCxNQUFNLG1DQUFtQyxlQUFlLFFBQVEsZUFBZTtBQUNoYyxpREFBaUQsb0JBQW9CLFNBQVMsZ0NBQWdDLHFCQUFxQixFQUFFLHdDQUF3QyxxTEFBcUwsVUFBVSxxQkFBcUIsMkVBQTJFLFVBQVU7QUFDdGQsNk5BQTZOLDJCQUEyQixpQ0FBaUMsZUFBZSw4Q0FBOEMsTUFBTSxrQ0FBa0Msd0NBQXdDLHdCQUF3QixZQUFZLGlCQUFpQjtBQUMzZCx5QkFBeUIsY0FBYyxXQUFXLGtCQUFrQix1QkFBdUIsc0tBQXNLLHlHQUF5RywyQ0FBMkMsaUJBQWlCLGlCQUFpQixrQkFBa0IsY0FBYyxrQkFBa0I7QUFDemUsRUFBRSxxQkFBcUIsTUFBTSwwQ0FBMEMsS0FBSyxhQUFhLEVBQUUsNEJBQTRCLEtBQUssbUVBQW1FLEVBQUUseUNBQXlDLHNCQUFzQixxQkFBcUIsa0dBQWtHLElBQUksc0JBQXNCLHNDQUFzQyxxQkFBcUIsdUNBQXVDLG9CQUFvQjtBQUN2Z0IsVUFBVSxjQUFjLDBDQUEwQyxvQkFBb0IsRUFBRSxvQkFBb0IsMkJBQTJCLHlDQUF5QyxnQ0FBZ0MsMkJBQTJCLHVCQUF1QixlQUFlLFNBQVMsb0NBQW9DLE9BQU8sOERBQThELDRCQUE0QiwwQkFBMEI7QUFDemIsV0FBVyxTQUFTLGlDQUFpQyxvREFBb0QsNEJBQTRCLHNDQUFzQyxHQUFHLGFBQWEseUJBQXlCLFVBQVUsS0FBSyxLQUFLLDBHQUEwRyxhQUFhLGFBQWEsU0FBUyx1QkFBdUI7QUFDNVksb05BQW9OLE1BQU0sZ0ZBQWdGLDhEQUE4RCx5QkFBeUIsb0JBQW9CLGtCQUFrQixJQUFJLHFCQUFxQjtBQUNoYyxzVUFBc1UsYUFBYSxvQkFBb0IsVUFBVSxxR0FBcUcsaUJBQWlCLGdCQUFnQjtBQUN2ZixpQkFBaUIsUUFBUSwyQ0FBMkMsNENBQTRDLHVDQUF1Qyw4Q0FBOEMsMkVBQTJFLGlCQUFpQixHQUFHLGtEQUFrRCx3QkFBd0IsV0FBVyxZQUFZLG1DQUFtQyw4QkFBOEIsT0FBTyxpQkFBaUIsb0JBQW9CLGdCQUFnQjtBQUNsZ0IsZ0JBQWdCLE1BQU0sMkNBQTJDLGdDQUFnQywrQkFBK0Isb0NBQW9DLDRCQUE0QiwwTEFBMEwsU0FBUztBQUNuWSxPQUFPLGFBQWEsTUFBTSxFQUFFLHlCQUF5QiwrSUFBK0ksd0JBQXdCLGNBQWMseUJBQXlCLFlBQVksOENBQThDLG9DQUFvQywyREFBMkQsVUFBVSxjQUFjLEtBQUssWUFBWSxLQUFLO0FBQzFjLE9BQU8sc0RBQXNELElBQUksVUFBVSxlQUFlLE9BQU8sZUFBZSxJQUFJLFVBQVUsZUFBZSxPQUFPLHNCQUFzQixtQ0FBbUMsSUFBSSxVQUFVLGVBQWUsT0FBTyxPQUFPLGlCQUFpQixJQUFJLFVBQVUsZUFBZSxrREFBa0QscUJBQXFCLEVBQUUsaURBQWlELHFCQUFxQixFQUFFLHVCQUF1QixxQkFBcUI7QUFDbmUsK0NBQStDLDhDQUE4QyxpQkFBaUIsaUJBQWlCLEtBQUssZ0NBQWdDLG1CQUFtQixFQUFFLHlCQUF5QixnREFBZ0QsZ0RBQWdELFNBQVMsa0JBQWtCLE9BQU8sYUFBYSx3QkFBd0IsMENBQTBDLHdCQUF3QixVQUFVLGFBQWEsK0JBQStCO0FBQ2pmLDBCQUEwQix5QkFBeUIsaUJBQWlCLDJCQUEyQixnQ0FBZ0Msd0JBQXdCLCtCQUErQixNQUFNLFNBQVMsNEJBQTRCLGFBQWEsaUNBQWlDLHNCQUFzQixFQUFFLGtEQUFrRCwyQ0FBMkMsY0FBYyxXQUFXLDBCQUEwQixLQUFLLFVBQVUsR0FBRyxpQkFBaUIseUJBQXlCO0FBQ25mLCtCQUErQixhQUFhLGNBQWMsNkJBQTZCLGlCQUFpQixFQUFFLGdCQUFnQixXQUFXLDBEQUEwRCxFQUFFLDJCQUEyQixFQUFFLElBQUksY0FBYyxlQUFlLDhCQUE4QixpQkFBaUIsd0JBQXdCLElBQUksMkJBQTJCLE9BQU8sNEJBQTRCLHlCQUF5Qix5QkFBeUIsRUFBRSxzQ0FBc0M7QUFDbGUsMEdBQTBHLFNBQVMsOEJBQThCLDBLQUEwSyw2Q0FBNkMsc0NBQXNDO0FBQzlZLDhDQUE4QyxRQUFRLDhCQUE4QixFQUFFLGtDQUFrQyw0QkFBNEIsUUFBUSx5REFBeUQsVUFBVSxvSEFBb0gsZ0JBQWdCLFFBQVEsd0RBQXdELGlCQUFpQixXQUFXLGtCQUFrQixzQkFBc0I7QUFDdmUsU0FBUyxpQ0FBaUMsNEJBQTRCLE1BQU0scUNBQXFDLHNCQUFzQix3QkFBd0IsZUFBZSxtREFBbUQsYUFBYSx1Q0FBdUMsT0FBTyxvQkFBb0IsU0FBUyxVQUFVLHlCQUF5QixxQ0FBcUMsOEJBQThCLEVBQUUsMEJBQTBCLDRDQUE0QztBQUN2ZSxPQUFPLDBDQUEwQyxtQ0FBbUMsd0NBQXdDLDJCQUEyQix3REFBd0QseUJBQXlCLGdEQUFnRCxXQUFXLG1EQUFtRCw0REFBNEQsMkJBQTJCLDhDQUE4QztBQUMzZCxtQ0FBbUMsaUJBQWlCLFNBQVMsNkJBQTZCLG1EQUFtRCxlQUFlLE1BQU0sOEpBQThKO0FBQ2hVLDRMQUE0TCxVQUFVLDRCQUE0QiwyREFBMkQsS0FBSyxpQkFBaUIsOEJBQThCLE9BQU8sYUFBYSxVQUFVLFNBQVMsd0JBQXdCLDhCQUE4QixnRUFBZ0U7QUFDOWUsR0FBRyx1QkFBdUIscUJBQXFCLHFDQUFxQyxVQUFVLG9CQUFvQixFQUFFLDhCQUE4Qiw4REFBOEQsUUFBUSxXQUFXLHNEQUFzRCxvQkFBb0IsRUFBRSxTQUFTLDJCQUEyQixtRUFBbUU7QUFDdFosNkJBQTZCLE9BQU8sNEJBQTRCLHlCQUF5QixRQUFRLHNDQUFzQyxPQUFPLDBCQUEwQixtQ0FBbUMsd0VBQXdFLFNBQVMsZ0NBQWdDLDRDQUE0QywrQkFBK0IsSUFBSSxhQUFhLGtCQUFrQixhQUFhLDJCQUEyQjtBQUNsZCxZQUFZLDhCQUE4Qiw4QkFBOEIscUNBQXFDLDJQQUEyUCxHQUFHLGFBQWEsWUFBWSxRQUFRLDJDQUEyQyxrQkFBa0IsaUJBQWlCO0FBQzFkLDZCQUE2QixNQUFNLE9BQU8sZ0JBQWdCLHNCQUFzQixtQkFBbUIsU0FBUyxRQUFRLDJCQUEyQixFQUFFLGlCQUFpQixvQkFBb0IsR0FBRywwQkFBMEIsd0JBQXdCLDJCQUEyQixLQUFLLGtDQUFrQyxLQUFLLDRCQUE0QixrQ0FBa0MsZ0NBQWdDLHdCQUF3QiwwQkFBMEIsR0FBRyx5QkFBeUIsSUFBSSx1QkFBdUIsSUFBSTtBQUM3Zix5QkFBeUIsNEJBQTRCLElBQUksS0FBSyxzQ0FBc0MsVUFBVSx5QkFBeUIsUUFBUSxvREFBb0Qsd0NBQXdDLFFBQVEsOEJBQThCLGNBQWMsMEJBQTBCLDhCQUE4QixjQUFjLFVBQVUsc0JBQXNCLE1BQU0sNkJBQTZCLGdCQUFnQix3QkFBd0Isc0JBQXNCO0FBQ3RlLHdCQUF3QixZQUFZLFlBQVksZ0JBQWdCLE1BQU0sU0FBUyxPQUFPLDBCQUEwQix1Q0FBdUMsRUFBRSxTQUFTLG1CQUFtQixvQkFBb0IsT0FBTyx1REFBdUQsb0JBQW9CLHdCQUF3QixTQUFTLG9CQUFvQiwwQkFBMEIsMEJBQTBCLG1CQUFtQixtQkFBbUIsNEJBQTRCLGdCQUFnQixHQUFHLEVBQUUsYUFBYSxLQUFLLGFBQWE7QUFDMWYsK0lBQStJLDBCQUEwQixvQkFBb0IsbUJBQW1CLDJGQUEyRiw0RUFBNEUsNkJBQTZCLGtCQUFrQixZQUFZLHdCQUF3QixtQkFBbUI7QUFDN2QsWUFBWSxPQUFPLHdFQUF3RSxnQ0FBZ0MsZUFBZSxpSUFBaUkseUJBQXlCLGtCQUFrQixLQUFLLHlCQUF5QixFQUFFLHlDQUF5QyxLQUFLLDZCQUE2QixFQUFFLEVBQUUsMENBQTBDLG1CQUFtQixFQUFFLHVCQUF1QjtBQUMzZiw2R0FBNkcsMEZBQTBGLGdDQUFnQyxrRUFBa0Usb0RBQW9ELGlEQUFpRCxLQUFLLHVEQUF1RCxFQUFFLHNCQUFzQixZQUFZO0FBQzllLEdBQUcsaUNBQWlDLFFBQVEsc0ZBQXNGLG9DQUFvQyxnRUFBZ0Usa0JBQWtCLG1DQUFtQyxnQkFBZ0IsZUFBZSxFQUFFLGVBQWUscUJBQXFCLG9GQUFvRix1Q0FBdUM7QUFDM2QsT0FBTyxtQkFBbUIsT0FBTyxFQUFFLEdBQUcseUJBQXlCLGtDQUFrQywyQkFBMkIseUJBQXlCLHdCQUF3QixpRUFBaUUsNkJBQTZCLE9BQU8seUJBQXlCLFFBQVEsdUNBQXVDLE9BQU8sa0ZBQWtGLEVBQUUsNEJBQTRCLGdCQUFnQixzQkFBc0I7QUFDdmYsd0JBQXdCLHVCQUF1QixlQUFlLEtBQUssRUFBRSwyQkFBMkIsMEJBQTBCLDZCQUE2QixPQUFPLFlBQVksRUFBRSwwQkFBMEIsOEpBQThKLE9BQU8sVUFBVSxLQUFLLHdCQUF3QixxQ0FBcUMsY0FBYyxlQUFlLHNCQUFzQixpQkFBaUI7QUFDM2YsV0FBVyxTQUFTLGdDQUFnQyxjQUFjLE9BQU8saUJBQWlCLGdDQUFnQyxhQUFhLE9BQU8sa0JBQWtCLEVBQUUsT0FBTyxHQUFHLFNBQVMsaUJBQWlCLFdBQVcsc0NBQXNDLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxhQUFhLG1IQUFtSCxnQkFBZ0Isb0RBQW9ELFNBQVM7QUFDaGUsdUNBQXVDLFdBQVcsa0RBQWtELDhFQUE4RSxlQUFlLGlDQUFpQyxNQUFNLFVBQVUsV0FBVyxHQUFHLDRDQUE0QywwQ0FBMEMsMEVBQTBFLGdCQUFnQixpQkFBaUI7QUFDamMsbUJBQW1CLHdCQUF3QixzQkFBc0IsaUJBQWlCLGNBQWMsb0VBQW9FLDJCQUEyQixrREFBa0QsWUFBWSw0RUFBNEUsb0RBQW9ELGdCQUFnQjtBQUM3WSxzREFBc0QsRUFBRSx1Q0FBdUMsNkZBQTZGLG1CQUFtQixtQkFBbUIsUUFBUSwwQkFBMEIsOEJBQThCLDJGQUEyRixZQUFZLEdBQUcsdUJBQXVCLHdCQUF3QixJQUFJO0FBQy9iLDhJQUE4SSx3QkFBd0Isa0JBQWtCLGFBQWEseURBQXlELE9BQU8sbURBQW1ELHVDQUF1QyxFQUFFLGdCQUFnQixxREFBcUQsbUJBQW1CLG9CQUFvQixxQ0FBcUMsdUNBQXVDO0FBQ3poQixpQkFBaUIsZ0NBQWdDLGNBQWMsc0JBQXNCLE1BQU0sWUFBWSwwQkFBMEIsTUFBTSxrQkFBa0IsV0FBVyw4Q0FBOEMsbUJBQW1CLHdCQUF3Qix5RUFBeUUsc0NBQXNDLElBQUksTUFBTSxlQUFlLHFCQUFxQixRQUFRLEtBQUs7QUFDdmEsMEhBQTBILDBEQUEwRCxpTUFBaU0sZUFBZSxZQUFZLHVDQUF1QywrREFBK0Q7QUFDdGYsd0JBQXdCLDJDQUEyQyxpQ0FBaUMsK0dBQStHLFVBQVUseUJBQXlCLG1CQUFtQixRQUFRLDJCQUEyQiwyQkFBMkIsb0JBQW9CLElBQUksd0RBQXdELGtCQUFrQiw0QkFBNEIsaUJBQWlCO0FBQ3RkLG1GQUFtRixzQ0FBc0MsMEZBQTBGLGdEQUFnRCxVQUFVLGVBQWUseUNBQXlDLHFDQUFxQyw4QkFBOEIsNERBQTRELHNDQUFzQztBQUMxZSxVQUFVLGdCQUFnQiwrQkFBK0IsMkJBQTJCLGtCQUFrQixrQ0FBa0MsNkJBQTZCLHlDQUF5QyxhQUFhLEVBQUUseUdBQXlHLGFBQWEseUJBQXlCLFVBQVUsb0NBQW9DLG1FQUFtRTtBQUM3ZCxLQUFLLGNBQWMscUtBQXFLLGtGQUFrRixRQUFRLHVCQUF1QixpQ0FBaUMsb0JBQW9CLEVBQUUsWUFBWSx5QkFBeUIsY0FBYyxXQUFXLGtCQUFrQixrQkFBa0IsY0FBYyxrQkFBa0IsZ0JBQWdCO0FBQ2xmLE1BQU0sc0JBQXNCLHdEQUF3RCxJQUFJLGdGQUFnRiw0QkFBNEIsdUJBQXVCLEVBQUUsR0FBRyxTQUFTLDZFQUE2RSw0QkFBNEIsdUJBQXVCLEVBQUUsS0FBSyxxQkFBcUIsNEJBQTRCLDRCQUE0QixrQ0FBa0MsWUFBWTtBQUMzZSwwR0FBMEcsK0hBQStILDhHQUE4RyxnQ0FBZ0MsMkJBQTJCLEVBQUUsU0FBUywyQkFBMkIsd0JBQXdCLDhCQUE4QixHQUFHLEVBQUU7QUFDbmYsT0FBTyxvQ0FBb0Msb0VBQW9FLE1BQU0sNERBQTRELFVBQVUsd0JBQXdCLCtJQUErSSw2QkFBNkIsT0FBTyxnQkFBZ0IsNEJBQTRCLHlCQUF5QixrQkFBa0I7QUFDN2QsMENBQTBDLHdCQUF3QixzQkFBc0IsRUFBRSwrSkFBK0osS0FBSyx1RUFBdUUsdUdBQXVHO0FBQzVhLHVFQUF1RSxLQUFLLHNCQUFzQixJQUFJLFNBQVMscUxBQXFMLFNBQVMscUJBQXFCLGlCQUFpQixhQUFhLDRKQUE0SiwyQkFBMkI7QUFDdmhCLHVEQUF1RCwyQkFBMkIsbUNBQW1DLFNBQVMsd0NBQXdDLE9BQU8sbUJBQW1CLHdCQUF3QiwyQ0FBMkMsd0JBQXdCLDRCQUE0QiwwQkFBMEIsY0FBYyxNQUFNLGVBQWUsUUFBUSxFQUFFLGVBQWUsTUFBTSxPQUFPLGtEQUFrRCxFQUFFLHlDQUF5QztBQUN2ZiwwQkFBMEIsc0NBQXNDLE1BQU0sRUFBRSw0QkFBNEIseUJBQXlCLEVBQUUsU0FBUywyQkFBMkIsdUVBQXVFLDJCQUEyQixXQUFXLFVBQVUsaUNBQWlDLEtBQUsscUZBQXFGLEVBQUUsMkJBQTJCLG1CQUFtQixFQUFFLFVBQVUsd0JBQXdCO0FBQ3plLG9CQUFvQixXQUFXLGNBQWMsOENBQThDLHVCQUF1QixpREFBaUQsZ0NBQWdDLDZEQUE2RCxXQUFXLFNBQVMsNEJBQTRCLHVCQUF1QiwrQkFBK0IsaURBQWlELDBCQUEwQjtBQUNqYixTQUFTLDRCQUE0QixnQ0FBZ0MsNENBQTRDLDJDQUEyQyw4QkFBOEIsc0JBQXNCLGlCQUFpQixPQUFPLHdCQUF3QixnQkFBZ0IsS0FBSyxVQUFVLEtBQUssYUFBYSxhQUFhLHlDQUF5QyxlQUFlLHdCQUF3Qix1Q0FBdUMsWUFBWSxxQ0FBcUMsYUFBYTtBQUNuZiwyRUFBMkUsd0JBQXdCLHVDQUF1QywwQkFBMEIsbUNBQW1DLE1BQU0sNEZBQTRGLFVBQVUsaUVBQWlFLGlCQUFpQixFQUFFLGtGQUFrRixpQkFBaUIsRUFBRTtBQUM1ZSxvREFBb0Qsa0JBQWtCLDJLQUEySztBQUNqUCxpSUFBaUksU0FBUywrRkFBK0YsUUFBUSxxR0FBcUcsT0FBTyxVQUFVLFdBQVcsMEJBQTBCLGtHQUFrRyxRQUFRO0FBQ3RmLHlDQUF5QyxXQUFXLHVDQUF1QyxlQUFlLFNBQVMsT0FBTyxxQ0FBcUMsU0FBUyx3RUFBd0UsaUJBQWlCLGtEQUFrRCw4Q0FBOEMsWUFBWSwwRUFBMEUsaUJBQWlCLGdCQUFnQixrQkFBa0IsZ0JBQWdCO0FBQzFmLDZCQUE2QiwrQ0FBK0MsdUVBQXVFLE9BQU8sb0JBQW9CLFVBQVUsWUFBWSxnREFBZ0QsUUFBUSw2RUFBNkUsVUFBVSxnRUFBZ0U7QUFDblosMkVBQTJFLDZLQUE2SyxVQUFVLGlFQUFpRSxZQUFZLDBCQUEwQixZQUFZLFlBQVksUUFBUSx3Q0FBd0M7QUFDamIscUJBQXFCLFVBQVUsc0RBQXNELGdEQUFnRCxRQUFRLGdEQUFnRCx5QkFBeUIseUJBQXlCLDBDQUEwQyxJQUFJLHlCQUF5Qix3QkFBd0IseUJBQXlCLGtEQUFrRCxJQUFJLEtBQUssYUFBYTtBQUMvYSwrQkFBK0IseUJBQXlCLFlBQVksV0FBVyxnQkFBZ0IsOEJBQThCLHVCQUF1QixrQkFBa0Isb0JBQW9CLG1MQUFtTCw4RUFBOEUsZUFBZSxjQUFjLHlCQUF5QjtBQUNqZix1RkFBdUYsRUFBRSxnQkFBZ0IsT0FBTywrSkFBK0oseUJBQXlCLDJFQUEyRSw0QkFBNEI7QUFDL1ksOERBQThELHlCQUF5QixxRUFBcUUsb0dBQW9HLHVMQUF1TCxZQUFZLHlDQUF5QztBQUM1ZSxzQ0FBc0MsK0JBQStCLCtEQUErRCxPQUFPLG9OQUFvTiw0Q0FBNEMsMkVBQTJFLFFBQVEsT0FBTztBQUNyZSwwR0FBMEcsa0NBQWtDLDZCQUE2Qiw2REFBNkQsT0FBTyxxQkFBcUIsbUNBQW1DLHlEQUF5RCxnQ0FBZ0MsZ0RBQWdEO0FBQzlhLG9FQUFvRSwyTEFBMkwsNEZBQTRGLGNBQWMsRUFBRSw0QkFBNEI7QUFDdlksTUFBTSxNQUFNLHVEQUF1RCwySEFBMkgsMEJBQTBCLDBCQUEwQixtRUFBbUUsR0FBRywrQkFBK0IscUdBQXFHLE1BQU07QUFDbGMsNFVBQTRVLHdCQUF3QixpSUFBaUksU0FBUztBQUM5ZSxHQUFHLDJCQUEyQix1QkFBdUIsMEJBQTBCLG9CQUFvQixvQkFBb0IsS0FBSyxrQkFBa0I7QUFDOUksc0NBQXNDLGlDQUFpQyxzQkFBc0IsZ0JBQWdCLHNCQUFzQiw0SEFBNEgsc0JBQXNCLGtCQUFrQixpREFBaUQsS0FBSztBQUM3Viw4QkFBOEIsc0JBQXNCLGlCQUFpQixzS0FBc0ssc0JBQXNCLDJEQUEyRCxLQUFLLHFEQUFxRCwyQkFBMkIsY0FBYyxnREFBZ0QscUNBQXFDO0FBQ3BmLE9BQU8sOEVBQThFLDZCQUE2Qix5QkFBeUIsUUFBUSxNQUFNLFFBQVEsY0FBYywwQkFBMEIsUUFBUSxLQUFLLFFBQVEsYUFBYSwyQkFBMkIsUUFBUSx1QkFBdUIsUUFBUSxZQUFZLHdCQUF3QixRQUFRLHVCQUF1QixRQUFRLFlBQVksb0JBQW9CLG1CQUFtQixVQUFVLG9DQUFvQyxZQUFZO0FBQ3JlLGlCQUFpQixzQkFBc0IsdURBQXVELGdCQUFnQiw0QkFBNEIsNkRBQTZELGdCQUFnQixvQkFBb0Isc0JBQXNCLHlCQUF5QixpQ0FBaUMsNkNBQTZDLHNDQUFzQyxvQkFBb0IsNkJBQTZCLDBCQUEwQjtBQUN6ZCxFQUFFLGtEQUFrRCx5QkFBeUIsV0FBVyxlQUFlLGdCQUFnQix1QkFBdUIsb0JBQW9CLFFBQVEsZ0RBQWdELGdCQUFnQixxQkFBcUIsWUFBWSxlQUFlLGtCQUFrQixXQUFXLFdBQVcscUVBQXFFLG1CQUFtQix5RkFBeUY7QUFDbmYsYUFBYSxnRUFBZ0Usa0JBQWtCLFNBQVMsRUFBRSw0Q0FBNEMsbURBQW1ELHdCQUF3QixtT0FBbU8sa0NBQWtDO0FBQ3RlLGtNQUFrTSxpQkFBaUIsY0FBYyw4QkFBOEIsdUJBQXVCLGdCQUFnQix5RkFBeUYscUZBQXFGLFNBQVMsOEJBQThCO0FBQzNmLGVBQWUsc0JBQXNCLHFDQUFxQywyQkFBMkIsK0JBQStCLHVCQUF1QixtREFBbUQsZ0NBQWdDLHNCQUFzQixxQ0FBcUMscUZBQXFGLFlBQVksOEZBQThGO0FBQ3hlLGlNQUFpTSxFQUFFLGlDQUFpQywrREFBK0QsbUJBQW1CLHdCQUF3QixtREFBbUQsZ0JBQWdCLG1CQUFtQiwyQ0FBMkM7QUFDL2MscURBQXFELFNBQVMsd0JBQXdCLCtEQUErRCx1QkFBdUIsK0RBQStELHFDQUFxQyxzSEFBc0gsY0FBYyxzQkFBc0IsK0NBQStDLFVBQVU7QUFDbmUsY0FBYyxvQkFBb0Isc0JBQXNCLGlIQUFpSCwrREFBK0Qsd0NBQXdDLDZCQUE2QixzQkFBc0IsU0FBUyx5QkFBeUIsUUFBUSxLQUFLLEVBQUUsVUFBVSxTQUFTLGVBQWUsSUFBSSxTQUFTLGtDQUFrQztBQUNyYyx3REFBd0QsZ0VBQWdFLDJEQUEyRCxFQUFFLG9JQUFvSSx3QkFBd0IsZUFBZSxlQUFlLDZCQUE2QixTQUFTLDhCQUE4Qix5REFBeUQ7QUFDNWUsdUdBQXVHLFVBQVUsa0NBQWtDLElBQUkseUNBQXlDLDBEQUEwRDtBQUMxUCxtREFBbUQsV0FBVyxXQUFXLHVCQUF1QixNQUFNLDhDQUE4QyxpRkFBaUYsc0RBQXNELEVBQUUsU0FBUyxxQkFBcUIsd0VBQXdFLDJCQUEyQiw2RUFBNkU7QUFDM2UsaUJBQWlCLG1DQUFtQyxTQUFTLHdCQUF3QixXQUFXLHdHQUF3RyxrQkFBa0IsK0RBQStELHlCQUF5QixNQUFNLHNFQUFzRSxFQUFFLEdBQUcsZ0NBQWdDO0FBQ25hLHVCQUF1QixnR0FBZ0csNERBQTRELDJCQUEyQixnQkFBZ0IsZ0VBQWdFLDhJQUE4SSxtQkFBbUI7QUFDL2IsU0FBUyxpQ0FBaUMsc0JBQXNCLHlCQUF5QiwyQkFBMkIsNkJBQTZCLCtOQUErTiw4QkFBOEIscUJBQXFCLHFCQUFxQjtBQUN4YixrTkFBa04sOEhBQThILDJHQUEyRyxxQkFBcUIsbUNBQW1DO0FBQ25mLGlJQUFpSSxnREFBZ0QsZ0RBQWdELDRDQUE0QyxnREFBZ0QsdUdBQXVHO0FBQ3BhLDRJQUE0SSw4QkFBOEIsa0RBQWtELEVBQUUseUJBQXlCLHFEQUFxRCxzRkFBc0YseUVBQXlFO0FBQzNjLHlDQUF5QyxzS0FBc0ssK0NBQStDLHdCQUF3Qiw2QkFBNkIsd0ZBQXdGLGlHQUFpRztBQUM1ZSx3RkFBd0YseUhBQXlILGtDQUFrQztBQUNuUCxrSkFBa0osNEJBQTRCLHNCQUFzQixvR0FBb0csMkJBQTJCLG9EQUFvRCxtQkFBbUIsK0JBQStCLFVBQVUsZ0JBQWdCLFdBQVcsZ0JBQWdCLFVBQVU7QUFDeGUsR0FBRyxTQUFTLHFDQUFxQywwQkFBMEIsUUFBUSxrQkFBa0IsNkdBQTZHLHdFQUF3RSxvQ0FBb0MsRUFBRSxTQUFTLDBCQUEwQix3REFBd0Q7QUFDM1osR0FBRyxzREFBc0QsK0JBQStCLGtCQUFrQiw2QkFBNkIsaUdBQWlHLFFBQVEsS0FBSyxXQUFXLDRCQUE0Qix5QkFBeUIsdUJBQXVCLHlEQUF5RCxTQUFTLGlCQUFpQixJQUFJLG1EQUFtRCwwQkFBMEIscUJBQXFCO0FBQ3JnQixFQUFFLHFCQUFxQixxQkFBcUIsNEJBQTRCLG1CQUFtQixnQ0FBZ0MsMEJBQTBCLGtEQUFrRCxFQUFFO0FBQ3pNLHVHQUF1RyxpQ0FBaUMscUJBQXFCLFVBQVUsdUJBQXVCLGdCQUFnQixFQUFFLE9BQU8sWUFBWSxFQUFFLCtCQUErQixZQUFZLFlBQVksY0FBYyxlQUFlLEVBQUUsb0JBQW9CLG1HQUFtRztBQUNsYixxSEFBcUgsZUFBZSxFQUFFLFNBQVMsd0JBQXdCO0FBQ3ZLLDJGQUEyRiw4QkFBOEIsNEJBQTRCLDJCQUEyQixlQUFlLHdCQUF3QixnQ0FBZ0MsT0FBTyxpSkFBaUosMEJBQTBCO0FBQ3phLGdDQUFnQyxpQ0FBaUMsNEJBQTRCLGdDQUFnQyx3REFBd0Qsc0JBQXNCLGtGQUFrRix1REFBdUQseUJBQXlCLG1EQUFtRDtBQUNoYSxvQ0FBb0MscUJBQXFCLGtNQUFrTSxRQUFRLHFCQUFxQixZQUFZLHdHQUF3RyxNQUFNLG1HQUFtRztBQUNyZixtQkFBbUIsb0JBQW9CLDBCQUEwQixTQUFTLHlCQUF5QixnSUFBZ0ksbUhBQW1ILDJCQUEyQjtBQUNqWCxvQ0FBb0MsaUVBQWlFLDBDQUEwQyxnQkFBZ0IsNkNBQTZDLEVBQUUsc0JBQXNCLG1GQUFtRixlQUFlLGFBQWEsMENBQTBDLFFBQVEsNEVBQTRFLG9CQUFvQjtBQUNyZSxVQUFVLGFBQWEsOERBQThELHdCQUF3QixFQUFFLGdCQUFnQixnRUFBZ0UsaUNBQWlDLDRGQUE0RixnQkFBZ0Isd0JBQXdCLCtFQUErRSxFQUFFLG9FQUFvRTtBQUN6ZixtQkFBbUIsNkVBQTZFLHNCQUFzQiw4RUFBOEUseUNBQXlDLHdDQUF3QyxFQUFFLDJEQUEyRCw4REFBOEQsd0NBQXdDO0FBQ3hiLHlCQUF5QixrREFBa0QsZUFBZSxFQUFFLG9DQUFvQywwQkFBMEIsaUJBQWlCLHdDQUF3QyxzQkFBc0I7QUFDek8sY0FBYyxrQ0FBa0MsdUNBQXVDLDRDQUE0Qyx1QkFBdUIsd0dBQXdHLG1CQUFtQiwyR0FBMkcsbUJBQW1CLDBFQUEwRTtBQUM3ZCxHQUFHLG9CQUFvQix5REFBeUQsbUJBQW1CLDZEQUE2RCxrQ0FBa0MsMkZBQTJGLFlBQVksWUFBWSxFQUFFLHNLQUFzSyxlQUFlO0FBQzVlLG1CQUFtQiw4QkFBOEIsU0FBUyxvREFBb0QsZ0JBQWdCLGdEQUFnRCx5QkFBeUIsc0ZBQXNGLDJDQUEyQyw0QkFBNEIseUJBQXlCLHlCQUF5QjtBQUN0WixnQ0FBZ0MsV0FBVyw4SEFBOEgsdUJBQXVCLGtJQUFrSSw2RUFBNkUsR0FBRyw2QkFBNkI7QUFDL2Esd0xBQXdMLDBDQUEwQyxnR0FBZ0csT0FBTyxnRUFBZ0UsNkJBQTZCLCtEQUErRDtBQUNyZSxZQUFZLG9DQUFvQyx1QkFBdUIsMEJBQTBCLDBFQUEwRSw4R0FBOEcsbUJBQW1CO0FBQzVTLDhEQUE4RCxxQkFBcUIsYUFBYSxzQkFBc0IsZ0JBQWdCLGNBQWMsRUFBRSxFQUFFLDhGQUE4RixxQkFBcUIsK0JBQStCLGtCQUFrQix3R0FBd0csbUNBQW1DO0FBQ3ZjLG1EQUFtRCxrQ0FBa0MsaUNBQWlDLDJFQUEyRSx1QkFBdUIscUJBQXFCLHNCQUFzQix3QkFBd0Isa0JBQWtCLHVEQUF1RCxFQUFFLGFBQWEsZUFBZSxJQUFJLGdFQUFnRSw4QkFBOEIsRUFBRTtBQUN0ZSxtQkFBbUIsb0NBQW9DLHdDQUF3QyxpSEFBaUgsb0NBQW9DLGFBQWEsbUJBQW1CLGtFQUFrRSxXQUFXLEdBQUcsMEJBQTBCLGFBQWEsRUFBRSx5RkFBeUY7QUFDdGUsd0JBQXdCLFFBQVEsa0JBQWtCLEtBQUssVUFBVSxFQUFFLHNEQUFzRCxLQUFLLEVBQUUsb0JBQW9CLElBQUksZ0JBQWdCLG1HQUFtRyw0QkFBNEIsRUFBRSx1R0FBdUcsa0JBQWtCLG1DQUFtQyxFQUFFLDZCQUE2QjtBQUNwZSw4QkFBOEIsZ0NBQWdDLG9hQUFvYSxxQkFBcUI7QUFDdmYsUUFBUSw2RkFBNkYsdUJBQXVCLHNCQUFzQixrQkFBa0IsSUFBSSx1QkFBdUIsMkJBQTJCLDZEQUE2RCwwQkFBMEIsK0JBQStCLEVBQUUsZ0JBQWdCLElBQUksYUFBYTtBQUNuWCx1QkFBdUIsMkNBQTJDLGFBQWEsK0ZBQStGLFNBQVMsMEVBQTBFLCtFQUErRSxrRkFBa0YsMkVBQTJFO0FBQzdlLDRDQUE0QyxvR0FBb0csdUNBQXVDLHNFQUFzRSx1QkFBdUIsb0JBQW9CLDJDQUEyQyw2SUFBNkksY0FBYyxRQUFRO0FBQ3RmLEVBQUUsZ0tBQWdLLFVBQVUseUNBQXlDLHdEQUF3RCxFQUFFLFlBQVksNkJBQTZCLEVBQUUsVUFBVSxvREFBb0Q7QUFDeFgsaUZBQWlGLGdCQUFnQix1QkFBdUIsUUFBUSxtRkFBbUYsS0FBSywrQkFBK0IsOENBQThDLE9BQU8sb0NBQW9DLEtBQUssYUFBYSx5RUFBeUUsa0RBQWtEO0FBQzdkLG1DQUFtQyxrQ0FBa0MsOERBQThELHNHQUFzRyxVQUFVLHVCQUF1QixRQUFRLDBFQUEwRTtBQUM1VixvR0FBb0cseUJBQXlCLFVBQVUsZ0NBQWdDLDhCQUE4QixnQ0FBZ0MsdUJBQXVCLEtBQUssZUFBZSw0R0FBNEcsK0JBQStCLFlBQVksa0NBQWtDLDRCQUE0QixrQkFBa0I7QUFDdmYsb0tBQW9LLGlFQUFpRSxLQUFLLG9EQUFvRCxnQ0FBZ0MsTUFBTSxnQ0FBZ0Msb0lBQW9JLFdBQVc7QUFDbmYsTUFBTSxnR0FBZ0cseUNBQXlDLDRDQUE0QyxxQ0FBcUMsWUFBWSx3QkFBd0IsSUFBSSxrQ0FBa0MsbUJBQW1CLGtCQUFrQixFQUFFLDhCQUE4QixJQUFJLDBDQUEwQyxnRUFBZ0U7QUFDN2QsNkVBQTZFLDJDQUEyQyxTQUFTLCtCQUErQiw0Q0FBNEMsT0FBTyx3SEFBd0gsb0ZBQW9GLDBCQUEwQiwwQkFBMEIsT0FBTyxPQUFPLGNBQWM7QUFDL2UsMkJBQTJCLEVBQUUsU0FBUyxvQkFBb0Isb0NBQW9DLGlCQUFpQixVQUFVLHNCQUFzQiw4QkFBOEIsbUdBQW1HLGlEQUFpRCw4S0FBOEssU0FBUztBQUN4Zix3QkFBd0IsNkNBQTZDLHlCQUF5Qiw2Q0FBNkMsaUNBQWlDLGlFQUFpRSxvRUFBb0UsU0FBUyxrQ0FBa0MsOEVBQThFLElBQUksNkJBQTZCO0FBQzNjLGdDQUFnQyxlQUFlLElBQUksd0JBQXdCLEVBQUUsNEJBQTRCLDZCQUE2Qiw0QkFBNEIsOEJBQThCLEVBQUUsT0FBTyxhQUFhLGtJQUFrSSxxQkFBcUIsaUNBQWlDLHFCQUFxQixtQkFBbUIsYUFBYSxlQUFlLG1CQUFtQixVQUFVO0FBQy9lLGlCQUFpQixnQ0FBZ0MsaUNBQWlDLHdCQUF3QixnQ0FBZ0MsY0FBYyxtREFBbUQsRUFBRSxxQkFBcUIseUNBQXlDLDBJQUEwSSxtQ0FBbUMsbUJBQW1CLG9EQUFvRDtBQUMvZixpQkFBaUIsU0FBUyxTQUFTLGtCQUFrQixvQkFBb0IsZUFBZSwrQ0FBK0MsMkNBQTJDLG9CQUFvQiw4Q0FBOEMsZ0ZBQWdGLDZCQUE2QixrQ0FBa0Msd0JBQXdCO0FBQzNaLGlDQUFpQyxLQUFLLDhHQUE4RyxFQUFFLHFCQUFxQixnRkFBZ0YsbUJBQW1CLE1BQU0sa0JBQWtCLFdBQVcsNkJBQTZCLGtDQUFrQyw0Q0FBNEMsbUNBQW1DLGNBQWMsS0FBSyx5QkFBeUI7QUFDM2Usa0RBQWtELE9BQU8sa0JBQWtCLDBHQUEwRyxvQkFBb0IsaUJBQWlCLGlCQUFpQiw4QkFBOEIsa0VBQWtFLDhHQUE4Ryx1QkFBdUIsNkJBQTZCO0FBQzdlLG9CQUFvQiwwUEFBMFAsOEJBQThCLEtBQUssZUFBZSxxQkFBcUIseUNBQXlDLHlDQUF5QyxjQUFjLHFCQUFxQixNQUFNO0FBQ2hkLFlBQVksU0FBUyxlQUFlLFFBQVEsSUFBSSxJQUFJLElBQUksY0FBYyw2RUFBNkUsOEJBQThCLElBQUksU0FBUyw4QkFBOEIsNkJBQTZCLHlDQUF5QywrQkFBK0IsZ0RBQWdELFNBQVMsdUJBQXVCLGlDQUFpQyxNQUFNLHFDQUFxQyxvQkFBb0I7QUFDamYsOE1BQThNLG9CQUFvQiwyQkFBMkIsS0FBSyx5QkFBeUIsNktBQTZLLFVBQVU7QUFDbGQsMEJBQTBCLGtDQUFrQyxVQUFVLDRCQUE0Qiw4R0FBOEcsa0RBQWtELHVCQUF1QixnRUFBZ0Usc0JBQXNCLDJCQUEyQixvRkFBb0Y7QUFDOWQsY0FBYyxXQUFXLFdBQVcsOEJBQThCLHVDQUF1QywyREFBMkQseUZBQXlGLHlJQUF5SSxVQUFVLGNBQWMsUUFBUSxPQUFPLEVBQUUsZ0NBQWdDLGNBQWM7QUFDN2QsOEhBQThILFlBQVksOERBQThELGFBQWEsUUFBUSxxR0FBcUcsR0FBRyxFQUFFLGtCQUFrQiwrQkFBK0IsZ0JBQWdCLHlCQUF5QixXQUFXO0FBQzVhLGtLQUFrSyxFQUFFLEVBQUUsNEJBQTRCLCtHQUErRyxtRkFBbUYsaUNBQWlDLHNDQUFzQywrQ0FBK0M7QUFDMWYsZ0JBQWdCLFlBQVksNkRBQTZELFNBQVMsTUFBTSxXQUFXLElBQUksTUFBTSxrRUFBa0Usa0JBQWtCLFlBQVksU0FBUyxnQ0FBZ0MseUJBQXlCLDZCQUE2QiwwRUFBMEUsNENBQTRDLDBCQUEwQixXQUFXO0FBQ3ZkLHFFQUFxRSxzQ0FBc0MscUJBQXFCLFVBQVUsSUFBSSxnQkFBZ0IsSUFBSSxZQUFZLGlCQUFpQixFQUFFLDJCQUEyQix1QkFBdUIsOEJBQThCLCtFQUErRSxJQUFJLEtBQUssYUFBYTtBQUN0WCx1REFBdUQsd0JBQXdCLGdCQUFnQixxQkFBcUIsbUJBQW1CLGVBQWUsYUFBYSwwREFBMEQsa0JBQWtCLHVCQUF1Qix1RkFBdUYsb0JBQW9CLHdCQUF3QixpRUFBaUU7QUFDMWMseUJBQXlCLHlCQUF5Qix5QkFBeUIsMEJBQTBCLGtCQUFrQix5QkFBeUIsUUFBUSxhQUFhLGtDQUFrQyxxRUFBcUUsa0RBQWtELDZGQUE2RixZQUFZLDBDQUEwQyxFQUFFLDRCQUE0QjtBQUMvZSxDQUFDLG1CQUFtQiw4QkFBOEIsbUNBQW1DLHFEQUFxRCxFQUFFLEVBQUUsU0FBUyxvQ0FBb0MsTUFBTSxnQkFBZ0IsMkVBQTJFLHFCQUFxQjtBQUNqVCxxQkFBcUIsU0FBUyxFQUFFLFNBQVMsK0JBQStCLFdBQVcsVUFBVSxNQUFNLDBCQUEwQixTQUFTLDRDQUE0QyxtQ0FBbUMsa0JBQWtCLHdEQUF3RCxFQUFFLDZDQUE2QyxvQ0FBb0MsV0FBVyxZQUFZLG9EQUFvRDtBQUM3YixzQkFBc0IsRUFBRSxtREFBbUQsa0RBQWtELGdHQUFnRyxrQkFBa0IseUJBQXlCLGlCQUFpQixFQUFFLDJCQUEyQixjQUFjLE9BQU8sMENBQTBDLCtCQUErQjtBQUNwWiwyRUFBMkUsZ0JBQWdCLG9EQUFvRCwyQkFBMkIseUNBQXlDLGdDQUFnQyxrQ0FBa0MsRUFBRSxvQkFBb0Isb0JBQW9CLEVBQUUscUNBQXFDLHNEQUFzRCw4QkFBOEIsZ0JBQWdCLGVBQWUsc0JBQXNCO0FBQy9lLGtDQUFrQyx1QkFBdUIsc0JBQXNCLEdBQUcsOEZBQThGLDJCQUEyQixzQ0FBc0MsR0FBRyxxQkFBcUIsc0RBQXNELDRCQUE0QixTQUFTLDZDQUE2QyxFQUFFLHFCQUFxQjtBQUN4YSxnQkFBZ0IseUJBQXlCLCtDQUErQyxFQUFFLHlFQUF5RSxxQ0FBcUMsSUFBSSxLQUFLLG9CQUFvQixtQkFBbUIsYUFBYSxFQUFFLG9CQUFvQixhQUFhLGlFQUFpRSxxQkFBcUIsa0JBQWtCLEVBQUUsNkNBQTZDLDJCQUEyQixtQkFBbUI7QUFDN2UsWUFBWSxvQkFBb0IsbUxBQW1MLEVBQUUsOEJBQThCLHVCQUF1QixpQkFBaUIscUJBQXFCLGlCQUFpQixzQ0FBc0Msc0NBQXNDLGtCQUFrQjtBQUMvWixpSkFBaUosaVNBQWlTO0FBQ2xiLFNBQVMsNkJBQTZCLGdDQUFnQyx3QkFBd0IsaUNBQWlDLDBDQUEwQyxrQkFBa0IsMENBQTBDLHlCQUF5QixPQUFPLGtDQUFrQyxnSkFBZ0osMkNBQTJDO0FBQ2xlLE9BQU8sNEJBQTRCLFlBQVksMEdBQTBHLGdCQUFnQiwyQ0FBMkMsRUFBRSxNQUFNLG1DQUFtQyxjQUFjLGFBQWEsUUFBUSxFQUFFLG9EQUFvRCxzQkFBc0IsbUJBQW1CLGlCQUFpQjtBQUNsWixJQUFJLGtDQUFrQyxvQkFBb0IsbUJBQW1CLHFDQUFxQyxrQkFBa0IsK0JBQStCLDJEQUEyRCxpQ0FBaUMsc0NBQXNDLHNCQUFzQixzSEFBc0gsbUNBQW1DLDJCQUEyQjtBQUMvZSwrREFBK0Qsa0NBQWtDLGlCQUFpQiwwR0FBMEcsb0JBQW9CLGlCQUFpQiwwQ0FBMEMsMklBQTJJLHVCQUF1QixVQUFVLEVBQUUsRUFBRSxtQkFBbUI7QUFDOWUsc0JBQXNCLG1EQUFtRCxnQkFBZ0IsK0JBQStCLDZCQUE2QiwrQkFBK0Isc0JBQXNCLHdLQUF3Syw4QkFBOEIseURBQXlELG9CQUFvQjtBQUM3ZCwrQ0FBK0MsUUFBUSxtSUFBbUkseUJBQXlCLGlEQUFpRCwwQkFBMEIsMkJBQTJCLDBCQUEwQiwyQkFBMkIsc0JBQXNCLHVCQUF1QiwwQ0FBMEM7QUFDcmMsd0NBQXdDLDJCQUEyQiwyQkFBMkIsMEJBQTBCLHlEQUF5RCxvQkFBb0IsZ0RBQWdELHFDQUFxQywwREFBMEQsb0dBQW9HLGdDQUFnQyw2QkFBNkI7QUFDcmYsS0FBSyxJQUFJLEtBQUssYUFBYSw2REFBNkQsdUJBQXVCLHFDQUFxQywyREFBMkQsNERBQTRELG1EQUFtRDtBQUM5VCw4QkFBOEIsYUFBYSx5REFBeUQsWUFBWSxvQ0FBb0MsSUFBSSxJQUFJLG1EQUFtRCw0REFBNEQscUJBQXFCLFVBQVUsT0FBTyxPQUFPLHFDQUFxQyw2QkFBNkIsbUJBQW1CO0FBQzdZLElBQUksOEZBQThGLHNCQUFzQix1Q0FBdUMsZ0JBQWdCLHNCQUFzQixFQUFFLHlDQUF5QyxNQUFNLGlDQUFpQywrRkFBK0Ysa0JBQWtCO0FBQ3hZLDRCQUE0QixzQ0FBc0MsaUNBQWlDLGdIQUFnSCxtQkFBbUIsaUhBQWlILHFCQUFxQixxQkFBcUIsMkRBQTJELGlCQUFpQixFQUFFLDBCQUEwQjtBQUN6ZSx5VUFBeVUsbUNBQW1DLG1CQUFtQixpQkFBaUIsa0NBQWtDLGNBQWMsZ0NBQWdDO0FBQ2hlLHNDQUFzQyxFQUFFLEtBQUssYUFBYSw2R0FBNkcsb0RBQW9ELFFBQVEsaUNBQWlDLFNBQVMsbUJBQW1CLGdCQUFnQiwyQkFBMkIsUUFBUSw0Q0FBNEMsRUFBRSxFQUFFLFNBQVMscUJBQXFCO0FBQ2phLDJDQUEyQywyREFBMkQsSUFBSSxlQUFlLG1DQUFtQyxxREFBcUQsZ0JBQWdCLG9EQUFvRCxFQUFFLG9DQUFvQyxtREFBbUQsZ0JBQWdCLDZCQUE2QiwrREFBK0QsRUFBRSxpQ0FBaUM7QUFDN2YsNENBQTRDLHNCQUFzQixFQUFFLDJCQUEyQixvRkFBb0Ysb0ZBQW9GLDJEQUEyRCxFQUFFLHFDQUFxQyxpQkFBaUIsNkJBQTZCLGdEQUFnRCxFQUFFLEVBQUUseUNBQXlDO0FBQ3BmLDREQUE0RCxFQUFFLG9DQUFvQyxzQkFBc0IsYUFBYSxHQUFHLEtBQUssYUFBYSxtS0FBbUssdUJBQXVCLGdCQUFnQixvQkFBb0IsbUJBQW1CLGFBQWEsbUJBQW1CLDhEQUE4RCxpQ0FBaUMsR0FBRztBQUM3Z0IsdUJBQXVCLHFCQUFxQixlQUFlLDJCQUEyQix5REFBeUQsc0NBQXNDLGVBQWUsc0JBQXNCLG9DQUFvQyxxQ0FBcUMsY0FBYyxzQkFBc0IsaUJBQWlCLHNDQUFzQyxlQUFlLGdDQUFnQyxvQkFBb0IsNEJBQTRCO0FBQzdkLDZDQUE2Qyx5S0FBeUssUUFBUSxVQUFVLGVBQWUsRUFBRSxXQUFXLFNBQVMsRUFBRSwwRUFBMEUsMEJBQTBCLDRGQUE0RjtBQUMvYyw4QkFBOEIsaUJBQWlCLHlCQUF5QixpQkFBaUIsdUVBQXVFLDRCQUE0QixFQUFFLGlCQUFpQixvQkFBb0IsY0FBYyxxQ0FBcUMsaUNBQWlDLG9DQUFvQyxFQUFFLGtFQUFrRSxrQkFBa0IsZ0NBQWdDO0FBQ2pkLDBEQUEwRCwrQ0FBK0MsbUJBQW1CLDRCQUE0QiwyRkFBMkYsR0FBRyxHQUFHLHdCQUF3QixnREFBZ0QsOEhBQThILFNBQVM7QUFDeGMsNERBQTRELGFBQWEsR0FBRyxtQkFBbUIscUJBQXFCLG1CQUFtQixtQkFBbUIsc0VBQXNFLEVBQUUsd0JBQXdCO0FBQzFQLHFMQUFxTCxxS0FBcUssU0FBUywwR0FBMEcsZ0NBQWdDO0FBQzdlLGlTQUFpUywrQkFBK0IsZ0JBQWdCLG1EQUFtRCxFQUFFLGdCQUFnQixjQUFjLDZEQUE2RDtBQUNoZSw2QkFBNkIsNEhBQTRILGdEQUFnRCw4QkFBOEIsb0RBQW9ELHlDQUF5QywwREFBMEQscUZBQXFGLHdCQUF3QixTQUFTO0FBQ3BmLFlBQVksbUJBQW1CLGdIQUFnSCxFQUFFLFNBQVMsNkJBQTZCLGlHQUFpRywwRkFBMEY7QUFDbFgsV0FBVyxFQUFFLG1CQUFtQixvRkFBb0YsVUFBVSx1QkFBdUIsZ0JBQWdCLGNBQWMsa0NBQWtDLFNBQVMsbUNBQW1DLFNBQVMsa0RBQWtELGdCQUFnQixrQkFBa0Isa0JBQWtCLGtGQUFrRixFQUFFLHdCQUF3QixhQUFhO0FBQ3plLFdBQVcsbUJBQW1CLGdCQUFnQixnQkFBZ0IsRUFBRSw2QkFBNkIsNkNBQTZDLHNCQUFzQixLQUFLLDZEQUE2RCxpQkFBaUIscUJBQXFCLFFBQVEsb0ZBQW9GLG1CQUFtQixnREFBZ0QseUJBQXlCLCtCQUErQixxQkFBcUI7QUFDcGYsRUFBRSxpQkFBaUIsZ0JBQWdCLGtCQUFrQixFQUFFLGdCQUFnQixpQkFBaUIsbUJBQW1CLHdDQUF3Qyw0QkFBNEIsNlFBQTZRLDRCQUE0QixTQUFTO0FBQ2plLHVCQUF1QixtR0FBbUcsd0VBQXdFLHFCQUFxQixXQUFXLHNKQUFzSiwwQkFBMEIsNENBQTRDLGVBQWU7QUFDN2MsT0FBTyx3Q0FBd0MsYUFBYSxrR0FBa0csU0FBUyw2RUFBNkUsZUFBZSxvS0FBb0ssY0FBYywrRUFBK0UsYUFBYTtBQUNqaEIsbUJBQW1CLFNBQVMsc0JBQXNCLDRCQUE0QixxQkFBcUIsNEVBQTRFLFdBQVcsaURBQWlELCtFQUErRSxnQkFBZ0IsOEVBQThFLFVBQVUsYUFBYSxrQkFBa0I7QUFDamMsK0JBQStCLGdCQUFnQix5Q0FBeUMsT0FBTyxpQ0FBaUMsa0JBQWtCLHlDQUF5QyxPQUFPLGlDQUFpQyx3REFBd0QsYUFBYSxtREFBbUQscUJBQXFCLDRCQUE0Qiw4Q0FBOEM7QUFDMWIseUdBQXlHLFNBQVMscUJBQXFCLDRCQUE0Qiw4R0FBOEcsNENBQTRDLE1BQU0sR0FBRywrQkFBK0IsdUNBQXVDLHNGQUFzRjtBQUNsZSxxRUFBcUUsaUJBQWlCLDBIQUEwSCxvR0FBb0csd0JBQXdCLCtCQUErQixJQUFJLGNBQWMsRUFBRSxLQUFLLGFBQWE7QUFDalosd1ZBQXdWLG9DQUFvQyx3QkFBd0IscUJBQXFCLGVBQWUsZ0NBQWdDO0FBQ3hkLGtEQUFrRCxxQkFBcUIsb0JBQW9CLHVDQUF1QyxjQUFjLFNBQVMsOEVBQThFLG1GQUFtRixvQkFBb0IsbUJBQW1CLFVBQVUsV0FBVyxlQUFlLGdCQUFnQixhQUFhLElBQUksT0FBTyxnQkFBZ0Isa0JBQWtCLGVBQWUsYUFBYTtBQUMzZSxHQUFHLG1DQUFtQyxXQUFXLGlCQUFpQixVQUFVLGVBQWUscUJBQXFCLFNBQVMsRUFBRSxXQUFXLFdBQVcsOENBQThDLGdCQUFnQix3QkFBd0IseUJBQXlCLDJEQUEyRCxRQUFRLGVBQWUsU0FBUyx5QkFBeUIsa0JBQWtCLFdBQVcsV0FBVyx1RUFBdUU7QUFDbmUsS0FBSyxZQUFZLFFBQVEseURBQXlELG9CQUFvQixzS0FBc0ssMkNBQTJDLHVCQUF1QiwyQkFBMkIsb0JBQW9CLGVBQWUsSUFBSSxpREFBaUQsS0FBSyxNQUFNLG9CQUFvQixJQUFJO0FBQ3BlLGVBQWUsZ0JBQWdCLG1GQUFtRixrQ0FBa0MsRUFBRSx5REFBeUQsb0JBQW9CLG1CQUFtQixnQkFBZ0IsYUFBYSxFQUFFLGtCQUFrQixvQkFBb0Isa0JBQWtCLGtCQUFrQixzQkFBc0IsNENBQTRDLHVEQUF1RCxtQkFBbUIsR0FBRztBQUM5ZSxXQUFXLEdBQUcsdUJBQXVCLGtCQUFrQixnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFLGVBQWUsU0FBUyxpQkFBaUIsaUJBQWlCLDZCQUE2QixnQkFBZ0IsU0FBUyxFQUFFLGlCQUFpQixjQUFjLDZDQUE2QyxzQkFBc0IsbUNBQW1DLFFBQVEsZUFBZSwyQkFBMkIsU0FBUyxvQkFBb0I7QUFDdGMsRUFBRSx5QkFBeUIsRUFBRSxrQkFBa0IsVUFBVSxTQUFTLEVBQUUsa0JBQWtCLFVBQVUsRUFBRSxjQUFjLGdCQUFnQixXQUFXLEVBQUUsOEJBQThCLFNBQVMsMEJBQTBCLG9DQUFvQyxrQkFBa0IsR0FBRyxFQUFFLFNBQVMsOEJBQThCLGlDQUFpQyxrQkFBa0IsRUFBRSwwQkFBMEIseUJBQXlCLGFBQWEsT0FBTyxrREFBa0QsWUFBWTtBQUMxZSxHQUFHLE9BQU8saUJBQWlCLGVBQWUsaURBQWlELHlCQUF5QixPQUFPLDJCQUEyQixpRUFBaUUseURBQXlELGdDQUFnQyx1QkFBdUIsb0JBQW9CLEVBQUUsa0JBQWtCLDBCQUEwQiw0Q0FBNEMsbUNBQW1DO0FBQ3hkLHVDQUF1QyxNQUFNLHFEQUFxRCw0Q0FBNEMsV0FBVyxNQUFNLGdHQUFnRyxPQUFPLHVCQUF1QixtQkFBbUIsbUdBQW1HLHlCQUF5Qiw4REFBOEQ7QUFDMWUsY0FBYywyQ0FBMkMsd0RBQXdELDRGQUE0Riw4QkFBOEIsb0JBQW9CLFVBQVUsV0FBVywySUFBMkksVUFBVSxXQUFXLEVBQUU7QUFDdGIsK0RBQStELHdFQUF3RSxJQUFJLGtDQUFrQyw4R0FBOEcsZUFBZSxxQkFBcUIsMEJBQTBCLHlEQUF5RCx5QkFBeUIsbUNBQW1DLGdCQUFnQixzQkFBc0I7QUFDcGYsNkJBQTZCLDRDQUE0QyxrQkFBa0Isa0NBQWtDLDZDQUE2Qyx3Q0FBd0MsZUFBZSxvREFBb0Qsb0JBQW9CLGtCQUFrQixtQkFBbUIsS0FBSyw2SkFBNko7QUFDaGYsMEJBQTBCLEtBQUssTUFBTSw0QkFBNEIsZ0dBQWdHLCtCQUErQixnQ0FBZ0Msb0NBQW9DLHdCQUF3QixvREFBb0Qsb0JBQW9CLG9GQUFvRixvREFBb0Q7QUFDNWUsc0ZBQXNGLHlEQUF5RCx5QkFBeUIsMkJBQTJCLCtDQUErQywyQ0FBMkMseUJBQXlCLEVBQUUsa0JBQWtCLHNCQUFzQixFQUFFLGlCQUFpQixvQkFBb0I7QUFDdlksZUFBZSw0Q0FBNEMsMEdBQTBHLHlDQUF5QyxVQUFVLG1CQUFtQixxQkFBcUIsdUJBQXVCLGFBQWEsMkJBQTJCLFlBQVksRUFBRSxpQkFBaUIseUJBQXlCLHdCQUF3QixnQkFBZ0Isb0JBQW9CLCtCQUErQiw2QkFBNkI7QUFDL2UsNkJBQTZCLHVDQUF1QyxpQkFBaUIsb0JBQW9CLHFCQUFxQixrREFBa0QsSUFBSSxtQkFBbUIsd0NBQXdDLHFCQUFxQixhQUFhLGFBQWEsRUFBRSxtQkFBbUIsZ0JBQWdCLGlCQUFpQixlQUFlLFlBQVksc0JBQXNCLGNBQWMsYUFBYSxtQ0FBbUMsZUFBZSxFQUFFLGdCQUFnQiwwQkFBMEIsY0FBYztBQUM1Z0IsUUFBUSwwQkFBMEIseUlBQXlJLDBDQUEwQyx3Q0FBd0MsOERBQThELGdFQUFnRSxxQkFBcUIscUJBQXFCLDBDQUEwQyw4QkFBOEI7QUFDN2Usc0NBQXNDLHdCQUF3QiwwQkFBMEIsdUNBQXVDLGtCQUFrQixrQkFBa0IsY0FBYyxzR0FBc0csMkJBQTJCLGdCQUFnQix1QkFBdUIsRUFBRSx5QkFBeUIsNkJBQTZCLG1DQUFtQyw4QkFBOEI7QUFDbGQsR0FBRyx1QkFBdUIsRUFBRSxFQUFFLGtCQUFrQixpQ0FBaUMsRUFBRSx1QkFBdUIsZ0JBQWdCLHlCQUF5QjtBQUNuSixzRkFBc0YsbUJBQW1CLG1CQUFtQixHQUFHLGdCQUFnQixtRUFBbUUsMkJBQTJCLE1BQU0sMERBQTBELEVBQUUsWUFBWSwwRkFBMEYsUUFBUSxRQUFRLGVBQWUsdUJBQXVCO0FBQzNjLGdCQUFnQixhQUFhLDhCQUE4Qiw4QkFBOEIsWUFBWSxpRkFBaUYsU0FBUyxTQUFTLFFBQVEseUVBQXlFLEVBQUUsY0FBYyx5QkFBeUIsb0JBQW9CLG1CQUFtQiwyQkFBMkIsc0RBQXNELDZDQUE2QztBQUN2ZSwwQkFBMEIsa0JBQWtCLFFBQVEsMENBQTBDLE9BQU8sRUFBRSx1QkFBdUIsc0JBQXNCLGdCQUFnQix3QkFBd0IsRUFBRSxnQkFBZ0IseUJBQXlCLGlMQUFpTCxFQUFFLHlCQUF5QiwwQkFBMEIsY0FBYyxXQUFXLEVBQUUseUJBQXlCO0FBQ2pnQix3QkFBd0IsK0JBQStCLHdFQUF3RSxjQUFjLGFBQWEsa0NBQWtDLFNBQVMsZUFBZSxFQUFFLG1CQUFtQixxREFBcUQsZ0JBQWdCLGlDQUFpQyxpQ0FBaUMsb0JBQW9CLG9CQUFvQixpQkFBaUIsc0JBQXNCLGdCQUFnQixhQUFhLEVBQUUsc0JBQXNCO0FBQ3BmLHFCQUFxQix5QkFBeUIsd0JBQXdCLGlEQUFpRCxvQkFBb0Isb0JBQW9CLHlDQUF5QyxzQkFBc0IsRUFBRSw4REFBOEQsU0FBUyxTQUFTLG9CQUFvQixvQkFBb0Isa0JBQWtCLHlDQUF5QyxvQkFBb0Isd0JBQXdCLFdBQVcsK0JBQStCO0FBQ3plLHdIQUF3SCxpQ0FBaUMsUUFBUSxnQ0FBZ0MsdUVBQXVFLDhCQUE4QixnQkFBZ0IsRUFBRSxvQkFBb0IsaUVBQWlFLGVBQWUsb0RBQW9ELGVBQWU7QUFDL2QsS0FBSyxlQUFlLElBQUkscUJBQXFCLDhEQUE4RCxlQUFlLElBQUkscUJBQXFCLDJMQUEyTCxXQUFXLGlDQUFpQyxFQUFFLGlDQUFpQyxrQkFBa0IsWUFBWSxFQUFFLDRCQUE0QixXQUFXO0FBQ3BlLDRFQUE0RSxrREFBa0QsMkNBQTJDLE1BQU0sd0JBQXdCLHVCQUF1Qix3QkFBd0IsaUJBQWlCLFlBQVksaUJBQWlCLGlCQUFpQixtQkFBbUIsWUFBWSwyQkFBMkIsZ0JBQWdCLEVBQUUsZUFBZSxvQkFBb0IsMEJBQTBCLFdBQVc7QUFDemMsd0JBQXdCLG1CQUFtQixxREFBcUQsNkNBQTZDLE9BQU8sZUFBZSxpQkFBaUIsaUVBQWlFLGtCQUFrQixFQUFFLEtBQUssYUFBYSwrR0FBK0csdUJBQXVCLG1CQUFtQixxQkFBcUIsY0FBYyxtQkFBbUI7QUFDMWUsR0FBRyxnTkFBZ04scUNBQXFDLHFCQUFxQixZQUFZLDRCQUE0Qix5REFBeUQsMkNBQTJDLFVBQVUsOENBQThDLDJCQUEyQjtBQUM1ZSxTQUFTLDBFQUEwRSxxQ0FBcUMscUZBQXFGLGdFQUFnRSxZQUFZLDZCQUE2QixRQUFRLCtFQUErRSw0QkFBNEI7QUFDemEsbUJBQW1CLElBQUksMENBQTBDLHNHQUFzRyxTQUFTLHlCQUF5QjtBQUN6TSw4REFBOEQsb0JBQW9CLG9EQUFvRCxXQUFXLGlCQUFpQixVQUFVLHNEQUFzRCxTQUFTLG9CQUFvQiwwQ0FBMEMsZUFBZSw4REFBOEQseUNBQXlDLCtEQUErRDtBQUM5ZCwyQkFBMkIsNEJBQTRCLG1GQUFtRixJQUFJLDZDQUE2QywyQkFBMkIsT0FBTyw4TEFBOEwsOEJBQThCO0FBQ3piLHdDQUF3QyxxQ0FBcUMsSUFBSSxVQUFVLHdCQUF3QixRQUFRLEtBQUssZ0JBQWdCLGVBQWUsR0FBRyxFQUFFLFlBQVksOEJBQThCLEVBQUUsZ0NBQWdDLGlDQUFpQywyRkFBMkYsZ0RBQWdELDBEQUEwRCxFQUFFLGNBQWMsYUFBYTtBQUNuZixhQUFhLHdVQUF3VSxtQ0FBbUMsMkRBQTJELGFBQWEsVUFBVSxTQUFTO0FBQ25kLFFBQVEsT0FBTyxXQUFXLFlBQVkseUNBQXlDLFNBQVMsc0RBQXNELFFBQVEsVUFBVSxhQUFhLG9DQUFvQyxrREFBa0QsUUFBUSw4RUFBOEUsMENBQTBDLHlEQUF5RCxPQUFPLFdBQVcsWUFBWSwwQkFBMEI7QUFDcGYsTUFBTSxxQkFBcUIsU0FBUyxXQUFXLDZEQUE2RCxFQUFFLGtMQUFrTCwwQkFBMEIsVUFBVSw0QkFBNEIsa0JBQWtCLGFBQWEsS0FBSyxxRUFBcUUsRUFBRSxXQUFXLGtCQUFrQixTQUFTLEVBQUU7QUFDbmYsZ0dBQWdHLGFBQWEsY0FBYywrQkFBK0IsZUFBZSxFQUFFLHFCQUFxQix5Q0FBeUMsNEJBQTRCLHFCQUFxQiw4QkFBOEIsb0JBQW9CLDJCQUEyQixTQUFTLGVBQWUsSUFBSSxzQ0FBc0MscUJBQXFCLE1BQU0sd0JBQXdCLEtBQUssa0JBQWtCO0FBQ25mLFlBQVkscUJBQXFCLG1DQUFtQyw4QkFBOEIsbUJBQW1CLFlBQVksaUhBQWlILEVBQUUseUNBQXlDLEVBQUUsb0NBQW9DLDhDQUE4QywyQ0FBMkMsaUJBQWlCLGFBQWE7QUFDMWIsS0FBSyxzQkFBc0IsMEJBQTBCLG1GQUFtRiw2REFBNkQsc0xBQXNMLG9CQUFvQixTQUFTLHdCQUF3QixpRUFBaUU7QUFDamYsRUFBRSxnQkFBZ0IsbUJBQW1CLGtCQUFrQixxTUFBcU0sMExBQTBMLGlDQUFpQyx5QkFBeUI7QUFDaGYsc0JBQXNCLHlEQUF5RCx1SUFBdUksRUFBRSwwQ0FBMEMsMENBQTBDLEVBQUUsU0FBUywyQkFBMkIsd0hBQXdIO0FBQzFjLGlEQUFpRCx3QkFBd0IsVUFBVSxxQkFBcUIsMklBQTJJLHNCQUFzQiwrRUFBK0UsK0VBQStFO0FBQ3ZhLDZFQUE2RSxRQUFRLFdBQVcsVUFBVSxnRkFBZ0Ysc0RBQXNELEVBQUUsS0FBSyxrQkFBa0IsaUJBQWlCLGtDQUFrQyxxQkFBcUIsRUFBRSxXQUFXLFFBQVEsY0FBYyxZQUFZLGdCQUFnQixJQUFJLHdDQUF3QywwQkFBMEIsSUFBSTtBQUMxZCxLQUFLLGFBQWEsSUFBSSwrQkFBK0IsaUJBQWlCLGFBQWEsSUFBSSx1QkFBdUIsU0FBUyxrRkFBa0Ysd0JBQXdCLFVBQVUsb0NBQW9DLFFBQVEsSUFBSSxvQ0FBb0MsK0JBQStCLDBCQUEwQixrQkFBa0IsS0FBSyxtRUFBbUUsZUFBZSx5QkFBeUI7QUFDMWYscUNBQXFDLElBQUksc0NBQXNDLGtCQUFrQix1R0FBdUcsa0VBQWtFLHVDQUF1QywrRUFBK0UsdUdBQXVHO0FBQ3ZlLEVBQUUsSUFBSSxvR0FBb0csZUFBZSxpQkFBaUIsc0JBQXNCLHNCQUFzQix5QkFBeUIsNEJBQTRCLGtEQUFrRCxRQUFRLElBQUksZ0JBQWdCLGtCQUFrQixNQUFNLFFBQVEsSUFBSSxlQUFlLE1BQU0sTUFBTSxPQUFPLHFEQUFxRCwyQkFBMkI7QUFDL2MseUlBQXlJLDZDQUE2Qyw2QkFBNkIsUUFBUSxJQUFJLDRLQUE0SyxvQkFBb0Isb0NBQW9DLElBQUk7QUFDdmMsbUJBQW1CLFlBQVksY0FBYyx5QkFBeUIsa0RBQWtELDJCQUEyQiw0QkFBNEIsZ0RBQWdELFdBQVcsUUFBUSxJQUFJLDRNQUE0TSxJQUFJLDRCQUE0QixjQUFjO0FBQ2hmLEtBQUssa0JBQWtCLHNCQUFzQix3Q0FBd0Msc0JBQXNCLG9PQUFvTyxzQkFBc0IseUNBQXlDLFFBQVEsSUFBSSxLQUFLLHVCQUF1QixRQUFRO0FBQzliLEVBQUUsb0RBQW9ELHVGQUF1RixrVUFBa1U7QUFDL2MsS0FBSyw2QkFBNkIsdUdBQXVHLHNEQUFzRCwwQ0FBMEMsc0JBQXNCLHlDQUF5QywwREFBMEQsc0NBQXNDLDJCQUEyQiw4QkFBOEIsaUJBQWlCLHdDQUF3QztBQUMxZix5REFBeUQsRUFBRSxxQkFBcUIsME1BQTBNLHFJQUFxSSxTQUFTLEVBQUUsb0VBQW9FO0FBQzllLG1GQUFtRix3S0FBd0sscUJBQXFCLCtDQUErQyw2REFBNkQsa0JBQWtCLGdDQUFnQyxxQkFBcUIsdUJBQXVCLHlCQUF5QjtBQUNuZix1QkFBdUIsMEJBQTBCLHVCQUF1QixpTUFBaU0saURBQWlELFdBQVcsK0NBQStDO0FBQ3BYLDBTQUEwUyw2QkFBNkIsd0NBQXdDLHdCQUF3QiwrRkFBK0Y7QUFDdGUsR0FBRyxHQUFHLHFDQUFxQywwQkFBMEIsU0FBUyw0QkFBNEIsMERBQTBELHFFQUFxRSwwQkFBMEIsYUFBYSw4QkFBOEIsOEJBQThCLDZDQUE2QztBQUN6WCxHQUFHLE9BQU8sa0NBQWtDLG9CQUFvQiwyRkFBMkYsZUFBZSxLQUFLLDhCQUE4QiwrREFBK0QsRUFBRSw0Q0FBNEMsZUFBZSxJQUFJLGtDQUFrQyxjQUFjLGlDQUFpQyxrQkFBa0IsdUVBQXVFO0FBQ3ZmLHdDQUF3QyxjQUFjLGdCQUFnQixrQkFBa0IsWUFBWSxFQUFFLDhCQUE4Qiw4Q0FBOEMsY0FBYyw0QkFBNEIsSUFBSSxpQkFBaUIsdUJBQXVCLGtEQUFrRCxrQkFBa0IsaUNBQWlDLDJDQUEyQztBQUN4WiwyTUFBMk0sRUFBRSxTQUFTLHFCQUFxQixzQkFBc0IsaUpBQWlKLDJCQUEyQjtBQUM3YSw4REFBOEQsRUFBRSxrQkFBa0Isa0JBQWtCLDRCQUE0QixJQUFJLGlFQUFpRSxTQUFTLGtCQUFrQix5RUFBeUUsc0lBQXNJLHVDQUF1QyxFQUFFLHVCQUF1QjtBQUMvZSxxTUFBcU0seUhBQXlILDBDQUEwQyxpQ0FBaUMsc0VBQXNFLDJCQUEyQjtBQUMxZSxHQUFHLGdCQUFnQixnQkFBZ0IsY0FBYyw2QkFBNkIsZ0NBQWdDLDZCQUE2QiwyQkFBMkIsMEJBQTBCLDhDQUE4QyxFQUFFLHdFQUF3RSxFQUFFLDJHQUEyRyxnQkFBZ0IsZ0JBQWdCLDBCQUEwQixhQUFhO0FBQzVlLDJCQUEyQixvQ0FBb0MscUNBQXFDLGlFQUFpRSxFQUFFLHVCQUF1QixvRUFBb0UsK0JBQStCLG1CQUFtQiw0Q0FBNEMsYUFBYSxVQUFVO0FBQ3ZYLHFDQUFxQyxRQUFRLGFBQWEseUNBQXlDLFNBQVMsdUJBQXVCLDJDQUEyQywrQkFBK0IsT0FBTywrRUFBK0UsbUJBQW1CLG1MQUFtTDtBQUN6ZSxnQkFBZ0IseURBQXlELGlCQUFpQiw4QkFBOEIsNENBQTRDLHFDQUFxQywwQkFBMEIsbUVBQW1FLGtCQUFrQixvREFBb0QsZUFBZSxvQ0FBb0MsaUJBQWlCLEtBQUssYUFBYSxpQkFBaUIsbUJBQW1CO0FBQ3RlLHdFQUF3RSx3QkFBd0Isc0NBQXNDLGFBQWEsb0VBQW9FLEdBQUcsaUJBQWlCLGNBQWMsc0JBQXNCLDJEQUEyRCxvREFBb0QsMEJBQTBCLDBGQUEwRixJQUFJO0FBQ3RmLHVCQUF1QixrQkFBa0IsUUFBUSxrRUFBa0UsaUJBQWlCLHFCQUFxQixtRUFBbUUsdUJBQXVCLDhEQUE4RCxnQkFBZ0IsYUFBYSxzREFBc0Qsb0JBQW9CLHNCQUFzQiw0QkFBNEIsb0JBQW9CO0FBQzlkLFdBQVcsOENBQThDLDhDQUE4QyxnQkFBZ0IsMENBQTBDLDJDQUEyQyxZQUFZLHFCQUFxQixxQkFBcUIsMENBQTBDLCtEQUErRCxTQUFTLDBFQUEwRSxtREFBbUQ7QUFDamYsd0NBQXdDLDRDQUE0QyxFQUFFLEtBQUssYUFBYSx1SUFBdUksZ0NBQWdDLHVCQUF1QixZQUFZLGtCQUFrQixlQUFlLFNBQVMsZ0JBQWdCLGVBQWUsYUFBYSxpQ0FBaUMsbUJBQW1CO0FBQzViLHdFQUF3RSwyREFBMkQsdUJBQXVCLG1CQUFtQixrQkFBa0Isb0JBQW9CLG1FQUFtRSw0QkFBNEIsMkJBQTJCLHFGQUFxRiw2REFBNkQsU0FBUztBQUN4ZSxHQUFHLGlIQUFpSCxpQ0FBaUMsbUNBQW1DLHFJQUFxSSxtQ0FBbUMsbUNBQW1DLGVBQWUscUNBQXFDLE9BQU87QUFDOWIsT0FBTyxpQ0FBaUMsV0FBVyxzQkFBc0IscURBQXFELEVBQUUsdUJBQXVCLHdIQUF3SCxHQUFHLG1DQUFtQyxtRUFBbUUsa0JBQWtCLHNCQUFzQixRQUFRLElBQUksaUNBQWlDLDhCQUE4QixJQUFJO0FBQy9lLHlDQUF5QyxtRUFBbUUscURBQXFELDhCQUE4QixTQUFTLGtDQUFrQyxnQkFBZ0IsZ0JBQWdCLFlBQVksRUFBRSxHQUFHLG1DQUFtQyxzQkFBc0IsMkJBQTJCLGtCQUFrQiw4RUFBOEUsRUFBRSxHQUFHLG1DQUFtQztBQUN2Ziw4RUFBOEUsZ0JBQWdCLGNBQWMsRUFBRSxJQUFJLHdDQUF3QyxpR0FBaUcsNE9BQTRPO0FBQ3ZlLEVBQUUsUUFBUSxJQUFJLHdHQUF3RztBQUN0SCxnTEFBZ0wsb0NBQW9DLG9CQUFvQixpQkFBaUIsd0NBQXdDLDhEQUE4RCx3QkFBd0IsdUJBQXVCLElBQUk7QUFDbFosK0RBQStELEdBQUcsZ0RBQWdELGdDQUFnQyxrQkFBa0IsV0FBVywyQkFBMkIsVUFBVSxLQUFLLGFBQWEsNFFBQTRRO0FBQ2xmLENBQUMsMEJBQTBCLGFBQWEsK0JBQStCLFVBQVUsWUFBWSxrQkFBa0IsbUJBQW1CLGVBQWUsZUFBZSxHQUFHLFNBQVMsMkJBQTJCLHVDQUF1QyxPQUFPLDJCQUEyQixFQUFFLGdCQUFnQixlQUFlLEVBQUUsYUFBYSx3QkFBd0IsU0FBUyx5QkFBeUIsK0RBQStELFFBQVE7QUFDamMsOEJBQThCLEdBQUcsNEJBQTRCLHlEQUF5RCwyQ0FBMkMscUNBQXFDLDBCQUEwQixpQ0FBaUMsMENBQTBDLGVBQWUsVUFBVSxHQUFHLDhCQUE4QixzQkFBc0IscUJBQXFCLE9BQU8sNEJBQTRCLEVBQUUsMkJBQTJCLEdBQUcsa0JBQWtCLElBQUksd0JBQXdCO0FBQ2pnQiwrQkFBK0Isb0VBQW9FLFVBQVUsRUFBRSx5REFBeUQsS0FBSyxlQUFlLEdBQUcsR0FBRyxxQkFBcUI7QUFDdk4sdUpBQXVKLGNBQWMsNkRBQTZELG9CQUFvQixNQUFNLHdCQUF3Qiw2Q0FBNkMsdURBQXVELHlCQUF5QixrQkFBa0Isc0RBQXNEO0FBQ3pkLGtCQUFrQixFQUFFLDBDQUEwQyx5Q0FBeUMsNERBQTRELGtCQUFrQiwyREFBMkQsK0NBQStDLDBEQUEwRCxFQUFFLG1FQUFtRSwrQkFBK0I7QUFDN2IsdUJBQXVCLHNEQUFzRCx3RUFBd0Usd0JBQXdCLHFDQUFxQyxHQUFHLEVBQUUsZ0JBQWdCLGFBQWEsRUFBRSx3QkFBd0IsV0FBVyxLQUFLLEVBQUUsMEJBQTBCLFdBQVcsS0FBSyxFQUFFLDZDQUE2QyxhQUFhLGNBQWMsbUZBQW1GLHlCQUF5QjtBQUNoZ0IsSUFBSSxFQUFFLGVBQWUseUJBQXlCLGFBQWEsa0JBQWtCLHVDQUF1QywwSkFBMEosVUFBVSw0QkFBNEIsK0NBQStDLDJCQUEyQixxREFBcUQsNkNBQTZDLGVBQWU7QUFDL2Usb0RBQW9ELFVBQVUsc0NBQXNDLFVBQVUsSUFBSSxzQkFBc0IsdURBQXVELEVBQUUsZUFBZSwyQkFBMkIsZ0hBQWdILFVBQVUsR0FBRyxhQUFhLG9EQUFvRCxNQUFNLFdBQVcsMENBQTBDLFlBQVk7QUFDaGYsNENBQTRDLCtCQUErQix5QkFBeUIsZ0JBQWdCLG1EQUFtRCw4Q0FBOEMsa0dBQWtHLGlDQUFpQyxlQUFlLDZCQUE2Qiw2REFBNkQsc0NBQXNDO0FBQ3ZlLDJCQUEyQiwyQkFBMkIsU0FBUyxlQUFlLGVBQWUsYUFBYSxpQkFBaUIsZUFBZSxPQUFPLFVBQVUsd0NBQXdDLHdCQUF3QixhQUFhLFlBQVksZ0NBQWdDLGVBQWUscUJBQXFCLHFCQUFxQixnQ0FBZ0Msc0JBQXNCO0FBQ25ZLG1HQUFtRyxjQUFjLGlGQUFpRiwwQ0FBMEMsZ0JBQWdCLFVBQVUsWUFBWSxFQUFFLFNBQVMsb0NBQW9DLEVBQUUsb0JBQW9CLElBQUkscUJBQXFCLHVCQUF1Qix1QkFBdUIsZ0JBQWdCLFVBQVUsRUFBRSxZQUFZLFlBQVksZUFBZSx1QkFBdUI7QUFDeGYsZUFBZSxxQkFBcUIsaUJBQWlCLGlFQUFpRSxpQkFBaUIsaUJBQWlCLGNBQWMsR0FBRyxnQkFBZ0Isb0JBQW9CLG9CQUFvQiwwREFBMEQsSUFBSSx1QkFBdUIsZUFBZSxhQUFhLDhFQUE4RSxxQkFBcUIsa0JBQWtCLEVBQUUsZUFBZSxnQkFBZ0Isb0JBQW9CO0FBQzVmLHVCQUF1QixhQUFhLFFBQVEsSUFBSSw2QkFBNkIsYUFBYSxhQUFhLEtBQUssRUFBRSxLQUFLLGFBQWEsa0VBQWtFLGlCQUFpQiw2QkFBNkIsRUFBRSwyQ0FBMkMsc0VBQXNFLDhFQUE4RSxpQkFBaUIsMEJBQTBCLFFBQVEsV0FBVztBQUMvZSxLQUFLLDZCQUE2QiwwQkFBMEIsRUFBRSxxQkFBcUIsV0FBVyxFQUFFLGlCQUFpQixvQkFBb0IsRUFBRSxrQkFBa0IsWUFBWSx3REFBd0QsbURBQW1ELGFBQWEsVUFBVSxtRkFBbUYsdUNBQXVDLEVBQUUsS0FBSyxRQUFRLFVBQVUsRUFBRSxxQkFBcUIsT0FBTyxNQUFNLEtBQUs7QUFDbmUsT0FBTyxRQUFRLDZEQUE2RCxHQUFHLEVBQUUsU0FBUywwQkFBMEIsK05BQStOLFdBQVcsc0JBQXNCLHFCQUFxQixrQkFBa0IsYUFBYSx1RUFBdUU7QUFDL2UsWUFBWSwrREFBK0QsVUFBVSxzREFBc0QsSUFBSSxpQkFBaUIsOEJBQThCLFFBQVEsV0FBVyxpSUFBaUksb0JBQW9CLHVCQUF1Qix1QkFBdUIsY0FBYyx1QkFBdUIscUJBQXFCLGNBQWMsc0JBQXNCO0FBQ2xmLE9BQU8sZ0JBQWdCLFNBQVMsc0JBQXNCLGlCQUFpQixrQ0FBa0MsZ0dBQWdHLDJCQUEyQiw2SEFBNkgsRUFBRSxnQkFBZ0Isa0JBQWtCLDRCQUE0QixJQUFJLHlEQUF5RDtBQUM5ZCxzQkFBc0IsNEJBQTRCLGdCQUFnQix1QkFBdUIsRUFBRSxvREFBb0QsRUFBRSxLQUFLLGFBQWEsYUFBYSxlQUFlLG9CQUFvQixFQUFFLCtCQUErQixpQ0FBaUMsU0FBUyxZQUFZLHVGQUF1RixVQUFVLFVBQVUsVUFBVSxRQUFRLHNCQUFzQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQjtBQUM3ZSx1QkFBdUIsS0FBSyxLQUFLLHVFQUF1RSx1RUFBdUUsZUFBZSxlQUFlLDBFQUEwRSwrQkFBK0IsVUFBVSxFQUFFLEtBQUssYUFBYSxrREFBa0QsbURBQW1EO0FBQ3piLHlFQUF5RSxFQUFFLEtBQUssYUFBYSxtSEFBbUgsbUJBQW1CLDhIQUE4SCxPQUFPLGdDQUFnQyxTQUFTLGlEQUFpRCxhQUFhLHFDQUFxQztBQUNwZixrRUFBa0UsV0FBVyxtQ0FBbUMsRUFBRSxxR0FBcUcsdUNBQXVDLHFCQUFxQixzQ0FBc0MsZ0NBQWdDLEVBQUUsNkJBQTZCLDhEQUE4RCxLQUFLLGlEQUFpRDtBQUM1ZSxZQUFZLDJNQUEyTSxFQUFFLDhOQUE4TixpQkFBaUI7QUFDeGMsMEJBQTBCLHVCQUF1Qiw0QkFBNEIsNkRBQTZELHFDQUFxQyxpRUFBaUUsb0JBQW9CLHdCQUF3QixrQkFBa0IsS0FBSyxpQkFBaUIsT0FBTywwQkFBMEIsc0JBQXNCO0FBQzNYLGtLQUFrSyxvQkFBb0IsaUNBQWlDLCtCQUErQix1QkFBdUIsb0lBQW9JO0FBQ2paLE1BQU0sU0FBUyxlQUFlLG1HQUFtRyxtQkFBbUIsNkRBQTZELEVBQUUsMEZBQTBGLHlFQUF5RSw0QkFBNEIsbURBQW1ELDBCQUEwQjtBQUMvZCwwR0FBMEcsZ0ZBQWdGLDZEQUE2RCxtSEFBbUgsR0FBRyxrQ0FBa0MsbUJBQW1CLFNBQVMsdUJBQXVCO0FBQ2xjLHdCQUF3Qix1QkFBdUIsZ0JBQWdCLDJCQUEyQixjQUFjLDhDQUE4Qyx5REFBeUQsd0JBQXdCLGlCQUFpQixFQUFFLGlHQUFpRyxnQ0FBZ0MsZ0NBQWdDLEVBQUUscUJBQXFCLCtEQUErRDtBQUNqZix3TkFBd04sbUJBQW1CLGNBQWMsNEJBQTRCLEdBQUcsb0JBQW9CLG1CQUFtQixxQkFBcUIsc0NBQXNDLGdDQUFnQyxFQUFFLHVDQUF1QyxFQUFFLEtBQUssYUFBYSxlQUFlO0FBQ3RlLE1BQU0sWUFBWSxFQUFFLEtBQUssYUFBYSxlQUFlLGVBQWUsb0JBQW9CLDRDQUE0QyxXQUFXLFVBQVUsd0NBQXdDLFlBQVksb0VBQW9FLFlBQVksb0RBQW9ELFFBQVEsa0NBQWtDLFFBQVEsd0JBQXdCLEVBQUU7QUFDN1osNENBQTRDLDBEQUEwRCxFQUFFLEtBQUssYUFBYSxnQ0FBZ0MsdUJBQXVCLHFCQUFxQiwwTEFBMEwsUUFBUSxJQUFJLHdFQUF3RSx1QkFBdUIsV0FBVztBQUN0ZixhQUFhLG9JQUFvSSxnQkFBZ0IsdURBQXVELDRDQUE0QyxnREFBZ0QsS0FBSywwSEFBMEgsaUJBQWlCLDZDQUE2QyxPQUFPO0FBQ3hmLFlBQVksRUFBRSx1TUFBdU0sd0NBQXdDLG9CQUFvQiw4QkFBOEIsWUFBWSx3Q0FBd0MsYUFBYSw4QkFBOEIsdUJBQXVCLGtCQUFrQix5QkFBeUI7QUFDaGQsaUNBQWlDLFFBQVEsSUFBSSw2Q0FBNkMsYUFBYSxRQUFRLElBQUksbUVBQW1FLDJCQUEyQixzQ0FBc0Msb0JBQW9CLHVCQUF1QixzQkFBc0I7QUFDeFQsMkVBQTJFLG9DQUFvQywwQkFBMEIsMkRBQTJELDJEQUEyRCxRQUFRLElBQUksS0FBSyxPQUFPLHlFQUF5RSx5RUFBeUUsUUFBUSxxQ0FBcUMsUUFBUSxrQkFBa0I7QUFDaGYsQ0FBQyw0RkFBNEYsVUFBVSx3REFBd0QscUJBQXFCLDJFQUEyRSxxQkFBcUIscUJBQXFCLG1DQUFtQyxxQ0FBcUMsVUFBVSxnQ0FBZ0M7QUFDM1osMEZBQTBGLHNDQUFzQyx5REFBeUQsOERBQThELHVCQUF1QixjQUFjLFlBQVksY0FBYyxtQkFBbUIsb0JBQW9CLDBEQUEwRCxhQUFhLHlDQUF5QztBQUM3Yyx3R0FBd0csb0JBQW9CLGtCQUFrQiwwQkFBMEIsZUFBZSw4QkFBOEIsRUFBRSx5Q0FBeUMscUJBQXFCLDZDQUE2QyxFQUFFLDBHQUEwRyxFQUFFLGdCQUFnQix1Q0FBdUMsYUFBYTtBQUNwZixrQkFBa0IsY0FBYyw0QkFBNEIsZ0JBQWdCLGtCQUFrQixTQUFTLG9CQUFvQix3Q0FBd0MsMEJBQTBCLDhEQUE4RCxTQUFTLDRLQUE0SyxrQ0FBa0M7QUFDbGQseUVBQXlFLHVCQUF1QixrQkFBa0IsYUFBYSxRQUFRLG9EQUFvRCw0Q0FBNEMsMENBQTBDLGdFQUFnRSx5QkFBeUIsMkNBQTJDLDJCQUEyQixzQkFBc0IscUJBQXFCO0FBQzNkLCtEQUErRCxnREFBZ0QsR0FBRyxFQUFFLEtBQUssYUFBYSwwS0FBMEssMkJBQTJCLGdCQUFnQix5QkFBeUIsc0JBQXNCLElBQUksZUFBZSxJQUFJLGNBQWMsUUFBUSxrQkFBa0IsOEJBQThCLEVBQUUsVUFBVTtBQUNuZixFQUFFLGtCQUFrQix5QkFBeUIsT0FBTyxzQkFBc0IsT0FBTyxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsZUFBZSxJQUFJLHNIQUFzSCxXQUFXLFNBQVMsSUFBSSwyTEFBMkwsSUFBSSxnQkFBZ0IsUUFBUTtBQUMvZSxXQUFXLGlCQUFpQixhQUFhLElBQUksRUFBRSxFQUFFLGtCQUFrQixRQUFRLHNDQUFzQywwSEFBMEgsMEtBQTBLLFdBQVcsbUNBQW1DLHNCQUFzQixpQ0FBaUMsVUFBVTtBQUNwZ0IsQ0FBQyxhQUFhLEVBQUUsdUJBQXVCLDZDQUE2QywrQ0FBK0M7QUFDbkksR0FBRyxtSUFBbUksOEJBQThCLHdCQUF3QixFQUFFO0FBQzlMLHNFQUFzRSxHQUFHLCtDQUErQyxzUUFBc1EsK0RBQStEO0FBQzdiLGlCQUFpQixTQUFTLDhCQUE4Qix1Q0FBdUMsbUNBQW1DLHlCQUF5QiwyQkFBMkIsZ0NBQWdDLFFBQVE7QUFDOU4sb0ZBQW9GLDZFQUE2RSxFQUFFLFlBQVksUUFBUSxnQkFBZ0IsbURBQW1ELHdFQUF3RSxRQUFRLDhDQUE4QyxnQkFBZ0IsbUVBQW1FLFFBQVE7QUFDbmQsbUJBQW1CLGlCQUFpQiw2RUFBNkUsbUNBQW1DLFVBQVUsa0RBQWtELDBNQUEwTSw0REFBNEQ7QUFDdGQsbUJBQW1CLGFBQWEsT0FBTyxpQ0FBaUMsNEJBQTRCLHNEQUFzRCxrRUFBa0Usb0JBQW9CLDBCQUEwQiwySkFBMko7QUFDcmEsdUdBQXVHLCtDQUErQyxLQUFLLDZCQUE2QixJQUFJLHFTQUFxUyx3QkFBd0I7QUFDemYsUUFBUSxVQUFVLGdCQUFnQixzQkFBc0Isb1JBQW9SLG1HQUFtRyxNQUFNLGNBQWMsMERBQTBEO0FBQzdmLG1CQUFtQixrSkFBa0osNkRBQTZELEVBQUUsdUJBQXVCLDhCQUE4QixFQUFFLHVCQUF1QixrQ0FBa0MsR0FBRywyQ0FBMkMsZ0JBQWdCO0FBQ2xaLGdHQUFnRyw0Q0FBNEMsMEJBQTBCLGtCQUFrQixrR0FBa0csaURBQWlELHdGQUF3RixRQUFRLEdBQUcsT0FBTztBQUNyYixZQUFZLDhFQUE4RSxnV0FBZ1csU0FBUyxFQUFFO0FBQ3JjLFNBQVMsK0pBQStKLDZGQUE2RixtRkFBbUYsc0VBQXNFLG1EQUFtRDtBQUNqZCw2QkFBNkIsZ0RBQWdELHNEQUFzRCxzQkFBc0IsRUFBRSxFQUFFLEtBQUssYUFBYSw0REFBNEQsdUNBQXVDLGFBQWEsU0FBUywwQkFBMEIsbUZBQW1GLGdCQUFnQixnQkFBZ0IsRUFBRSxFQUFFLEVBQUUsMkJBQTJCO0FBQ3RkLGNBQWMsNEVBQTRFLHVCQUF1QixtRkFBbUYsRUFBRSxFQUFFLEVBQUUsMkJBQTJCLElBQUksZ0JBQWdCLEVBQUUsOENBQThDLDZEQUE2RCxxQ0FBcUMsUUFBUSxJQUFJO0FBQ3ZaLFVBQVUscUJBQXFCLHdDQUF3QyxFQUFFLFFBQVEsSUFBSSxxQkFBcUIsSUFBSSwwVUFBMFUsZ0JBQWdCLFFBQVE7QUFDaGQscUNBQXFDLFNBQVMsb0ZBQW9GLEdBQUcsS0FBSyxhQUFhLG9QQUFvUCxrQkFBa0IsNEJBQTRCLDJDQUEyQztBQUNwZSxtREFBbUQsdUJBQXVCLHVDQUF1QyxtRkFBbUYsRUFBRSwrQ0FBK0MsU0FBUyxnRkFBZ0YsdUJBQXVCLEVBQUUsNkJBQTZCLG1DQUFtQyx3QkFBd0IsR0FBRyxxQkFBcUIsNkJBQTZCO0FBQ3BmLHlLQUF5SyxxQ0FBcUMsMENBQTBDLG1CQUFtQixJQUFJLDJHQUEyRyxVQUFVLElBQUksc0NBQXNDO0FBQzlhLHdFQUF3RSx1REFBdUQsNkVBQTZFLHVCQUF1QixFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSwwQkFBMEIsS0FBSyw4REFBOEQsd0RBQXdELGdFQUFnRSxlQUFlO0FBQzVlLEtBQUssc0dBQXNHLDhDQUE4QyxvQkFBb0IsY0FBYyxnQ0FBZ0MsMkJBQTJCLGtEQUFrRCxpQkFBaUIsYUFBYSx5QkFBeUIsaUJBQWlCLDhCQUE4QixHQUFHLGdCQUFnQixvRkFBb0YsRUFBRTtBQUN2ZixrQ0FBa0Msc0JBQXNCLDZEQUE2RCxzREFBc0QsaUNBQWlDLCtCQUErQixnQ0FBZ0MsWUFBWSxXQUFXLEVBQUUsR0FBRyxFQUFFLG9DQUFvQyxlQUFlLHlCQUF5QixtSEFBbUg7QUFDeGUsbURBQW1ELFlBQVkscUJBQXFCLDhDQUE4QyxpRUFBaUUsb0JBQW9CLFdBQVcsaUJBQWlCLGtCQUFrQixZQUFZLFNBQVMsRUFBRSxrQkFBa0IsNEJBQTRCLDhDQUE4QyxXQUFXLHdEQUF3RCxhQUFhO0FBQ3hjLDZCQUE2QixFQUFFLHVCQUF1Qix3RUFBd0UsbUZBQW1GLG1CQUFtQiw2QkFBNkIsbUJBQW1CLGFBQWEsRUFBRSxpQ0FBaUMsMEJBQTBCO0FBQzlWLGdMQUFnTCxNQUFNLGdCQUFnQixNQUFNLGdCQUFnQixpRUFBaUUsY0FBYyxRQUFRLE9BQU8sRUFBRSxnQkFBZ0IsZUFBZSxjQUFjLEdBQUcsRUFBRSxlQUFlLHFCQUFxQixnQ0FBZ0MsbUJBQW1CLHdDQUF3QyxhQUFhO0FBQzFmLFdBQVcsZ0NBQWdDLHNDQUFzQyx3QkFBd0IsdUNBQXVDLHdJQUF3SSxFQUFFLEVBQUUseUJBQXlCLG9DQUFvQyxtRUFBbUUsMEJBQTBCLHVCQUF1Qix3QkFBd0I7QUFDcmUsZ0NBQWdDLGFBQWEsRUFBRSxnQ0FBZ0MseUJBQXlCLDRCQUE0Qix3REFBd0QsV0FBVyw2QkFBNkIsU0FBUyxFQUFFLDJCQUEyQix3QkFBd0IsaUZBQWlGLHdGQUF3RjtBQUMzYyxlQUFlLDJDQUEyQyxRQUFRLHNKQUFzSiwrQkFBK0I7QUFDdlAsc0NBQXNDLEtBQUssU0FBUyxxQkFBcUIsd0NBQXdDLDRCQUE0QixZQUFZLEVBQUUsb0hBQW9ILGtDQUFrQywrRUFBK0UsOEdBQThHLHdCQUF3QjtBQUN0Z0IsUUFBUSw0RUFBNEUseUJBQXlCLDREQUE0RCwwREFBMEQsc0JBQXNCLEVBQUUsY0FBYyxzQkFBc0IsaUdBQWlHLEVBQUUsZUFBZSx1QkFBdUIsaUNBQWlDLDhCQUE4QjtBQUN2ZSxvQkFBb0IsdUJBQXVCLG1CQUFtQix1QkFBdUIsMkRBQTJELG1CQUFtQixvQkFBb0IsNENBQTRDLG1FQUFtRSxnQkFBZ0Isc0JBQXNCLDhEQUE4RCxRQUFRLHlFQUF5RTtBQUMzZCxnREFBZ0QsaUhBQWlILGlCQUFpQixzRUFBc0UsbUJBQW1CLGlDQUFpQywwQkFBMEIsdUZBQXVGLHNGQUFzRjtBQUNuZiw0REFBNEQsa0JBQWtCLEVBQUUsNkVBQTZFLDhCQUE4QixhQUFhLDJDQUEyQyw4Q0FBOEMsRUFBRSw2QkFBNkIsbUJBQW1CLEVBQUUscUJBQXFCLG1CQUFtQixPQUFPLGlCQUFpQixvQkFBb0IsaUJBQWlCLG9CQUFvQixvQkFBb0I7QUFDbGUsbUJBQW1CLHlDQUF5Qyw4QkFBOEIsZ0NBQWdDLEVBQUUsS0FBSyxhQUFhLCtFQUErRSxzQ0FBc0MsNERBQTRELGtDQUFrQyxzQ0FBc0MsZ0NBQWdDLE9BQU8sMENBQTBDLGtDQUFrQztBQUMxZixFQUFFLGVBQWUsMEJBQTBCLGdGQUFnRiw2REFBNkQsbURBQW1ELDhDQUE4QyxrQkFBa0Isd0JBQXdCLGdMQUFnTDtBQUNuZixlQUFlLHVDQUF1QyxvQkFBb0IsTUFBTSw2QkFBNkIsdUVBQXVFLGNBQWMsd0JBQXdCLDhCQUE4QiwwQkFBMEIsYUFBYSw0QkFBNEIsRUFBRSxTQUFTLHNCQUFzQixVQUFVLEtBQUssU0FBUyIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gSGlnaGNoYXJ0cyBKUyB2NS4wLjE0ICgyMDE3LTA3LTI4KVxuXG4gKGMpIDIwMDktMjAxNiBUb3JzdGVpbiBIb25zaVxuXG4gTGljZW5zZTogd3d3LmhpZ2hjaGFydHMuY29tL2xpY2Vuc2VcbiovXG4oZnVuY3Rpb24oTSxTKXtcIm9iamVjdFwiPT09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9TS5kb2N1bWVudD9TKE0pOlM6TS5IaWdoY2hhcnRzPVMoTSl9KShcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcyxmdW5jdGlvbihNKXtNPWZ1bmN0aW9uKCl7dmFyIGE9d2luZG93LEM9YS5kb2N1bWVudCxBPWEubmF2aWdhdG9yJiZhLm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIsRj1DJiZDLmNyZWF0ZUVsZW1lbnROUyYmISFDLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJzdmdcIikuY3JlYXRlU1ZHUmVjdCxFPS8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChBKSYmIXdpbmRvdy5vcGVyYSxtPSFGLGY9L0ZpcmVmb3gvLnRlc3QoQSksbD1mJiY0PnBhcnNlSW50KEEuc3BsaXQoXCJGaXJlZm94L1wiKVsxXSwxMCk7cmV0dXJuIGEuSGlnaGNoYXJ0cz9hLkhpZ2hjaGFydHMuZXJyb3IoMTYsITApOntwcm9kdWN0OlwiSGlnaGNoYXJ0c1wiLFxudmVyc2lvbjpcIjUuMC4xNFwiLGRlZzJyYWQ6MipNYXRoLlBJLzM2MCxkb2M6QyxoYXNCaWRpQnVnOmwsaGFzVG91Y2g6QyYmdm9pZCAwIT09Qy5kb2N1bWVudEVsZW1lbnQub250b3VjaHN0YXJ0LGlzTVM6RSxpc1dlYktpdDovQXBwbGVXZWJLaXQvLnRlc3QoQSksaXNGaXJlZm94OmYsaXNUb3VjaERldmljZTovKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KEEpLFNWR19OUzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsY2hhcnRDb3VudDowLHNlcmllc1R5cGVzOnt9LHN5bWJvbFNpemVzOnt9LHN2ZzpGLHZtbDptLHdpbjphLG1hcmdpbk5hbWVzOltcInBsb3RUb3BcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcInBsb3RMZWZ0XCJdLG5vb3A6ZnVuY3Rpb24oKXt9LGNoYXJ0czpbXX19KCk7KGZ1bmN0aW9uKGEpe3ZhciBDPVtdLEE9YS5jaGFydHMsRj1hLmRvYyxFPWEud2luO2EuZXJyb3I9ZnVuY3Rpb24obSxmKXttPWEuaXNOdW1iZXIobSk/XCJIaWdoY2hhcnRzIGVycm9yICNcIitcbm0rXCI6IHd3dy5oaWdoY2hhcnRzLmNvbS9lcnJvcnMvXCIrbTptO2lmKGYpdGhyb3cgRXJyb3IobSk7RS5jb25zb2xlJiZjb25zb2xlLmxvZyhtKX07YS5GeD1mdW5jdGlvbihhLGYsbCl7dGhpcy5vcHRpb25zPWY7dGhpcy5lbGVtPWE7dGhpcy5wcm9wPWx9O2EuRngucHJvdG90eXBlPXtkU2V0dGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wYXRoc1swXSxmPXRoaXMucGF0aHNbMV0sbD1bXSxyPXRoaXMubm93LHU9YS5sZW5ndGgsdDtpZigxPT09cilsPXRoaXMudG9EO2Vsc2UgaWYodT09PWYubGVuZ3RoJiYxPnIpZm9yKDt1LS07KXQ9cGFyc2VGbG9hdChhW3VdKSxsW3VdPWlzTmFOKHQpP2FbdV06cipwYXJzZUZsb2F0KGZbdV0tdCkrdDtlbHNlIGw9Zjt0aGlzLmVsZW0uYXR0cihcImRcIixsLG51bGwsITApfSx1cGRhdGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW0sZj10aGlzLnByb3AsbD10aGlzLm5vdyxyPXRoaXMub3B0aW9ucy5zdGVwO2lmKHRoaXNbZitcIlNldHRlclwiXSl0aGlzW2YrXG5cIlNldHRlclwiXSgpO2Vsc2UgYS5hdHRyP2EuZWxlbWVudCYmYS5hdHRyKGYsbCxudWxsLCEwKTphLnN0eWxlW2ZdPWwrdGhpcy51bml0O3ImJnIuY2FsbChhLGwsdGhpcyl9LHJ1bjpmdW5jdGlvbihhLGYsbCl7dmFyIHI9dGhpcyxtPWZ1bmN0aW9uKGEpe3JldHVybiBtLnN0b3BwZWQ/ITE6ci5zdGVwKGEpfSx0O3RoaXMuc3RhcnRUaW1lPStuZXcgRGF0ZTt0aGlzLnN0YXJ0PWE7dGhpcy5lbmQ9Zjt0aGlzLnVuaXQ9bDt0aGlzLm5vdz10aGlzLnN0YXJ0O3RoaXMucG9zPTA7bS5lbGVtPXRoaXMuZWxlbTttLnByb3A9dGhpcy5wcm9wO20oKSYmMT09PUMucHVzaChtKSYmKG0udGltZXJJZD1zZXRJbnRlcnZhbChmdW5jdGlvbigpe2Zvcih0PTA7dDxDLmxlbmd0aDt0KyspQ1t0XSgpfHxDLnNwbGljZSh0LS0sMSk7Qy5sZW5ndGh8fGNsZWFySW50ZXJ2YWwobS50aW1lcklkKX0sMTMpKX0sc3RlcDpmdW5jdGlvbihtKXt2YXIgZj0rbmV3IERhdGUsbCxyPXRoaXMub3B0aW9ucyx1PXRoaXMuZWxlbSxcbnQ9ci5jb21wbGV0ZSxnPXIuZHVyYXRpb24sZD1yLmN1ckFuaW07dS5hdHRyJiYhdS5lbGVtZW50P209ITE6bXx8Zj49Zyt0aGlzLnN0YXJ0VGltZT8odGhpcy5ub3c9dGhpcy5lbmQsdGhpcy5wb3M9MSx0aGlzLnVwZGF0ZSgpLGw9ZFt0aGlzLnByb3BdPSEwLGEub2JqZWN0RWFjaChkLGZ1bmN0aW9uKGEpeyEwIT09YSYmKGw9ITEpfSksbCYmdCYmdC5jYWxsKHUpLG09ITEpOih0aGlzLnBvcz1yLmVhc2luZygoZi10aGlzLnN0YXJ0VGltZSkvZyksdGhpcy5ub3c9dGhpcy5zdGFydCsodGhpcy5lbmQtdGhpcy5zdGFydCkqdGhpcy5wb3MsdGhpcy51cGRhdGUoKSxtPSEwKTtyZXR1cm4gbX0saW5pdFBhdGg6ZnVuY3Rpb24obSxmLGwpe2Z1bmN0aW9uIHIoYSl7dmFyIGMsZTtmb3Iobj1hLmxlbmd0aDtuLS07KWM9XCJNXCI9PT1hW25dfHxcIkxcIj09PWFbbl0sZT0vW2EtekEtWl0vLnRlc3QoYVtuKzNdKSxjJiZlJiZhLnNwbGljZShuKzEsMCxhW24rMV0sYVtuKzJdLGFbbisxXSxhW24rMl0pfVxuZnVuY3Rpb24gdShhLGMpe2Zvcig7YS5sZW5ndGg8djspe2FbMF09Y1t2LWEubGVuZ3RoXTt2YXIgYj1hLnNsaWNlKDAsZSk7W10uc3BsaWNlLmFwcGx5KGEsWzAsMF0uY29uY2F0KGIpKTtEJiYoYj1hLnNsaWNlKGEubGVuZ3RoLWUpLFtdLnNwbGljZS5hcHBseShhLFthLmxlbmd0aCwwXS5jb25jYXQoYikpLG4tLSl9YVswXT1cIk1cIn1mdW5jdGlvbiB0KGEsYyl7Zm9yKHZhciBxPSh2LWEubGVuZ3RoKS9lOzA8cSYmcS0tOyl5PWEuc2xpY2UoKS5zcGxpY2UoYS5sZW5ndGgvSi1lLGUqSikseVswXT1jW3YtZS1xKmVdLGImJih5W2UtNl09eVtlLTJdLHlbZS01XT15W2UtMV0pLFtdLnNwbGljZS5hcHBseShhLFthLmxlbmd0aC9KLDBdLmNvbmNhdCh5KSksRCYmcS0tfWY9Znx8XCJcIjt2YXIgZyxkPW0uc3RhcnRYLGs9bS5lbmRYLGI9LTE8Zi5pbmRleE9mKFwiQ1wiKSxlPWI/NzozLHYseSxuO2Y9Zi5zcGxpdChcIiBcIik7bD1sLnNsaWNlKCk7dmFyIEQ9bS5pc0FyZWEsSj1EPzI6MSxjO2ImJihyKGYpLFxucihsKSk7aWYoZCYmayl7Zm9yKG49MDtuPGQubGVuZ3RoO24rKylpZihkW25dPT09a1swXSl7Zz1uO2JyZWFrfWVsc2UgaWYoZFswXT09PWtbay5sZW5ndGgtZC5sZW5ndGgrbl0pe2c9bjtjPSEwO2JyZWFrfXZvaWQgMD09PWcmJihmPVtdKX1mLmxlbmd0aCYmYS5pc051bWJlcihnKSYmKHY9bC5sZW5ndGgrZypKKmUsYz8odShmLGwpLHQobCxmKSk6KHUobCxmKSx0KGYsbCkpKTtyZXR1cm5bZixsXX19O2EuRngucHJvdG90eXBlLmZpbGxTZXR0ZXI9YS5GeC5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyPWZ1bmN0aW9uKCl7dGhpcy5lbGVtLmF0dHIodGhpcy5wcm9wLGEuY29sb3IodGhpcy5zdGFydCkudHdlZW5UbyhhLmNvbG9yKHRoaXMuZW5kKSx0aGlzLnBvcyksbnVsbCwhMCl9O2EuZXh0ZW5kPWZ1bmN0aW9uKGEsZil7dmFyIG07YXx8KGE9e30pO2ZvcihtIGluIGYpYVttXT1mW21dO3JldHVybiBhfTthLm1lcmdlPWZ1bmN0aW9uKCl7dmFyIG0sZj1hcmd1bWVudHMsbCxyPXt9LHU9XG5mdW5jdGlvbihmLGcpe1wib2JqZWN0XCIhPT10eXBlb2YgZiYmKGY9e30pO2Eub2JqZWN0RWFjaChnLGZ1bmN0aW9uKGQsayl7IWEuaXNPYmplY3QoZCwhMCl8fGEuaXNDbGFzcyhkKXx8YS5pc0RPTUVsZW1lbnQoZCk/ZltrXT1nW2tdOmZba109dShmW2tdfHx7fSxkKX0pO3JldHVybiBmfTshMD09PWZbMF0mJihyPWZbMV0sZj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmLDIpKTtsPWYubGVuZ3RoO2ZvcihtPTA7bTxsO20rKylyPXUocixmW21dKTtyZXR1cm4gcn07YS5wSW50PWZ1bmN0aW9uKGEsZil7cmV0dXJuIHBhcnNlSW50KGEsZnx8MTApfTthLmlzU3RyaW5nPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYX07YS5pc0FycmF5PWZ1bmN0aW9uKGEpe2E9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PWF8fFwiW29iamVjdCBBcnJheSBJdGVyYXRvcl1cIj09PWF9O2EuaXNPYmplY3Q9ZnVuY3Rpb24obSxcbmYpe3JldHVybiEhbSYmXCJvYmplY3RcIj09PXR5cGVvZiBtJiYoIWZ8fCFhLmlzQXJyYXkobSkpfTthLmlzRE9NRWxlbWVudD1mdW5jdGlvbihtKXtyZXR1cm4gYS5pc09iamVjdChtKSYmXCJudW1iZXJcIj09PXR5cGVvZiBtLm5vZGVUeXBlfTthLmlzQ2xhc3M9ZnVuY3Rpb24obSl7dmFyIGY9bSYmbS5jb25zdHJ1Y3RvcjtyZXR1cm4hKCFhLmlzT2JqZWN0KG0sITApfHxhLmlzRE9NRWxlbWVudChtKXx8IWZ8fCFmLm5hbWV8fFwiT2JqZWN0XCI9PT1mLm5hbWUpfTthLmlzTnVtYmVyPWZ1bmN0aW9uKGEpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYSYmIWlzTmFOKGEpfTthLmVyYXNlPWZ1bmN0aW9uKGEsZil7Zm9yKHZhciBtPWEubGVuZ3RoO20tLTspaWYoYVttXT09PWYpe2Euc3BsaWNlKG0sMSk7YnJlYWt9fTthLmRlZmluZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMCE9PWEmJm51bGwhPT1hfTthLmF0dHI9ZnVuY3Rpb24obSxmLGwpe3ZhciByO2EuaXNTdHJpbmcoZik/YS5kZWZpbmVkKGwpP1xubS5zZXRBdHRyaWJ1dGUoZixsKTptJiZtLmdldEF0dHJpYnV0ZSYmKHI9bS5nZXRBdHRyaWJ1dGUoZikpOmEuZGVmaW5lZChmKSYmYS5pc09iamVjdChmKSYmYS5vYmplY3RFYWNoKGYsZnVuY3Rpb24oYSxmKXttLnNldEF0dHJpYnV0ZShmLGEpfSk7cmV0dXJuIHJ9O2Euc3BsYXQ9ZnVuY3Rpb24obSl7cmV0dXJuIGEuaXNBcnJheShtKT9tOlttXX07YS5zeW5jVGltZW91dD1mdW5jdGlvbihhLGYsbCl7aWYoZilyZXR1cm4gc2V0VGltZW91dChhLGYsbCk7YS5jYWxsKDAsbCl9O2EucGljaz1mdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50cyxmLGwscj1hLmxlbmd0aDtmb3IoZj0wO2Y8cjtmKyspaWYobD1hW2ZdLHZvaWQgMCE9PWwmJm51bGwhPT1sKXJldHVybiBsfTthLmNzcz1mdW5jdGlvbihtLGYpe2EuaXNNUyYmIWEuc3ZnJiZmJiZ2b2lkIDAhPT1mLm9wYWNpdHkmJihmLmZpbHRlcj1cImFscGhhKG9wYWNpdHlcXHgzZFwiKzEwMCpmLm9wYWNpdHkrXCIpXCIpO2EuZXh0ZW5kKG0uc3R5bGUsXG5mKX07YS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKG0sZixsLHIsdSl7bT1GLmNyZWF0ZUVsZW1lbnQobSk7dmFyIHQ9YS5jc3M7ZiYmYS5leHRlbmQobSxmKTt1JiZ0KG0se3BhZGRpbmc6MCxib3JkZXI6XCJub25lXCIsbWFyZ2luOjB9KTtsJiZ0KG0sbCk7ciYmci5hcHBlbmRDaGlsZChtKTtyZXR1cm4gbX07YS5leHRlbmRDbGFzcz1mdW5jdGlvbihtLGYpe3ZhciBsPWZ1bmN0aW9uKCl7fTtsLnByb3RvdHlwZT1uZXcgbTthLmV4dGVuZChsLnByb3RvdHlwZSxmKTtyZXR1cm4gbH07YS5wYWQ9ZnVuY3Rpb24oYSxmLGwpe3JldHVybiBBcnJheSgoZnx8MikrMS1TdHJpbmcoYSkubGVuZ3RoKS5qb2luKGx8fDApK2F9O2EucmVsYXRpdmVMZW5ndGg9ZnVuY3Rpb24oYSxmLGwpe3JldHVybi8lJC8udGVzdChhKT9mKnBhcnNlRmxvYXQoYSkvMTAwKyhsfHwwKTpwYXJzZUZsb2F0KGEpfTthLndyYXA9ZnVuY3Rpb24oYSxmLGwpe3ZhciByPWFbZl07YVtmXT1mdW5jdGlvbigpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG5mPWFyZ3VtZW50cyxnPXRoaXM7Zy5wcm9jZWVkPWZ1bmN0aW9uKCl7ci5hcHBseShnLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzOmYpfTthLnVuc2hpZnQocik7YT1sLmFwcGx5KHRoaXMsYSk7Zy5wcm9jZWVkPW51bGw7cmV0dXJuIGF9fTthLmdldFRaT2Zmc2V0PWZ1bmN0aW9uKG0pe3ZhciBmPWEuRGF0ZTtyZXR1cm4gNkU0KihmLmhjR2V0VGltZXpvbmVPZmZzZXQmJmYuaGNHZXRUaW1lem9uZU9mZnNldChtKXx8Zi5oY1RpbWV6b25lT2Zmc2V0fHwwKX07YS5kYXRlRm9ybWF0PWZ1bmN0aW9uKG0sZixsKXtpZighYS5kZWZpbmVkKGYpfHxpc05hTihmKSlyZXR1cm4gYS5kZWZhdWx0T3B0aW9ucy5sYW5nLmludmFsaWREYXRlfHxcIlwiO209YS5waWNrKG0sXCIlWS0lbS0lZCAlSDolTTolU1wiKTt2YXIgcj1hLkRhdGUsdT1uZXcgcihmLWEuZ2V0VFpPZmZzZXQoZikpLHQ9dVtyLmhjR2V0SG91cnNdKCksZz11W3IuaGNHZXREYXldKCksZD11W3IuaGNHZXREYXRlXSgpLGs9dVtyLmhjR2V0TW9udGhdKCksXG5iPXVbci5oY0dldEZ1bGxZZWFyXSgpLGU9YS5kZWZhdWx0T3B0aW9ucy5sYW5nLHY9ZS53ZWVrZGF5cyx5PWUuc2hvcnRXZWVrZGF5cyxuPWEucGFkLHI9YS5leHRlbmQoe2E6eT95W2ddOnZbZ10uc3Vic3RyKDAsMyksQTp2W2ddLGQ6bihkKSxlOm4oZCwyLFwiIFwiKSx3OmcsYjplLnNob3J0TW9udGhzW2tdLEI6ZS5tb250aHNba10sbTpuKGsrMSkseTpiLnRvU3RyaW5nKCkuc3Vic3RyKDIsMiksWTpiLEg6bih0KSxrOnQsSTpuKHQlMTJ8fDEyKSxsOnQlMTJ8fDEyLE06bih1W3IuaGNHZXRNaW51dGVzXSgpKSxwOjEyPnQ/XCJBTVwiOlwiUE1cIixQOjEyPnQ/XCJhbVwiOlwicG1cIixTOm4odS5nZXRTZWNvbmRzKCkpLEw6bihNYXRoLnJvdW5kKGYlMUUzKSwzKX0sYS5kYXRlRm9ybWF0cyk7YS5vYmplY3RFYWNoKHIsZnVuY3Rpb24oYSxlKXtmb3IoOy0xIT09bS5pbmRleE9mKFwiJVwiK2UpOyltPW0ucmVwbGFjZShcIiVcIitlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EoZik6YSl9KTtyZXR1cm4gbD9tLnN1YnN0cigwLFxuMSkudG9VcHBlckNhc2UoKSttLnN1YnN0cigxKTptfTthLmZvcm1hdFNpbmdsZT1mdW5jdGlvbihtLGYpe3ZhciBsPS9cXC4oWzAtOV0pLyxyPWEuZGVmYXVsdE9wdGlvbnMubGFuZzsvZiQvLnRlc3QobSk/KGw9KGw9bS5tYXRjaChsKSk/bFsxXTotMSxudWxsIT09ZiYmKGY9YS5udW1iZXJGb3JtYXQoZixsLHIuZGVjaW1hbFBvaW50LC0xPG0uaW5kZXhPZihcIixcIik/ci50aG91c2FuZHNTZXA6XCJcIikpKTpmPWEuZGF0ZUZvcm1hdChtLGYpO3JldHVybiBmfTthLmZvcm1hdD1mdW5jdGlvbihtLGYpe2Zvcih2YXIgbD1cIntcIixyPSExLHUsdCxnLGQsaz1bXSxiO207KXtsPW0uaW5kZXhPZihsKTtpZigtMT09PWwpYnJlYWs7dT1tLnNsaWNlKDAsbCk7aWYocil7dT11LnNwbGl0KFwiOlwiKTt0PXUuc2hpZnQoKS5zcGxpdChcIi5cIik7ZD10Lmxlbmd0aDtiPWY7Zm9yKGc9MDtnPGQ7ZysrKWI9Ylt0W2ddXTt1Lmxlbmd0aCYmKGI9YS5mb3JtYXRTaW5nbGUodS5qb2luKFwiOlwiKSxiKSk7ay5wdXNoKGIpfWVsc2Ugay5wdXNoKHUpO1xubT1tLnNsaWNlKGwrMSk7bD0ocj0hcik/XCJ9XCI6XCJ7XCJ9ay5wdXNoKG0pO3JldHVybiBrLmpvaW4oXCJcIil9O2EuZ2V0TWFnbml0dWRlPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnBvdygxMCxNYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGguTE4xMCkpfTthLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbD1mdW5jdGlvbihtLGYsbCxyLHUpe3ZhciB0LGc9bTtsPWEucGljayhsLDEpO3Q9bS9sO2Z8fChmPXU/WzEsMS4yLDEuNSwyLDIuNSwzLDQsNSw2LDgsMTBdOlsxLDIsMi41LDUsMTBdLCExPT09ciYmKDE9PT1sP2Y9YS5ncmVwKGYsZnVuY3Rpb24oYSl7cmV0dXJuIDA9PT1hJTF9KTouMT49bCYmKGY9WzEvbF0pKSk7Zm9yKHI9MDtyPGYubGVuZ3RoJiYhKGc9ZltyXSx1JiZnKmw+PW18fCF1JiZ0PD0oZltyXSsoZltyKzFdfHxmW3JdKSkvMik7cisrKTtyZXR1cm4gZz1hLmNvcnJlY3RGbG9hdChnKmwsLU1hdGgucm91bmQoTWF0aC5sb2coLjAwMSkvTWF0aC5MTjEwKSl9O2Euc3RhYmxlU29ydD1cbmZ1bmN0aW9uKGEsZil7dmFyIGw9YS5sZW5ndGgscixtO2ZvcihtPTA7bTxsO20rKylhW21dLnNhZmVJPW07YS5zb3J0KGZ1bmN0aW9uKGEsZyl7cj1mKGEsZyk7cmV0dXJuIDA9PT1yP2Euc2FmZUktZy5zYWZlSTpyfSk7Zm9yKG09MDttPGw7bSsrKWRlbGV0ZSBhW21dLnNhZmVJfTthLmFycmF5TWluPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZj1hLmxlbmd0aCxsPWFbMF07Zi0tOylhW2ZdPGwmJihsPWFbZl0pO3JldHVybiBsfTthLmFycmF5TWF4PWZ1bmN0aW9uKGEpe2Zvcih2YXIgZj1hLmxlbmd0aCxsPWFbMF07Zi0tOylhW2ZdPmwmJihsPWFbZl0pO3JldHVybiBsfTthLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzPWZ1bmN0aW9uKG0sZil7YS5vYmplY3RFYWNoKG0sZnVuY3Rpb24oYSxyKXthJiZhIT09ZiYmYS5kZXN0cm95JiZhLmRlc3Ryb3koKTtkZWxldGUgbVtyXX0pfTthLmRpc2NhcmRFbGVtZW50PWZ1bmN0aW9uKG0pe3ZhciBmPWEuZ2FyYmFnZUJpbjtmfHwoZj1hLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xubSYmZi5hcHBlbmRDaGlsZChtKTtmLmlubmVySFRNTD1cIlwifTthLmNvcnJlY3RGbG9hdD1mdW5jdGlvbihhLGYpe3JldHVybiBwYXJzZUZsb2F0KGEudG9QcmVjaXNpb24oZnx8MTQpKX07YS5zZXRBbmltYXRpb249ZnVuY3Rpb24obSxmKXtmLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbj1hLnBpY2sobSxmLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLCEwKX07YS5hbmltT2JqZWN0PWZ1bmN0aW9uKG0pe3JldHVybiBhLmlzT2JqZWN0KG0pP2EubWVyZ2UobSk6e2R1cmF0aW9uOm0/NTAwOjB9fTthLnRpbWVVbml0cz17bWlsbGlzZWNvbmQ6MSxzZWNvbmQ6MUUzLG1pbnV0ZTo2RTQsaG91cjozNkU1LGRheTo4NjRFNSx3ZWVrOjYwNDhFNSxtb250aDoyNDE5MkU1LHllYXI6MzE0NDk2RTV9O2EubnVtYmVyRm9ybWF0PWZ1bmN0aW9uKG0sZixsLHIpe209K218fDA7Zj0rZjt2YXIgdT1hLmRlZmF1bHRPcHRpb25zLmxhbmcsdD0obS50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXXx8XCJcIikuc3BsaXQoXCJlXCIpWzBdLmxlbmd0aCxcbmcsZCxrPW0udG9TdHJpbmcoKS5zcGxpdChcImVcIik7LTE9PT1mP2Y9TWF0aC5taW4odCwyMCk6YS5pc051bWJlcihmKXx8KGY9Mik7ZD0oTWF0aC5hYnMoa1sxXT9rWzBdOm0pK01hdGgucG93KDEwLC1NYXRoLm1heChmLHQpLTEpKS50b0ZpeGVkKGYpO3Q9U3RyaW5nKGEucEludChkKSk7Zz0zPHQubGVuZ3RoP3QubGVuZ3RoJTM6MDtsPWEucGljayhsLHUuZGVjaW1hbFBvaW50KTtyPWEucGljayhyLHUudGhvdXNhbmRzU2VwKTttPSgwPm0/XCItXCI6XCJcIikrKGc/dC5zdWJzdHIoMCxnKStyOlwiXCIpO20rPXQuc3Vic3RyKGcpLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLFwiJDFcIityKTtmJiYobSs9bCtkLnNsaWNlKC1mKSk7a1sxXSYmKG0rPVwiZVwiK2tbMV0pO3JldHVybiBtfTtNYXRoLmVhc2VJbk91dFNpbmU9ZnVuY3Rpb24oYSl7cmV0dXJuLS41KihNYXRoLmNvcyhNYXRoLlBJKmEpLTEpfTthLmdldFN0eWxlPWZ1bmN0aW9uKG0sZixsKXtpZihcIndpZHRoXCI9PT1mKXJldHVybiBNYXRoLm1pbihtLm9mZnNldFdpZHRoLFxubS5zY3JvbGxXaWR0aCktYS5nZXRTdHlsZShtLFwicGFkZGluZy1sZWZ0XCIpLWEuZ2V0U3R5bGUobSxcInBhZGRpbmctcmlnaHRcIik7aWYoXCJoZWlnaHRcIj09PWYpcmV0dXJuIE1hdGgubWluKG0ub2Zmc2V0SGVpZ2h0LG0uc2Nyb2xsSGVpZ2h0KS1hLmdldFN0eWxlKG0sXCJwYWRkaW5nLXRvcFwiKS1hLmdldFN0eWxlKG0sXCJwYWRkaW5nLWJvdHRvbVwiKTtpZihtPUUuZ2V0Q29tcHV0ZWRTdHlsZShtLHZvaWQgMCkpbT1tLmdldFByb3BlcnR5VmFsdWUoZiksYS5waWNrKGwsITApJiYobT1hLnBJbnQobSkpO3JldHVybiBtfTthLmluQXJyYXk9ZnVuY3Rpb24oYSxmKXtyZXR1cm4gZi5pbmRleE9mP2YuaW5kZXhPZihhKTpbXS5pbmRleE9mLmNhbGwoZixhKX07YS5ncmVwPWZ1bmN0aW9uKGEsZil7cmV0dXJuW10uZmlsdGVyLmNhbGwoYSxmKX07YS5maW5kPWZ1bmN0aW9uKGEsZil7cmV0dXJuW10uZmluZC5jYWxsKGEsZil9O2EubWFwPWZ1bmN0aW9uKGEsZil7Zm9yKHZhciBsPVtdLHI9MCxtPVxuYS5sZW5ndGg7cjxtO3IrKylsW3JdPWYuY2FsbChhW3JdLGFbcl0scixhKTtyZXR1cm4gbH07YS5vZmZzZXQ9ZnVuY3Rpb24oYSl7dmFyIGY9Ri5kb2N1bWVudEVsZW1lbnQ7YT1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt0b3A6YS50b3ArKEUucGFnZVlPZmZzZXR8fGYuc2Nyb2xsVG9wKS0oZi5jbGllbnRUb3B8fDApLGxlZnQ6YS5sZWZ0KyhFLnBhZ2VYT2Zmc2V0fHxmLnNjcm9sbExlZnQpLShmLmNsaWVudExlZnR8fDApfX07YS5zdG9wPWZ1bmN0aW9uKGEsZil7Zm9yKHZhciBsPUMubGVuZ3RoO2wtLTspQ1tsXS5lbGVtIT09YXx8ZiYmZiE9PUNbbF0ucHJvcHx8KENbbF0uc3RvcHBlZD0hMCl9O2EuZWFjaD1mdW5jdGlvbihhLGYsbCl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxmLGwpfTthLm9iamVjdEVhY2g9ZnVuY3Rpb24oYSxmLGwpe2Zvcih2YXIgciBpbiBhKWEuaGFzT3duUHJvcGVydHkocikmJmYuY2FsbChsLGFbcl0scixhKX07XG5hLmFkZEV2ZW50PWZ1bmN0aW9uKG0sZixsKXtmdW5jdGlvbiByKGEpe2EudGFyZ2V0PWEuc3JjRWxlbWVudHx8RTtsLmNhbGwobSxhKX12YXIgdT1tLmhjRXZlbnRzPW0uaGNFdmVudHN8fHt9O20uYWRkRXZlbnRMaXN0ZW5lcj9tLmFkZEV2ZW50TGlzdGVuZXIoZixsLCExKTptLmF0dGFjaEV2ZW50JiYobS5oY0V2ZW50c0lFfHwobS5oY0V2ZW50c0lFPXt9KSxsLmhjR2V0S2V5fHwobC5oY0dldEtleT1hLnVuaXF1ZUtleSgpKSxtLmhjRXZlbnRzSUVbbC5oY0dldEtleV09cixtLmF0dGFjaEV2ZW50KFwib25cIitmLHIpKTt1W2ZdfHwodVtmXT1bXSk7dVtmXS5wdXNoKGwpO3JldHVybiBmdW5jdGlvbigpe2EucmVtb3ZlRXZlbnQobSxmLGwpfX07YS5yZW1vdmVFdmVudD1mdW5jdGlvbihtLGYsbCl7ZnVuY3Rpb24gcihhLGIpe20ucmVtb3ZlRXZlbnRMaXN0ZW5lcj9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxiLCExKTptLmF0dGFjaEV2ZW50JiYoYj1tLmhjRXZlbnRzSUVbYi5oY0dldEtleV0sXG5tLmRldGFjaEV2ZW50KFwib25cIithLGIpKX1mdW5jdGlvbiB1KCl7dmFyIGQsYjttLm5vZGVOYW1lJiYoZj8oZD17fSxkW2ZdPSEwKTpkPWcsYS5vYmplY3RFYWNoKGQsZnVuY3Rpb24oYSxkKXtpZihnW2RdKWZvcihiPWdbZF0ubGVuZ3RoO2ItLTspcihkLGdbZF1bYl0pfSkpfXZhciB0LGc9bS5oY0V2ZW50cyxkO2cmJihmPyh0PWdbZl18fFtdLGw/KGQ9YS5pbkFycmF5KGwsdCksLTE8ZCYmKHQuc3BsaWNlKGQsMSksZ1tmXT10KSxyKGYsbCkpOih1KCksZ1tmXT1bXSkpOih1KCksbS5oY0V2ZW50cz17fSkpfTthLmZpcmVFdmVudD1mdW5jdGlvbihtLGYsbCxyKXt2YXIgdTt1PW0uaGNFdmVudHM7dmFyIHQsZztsPWx8fHt9O2lmKEYuY3JlYXRlRXZlbnQmJihtLmRpc3BhdGNoRXZlbnR8fG0uZmlyZUV2ZW50KSl1PUYuY3JlYXRlRXZlbnQoXCJFdmVudHNcIiksdS5pbml0RXZlbnQoZiwhMCwhMCksYS5leHRlbmQodSxsKSxtLmRpc3BhdGNoRXZlbnQ/bS5kaXNwYXRjaEV2ZW50KHUpOm0uZmlyZUV2ZW50KGYsXG51KTtlbHNlIGlmKHUpZm9yKHU9dVtmXXx8W10sdD11Lmxlbmd0aCxsLnRhcmdldHx8YS5leHRlbmQobCx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXtsLmRlZmF1bHRQcmV2ZW50ZWQ9ITB9LHRhcmdldDptLHR5cGU6Zn0pLGY9MDtmPHQ7ZisrKShnPXVbZl0pJiYhMT09PWcuY2FsbChtLGwpJiZsLnByZXZlbnREZWZhdWx0KCk7ciYmIWwuZGVmYXVsdFByZXZlbnRlZCYmcihsKX07YS5hbmltYXRlPWZ1bmN0aW9uKG0sZixsKXt2YXIgcix1PVwiXCIsdCxnLGQ7YS5pc09iamVjdChsKXx8KGQ9YXJndW1lbnRzLGw9e2R1cmF0aW9uOmRbMl0sZWFzaW5nOmRbM10sY29tcGxldGU6ZFs0XX0pO2EuaXNOdW1iZXIobC5kdXJhdGlvbil8fChsLmR1cmF0aW9uPTQwMCk7bC5lYXNpbmc9XCJmdW5jdGlvblwiPT09dHlwZW9mIGwuZWFzaW5nP2wuZWFzaW5nOk1hdGhbbC5lYXNpbmddfHxNYXRoLmVhc2VJbk91dFNpbmU7bC5jdXJBbmltPWEubWVyZ2UoZik7YS5vYmplY3RFYWNoKGYsZnVuY3Rpb24oZCxcbmIpe2Euc3RvcChtLGIpO2c9bmV3IGEuRngobSxsLGIpO3Q9bnVsbDtcImRcIj09PWI/KGcucGF0aHM9Zy5pbml0UGF0aChtLG0uZCxmLmQpLGcudG9EPWYuZCxyPTAsdD0xKTptLmF0dHI/cj1tLmF0dHIoYik6KHI9cGFyc2VGbG9hdChhLmdldFN0eWxlKG0sYikpfHwwLFwib3BhY2l0eVwiIT09YiYmKHU9XCJweFwiKSk7dHx8KHQ9ZCk7dCYmdC5tYXRjaCYmdC5tYXRjaChcInB4XCIpJiYodD10LnJlcGxhY2UoL3B4L2csXCJcIikpO2cucnVuKHIsdCx1KX0pfTthLnNlcmllc1R5cGU9ZnVuY3Rpb24obSxmLGwscix1KXt2YXIgdD1hLmdldE9wdGlvbnMoKSxnPWEuc2VyaWVzVHlwZXM7dC5wbG90T3B0aW9uc1ttXT1hLm1lcmdlKHQucGxvdE9wdGlvbnNbZl0sbCk7Z1ttXT1hLmV4dGVuZENsYXNzKGdbZl18fGZ1bmN0aW9uKCl7fSxyKTtnW21dLnByb3RvdHlwZS50eXBlPW07dSYmKGdbbV0ucHJvdG90eXBlLnBvaW50Q2xhc3M9YS5leHRlbmRDbGFzcyhhLlBvaW50LHUpKTtyZXR1cm4gZ1ttXX07YS51bmlxdWVLZXk9XG5mdW5jdGlvbigpe3ZhciBhPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLDkpLGY9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm5cImhpZ2hjaGFydHMtXCIrYStcIi1cIitmKyt9fSgpO0UualF1ZXJ5JiYoRS5qUXVlcnkuZm4uaGlnaGNoYXJ0cz1mdW5jdGlvbigpe3ZhciBtPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZih0aGlzWzBdKXJldHVybiBtWzBdPyhuZXcgKGFbYS5pc1N0cmluZyhtWzBdKT9tLnNoaWZ0KCk6XCJDaGFydFwiXSkodGhpc1swXSxtWzBdLG1bMV0pLHRoaXMpOkFbYS5hdHRyKHRoaXNbMF0sXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIildfSk7RiYmIUYuZGVmYXVsdFZpZXcmJihhLmdldFN0eWxlPWZ1bmN0aW9uKG0sZil7dmFyIGw9e3dpZHRoOlwiY2xpZW50V2lkdGhcIixoZWlnaHQ6XCJjbGllbnRIZWlnaHRcIn1bZl07aWYobS5zdHlsZVtmXSlyZXR1cm4gYS5wSW50KG0uc3R5bGVbZl0pO1wib3BhY2l0eVwiPT09ZiYmKGY9XCJmaWx0ZXJcIik7aWYobClyZXR1cm4gbS5zdHlsZS56b29tPVxuMSxNYXRoLm1heChtW2xdLTIqYS5nZXRTdHlsZShtLFwicGFkZGluZ1wiKSwwKTttPW0uY3VycmVudFN0eWxlW2YucmVwbGFjZSgvXFwtKFxcdykvZyxmdW5jdGlvbihhLGYpe3JldHVybiBmLnRvVXBwZXJDYXNlKCl9KV07XCJmaWx0ZXJcIj09PWYmJihtPW0ucmVwbGFjZSgvYWxwaGFcXChvcGFjaXR5PShbMC05XSspXFwpLyxmdW5jdGlvbihhLGYpe3JldHVybiBmLzEwMH0pKTtyZXR1cm5cIlwiPT09bT8xOmEucEludChtKX0pO0FycmF5LnByb3RvdHlwZS5mb3JFYWNofHwoYS5lYWNoPWZ1bmN0aW9uKGEsZixsKXtmb3IodmFyIHI9MCxtPWEubGVuZ3RoO3I8bTtyKyspaWYoITE9PT1mLmNhbGwobCxhW3JdLHIsYSkpcmV0dXJuIHJ9KTtBcnJheS5wcm90b3R5cGUuaW5kZXhPZnx8KGEuaW5BcnJheT1mdW5jdGlvbihhLGYpe3ZhciBsLHI9MDtpZihmKWZvcihsPWYubGVuZ3RoO3I8bDtyKyspaWYoZltyXT09PWEpcmV0dXJuIHI7cmV0dXJuLTF9KTtBcnJheS5wcm90b3R5cGUuZmlsdGVyfHwoYS5ncmVwPVxuZnVuY3Rpb24oYSxmKXtmb3IodmFyIGw9W10scj0wLG09YS5sZW5ndGg7cjxtO3IrKylmKGFbcl0scikmJmwucHVzaChhW3JdKTtyZXR1cm4gbH0pO0FycmF5LnByb3RvdHlwZS5maW5kfHwoYS5maW5kPWZ1bmN0aW9uKGEsZil7dmFyIGwscj1hLmxlbmd0aDtmb3IobD0wO2w8cjtsKyspaWYoZihhW2xdLGwpKXJldHVybiBhW2xdfSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5lYWNoLEE9YS5pc051bWJlcixGPWEubWFwLEU9YS5tZXJnZSxtPWEucEludDthLkNvbG9yPWZ1bmN0aW9uKGYpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGEuQ29sb3IpKXJldHVybiBuZXcgYS5Db2xvcihmKTt0aGlzLmluaXQoZil9O2EuQ29sb3IucHJvdG90eXBlPXtwYXJzZXJzOlt7cmVnZXg6L3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKGEpe3JldHVyblttKGFbMV0pLFxubShhWzJdKSxtKGFbM10pLHBhcnNlRmxvYXQoYVs0XSwxMCldfX0se3JlZ2V4Oi9yZ2JcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKlxcKS8scGFyc2U6ZnVuY3Rpb24oYSl7cmV0dXJuW20oYVsxXSksbShhWzJdKSxtKGFbM10pLDFdfX1dLG5hbWVzOntub25lOlwicmdiYSgyNTUsMjU1LDI1NSwwKVwiLHdoaXRlOlwiI2ZmZmZmZlwiLGJsYWNrOlwiIzAwMDAwMFwifSxpbml0OmZ1bmN0aW9uKGYpe3ZhciBsLHIsbSx0O2lmKCh0aGlzLmlucHV0PWY9dGhpcy5uYW1lc1tmJiZmLnRvTG93ZXJDYXNlP2YudG9Mb3dlckNhc2UoKTpcIlwiXXx8ZikmJmYuc3RvcHMpdGhpcy5zdG9wcz1GKGYuc3RvcHMsZnVuY3Rpb24oZyl7cmV0dXJuIG5ldyBhLkNvbG9yKGdbMV0pfSk7ZWxzZSBpZihmJiZcIiNcIj09PWYuY2hhckF0KCkmJihsPWYubGVuZ3RoLGY9cGFyc2VJbnQoZi5zdWJzdHIoMSksMTYpLDc9PT1sP3I9WyhmJjE2NzExNjgwKT4+MTYsKGYmNjUyODApPj5cbjgsZiYyNTUsMV06ND09PWwmJihyPVsoZiYzODQwKT4+NHwoZiYzODQwKT4+OCwoZiYyNDApPj40fGYmMjQwLChmJjE1KTw8NHxmJjE1LDFdKSksIXIpZm9yKG09dGhpcy5wYXJzZXJzLmxlbmd0aDttLS0mJiFyOyl0PXRoaXMucGFyc2Vyc1ttXSwobD10LnJlZ2V4LmV4ZWMoZikpJiYocj10LnBhcnNlKGwpKTt0aGlzLnJnYmE9cnx8W119LGdldDpmdW5jdGlvbihhKXt2YXIgZj10aGlzLmlucHV0LHI9dGhpcy5yZ2JhLG07dGhpcy5zdG9wcz8obT1FKGYpLG0uc3RvcHM9W10uY29uY2F0KG0uc3RvcHMpLEModGhpcy5zdG9wcyxmdW5jdGlvbihmLGcpe20uc3RvcHNbZ109W20uc3RvcHNbZ11bMF0sZi5nZXQoYSldfSkpOm09ciYmQShyWzBdKT9cInJnYlwiPT09YXx8IWEmJjE9PT1yWzNdP1wicmdiKFwiK3JbMF0rXCIsXCIrclsxXStcIixcIityWzJdK1wiKVwiOlwiYVwiPT09YT9yWzNdOlwicmdiYShcIityLmpvaW4oXCIsXCIpK1wiKVwiOmY7cmV0dXJuIG19LGJyaWdodGVuOmZ1bmN0aW9uKGEpe3ZhciBmLHI9dGhpcy5yZ2JhO1xuaWYodGhpcy5zdG9wcylDKHRoaXMuc3RvcHMsZnVuY3Rpb24oZil7Zi5icmlnaHRlbihhKX0pO2Vsc2UgaWYoQShhKSYmMCE9PWEpZm9yKGY9MDszPmY7ZisrKXJbZl0rPW0oMjU1KmEpLDA+cltmXSYmKHJbZl09MCksMjU1PHJbZl0mJihyW2ZdPTI1NSk7cmV0dXJuIHRoaXN9LHNldE9wYWNpdHk6ZnVuY3Rpb24oYSl7dGhpcy5yZ2JhWzNdPWE7cmV0dXJuIHRoaXN9LHR3ZWVuVG86ZnVuY3Rpb24oYSxsKXt2YXIgZixtO2EucmdiYS5sZW5ndGg/KGY9dGhpcy5yZ2JhLGE9YS5yZ2JhLG09MSE9PWFbM118fDEhPT1mWzNdLGE9KG0/XCJyZ2JhKFwiOlwicmdiKFwiKStNYXRoLnJvdW5kKGFbMF0rKGZbMF0tYVswXSkqKDEtbCkpK1wiLFwiK01hdGgucm91bmQoYVsxXSsoZlsxXS1hWzFdKSooMS1sKSkrXCIsXCIrTWF0aC5yb3VuZChhWzJdKyhmWzJdLWFbMl0pKigxLWwpKSsobT9cIixcIisoYVszXSsoZlszXS1hWzNdKSooMS1sKSk6XCJcIikrXCIpXCIpOmE9YS5pbnB1dHx8XCJub25lXCI7cmV0dXJuIGF9fTthLmNvbG9yPVxuZnVuY3Rpb24oZil7cmV0dXJuIG5ldyBhLkNvbG9yKGYpfX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQyxBLEY9YS5hZGRFdmVudCxFPWEuYW5pbWF0ZSxtPWEuYXR0cixmPWEuY2hhcnRzLGw9YS5jb2xvcixyPWEuY3NzLHU9YS5jcmVhdGVFbGVtZW50LHQ9YS5kZWZpbmVkLGc9YS5kZWcycmFkLGQ9YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxrPWEuZG9jLGI9YS5lYWNoLGU9YS5leHRlbmQsdj1hLmVyYXNlLHk9YS5ncmVwLG49YS5oYXNUb3VjaCxEPWEuaW5BcnJheSxKPWEuaXNBcnJheSxjPWEuaXNGaXJlZm94LEc9YS5pc01TLHE9YS5pc09iamVjdCxCPWEuaXNTdHJpbmcsSz1hLmlzV2ViS2l0LHA9YS5tZXJnZSx6PWEubm9vcCxJPWEub2JqZWN0RWFjaCxMPWEucGljayxoPWEucEludCx3PWEucmVtb3ZlRXZlbnQsUD1hLnN0b3AsSD1hLnN2ZyxPPWEuU1ZHX05TLFE9YS5zeW1ib2xTaXplcyxSPWEud2luO0M9YS5TVkdFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2UoQy5wcm90b3R5cGUsXG57b3BhY2l0eToxLFNWR19OUzpPLHRleHRQcm9wczpcImRpcmVjdGlvbiBmb250U2l6ZSBmb250V2VpZ2h0IGZvbnRGYW1pbHkgZm9udFN0eWxlIGNvbG9yIGxpbmVIZWlnaHQgd2lkdGggdGV4dEFsaWduIHRleHREZWNvcmF0aW9uIHRleHRPdmVyZmxvdyB0ZXh0T3V0bGluZVwiLnNwbGl0KFwiIFwiKSxpbml0OmZ1bmN0aW9uKGEsaCl7dGhpcy5lbGVtZW50PVwic3BhblwiPT09aD91KGgpOmsuY3JlYXRlRWxlbWVudE5TKHRoaXMuU1ZHX05TLGgpO3RoaXMucmVuZGVyZXI9YX0sYW5pbWF0ZTpmdW5jdGlvbih4LGgsYyl7aD1hLmFuaW1PYmplY3QoTChoLHRoaXMucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCEwKSk7MCE9PWguZHVyYXRpb24/KGMmJihoLmNvbXBsZXRlPWMpLEUodGhpcyx4LGgpKToodGhpcy5hdHRyKHgsbnVsbCxjKSxoLnN0ZXAmJmguc3RlcC5jYWxsKHRoaXMpKTtyZXR1cm4gdGhpc30sY29sb3JHcmFkaWVudDpmdW5jdGlvbih4LGgsYyl7dmFyIHc9dGhpcy5yZW5kZXJlcixcbmUscSxOLGQsbixnLGssSCxHLHYsej1bXSxmO3gucmFkaWFsR3JhZGllbnQ/cT1cInJhZGlhbEdyYWRpZW50XCI6eC5saW5lYXJHcmFkaWVudCYmKHE9XCJsaW5lYXJHcmFkaWVudFwiKTtxJiYoTj14W3FdLG49dy5ncmFkaWVudHMsaz14LnN0b3BzLHY9Yy5yYWRpYWxSZWZlcmVuY2UsSihOKSYmKHhbcV09Tj17eDE6TlswXSx5MTpOWzFdLHgyOk5bMl0seTI6TlszXSxncmFkaWVudFVuaXRzOlwidXNlclNwYWNlT25Vc2VcIn0pLFwicmFkaWFsR3JhZGllbnRcIj09PXEmJnYmJiF0KE4uZ3JhZGllbnRVbml0cykmJihkPU4sTj1wKE4sdy5nZXRSYWRpYWxBdHRyKHYsZCkse2dyYWRpZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwifSkpLEkoTixmdW5jdGlvbihhLHgpe1wiaWRcIiE9PXgmJnoucHVzaCh4LGEpfSksSShrLGZ1bmN0aW9uKGEpe3oucHVzaChhKX0pLHo9ei5qb2luKFwiLFwiKSxuW3pdP3Y9blt6XS5hdHRyKFwiaWRcIik6KE4uaWQ9dj1hLnVuaXF1ZUtleSgpLG5bel09Zz13LmNyZWF0ZUVsZW1lbnQocSkuYXR0cihOKS5hZGQody5kZWZzKSxcbmcucmFkQXR0cj1kLGcuc3RvcHM9W10sYihrLGZ1bmN0aW9uKHgpezA9PT14WzFdLmluZGV4T2YoXCJyZ2JhXCIpPyhlPWEuY29sb3IoeFsxXSksSD1lLmdldChcInJnYlwiKSxHPWUuZ2V0KFwiYVwiKSk6KEg9eFsxXSxHPTEpO3g9dy5jcmVhdGVFbGVtZW50KFwic3RvcFwiKS5hdHRyKHtvZmZzZXQ6eFswXSxcInN0b3AtY29sb3JcIjpILFwic3RvcC1vcGFjaXR5XCI6R30pLmFkZChnKTtnLnN0b3BzLnB1c2goeCl9KSksZj1cInVybChcIit3LnVybCtcIiNcIit2K1wiKVwiLGMuc2V0QXR0cmlidXRlKGgsZiksYy5ncmFkaWVudD16LHgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gZn0pfSxhcHBseVRleHRPdXRsaW5lOmZ1bmN0aW9uKHgpe3ZhciBoPXRoaXMuZWxlbWVudCxjLHcscCxlLHE7LTEhPT14LmluZGV4T2YoXCJjb250cmFzdFwiKSYmKHg9eC5yZXBsYWNlKC9jb250cmFzdC9nLHRoaXMucmVuZGVyZXIuZ2V0Q29udHJhc3QoaC5zdHlsZS5maWxsKSkpO3g9eC5zcGxpdChcIiBcIik7dz14W3gubGVuZ3RoLTFdO1xuaWYoKHA9eFswXSkmJlwibm9uZVwiIT09cCYmYS5zdmcpe3RoaXMuZmFrZVRTPSEwO3g9W10uc2xpY2UuY2FsbChoLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIikpO3RoaXMueVNldHRlcj10aGlzLnhTZXR0ZXI7cD1wLnJlcGxhY2UoLyheW1xcZFxcLl0rKSguKj8pJC9nLGZ1bmN0aW9uKGEseCxoKXtyZXR1cm4gMip4K2h9KTtmb3IocT14Lmxlbmd0aDtxLS07KWM9eFtxXSxcImhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCI9PT1jLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpJiZ2KHgsaC5yZW1vdmVDaGlsZChjKSk7ZT1oLmZpcnN0Q2hpbGQ7Yih4LGZ1bmN0aW9uKGEseCl7MD09PXgmJihhLnNldEF0dHJpYnV0ZShcInhcIixoLmdldEF0dHJpYnV0ZShcInhcIikpLHg9aC5nZXRBdHRyaWJ1dGUoXCJ5XCIpLGEuc2V0QXR0cmlidXRlKFwieVwiLHh8fDApLG51bGw9PT14JiZoLnNldEF0dHJpYnV0ZShcInlcIiwwKSk7YT1hLmNsb25lTm9kZSgxKTttKGEse1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIsXG5maWxsOncsc3Ryb2tlOncsXCJzdHJva2Utd2lkdGhcIjpwLFwic3Ryb2tlLWxpbmVqb2luXCI6XCJyb3VuZFwifSk7aC5pbnNlcnRCZWZvcmUoYSxlKX0pfX0sYXR0cjpmdW5jdGlvbihhLGgsYyx3KXt2YXIgeCxwPXRoaXMuZWxlbWVudCxlLHE9dGhpcyxiLE47XCJzdHJpbmdcIj09PXR5cGVvZiBhJiZ2b2lkIDAhPT1oJiYoeD1hLGE9e30sYVt4XT1oKTtcInN0cmluZ1wiPT09dHlwZW9mIGE/cT0odGhpc1thK1wiR2V0dGVyXCJdfHx0aGlzLl9kZWZhdWx0R2V0dGVyKS5jYWxsKHRoaXMsYSxwKTooSShhLGZ1bmN0aW9uKHgsaCl7Yj0hMTt3fHxQKHRoaXMsaCk7dGhpcy5zeW1ib2xOYW1lJiYvXih4fHl8d2lkdGh8aGVpZ2h0fHJ8c3RhcnR8ZW5kfGlubmVyUnxhbmNob3JYfGFuY2hvclkpJC8udGVzdChoKSYmKGV8fCh0aGlzLnN5bWJvbEF0dHIoYSksZT0hMCksYj0hMCk7IXRoaXMucm90YXRpb258fFwieFwiIT09aCYmXCJ5XCIhPT1ofHwodGhpcy5kb1RyYW5zZm9ybT0hMCk7Ynx8KE49dGhpc1toK1wiU2V0dGVyXCJdfHxcbnRoaXMuX2RlZmF1bHRTZXR0ZXIsTi5jYWxsKHRoaXMseCxoLHApLHRoaXMuc2hhZG93cyYmL14od2lkdGh8aGVpZ2h0fHZpc2liaWxpdHl8eHx5fGR8dHJhbnNmb3JtfGN4fGN5fHIpJC8udGVzdChoKSYmdGhpcy51cGRhdGVTaGFkb3dzKGgseCxOKSl9LHRoaXMpLHRoaXMuYWZ0ZXJTZXR0ZXJzKCkpO2MmJmMoKTtyZXR1cm4gcX0sYWZ0ZXJTZXR0ZXJzOmZ1bmN0aW9uKCl7dGhpcy5kb1RyYW5zZm9ybSYmKHRoaXMudXBkYXRlVHJhbnNmb3JtKCksdGhpcy5kb1RyYW5zZm9ybT0hMSl9LHVwZGF0ZVNoYWRvd3M6ZnVuY3Rpb24oYSxoLGMpe2Zvcih2YXIgeD10aGlzLnNoYWRvd3Msdz14Lmxlbmd0aDt3LS07KWMuY2FsbCh4W3ddLFwiaGVpZ2h0XCI9PT1hP01hdGgubWF4KGgtKHhbd10uY3V0SGVpZ2h0fHwwKSwwKTpcImRcIj09PWE/dGhpcy5kOmgsYSx4W3ddKX0sYWRkQ2xhc3M6ZnVuY3Rpb24oYSxoKXt2YXIgeD10aGlzLmF0dHIoXCJjbGFzc1wiKXx8XCJcIjstMT09PXguaW5kZXhPZihhKSYmXG4oaHx8KGE9KHgrKHg/XCIgXCI6XCJcIikrYSkucmVwbGFjZShcIiAgXCIsXCIgXCIpKSx0aGlzLmF0dHIoXCJjbGFzc1wiLGEpKTtyZXR1cm4gdGhpc30saGFzQ2xhc3M6ZnVuY3Rpb24oYSl7cmV0dXJuLTEhPT1EKGEsKHRoaXMuYXR0cihcImNsYXNzXCIpfHxcIlwiKS5zcGxpdChcIiBcIikpfSxyZW1vdmVDbGFzczpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwodGhpcy5hdHRyKFwiY2xhc3NcIil8fFwiXCIpLnJlcGxhY2UoYSxcIlwiKSl9LHN5bWJvbEF0dHI6ZnVuY3Rpb24oYSl7dmFyIHg9dGhpcztiKFwieCB5IHIgc3RhcnQgZW5kIHdpZHRoIGhlaWdodCBpbm5lclIgYW5jaG9yWCBhbmNob3JZXCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGgpe3hbaF09TChhW2hdLHhbaF0pfSk7eC5hdHRyKHtkOngucmVuZGVyZXIuc3ltYm9sc1t4LnN5bWJvbE5hbWVdKHgueCx4LnkseC53aWR0aCx4LmhlaWdodCx4KX0pfSxjbGlwOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoXCJjbGlwLXBhdGhcIixhP1widXJsKFwiK1xudGhpcy5yZW5kZXJlci51cmwrXCIjXCIrYS5pZCtcIilcIjpcIm5vbmVcIil9LGNyaXNwOmZ1bmN0aW9uKGEsaCl7dmFyIHg9dGhpcyxjPXt9LHc7aD1ofHxhLnN0cm9rZVdpZHRofHwwO3c9TWF0aC5yb3VuZChoKSUyLzI7YS54PU1hdGguZmxvb3IoYS54fHx4Lnh8fDApK3c7YS55PU1hdGguZmxvb3IoYS55fHx4Lnl8fDApK3c7YS53aWR0aD1NYXRoLmZsb29yKChhLndpZHRofHx4LndpZHRofHwwKS0yKncpO2EuaGVpZ2h0PU1hdGguZmxvb3IoKGEuaGVpZ2h0fHx4LmhlaWdodHx8MCktMip3KTt0KGEuc3Ryb2tlV2lkdGgpJiYoYS5zdHJva2VXaWR0aD1oKTtJKGEsZnVuY3Rpb24oYSxoKXt4W2hdIT09YSYmKHhbaF09Y1toXT1hKX0pO3JldHVybiBjfSxjc3M6ZnVuY3Rpb24oYSl7dmFyIHg9dGhpcy5zdHlsZXMsYz17fSx3PXRoaXMuZWxlbWVudCxwLHE9XCJcIixiLGQ9IXgsbj1bXCJ0ZXh0T3V0bGluZVwiLFwidGV4dE92ZXJmbG93XCIsXCJ3aWR0aFwiXTthJiZhLmNvbG9yJiYoYS5maWxsPWEuY29sb3IpO1xueCYmSShhLGZ1bmN0aW9uKGEsaCl7YSE9PXhbaF0mJihjW2hdPWEsZD0hMCl9KTtkJiYoeCYmKGE9ZSh4LGMpKSxwPXRoaXMudGV4dFdpZHRoPWEmJmEud2lkdGgmJlwiYXV0b1wiIT09YS53aWR0aCYmXCJ0ZXh0XCI9PT13Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJmgoYS53aWR0aCksdGhpcy5zdHlsZXM9YSxwJiYhSCYmdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQmJmRlbGV0ZSBhLndpZHRoLEcmJiFIP3IodGhpcy5lbGVtZW50LGEpOihiPWZ1bmN0aW9uKGEseCl7cmV0dXJuXCItXCIreC50b0xvd2VyQ2FzZSgpfSxJKGEsZnVuY3Rpb24oYSx4KXstMT09PUQoeCxuKSYmKHErPXgucmVwbGFjZSgvKFtBLVpdKS9nLGIpK1wiOlwiK2ErXCI7XCIpfSkscSYmbSh3LFwic3R5bGVcIixxKSksdGhpcy5hZGRlZCYmKFwidGV4dFwiPT09dGhpcy5lbGVtZW50Lm5vZGVOYW1lJiZ0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKSxhJiZhLnRleHRPdXRsaW5lJiZ0aGlzLmFwcGx5VGV4dE91dGxpbmUoYS50ZXh0T3V0bGluZSkpKTtcbnJldHVybiB0aGlzfSxzdHJva2VXaWR0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdfHwwfSxvbjpmdW5jdGlvbihhLGgpe3ZhciB4PXRoaXMsYz14LmVsZW1lbnQ7biYmXCJjbGlja1wiPT09YT8oYy5vbnRvdWNoc3RhcnQ9ZnVuY3Rpb24oYSl7eC50b3VjaEV2ZW50RmlyZWQ9RGF0ZS5ub3coKTthLnByZXZlbnREZWZhdWx0KCk7aC5jYWxsKGMsYSl9LGMub25jbGljaz1mdW5jdGlvbihhKXsoLTE9PT1SLm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIil8fDExMDA8RGF0ZS5ub3coKS0oeC50b3VjaEV2ZW50RmlyZWR8fDApKSYmaC5jYWxsKGMsYSl9KTpjW1wib25cIithXT1oO3JldHVybiB0aGlzfSxzZXRSYWRpYWxSZWZlcmVuY2U6ZnVuY3Rpb24oYSl7dmFyIHg9dGhpcy5yZW5kZXJlci5ncmFkaWVudHNbdGhpcy5lbGVtZW50LmdyYWRpZW50XTt0aGlzLmVsZW1lbnQucmFkaWFsUmVmZXJlbmNlPWE7eCYmeC5yYWRBdHRyJiZ4LmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRSYWRpYWxBdHRyKGEsXG54LnJhZEF0dHIpKTtyZXR1cm4gdGhpc30sdHJhbnNsYXRlOmZ1bmN0aW9uKGEsaCl7cmV0dXJuIHRoaXMuYXR0cih7dHJhbnNsYXRlWDphLHRyYW5zbGF0ZVk6aH0pfSxpbnZlcnQ6ZnVuY3Rpb24oYSl7dGhpcy5pbnZlcnRlZD1hO3RoaXMudXBkYXRlVHJhbnNmb3JtKCk7cmV0dXJuIHRoaXN9LHVwZGF0ZVRyYW5zZm9ybTpmdW5jdGlvbigpe3ZhciBhPXRoaXMudHJhbnNsYXRlWHx8MCxoPXRoaXMudHJhbnNsYXRlWXx8MCxjPXRoaXMuc2NhbGVYLHc9dGhpcy5zY2FsZVkscD10aGlzLmludmVydGVkLGU9dGhpcy5yb3RhdGlvbixxPXRoaXMuZWxlbWVudDtwJiYoYSs9dGhpcy53aWR0aCxoKz10aGlzLmhlaWdodCk7YT1bXCJ0cmFuc2xhdGUoXCIrYStcIixcIitoK1wiKVwiXTtwP2EucHVzaChcInJvdGF0ZSg5MCkgc2NhbGUoLTEsMSlcIik6ZSYmYS5wdXNoKFwicm90YXRlKFwiK2UrXCIgXCIrKHEuZ2V0QXR0cmlidXRlKFwieFwiKXx8MCkrXCIgXCIrKHEuZ2V0QXR0cmlidXRlKFwieVwiKXx8MCkrXCIpXCIpOyh0KGMpfHxcbnQodykpJiZhLnB1c2goXCJzY2FsZShcIitMKGMsMSkrXCIgXCIrTCh3LDEpK1wiKVwiKTthLmxlbmd0aCYmcS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIixhLmpvaW4oXCIgXCIpKX0sdG9Gcm9udDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDthLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYSk7cmV0dXJuIHRoaXN9LGFsaWduOmZ1bmN0aW9uKGEsaCxjKXt2YXIgeCx3LHAsZSxxPXt9O3c9dGhpcy5yZW5kZXJlcjtwPXcuYWxpZ25lZE9iamVjdHM7dmFyIGIsZDtpZihhKXtpZih0aGlzLmFsaWduT3B0aW9ucz1hLHRoaXMuYWxpZ25CeVRyYW5zbGF0ZT1oLCFjfHxCKGMpKXRoaXMuYWxpZ25Ubz14PWN8fFwicmVuZGVyZXJcIix2KHAsdGhpcykscC5wdXNoKHRoaXMpLGM9bnVsbH1lbHNlIGE9dGhpcy5hbGlnbk9wdGlvbnMsaD10aGlzLmFsaWduQnlUcmFuc2xhdGUseD10aGlzLmFsaWduVG87Yz1MKGMsd1t4XSx3KTt4PWEuYWxpZ247dz1hLnZlcnRpY2FsQWxpZ247cD0oYy54fHwwKSsoYS54fHxcbjApO2U9KGMueXx8MCkrKGEueXx8MCk7XCJyaWdodFwiPT09eD9iPTE6XCJjZW50ZXJcIj09PXgmJihiPTIpO2ImJihwKz0oYy53aWR0aC0oYS53aWR0aHx8MCkpL2IpO3FbaD9cInRyYW5zbGF0ZVhcIjpcInhcIl09TWF0aC5yb3VuZChwKTtcImJvdHRvbVwiPT09dz9kPTE6XCJtaWRkbGVcIj09PXcmJihkPTIpO2QmJihlKz0oYy5oZWlnaHQtKGEuaGVpZ2h0fHwwKSkvZCk7cVtoP1widHJhbnNsYXRlWVwiOlwieVwiXT1NYXRoLnJvdW5kKGUpO3RoaXNbdGhpcy5wbGFjZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHEpO3RoaXMucGxhY2VkPSEwO3RoaXMuYWxpZ25BdHRyPXE7cmV0dXJuIHRoaXN9LGdldEJCb3g6ZnVuY3Rpb24oYSxoKXt2YXIgeCxjPXRoaXMucmVuZGVyZXIsdyxwPXRoaXMuZWxlbWVudCxxPXRoaXMuc3R5bGVzLGQsbj10aGlzLnRleHRTdHIsayxOPWMuY2FjaGUsSD1jLmNhY2hlS2V5cyxHO2g9TChoLHRoaXMucm90YXRpb24pO3c9aCpnO2Q9cSYmcS5mb250U2l6ZTt2b2lkIDAhPT1uJiYoRz1uLnRvU3RyaW5nKCksXG4tMT09PUcuaW5kZXhPZihcIlxceDNjXCIpJiYoRz1HLnJlcGxhY2UoL1swLTldL2csXCIwXCIpKSxHKz1bXCJcIixofHwwLGQscSYmcS53aWR0aCxxJiZxLnRleHRPdmVyZmxvd10uam9pbigpKTtHJiYhYSYmKHg9TltHXSk7aWYoIXgpe2lmKHAubmFtZXNwYWNlVVJJPT09dGhpcy5TVkdfTlN8fGMuZm9yRXhwb3J0KXt0cnl7KGs9dGhpcy5mYWtlVFMmJmZ1bmN0aW9uKGEpe2IocC5xdWVyeVNlbGVjdG9yQWxsKFwiLmhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIpLGZ1bmN0aW9uKHgpe3guc3R5bGUuZGlzcGxheT1hfSl9KSYmayhcIm5vbmVcIikseD1wLmdldEJCb3g/ZSh7fSxwLmdldEJCb3goKSk6e3dpZHRoOnAub2Zmc2V0V2lkdGgsaGVpZ2h0OnAub2Zmc2V0SGVpZ2h0fSxrJiZrKFwiXCIpfWNhdGNoKFcpe31pZigheHx8MD54LndpZHRoKXg9e3dpZHRoOjAsaGVpZ2h0OjB9fWVsc2UgeD10aGlzLmh0bWxHZXRCQm94KCk7Yy5pc1NWRyYmKGE9eC53aWR0aCxjPXguaGVpZ2h0LHEmJlwiMTFweFwiPT09cS5mb250U2l6ZSYmXG4xNz09PU1hdGgucm91bmQoYykmJih4LmhlaWdodD1jPTE0KSxoJiYoeC53aWR0aD1NYXRoLmFicyhjKk1hdGguc2luKHcpKStNYXRoLmFicyhhKk1hdGguY29zKHcpKSx4LmhlaWdodD1NYXRoLmFicyhjKk1hdGguY29zKHcpKStNYXRoLmFicyhhKk1hdGguc2luKHcpKSkpO2lmKEcmJjA8eC5oZWlnaHQpe2Zvcig7MjUwPEgubGVuZ3RoOylkZWxldGUgTltILnNoaWZ0KCldO05bR118fEgucHVzaChHKTtOW0ddPXh9fXJldHVybiB4fSxzaG93OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoe3Zpc2liaWxpdHk6YT9cImluaGVyaXRcIjpcInZpc2libGVcIn0pfSxoaWRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXR0cih7dmlzaWJpbGl0eTpcImhpZGRlblwifSl9LGZhZGVPdXQ6ZnVuY3Rpb24oYSl7dmFyIHg9dGhpczt4LmFuaW1hdGUoe29wYWNpdHk6MH0se2R1cmF0aW9uOmF8fDE1MCxjb21wbGV0ZTpmdW5jdGlvbigpe3guYXR0cih7eTotOTk5OX0pfX0pfSxhZGQ6ZnVuY3Rpb24oYSl7dmFyIHg9XG50aGlzLnJlbmRlcmVyLGg9dGhpcy5lbGVtZW50LGM7YSYmKHRoaXMucGFyZW50R3JvdXA9YSk7dGhpcy5wYXJlbnRJbnZlcnRlZD1hJiZhLmludmVydGVkO3ZvaWQgMCE9PXRoaXMudGV4dFN0ciYmeC5idWlsZFRleHQodGhpcyk7dGhpcy5hZGRlZD0hMDtpZighYXx8YS5oYW5kbGVafHx0aGlzLnpJbmRleCljPXRoaXMuekluZGV4U2V0dGVyKCk7Y3x8KGE/YS5lbGVtZW50OnguYm94KS5hcHBlbmRDaGlsZChoKTtpZih0aGlzLm9uQWRkKXRoaXMub25BZGQoKTtyZXR1cm4gdGhpc30sc2FmZVJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEpe3ZhciB4PWEucGFyZW50Tm9kZTt4JiZ4LnJlbW92ZUNoaWxkKGEpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxoPWEuZWxlbWVudHx8e30sYz1hLnJlbmRlcmVyLmlzU1ZHJiZcIlNQQU5cIj09PWgubm9kZU5hbWUmJmEucGFyZW50R3JvdXAsdz1oLm93bmVyU1ZHRWxlbWVudDtoLm9uY2xpY2s9aC5vbm1vdXNlb3V0PWgub25tb3VzZW92ZXI9aC5vbm1vdXNlbW92ZT1cbmgucG9pbnQ9bnVsbDtQKGEpO2EuY2xpcFBhdGgmJncmJihiKHcucXVlcnlTZWxlY3RvckFsbChcIltjbGlwLXBhdGhdXCIpLGZ1bmN0aW9uKHgpey0xPHguZ2V0QXR0cmlidXRlKFwiY2xpcC1wYXRoXCIpLmluZGV4T2YoYS5jbGlwUGF0aC5lbGVtZW50LmlkK1wiKVwiKSYmeC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIil9KSxhLmNsaXBQYXRoPWEuY2xpcFBhdGguZGVzdHJveSgpKTtpZihhLnN0b3BzKXtmb3Iodz0wO3c8YS5zdG9wcy5sZW5ndGg7dysrKWEuc3RvcHNbd109YS5zdG9wc1t3XS5kZXN0cm95KCk7YS5zdG9wcz1udWxsfWEuc2FmZVJlbW92ZUNoaWxkKGgpO2ZvcihhLmRlc3Ryb3lTaGFkb3dzKCk7YyYmYy5kaXYmJjA9PT1jLmRpdi5jaGlsZE5vZGVzLmxlbmd0aDspaD1jLnBhcmVudEdyb3VwLGEuc2FmZVJlbW92ZUNoaWxkKGMuZGl2KSxkZWxldGUgYy5kaXYsYz1oO2EuYWxpZ25UbyYmdihhLnJlbmRlcmVyLmFsaWduZWRPYmplY3RzLGEpO0koYSxmdW5jdGlvbih4LGgpe2RlbGV0ZSBhW2hdfSk7XG5yZXR1cm4gbnVsbH0sc2hhZG93OmZ1bmN0aW9uKGEsaCxjKXt2YXIgeD1bXSx3LHAscT10aGlzLmVsZW1lbnQsZSxiLGQsbjtpZighYSl0aGlzLmRlc3Ryb3lTaGFkb3dzKCk7ZWxzZSBpZighdGhpcy5zaGFkb3dzKXtiPUwoYS53aWR0aCwzKTtkPShhLm9wYWNpdHl8fC4xNSkvYjtuPXRoaXMucGFyZW50SW52ZXJ0ZWQ/XCIoLTEsLTEpXCI6XCIoXCIrTChhLm9mZnNldFgsMSkrXCIsIFwiK0woYS5vZmZzZXRZLDEpK1wiKVwiO2Zvcih3PTE7dzw9Yjt3KyspcD1xLmNsb25lTm9kZSgwKSxlPTIqYisxLTIqdyxtKHAse2lzU2hhZG93OlwidHJ1ZVwiLHN0cm9rZTphLmNvbG9yfHxcIiMwMDAwMDBcIixcInN0cm9rZS1vcGFjaXR5XCI6ZCp3LFwic3Ryb2tlLXdpZHRoXCI6ZSx0cmFuc2Zvcm06XCJ0cmFuc2xhdGVcIituLGZpbGw6XCJub25lXCJ9KSxjJiYobShwLFwiaGVpZ2h0XCIsTWF0aC5tYXgobShwLFwiaGVpZ2h0XCIpLWUsMCkpLHAuY3V0SGVpZ2h0PWUpLGg/aC5lbGVtZW50LmFwcGVuZENoaWxkKHApOnEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocCxcbnEpLHgucHVzaChwKTt0aGlzLnNoYWRvd3M9eH1yZXR1cm4gdGhpc30sZGVzdHJveVNoYWRvd3M6ZnVuY3Rpb24oKXtiKHRoaXMuc2hhZG93c3x8W10sZnVuY3Rpb24oYSl7dGhpcy5zYWZlUmVtb3ZlQ2hpbGQoYSl9LHRoaXMpO3RoaXMuc2hhZG93cz12b2lkIDB9LHhHZXR0ZXI6ZnVuY3Rpb24oYSl7XCJjaXJjbGVcIj09PXRoaXMuZWxlbWVudC5ub2RlTmFtZSYmKFwieFwiPT09YT9hPVwiY3hcIjpcInlcIj09PWEmJihhPVwiY3lcIikpO3JldHVybiB0aGlzLl9kZWZhdWx0R2V0dGVyKGEpfSxfZGVmYXVsdEdldHRlcjpmdW5jdGlvbihhKXthPUwodGhpc1thXSx0aGlzLmVsZW1lbnQ/dGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShhKTpudWxsLDApOy9eW1xcLTAtOVxcLl0rJC8udGVzdChhKSYmKGE9cGFyc2VGbG9hdChhKSk7cmV0dXJuIGF9LGRTZXR0ZXI6ZnVuY3Rpb24oYSxoLGMpe2EmJmEuam9pbiYmKGE9YS5qb2luKFwiIFwiKSk7LyhOYU58IHsyfXxeJCkvLnRlc3QoYSkmJihhPVwiTSAwIDBcIik7dGhpc1toXSE9PVxuYSYmKGMuc2V0QXR0cmlidXRlKGgsYSksdGhpc1toXT1hKX0sZGFzaHN0eWxlU2V0dGVyOmZ1bmN0aW9uKGEpe3ZhciB4LGM9dGhpc1tcInN0cm9rZS13aWR0aFwiXTtcImluaGVyaXRcIj09PWMmJihjPTEpO2lmKGE9YSYmYS50b0xvd2VyQ2FzZSgpKXthPWEucmVwbGFjZShcInNob3J0ZGFzaGRvdGRvdFwiLFwiMywxLDEsMSwxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hkb3RcIixcIjMsMSwxLDFcIikucmVwbGFjZShcInNob3J0ZG90XCIsXCIxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hcIixcIjMsMSxcIikucmVwbGFjZShcImxvbmdkYXNoXCIsXCI4LDMsXCIpLnJlcGxhY2UoL2RvdC9nLFwiMSwzLFwiKS5yZXBsYWNlKFwiZGFzaFwiLFwiNCwzLFwiKS5yZXBsYWNlKC8sJC8sXCJcIikuc3BsaXQoXCIsXCIpO2Zvcih4PWEubGVuZ3RoO3gtLTspYVt4XT1oKGFbeF0pKmM7YT1hLmpvaW4oXCIsXCIpLnJlcGxhY2UoL05hTi9nLFwibm9uZVwiKTt0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGEpfX0sYWxpZ25TZXR0ZXI6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsXG57bGVmdDpcInN0YXJ0XCIsY2VudGVyOlwibWlkZGxlXCIscmlnaHQ6XCJlbmRcIn1bYV0pfSxvcGFjaXR5U2V0dGVyOmZ1bmN0aW9uKGEsaCxjKXt0aGlzW2hdPWE7Yy5zZXRBdHRyaWJ1dGUoaCxhKX0sdGl0bGVTZXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGg9dGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGl0bGVcIilbMF07aHx8KGg9ay5jcmVhdGVFbGVtZW50TlModGhpcy5TVkdfTlMsXCJ0aXRsZVwiKSx0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaCkpO2guZmlyc3RDaGlsZCYmaC5yZW1vdmVDaGlsZChoLmZpcnN0Q2hpbGQpO2guYXBwZW5kQ2hpbGQoay5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoTChhKSxcIlwiKS5yZXBsYWNlKC88W14+XSo+L2csXCJcIikpKX0sdGV4dFNldHRlcjpmdW5jdGlvbihhKXthIT09dGhpcy50ZXh0U3RyJiYoZGVsZXRlIHRoaXMuYkJveCx0aGlzLnRleHRTdHI9YSx0aGlzLmFkZGVkJiZ0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKSl9LGZpbGxTZXR0ZXI6ZnVuY3Rpb24oYSxcbmgsYyl7XCJzdHJpbmdcIj09PXR5cGVvZiBhP2Muc2V0QXR0cmlidXRlKGgsYSk6YSYmdGhpcy5jb2xvckdyYWRpZW50KGEsaCxjKX0sdmlzaWJpbGl0eVNldHRlcjpmdW5jdGlvbihhLGgsYyl7XCJpbmhlcml0XCI9PT1hP2MucmVtb3ZlQXR0cmlidXRlKGgpOnRoaXNbaF0hPT1hJiZjLnNldEF0dHJpYnV0ZShoLGEpO3RoaXNbaF09YX0sekluZGV4U2V0dGVyOmZ1bmN0aW9uKGEsYyl7dmFyIHg9dGhpcy5yZW5kZXJlcix3PXRoaXMucGFyZW50R3JvdXAscD0od3x8eCkuZWxlbWVudHx8eC5ib3gscSxlPXRoaXMuZWxlbWVudCxiO3E9dGhpcy5hZGRlZDt2YXIgZDt0KGEpJiYoZS56SW5kZXg9YSxhPSthLHRoaXNbY109PT1hJiYocT0hMSksdGhpc1tjXT1hKTtpZihxKXsoYT10aGlzLnpJbmRleCkmJncmJih3LmhhbmRsZVo9ITApO2M9cC5jaGlsZE5vZGVzO2ZvcihkPTA7ZDxjLmxlbmd0aCYmIWI7ZCsrKXc9Y1tkXSxxPXcuekluZGV4LHchPT1lJiYoaChxKT5hfHwhdChhKSYmdChxKXx8MD5cbmEmJiF0KHEpJiZwIT09eC5ib3gpJiYocC5pbnNlcnRCZWZvcmUoZSx3KSxiPSEwKTtifHxwLmFwcGVuZENoaWxkKGUpfXJldHVybiBifSxfZGVmYXVsdFNldHRlcjpmdW5jdGlvbihhLGgsYyl7Yy5zZXRBdHRyaWJ1dGUoaCxhKX19KTtDLnByb3RvdHlwZS55R2V0dGVyPUMucHJvdG90eXBlLnhHZXR0ZXI7Qy5wcm90b3R5cGUudHJhbnNsYXRlWFNldHRlcj1DLnByb3RvdHlwZS50cmFuc2xhdGVZU2V0dGVyPUMucHJvdG90eXBlLnJvdGF0aW9uU2V0dGVyPUMucHJvdG90eXBlLnZlcnRpY2FsQWxpZ25TZXR0ZXI9Qy5wcm90b3R5cGUuc2NhbGVYU2V0dGVyPUMucHJvdG90eXBlLnNjYWxlWVNldHRlcj1mdW5jdGlvbihhLGgpe3RoaXNbaF09YTt0aGlzLmRvVHJhbnNmb3JtPSEwfTtDLnByb3RvdHlwZVtcInN0cm9rZS13aWR0aFNldHRlclwiXT1DLnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9ZnVuY3Rpb24oYSxoLGMpe3RoaXNbaF09YTt0aGlzLnN0cm9rZSYmdGhpc1tcInN0cm9rZS13aWR0aFwiXT9cbihDLnByb3RvdHlwZS5maWxsU2V0dGVyLmNhbGwodGhpcyx0aGlzLnN0cm9rZSxcInN0cm9rZVwiLGMpLGMuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsdGhpc1tcInN0cm9rZS13aWR0aFwiXSksdGhpcy5oYXNTdHJva2U9ITApOlwic3Ryb2tlLXdpZHRoXCI9PT1oJiYwPT09YSYmdGhpcy5oYXNTdHJva2UmJihjLnJlbW92ZUF0dHJpYnV0ZShcInN0cm9rZVwiKSx0aGlzLmhhc1N0cm9rZT0hMSl9O0E9YS5TVkdSZW5kZXJlcj1mdW5jdGlvbigpe3RoaXMuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2UoQS5wcm90b3R5cGUse0VsZW1lbnQ6QyxTVkdfTlM6Tyxpbml0OmZ1bmN0aW9uKGEsaCx3LHAscSxlKXt2YXIgeDtwPXRoaXMuY3JlYXRlRWxlbWVudChcInN2Z1wiKS5hdHRyKHt2ZXJzaW9uOlwiMS4xXCIsXCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy1yb290XCJ9KS5jc3ModGhpcy5nZXRTdHlsZShwKSk7eD1wLmVsZW1lbnQ7YS5hcHBlbmRDaGlsZCh4KTstMT09PWEuaW5uZXJIVE1MLmluZGV4T2YoXCJ4bWxuc1wiKSYmXG5tKHgsXCJ4bWxuc1wiLHRoaXMuU1ZHX05TKTt0aGlzLmlzU1ZHPSEwO3RoaXMuYm94PXg7dGhpcy5ib3hXcmFwcGVyPXA7dGhpcy5hbGlnbmVkT2JqZWN0cz1bXTt0aGlzLnVybD0oY3x8SykmJmsuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiYXNlXCIpLmxlbmd0aD9SLmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qPyQvLFwiXCIpLnJlcGxhY2UoLzxbXj5dKj4vZyxcIlwiKS5yZXBsYWNlKC8oW1xcKCdcXCldKS9nLFwiXFxcXCQxXCIpLnJlcGxhY2UoLyAvZyxcIiUyMFwiKTpcIlwiO3RoaXMuY3JlYXRlRWxlbWVudChcImRlc2NcIikuYWRkKCkuZWxlbWVudC5hcHBlbmRDaGlsZChrLmNyZWF0ZVRleHROb2RlKFwiQ3JlYXRlZCB3aXRoIEhpZ2hjaGFydHMgNS4wLjE0XCIpKTt0aGlzLmRlZnM9dGhpcy5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKS5hZGQoKTt0aGlzLmFsbG93SFRNTD1lO3RoaXMuZm9yRXhwb3J0PXE7dGhpcy5ncmFkaWVudHM9e307dGhpcy5jYWNoZT17fTt0aGlzLmNhY2hlS2V5cz1bXTt0aGlzLmltZ0NvdW50PVxuMDt0aGlzLnNldFNpemUoaCx3LCExKTt2YXIgYjtjJiZhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCYmKGg9ZnVuY3Rpb24oKXtyKGEse2xlZnQ6MCx0b3A6MH0pO2I9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyKGEse2xlZnQ6TWF0aC5jZWlsKGIubGVmdCktYi5sZWZ0K1wicHhcIix0b3A6TWF0aC5jZWlsKGIudG9wKS1iLnRvcCtcInB4XCJ9KX0saCgpLHRoaXMudW5TdWJQaXhlbEZpeD1GKFIsXCJyZXNpemVcIixoKSl9LGdldFN0eWxlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnN0eWxlPWUoe2ZvbnRGYW1pbHk6J1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsZm9udFNpemU6XCIxMnB4XCJ9LGEpfSxzZXRTdHlsZTpmdW5jdGlvbihhKXt0aGlzLmJveFdyYXBwZXIuY3NzKHRoaXMuZ2V0U3R5bGUoYSkpfSxpc0hpZGRlbjpmdW5jdGlvbigpe3JldHVybiF0aGlzLmJveFdyYXBwZXIuZ2V0QkJveCgpLndpZHRofSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLmRlZnM7dGhpcy5ib3g9bnVsbDt0aGlzLmJveFdyYXBwZXI9dGhpcy5ib3hXcmFwcGVyLmRlc3Ryb3koKTtkKHRoaXMuZ3JhZGllbnRzfHx7fSk7dGhpcy5ncmFkaWVudHM9bnVsbDthJiYodGhpcy5kZWZzPWEuZGVzdHJveSgpKTt0aGlzLnVuU3ViUGl4ZWxGaXgmJnRoaXMudW5TdWJQaXhlbEZpeCgpO3JldHVybiB0aGlzLmFsaWduZWRPYmplY3RzPW51bGx9LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oYSl7dmFyIGg9bmV3IHRoaXMuRWxlbWVudDtoLmluaXQodGhpcyxhKTtyZXR1cm4gaH0sZHJhdzp6LGdldFJhZGlhbEF0dHI6ZnVuY3Rpb24oYSxoKXtyZXR1cm57Y3g6YVswXS1hWzJdLzIraC5jeCphWzJdLGN5OmFbMV0tYVsyXS8yK2guY3kqYVsyXSxyOmguciphWzJdfX0sZ2V0U3BhbldpZHRoOmZ1bmN0aW9uKGEsaCl7dmFyIGM9YS5nZXRCQm94KCEwKS53aWR0aDshSCYmdGhpcy5mb3JFeHBvcnQmJihjPXRoaXMubWVhc3VyZVNwYW5XaWR0aChoLmZpcnN0Q2hpbGQuZGF0YSxcbmEuc3R5bGVzKSk7cmV0dXJuIGN9LGFwcGx5RWxsaXBzaXM6ZnVuY3Rpb24oYSxoLGMsdyl7dmFyIHg9YS5yb3RhdGlvbixwPWMscSxlPTAsYj1jLmxlbmd0aCxkPWZ1bmN0aW9uKGEpe2gucmVtb3ZlQ2hpbGQoaC5maXJzdENoaWxkKTthJiZoLmFwcGVuZENoaWxkKGsuY3JlYXRlVGV4dE5vZGUoYSkpfSxuO2Eucm90YXRpb249MDtwPXRoaXMuZ2V0U3BhbldpZHRoKGEsaCk7aWYobj1wPncpe2Zvcig7ZTw9YjspcT1NYXRoLmNlaWwoKGUrYikvMikscD1jLnN1YnN0cmluZygwLHEpK1wiXFx1MjAyNlwiLGQocCkscD10aGlzLmdldFNwYW5XaWR0aChhLGgpLGU9PT1iP2U9YisxOnA+dz9iPXEtMTplPXE7MD09PWImJmQoXCJcIil9YS5yb3RhdGlvbj14O3JldHVybiBufSxidWlsZFRleHQ6ZnVuY3Rpb24oYSl7dmFyIGM9YS5lbGVtZW50LHc9dGhpcyx4PXcuZm9yRXhwb3J0LHA9TChhLnRleHRTdHIsXCJcIikudG9TdHJpbmcoKSxxPS0xIT09cC5pbmRleE9mKFwiXFx4M2NcIiksZT1jLmNoaWxkTm9kZXMsXG5kLG4sZyxHLHY9bShjLFwieFwiKSx6PWEuc3R5bGVzLGY9YS50ZXh0V2lkdGgsST16JiZ6LmxpbmVIZWlnaHQsQj16JiZ6LnRleHRPdXRsaW5lLEQ9eiYmXCJlbGxpcHNpc1wiPT09ei50ZXh0T3ZlcmZsb3csbD16JiZcIm5vd3JhcFwiPT09ei53aGl0ZVNwYWNlLFA9eiYmei5mb250U2l6ZSx0LEosdT1lLmxlbmd0aCx6PWYmJiFhLmFkZGVkJiZ0aGlzLmJveCxLPWZ1bmN0aW9uKGEpe3ZhciB4O3g9LyhweHxlbSkkLy50ZXN0KGEmJmEuc3R5bGUuZm9udFNpemUpP2Euc3R5bGUuZm9udFNpemU6UHx8dy5zdHlsZS5mb250U2l6ZXx8MTI7cmV0dXJuIEk/aChJKTp3LmZvbnRNZXRyaWNzKHgsYS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKT9hOmMpLmh9O3Q9W3AsRCxsLEksQixQLGZdLmpvaW4oKTtpZih0IT09YS50ZXh0Q2FjaGUpe2ZvcihhLnRleHRDYWNoZT10O3UtLTspYy5yZW1vdmVDaGlsZChlW3VdKTtxfHxCfHxEfHxmfHwtMSE9PXAuaW5kZXhPZihcIiBcIik/KGQ9LzwuKmNsYXNzPVwiKFteXCJdKylcIi4qPi8sXG5uPS88LipzdHlsZT1cIihbXlwiXSspXCIuKj4vLGc9LzwuKmhyZWY9XCIoW15cIl0rKVwiLio+Lyx6JiZ6LmFwcGVuZENoaWxkKGMpLHA9cT9wLnJlcGxhY2UoLzwoYnxzdHJvbmcpPi9nLCdcXHgzY3NwYW4gc3R5bGVcXHgzZFwiZm9udC13ZWlnaHQ6Ym9sZFwiXFx4M2UnKS5yZXBsYWNlKC88KGl8ZW0pPi9nLCdcXHgzY3NwYW4gc3R5bGVcXHgzZFwiZm9udC1zdHlsZTppdGFsaWNcIlxceDNlJykucmVwbGFjZSgvPGEvZyxcIlxceDNjc3BhblwiKS5yZXBsYWNlKC88XFwvKGJ8c3Ryb25nfGl8ZW18YSk+L2csXCJcXHgzYy9zcGFuXFx4M2VcIikuc3BsaXQoLzxici4qPz4vZyk6W3BdLHA9eShwLGZ1bmN0aW9uKGEpe3JldHVyblwiXCIhPT1hfSksYihwLGZ1bmN0aW9uKGgscCl7dmFyIHEsZT0wO2g9aC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpLnJlcGxhY2UoLzxzcGFuL2csXCJ8fHxcXHgzY3NwYW5cIikucmVwbGFjZSgvPFxcL3NwYW4+L2csXCJcXHgzYy9zcGFuXFx4M2V8fHxcIik7cT1oLnNwbGl0KFwifHx8XCIpO2IocSxmdW5jdGlvbihoKXtpZihcIlwiIT09XG5ofHwxPT09cS5sZW5ndGgpe3ZhciBiPXt9LHo9ay5jcmVhdGVFbGVtZW50TlMody5TVkdfTlMsXCJ0c3BhblwiKSx5LEk7ZC50ZXN0KGgpJiYoeT1oLm1hdGNoKGQpWzFdLG0oeixcImNsYXNzXCIseSkpO24udGVzdChoKSYmKEk9aC5tYXRjaChuKVsxXS5yZXBsYWNlKC8oO3wgfF4pY29sb3IoWyA6XSkvLFwiJDFmaWxsJDJcIiksbSh6LFwic3R5bGVcIixJKSk7Zy50ZXN0KGgpJiYheCYmKG0oeixcIm9uY2xpY2tcIiwnbG9jYXRpb24uaHJlZlxceDNkXCInK2gubWF0Y2goZylbMV0rJ1wiJykscih6LHtjdXJzb3I6XCJwb2ludGVyXCJ9KSk7aD0oaC5yZXBsYWNlKC88KC58XFxuKSo/Pi9nLFwiXCIpfHxcIiBcIikucmVwbGFjZSgvJmx0Oy9nLFwiXFx4M2NcIikucmVwbGFjZSgvJmd0Oy9nLFwiXFx4M2VcIik7aWYoXCIgXCIhPT1oKXt6LmFwcGVuZENoaWxkKGsuY3JlYXRlVGV4dE5vZGUoaCkpO2U/Yi5keD0wOnAmJm51bGwhPT12JiYoYi54PXYpO20oeixiKTtjLmFwcGVuZENoaWxkKHopOyFlJiZKJiYoIUgmJngmJnIoeix7ZGlzcGxheTpcImJsb2NrXCJ9KSxcbm0oeixcImR5XCIsSyh6KSkpO2lmKGYpe2I9aC5yZXBsYWNlKC8oW15cXF5dKS0vZyxcIiQxLSBcIikuc3BsaXQoXCIgXCIpO3k9MTxxLmxlbmd0aHx8cHx8MTxiLmxlbmd0aCYmIWw7dmFyIEI9W10sTixQPUsoeiksdD1hLnJvdGF0aW9uO2ZvcihEJiYoRz13LmFwcGx5RWxsaXBzaXMoYSx6LGgsZikpOyFEJiZ5JiYoYi5sZW5ndGh8fEIubGVuZ3RoKTspYS5yb3RhdGlvbj0wLE49dy5nZXRTcGFuV2lkdGgoYSx6KSxoPU4+Zix2b2lkIDA9PT1HJiYoRz1oKSxoJiYxIT09Yi5sZW5ndGg/KHoucmVtb3ZlQ2hpbGQoei5maXJzdENoaWxkKSxCLnVuc2hpZnQoYi5wb3AoKSkpOihiPUIsQj1bXSxiLmxlbmd0aCYmIWwmJih6PWsuY3JlYXRlRWxlbWVudE5TKE8sXCJ0c3BhblwiKSxtKHose2R5OlAseDp2fSksSSYmbSh6LFwic3R5bGVcIixJKSxjLmFwcGVuZENoaWxkKHopKSxOPmYmJihmPU4pKSxiLmxlbmd0aCYmei5hcHBlbmRDaGlsZChrLmNyZWF0ZVRleHROb2RlKGIuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZyxcblwiLVwiKSkpO2Eucm90YXRpb249dH1lKyt9fX0pO0o9Snx8Yy5jaGlsZE5vZGVzLmxlbmd0aH0pLEcmJmEuYXR0cihcInRpdGxlXCIsYS50ZXh0U3RyKSx6JiZ6LnJlbW92ZUNoaWxkKGMpLEImJmEuYXBwbHlUZXh0T3V0bGluZSYmYS5hcHBseVRleHRPdXRsaW5lKEIpKTpjLmFwcGVuZENoaWxkKGsuY3JlYXRlVGV4dE5vZGUocC5yZXBsYWNlKC8mbHQ7L2csXCJcXHgzY1wiKS5yZXBsYWNlKC8mZ3Q7L2csXCJcXHgzZVwiKSkpfX0sZ2V0Q29udHJhc3Q6ZnVuY3Rpb24oYSl7YT1sKGEpLnJnYmE7cmV0dXJuIDUxMDxhWzBdK2FbMV0rYVsyXT9cIiMwMDAwMDBcIjpcIiNGRkZGRkZcIn0sYnV0dG9uOmZ1bmN0aW9uKGEsaCxjLHcscSxiLGQsbixnKXt2YXIgeD10aGlzLmxhYmVsKGEsaCxjLGcsbnVsbCxudWxsLG51bGwsbnVsbCxcImJ1dHRvblwiKSxrPTA7eC5hdHRyKHAoe3BhZGRpbmc6OCxyOjJ9LHEpKTt2YXIgeixILHYsZjtxPXAoe2ZpbGw6XCIjZjdmN2Y3XCIsc3Ryb2tlOlwiI2NjY2NjY1wiLFwic3Ryb2tlLXdpZHRoXCI6MSxcbnN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixjdXJzb3I6XCJwb2ludGVyXCIsZm9udFdlaWdodDpcIm5vcm1hbFwifX0scSk7ej1xLnN0eWxlO2RlbGV0ZSBxLnN0eWxlO2I9cChxLHtmaWxsOlwiI2U2ZTZlNlwifSxiKTtIPWIuc3R5bGU7ZGVsZXRlIGIuc3R5bGU7ZD1wKHEse2ZpbGw6XCIjZTZlYmY1XCIsc3R5bGU6e2NvbG9yOlwiIzAwMDAwMFwiLGZvbnRXZWlnaHQ6XCJib2xkXCJ9fSxkKTt2PWQuc3R5bGU7ZGVsZXRlIGQuc3R5bGU7bj1wKHEse3N0eWxlOntjb2xvcjpcIiNjY2NjY2NcIn19LG4pO2Y9bi5zdHlsZTtkZWxldGUgbi5zdHlsZTtGKHguZWxlbWVudCxHP1wibW91c2VvdmVyXCI6XCJtb3VzZWVudGVyXCIsZnVuY3Rpb24oKXszIT09ayYmeC5zZXRTdGF0ZSgxKX0pO0YoeC5lbGVtZW50LEc/XCJtb3VzZW91dFwiOlwibW91c2VsZWF2ZVwiLGZ1bmN0aW9uKCl7MyE9PWsmJnguc2V0U3RhdGUoayl9KTt4LnNldFN0YXRlPWZ1bmN0aW9uKGEpezEhPT1hJiYoeC5zdGF0ZT1rPWEpO3gucmVtb3ZlQ2xhc3MoL2hpZ2hjaGFydHMtYnV0dG9uLShub3JtYWx8aG92ZXJ8cHJlc3NlZHxkaXNhYmxlZCkvKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYnV0dG9uLVwiK1xuW1wibm9ybWFsXCIsXCJob3ZlclwiLFwicHJlc3NlZFwiLFwiZGlzYWJsZWRcIl1bYXx8MF0pO3guYXR0cihbcSxiLGQsbl1bYXx8MF0pLmNzcyhbeixILHYsZl1bYXx8MF0pfTt4LmF0dHIocSkuY3NzKGUoe2N1cnNvcjpcImRlZmF1bHRcIn0seikpO3JldHVybiB4Lm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXszIT09ayYmdy5jYWxsKHgsYSl9KX0sY3Jpc3BMaW5lOmZ1bmN0aW9uKGEsaCl7YVsxXT09PWFbNF0mJihhWzFdPWFbNF09TWF0aC5yb3VuZChhWzFdKS1oJTIvMik7YVsyXT09PWFbNV0mJihhWzJdPWFbNV09TWF0aC5yb3VuZChhWzJdKStoJTIvMik7cmV0dXJuIGF9LHBhdGg6ZnVuY3Rpb24oYSl7dmFyIGg9e2ZpbGw6XCJub25lXCJ9O0ooYSk/aC5kPWE6cShhKSYmZShoLGEpO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpLmF0dHIoaCl9LGNpcmNsZTpmdW5jdGlvbihhLGgsYyl7YT1xKGEpP2E6e3g6YSx5OmgscjpjfTtoPXRoaXMuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiKTtoLnhTZXR0ZXI9XG5oLnlTZXR0ZXI9ZnVuY3Rpb24oYSxoLGMpe2Muc2V0QXR0cmlidXRlKFwiY1wiK2gsYSl9O3JldHVybiBoLmF0dHIoYSl9LGFyYzpmdW5jdGlvbihhLGgsYyx3LHAsYil7cShhKT8odz1hLGg9dy55LGM9dy5yLGE9dy54KTp3PXtpbm5lclI6dyxzdGFydDpwLGVuZDpifTthPXRoaXMuc3ltYm9sKFwiYXJjXCIsYSxoLGMsYyx3KTthLnI9YztyZXR1cm4gYX0scmVjdDpmdW5jdGlvbihhLGgsYyx3LHAsYil7cD1xKGEpP2EucjpwO3ZhciB4PXRoaXMuY3JlYXRlRWxlbWVudChcInJlY3RcIik7YT1xKGEpP2E6dm9pZCAwPT09YT97fTp7eDphLHk6aCx3aWR0aDpNYXRoLm1heChjLDApLGhlaWdodDpNYXRoLm1heCh3LDApfTt2b2lkIDAhPT1iJiYoYS5zdHJva2VXaWR0aD1iLGE9eC5jcmlzcChhKSk7YS5maWxsPVwibm9uZVwiO3AmJihhLnI9cCk7eC5yU2V0dGVyPWZ1bmN0aW9uKGEsaCxjKXttKGMse3J4OmEscnk6YX0pfTtyZXR1cm4geC5hdHRyKGEpfSxzZXRTaXplOmZ1bmN0aW9uKGEsaCxjKXt2YXIgdz1cbnRoaXMuYWxpZ25lZE9iamVjdHMscD13Lmxlbmd0aDt0aGlzLndpZHRoPWE7dGhpcy5oZWlnaHQ9aDtmb3IodGhpcy5ib3hXcmFwcGVyLmFuaW1hdGUoe3dpZHRoOmEsaGVpZ2h0Omh9LHtzdGVwOmZ1bmN0aW9uKCl7dGhpcy5hdHRyKHt2aWV3Qm94OlwiMCAwIFwiK3RoaXMuYXR0cihcIndpZHRoXCIpK1wiIFwiK3RoaXMuYXR0cihcImhlaWdodFwiKX0pfSxkdXJhdGlvbjpMKGMsITApP3ZvaWQgMDowfSk7cC0tOyl3W3BdLmFsaWduKCl9LGc6ZnVuY3Rpb24oYSl7dmFyIGg9dGhpcy5jcmVhdGVFbGVtZW50KFwiZ1wiKTtyZXR1cm4gYT9oLmF0dHIoe1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYX0pOmh9LGltYWdlOmZ1bmN0aW9uKGEsaCxjLHcscCl7dmFyIHg9e3ByZXNlcnZlQXNwZWN0UmF0aW86XCJub25lXCJ9OzE8YXJndW1lbnRzLmxlbmd0aCYmZSh4LHt4OmgseTpjLHdpZHRoOncsaGVpZ2h0OnB9KTt4PXRoaXMuY3JlYXRlRWxlbWVudChcImltYWdlXCIpLmF0dHIoeCk7eC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TP1xueC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwiaHJlZlwiLGEpOnguZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoYy1zdmctaHJlZlwiLGEpO3JldHVybiB4fSxzeW1ib2w6ZnVuY3Rpb24oYSxoLGMsdyxwLHEpe3ZhciB4PXRoaXMsZCxuPS9edXJsXFwoKC4qPylcXCkkLyxnPW4udGVzdChhKSx6PSFnJiYodGhpcy5zeW1ib2xzW2FdP2E6XCJjaXJjbGVcIiksRz16JiZ0aGlzLnN5bWJvbHNbel0sSD10KGgpJiZHJiZHLmNhbGwodGhpcy5zeW1ib2xzLE1hdGgucm91bmQoaCksTWF0aC5yb3VuZChjKSx3LHAscSksdix5O0c/KGQ9dGhpcy5wYXRoKEgpLGQuYXR0cihcImZpbGxcIixcIm5vbmVcIiksZShkLHtzeW1ib2xOYW1lOnoseDpoLHk6Yyx3aWR0aDp3LGhlaWdodDpwfSkscSYmZShkLHEpKTpnJiYodj1hLm1hdGNoKG4pWzFdLGQ9dGhpcy5pbWFnZSh2KSxkLmltZ3dpZHRoPUwoUVt2XSYmUVt2XS53aWR0aCxxJiZxLndpZHRoKSxkLmltZ2hlaWdodD1cbkwoUVt2XSYmUVt2XS5oZWlnaHQscSYmcS5oZWlnaHQpLHk9ZnVuY3Rpb24oKXtkLmF0dHIoe3dpZHRoOmQud2lkdGgsaGVpZ2h0OmQuaGVpZ2h0fSl9LGIoW1wid2lkdGhcIixcImhlaWdodFwiXSxmdW5jdGlvbihhKXtkW2ErXCJTZXR0ZXJcIl09ZnVuY3Rpb24oYSxoKXt2YXIgYz17fSx3PXRoaXNbXCJpbWdcIitoXSxwPVwid2lkdGhcIj09PWg/XCJ0cmFuc2xhdGVYXCI6XCJ0cmFuc2xhdGVZXCI7dGhpc1toXT1hO3QodykmJih0aGlzLmVsZW1lbnQmJnRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoaCx3KSx0aGlzLmFsaWduQnlUcmFuc2xhdGV8fChjW3BdPSgodGhpc1toXXx8MCktdykvMix0aGlzLmF0dHIoYykpKX19KSx0KGgpJiZkLmF0dHIoe3g6aCx5OmN9KSxkLmlzSW1nPSEwLHQoZC5pbWd3aWR0aCkmJnQoZC5pbWdoZWlnaHQpP3koKTooZC5hdHRyKHt3aWR0aDowLGhlaWdodDowfSksdShcImltZ1wiLHtvbmxvYWQ6ZnVuY3Rpb24oKXt2YXIgYT1mW3guY2hhcnRJbmRleF07MD09PXRoaXMud2lkdGgmJlxuKHIodGhpcyx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi05OTllbVwifSksay5ib2R5LmFwcGVuZENoaWxkKHRoaXMpKTtRW3ZdPXt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH07ZC5pbWd3aWR0aD10aGlzLndpZHRoO2QuaW1naGVpZ2h0PXRoaXMuaGVpZ2h0O2QuZWxlbWVudCYmeSgpO3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO3guaW1nQ291bnQtLTtpZigheC5pbWdDb3VudCYmYSYmYS5vbmxvYWQpYS5vbmxvYWQoKX0sc3JjOnZ9KSx0aGlzLmltZ0NvdW50KyspKTtyZXR1cm4gZH0sc3ltYm9sczp7Y2lyY2xlOmZ1bmN0aW9uKGEsaCxjLHcpe3JldHVybiB0aGlzLmFyYyhhK2MvMixoK3cvMixjLzIsdy8yLHtzdGFydDowLGVuZDoyKk1hdGguUEksb3BlbjohMX0pfSxzcXVhcmU6ZnVuY3Rpb24oYSxoLGMsdyl7cmV0dXJuW1wiTVwiLGEsaCxcIkxcIixhK2MsaCxhK2MsaCt3LGEsaCt3LFwiWlwiXX0sdHJpYW5nbGU6ZnVuY3Rpb24oYSxcbmgsYyx3KXtyZXR1cm5bXCJNXCIsYStjLzIsaCxcIkxcIixhK2MsaCt3LGEsaCt3LFwiWlwiXX0sXCJ0cmlhbmdsZS1kb3duXCI6ZnVuY3Rpb24oYSxoLGMsdyl7cmV0dXJuW1wiTVwiLGEsaCxcIkxcIixhK2MsaCxhK2MvMixoK3csXCJaXCJdfSxkaWFtb25kOmZ1bmN0aW9uKGEsaCxjLHcpe3JldHVybltcIk1cIixhK2MvMixoLFwiTFwiLGErYyxoK3cvMixhK2MvMixoK3csYSxoK3cvMixcIlpcIl19LGFyYzpmdW5jdGlvbihhLGgsYyx3LHApe3ZhciBxPXAuc3RhcnQsYj1wLnJ8fGMseD1wLnJ8fHd8fGMsZT1wLmVuZC0uMDAxO2M9cC5pbm5lclI7dz1MKHAub3BlbiwuMDAxPk1hdGguYWJzKHAuZW5kLXAuc3RhcnQtMipNYXRoLlBJKSk7dmFyIGQ9TWF0aC5jb3MocSksbj1NYXRoLnNpbihxKSxnPU1hdGguY29zKGUpLGU9TWF0aC5zaW4oZSk7cD0uMDAxPnAuZW5kLXEtTWF0aC5QST8wOjE7Yj1bXCJNXCIsYStiKmQsaCt4Km4sXCJBXCIsYix4LDAscCwxLGErYipnLGgreCplXTt0KGMpJiZiLnB1c2godz9cIk1cIjpcIkxcIixhK2MqXG5nLGgrYyplLFwiQVwiLGMsYywwLHAsMCxhK2MqZCxoK2Mqbik7Yi5wdXNoKHc/XCJcIjpcIlpcIik7cmV0dXJuIGJ9LGNhbGxvdXQ6ZnVuY3Rpb24oYSxoLGMsdyxwKXt2YXIgcT1NYXRoLm1pbihwJiZwLnJ8fDAsYyx3KSxiPXErNixlPXAmJnAuYW5jaG9yWDtwPXAmJnAuYW5jaG9yWTt2YXIgZDtkPVtcIk1cIixhK3EsaCxcIkxcIixhK2MtcSxoLFwiQ1wiLGErYyxoLGErYyxoLGErYyxoK3EsXCJMXCIsYStjLGgrdy1xLFwiQ1wiLGErYyxoK3csYStjLGgrdyxhK2MtcSxoK3csXCJMXCIsYStxLGgrdyxcIkNcIixhLGgrdyxhLGgrdyxhLGgrdy1xLFwiTFwiLGEsaCtxLFwiQ1wiLGEsaCxhLGgsYStxLGhdO2UmJmU+Yz9wPmgrYiYmcDxoK3ctYj9kLnNwbGljZSgxMywzLFwiTFwiLGErYyxwLTYsYStjKzYscCxhK2MscCs2LGErYyxoK3ctcSk6ZC5zcGxpY2UoMTMsMyxcIkxcIixhK2Msdy8yLGUscCxhK2Msdy8yLGErYyxoK3ctcSk6ZSYmMD5lP3A+aCtiJiZwPGgrdy1iP2Quc3BsaWNlKDMzLDMsXCJMXCIsYSxwKzYsYS02LHAsYSxwLTYsXG5hLGgrcSk6ZC5zcGxpY2UoMzMsMyxcIkxcIixhLHcvMixlLHAsYSx3LzIsYSxoK3EpOnAmJnA+dyYmZT5hK2ImJmU8YStjLWI/ZC5zcGxpY2UoMjMsMyxcIkxcIixlKzYsaCt3LGUsaCt3KzYsZS02LGgrdyxhK3EsaCt3KTpwJiYwPnAmJmU+YStiJiZlPGErYy1iJiZkLnNwbGljZSgzLDMsXCJMXCIsZS02LGgsZSxoLTYsZSs2LGgsYy1xLGgpO3JldHVybiBkfX0sY2xpcFJlY3Q6ZnVuY3Rpb24oaCxjLHcscCl7dmFyIHE9YS51bmlxdWVLZXkoKSxiPXRoaXMuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpLmF0dHIoe2lkOnF9KS5hZGQodGhpcy5kZWZzKTtoPXRoaXMucmVjdChoLGMsdyxwLDApLmFkZChiKTtoLmlkPXE7aC5jbGlwUGF0aD1iO2guY291bnQ9MDtyZXR1cm4gaH0sdGV4dDpmdW5jdGlvbihhLGgsYyx3KXt2YXIgcD0hSCYmdGhpcy5mb3JFeHBvcnQscT17fTtpZih3JiYodGhpcy5hbGxvd0hUTUx8fCF0aGlzLmZvckV4cG9ydCkpcmV0dXJuIHRoaXMuaHRtbChhLGgsYyk7cS54PU1hdGgucm91bmQoaHx8XG4wKTtjJiYocS55PU1hdGgucm91bmQoYykpO2lmKGF8fDA9PT1hKXEudGV4dD1hO2E9dGhpcy5jcmVhdGVFbGVtZW50KFwidGV4dFwiKS5hdHRyKHEpO3AmJmEuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCJ9KTt3fHwoYS54U2V0dGVyPWZ1bmN0aW9uKGEsaCxjKXt2YXIgdz1jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIikscCxxPWMuZ2V0QXR0cmlidXRlKGgpLGI7Zm9yKGI9MDtiPHcubGVuZ3RoO2IrKylwPXdbYl0scC5nZXRBdHRyaWJ1dGUoaCk9PT1xJiZwLnNldEF0dHJpYnV0ZShoLGEpO2Muc2V0QXR0cmlidXRlKGgsYSl9KTtyZXR1cm4gYX0sZm9udE1ldHJpY3M6ZnVuY3Rpb24oYSxjKXthPWF8fGMmJmMuc3R5bGUmJmMuc3R5bGUuZm9udFNpemV8fHRoaXMuc3R5bGUmJnRoaXMuc3R5bGUuZm9udFNpemU7YT0vcHgvLnRlc3QoYSk/aChhKTovZW0vLnRlc3QoYSk/cGFyc2VGbG9hdChhKSooYz90aGlzLmZvbnRNZXRyaWNzKG51bGwsYy5wYXJlbnROb2RlKS5mOjE2KToxMjtcbmM9MjQ+YT9hKzM6TWF0aC5yb3VuZCgxLjIqYSk7cmV0dXJue2g6YyxiOk1hdGgucm91bmQoLjgqYyksZjphfX0scm90Q29ycjpmdW5jdGlvbihhLGgsYyl7dmFyIHc9YTtoJiZjJiYodz1NYXRoLm1heCh3Kk1hdGguY29zKGgqZyksNCkpO3JldHVybnt4Oi1hLzMqTWF0aC5zaW4oaCpnKSx5Ond9fSxsYWJlbDpmdW5jdGlvbihoLGMscSxkLG4sZyxrLHosRyl7dmFyIHg9dGhpcyxIPXguZyhcImJ1dHRvblwiIT09RyYmXCJsYWJlbFwiKSx2PUgudGV4dD14LnRleHQoXCJcIiwwLDAsaykuYXR0cih7ekluZGV4OjF9KSxmLHksST0wLEI9MyxEPTAscixsLFAsbSxKLE89e30sTCx1LE49L151cmxcXCgoLio/KVxcKSQvLnRlc3QoZCksSz1OLFUsVCxRLFI7RyYmSC5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrRyk7Sz1OO1U9ZnVuY3Rpb24oKXtyZXR1cm4oTHx8MCklMi8yfTtUPWZ1bmN0aW9uKCl7dmFyIGE9di5lbGVtZW50LnN0eWxlLGg9e307eT0odm9pZCAwPT09cnx8dm9pZCAwPT09bHx8SikmJnQodi50ZXh0U3RyKSYmXG52LmdldEJCb3goKTtILndpZHRoPShyfHx5LndpZHRofHwwKSsyKkIrRDtILmhlaWdodD0obHx8eS5oZWlnaHR8fDApKzIqQjt1PUIreC5mb250TWV0cmljcyhhJiZhLmZvbnRTaXplLHYpLmI7SyYmKGZ8fChILmJveD1mPXguc3ltYm9sc1tkXXx8Tj94LnN5bWJvbChkKTp4LnJlY3QoKSxmLmFkZENsYXNzKChcImJ1dHRvblwiPT09Rz9cIlwiOlwiaGlnaGNoYXJ0cy1sYWJlbC1ib3hcIikrKEc/XCIgaGlnaGNoYXJ0cy1cIitHK1wiLWJveFwiOlwiXCIpKSxmLmFkZChIKSxhPVUoKSxoLng9YSxoLnk9KHo/LXU6MCkrYSksaC53aWR0aD1NYXRoLnJvdW5kKEgud2lkdGgpLGguaGVpZ2h0PU1hdGgucm91bmQoSC5oZWlnaHQpLGYuYXR0cihlKGgsTykpLE89e30pfTtRPWZ1bmN0aW9uKCl7dmFyIGE9RCtCLGg7aD16PzA6dTt0KHIpJiZ5JiYoXCJjZW50ZXJcIj09PUp8fFwicmlnaHRcIj09PUopJiYoYSs9e2NlbnRlcjouNSxyaWdodDoxfVtKXSooci15LndpZHRoKSk7aWYoYSE9PXYueHx8aCE9PXYueSl2LmF0dHIoXCJ4XCIsXG5hKSx2b2lkIDAhPT1oJiZ2LmF0dHIoXCJ5XCIsaCk7di54PWE7di55PWh9O1I9ZnVuY3Rpb24oYSxoKXtmP2YuYXR0cihhLGgpOk9bYV09aH07SC5vbkFkZD1mdW5jdGlvbigpe3YuYWRkKEgpO0guYXR0cih7dGV4dDpofHwwPT09aD9oOlwiXCIseDpjLHk6cX0pO2YmJnQobikmJkguYXR0cih7YW5jaG9yWDpuLGFuY2hvclk6Z30pfTtILndpZHRoU2V0dGVyPWZ1bmN0aW9uKGgpe3I9YS5pc051bWJlcihoKT9oOm51bGx9O0guaGVpZ2h0U2V0dGVyPWZ1bmN0aW9uKGEpe2w9YX07SFtcInRleHQtYWxpZ25TZXR0ZXJcIl09ZnVuY3Rpb24oYSl7Sj1hfTtILnBhZGRpbmdTZXR0ZXI9ZnVuY3Rpb24oYSl7dChhKSYmYSE9PUImJihCPUgucGFkZGluZz1hLFEoKSl9O0gucGFkZGluZ0xlZnRTZXR0ZXI9ZnVuY3Rpb24oYSl7dChhKSYmYSE9PUQmJihEPWEsUSgpKX07SC5hbGlnblNldHRlcj1mdW5jdGlvbihhKXthPXtsZWZ0OjAsY2VudGVyOi41LHJpZ2h0OjF9W2FdO2EhPT1JJiYoST1hLHkmJkguYXR0cih7eDpQfSkpfTtcbkgudGV4dFNldHRlcj1mdW5jdGlvbihhKXt2b2lkIDAhPT1hJiZ2LnRleHRTZXR0ZXIoYSk7VCgpO1EoKX07SFtcInN0cm9rZS13aWR0aFNldHRlclwiXT1mdW5jdGlvbihhLGgpe2EmJihLPSEwKTtMPXRoaXNbXCJzdHJva2Utd2lkdGhcIl09YTtSKGgsYSl9O0guc3Ryb2tlU2V0dGVyPUguZmlsbFNldHRlcj1ILnJTZXR0ZXI9ZnVuY3Rpb24oYSxoKXtcInJcIiE9PWgmJihcImZpbGxcIj09PWgmJmEmJihLPSEwKSxIW2hdPWEpO1IoaCxhKX07SC5hbmNob3JYU2V0dGVyPWZ1bmN0aW9uKGEsaCl7bj1ILmFuY2hvclg9YTtSKGgsTWF0aC5yb3VuZChhKS1VKCktUCl9O0guYW5jaG9yWVNldHRlcj1mdW5jdGlvbihhLGgpe2c9SC5hbmNob3JZPWE7UihoLGEtbSl9O0gueFNldHRlcj1mdW5jdGlvbihhKXtILng9YTtJJiYoYS09SSooKHJ8fHkud2lkdGgpKzIqQikpO1A9TWF0aC5yb3VuZChhKTtILmF0dHIoXCJ0cmFuc2xhdGVYXCIsUCl9O0gueVNldHRlcj1mdW5jdGlvbihhKXttPUgueT1NYXRoLnJvdW5kKGEpO1xuSC5hdHRyKFwidHJhbnNsYXRlWVwiLG0pfTt2YXIgVj1ILmNzcztyZXR1cm4gZShILHtjc3M6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGg9e307YT1wKGEpO2IoSC50ZXh0UHJvcHMsZnVuY3Rpb24oYyl7dm9pZCAwIT09YVtjXSYmKGhbY109YVtjXSxkZWxldGUgYVtjXSl9KTt2LmNzcyhoKX1yZXR1cm4gVi5jYWxsKEgsYSl9LGdldEJCb3g6ZnVuY3Rpb24oKXtyZXR1cm57d2lkdGg6eS53aWR0aCsyKkIsaGVpZ2h0OnkuaGVpZ2h0KzIqQix4OnkueC1CLHk6eS55LUJ9fSxzaGFkb3c6ZnVuY3Rpb24oYSl7YSYmKFQoKSxmJiZmLnNoYWRvdyhhKSk7cmV0dXJuIEh9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt3KEguZWxlbWVudCxcIm1vdXNlZW50ZXJcIik7dyhILmVsZW1lbnQsXCJtb3VzZWxlYXZlXCIpO3YmJih2PXYuZGVzdHJveSgpKTtmJiYoZj1mLmRlc3Ryb3koKSk7Qy5wcm90b3R5cGUuZGVzdHJveS5jYWxsKEgpO0g9eD1UPVE9Uj1udWxsfX0pfX0pO2EuUmVuZGVyZXI9QX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1cbmEuYXR0cixBPWEuY3JlYXRlRWxlbWVudCxGPWEuY3NzLEU9YS5kZWZpbmVkLG09YS5lYWNoLGY9YS5leHRlbmQsbD1hLmlzRmlyZWZveCxyPWEuaXNNUyx1PWEuaXNXZWJLaXQsdD1hLnBJbnQsZz1hLlNWR1JlbmRlcmVyLGQ9YS53aW4saz1hLndyYXA7ZihhLlNWR0VsZW1lbnQucHJvdG90eXBlLHtodG1sQ3NzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudDtpZihiPWEmJlwiU1BBTlwiPT09Yi50YWdOYW1lJiZhLndpZHRoKWRlbGV0ZSBhLndpZHRoLHRoaXMudGV4dFdpZHRoPWIsdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTthJiZcImVsbGlwc2lzXCI9PT1hLnRleHRPdmVyZmxvdyYmKGEud2hpdGVTcGFjZT1cIm5vd3JhcFwiLGEub3ZlcmZsb3c9XCJoaWRkZW5cIik7dGhpcy5zdHlsZXM9Zih0aGlzLnN0eWxlcyxhKTtGKHRoaXMuZWxlbWVudCxhKTtyZXR1cm4gdGhpc30saHRtbEdldEJCb3g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7XCJ0ZXh0XCI9PT1hLm5vZGVOYW1lJiYoYS5zdHlsZS5wb3NpdGlvbj1cblwiYWJzb2x1dGVcIik7cmV0dXJue3g6YS5vZmZzZXRMZWZ0LHk6YS5vZmZzZXRUb3Asd2lkdGg6YS5vZmZzZXRXaWR0aCxoZWlnaHQ6YS5vZmZzZXRIZWlnaHR9fSxodG1sVXBkYXRlVHJhbnNmb3JtOmZ1bmN0aW9uKCl7aWYodGhpcy5hZGRlZCl7dmFyIGE9dGhpcy5yZW5kZXJlcixlPXRoaXMuZWxlbWVudCxkPXRoaXMudHJhbnNsYXRlWHx8MCxnPXRoaXMudHJhbnNsYXRlWXx8MCxuPXRoaXMueHx8MCxrPXRoaXMueXx8MCxmPXRoaXMudGV4dEFsaWdufHxcImxlZnRcIixjPXtsZWZ0OjAsY2VudGVyOi41LHJpZ2h0OjF9W2ZdLEc9dGhpcy5zdHlsZXM7RihlLHttYXJnaW5MZWZ0OmQsbWFyZ2luVG9wOmd9KTt0aGlzLnNoYWRvd3MmJm0odGhpcy5zaGFkb3dzLGZ1bmN0aW9uKGEpe0YoYSx7bWFyZ2luTGVmdDpkKzEsbWFyZ2luVG9wOmcrMX0pfSk7dGhpcy5pbnZlcnRlZCYmbShlLmNoaWxkTm9kZXMsZnVuY3Rpb24oYyl7YS5pbnZlcnRDaGlsZChjLGUpfSk7aWYoXCJTUEFOXCI9PT1lLnRhZ05hbWUpe3ZhciBxPVxudGhpcy5yb3RhdGlvbixCPXQodGhpcy50ZXh0V2lkdGgpLHI9RyYmRy53aGl0ZVNwYWNlLHA9W3EsZixlLmlubmVySFRNTCx0aGlzLnRleHRXaWR0aCx0aGlzLnRleHRBbGlnbl0uam9pbigpO3AhPT10aGlzLmNUVCYmKEc9YS5mb250TWV0cmljcyhlLnN0eWxlLmZvbnRTaXplKS5iLEUocSkmJnRoaXMuc2V0U3BhblJvdGF0aW9uKHEsYyxHKSxGKGUse3dpZHRoOlwiXCIsd2hpdGVTcGFjZTpyfHxcIm5vd3JhcFwifSksZS5vZmZzZXRXaWR0aD5CJiYvWyBcXC1dLy50ZXN0KGUudGV4dENvbnRlbnR8fGUuaW5uZXJUZXh0KSYmRihlLHt3aWR0aDpCK1wicHhcIixkaXNwbGF5OlwiYmxvY2tcIix3aGl0ZVNwYWNlOnJ8fFwibm9ybWFsXCJ9KSx0aGlzLmdldFNwYW5Db3JyZWN0aW9uKGUub2Zmc2V0V2lkdGgsRyxjLHEsZikpO0YoZSx7bGVmdDpuKyh0aGlzLnhDb3JyfHwwKStcInB4XCIsdG9wOmsrKHRoaXMueUNvcnJ8fDApK1wicHhcIn0pO3UmJihHPWUub2Zmc2V0SGVpZ2h0KTt0aGlzLmNUVD1wfX1lbHNlIHRoaXMuYWxpZ25PbkFkZD1cbiEwfSxzZXRTcGFuUm90YXRpb246ZnVuY3Rpb24oYSxlLGcpe3ZhciBiPXt9LG49cj9cIi1tcy10cmFuc2Zvcm1cIjp1P1wiLXdlYmtpdC10cmFuc2Zvcm1cIjpsP1wiTW96VHJhbnNmb3JtXCI6ZC5vcGVyYT9cIi1vLXRyYW5zZm9ybVwiOlwiXCI7YltuXT1iLnRyYW5zZm9ybT1cInJvdGF0ZShcIithK1wiZGVnKVwiO2JbbisobD9cIk9yaWdpblwiOlwiLW9yaWdpblwiKV09Yi50cmFuc2Zvcm1PcmlnaW49MTAwKmUrXCIlIFwiK2crXCJweFwiO0YodGhpcy5lbGVtZW50LGIpfSxnZXRTcGFuQ29ycmVjdGlvbjpmdW5jdGlvbihhLGUsZCl7dGhpcy54Q29ycj0tYSpkO3RoaXMueUNvcnI9LWV9fSk7ZihnLnByb3RvdHlwZSx7aHRtbDpmdW5jdGlvbihhLGUsZCl7dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxuPWIuZWxlbWVudCxnPWIucmVuZGVyZXIsdj1nLmlzU1ZHLGM9ZnVuY3Rpb24oYSxjKXttKFtcIm9wYWNpdHlcIixcInZpc2liaWxpdHlcIl0sZnVuY3Rpb24ocSl7ayhhLHErXCJTZXR0ZXJcIixmdW5jdGlvbihhLFxucCxxLGIpe2EuY2FsbCh0aGlzLHAscSxiKTtjW3FdPXB9KX0pfTtiLnRleHRTZXR0ZXI9ZnVuY3Rpb24oYSl7YSE9PW4uaW5uZXJIVE1MJiZkZWxldGUgdGhpcy5iQm94O24uaW5uZXJIVE1MPXRoaXMudGV4dFN0cj1hO2IuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpfTt2JiZjKGIsYi5lbGVtZW50LnN0eWxlKTtiLnhTZXR0ZXI9Yi55U2V0dGVyPWIuYWxpZ25TZXR0ZXI9Yi5yb3RhdGlvblNldHRlcj1mdW5jdGlvbihhLGMpe1wiYWxpZ25cIj09PWMmJihjPVwidGV4dEFsaWduXCIpO2JbY109YTtiLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKX07Yi5hdHRyKHt0ZXh0OmEseDpNYXRoLnJvdW5kKGUpLHk6TWF0aC5yb3VuZChkKX0pLmNzcyh7Zm9udEZhbWlseTp0aGlzLnN0eWxlLmZvbnRGYW1pbHksZm9udFNpemU6dGhpcy5zdHlsZS5mb250U2l6ZSxwb3NpdGlvbjpcImFic29sdXRlXCJ9KTtuLnN0eWxlLndoaXRlU3BhY2U9XCJub3dyYXBcIjtiLmNzcz1iLmh0bWxDc3M7diYmKGIuYWRkPWZ1bmN0aW9uKGEpe3ZhciBxLFxuZT1nLmJveC5wYXJlbnROb2RlLGQ9W107aWYodGhpcy5wYXJlbnRHcm91cD1hKXtpZihxPWEuZGl2LCFxKXtmb3IoO2E7KWQucHVzaChhKSxhPWEucGFyZW50R3JvdXA7bShkLnJldmVyc2UoKSxmdW5jdGlvbihhKXt2YXIgcCxuPUMoYS5lbGVtZW50LFwiY2xhc3NcIik7biYmKG49e2NsYXNzTmFtZTpufSk7cT1hLmRpdj1hLmRpdnx8QShcImRpdlwiLG4se3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixsZWZ0OihhLnRyYW5zbGF0ZVh8fDApK1wicHhcIix0b3A6KGEudHJhbnNsYXRlWXx8MCkrXCJweFwiLGRpc3BsYXk6YS5kaXNwbGF5LG9wYWNpdHk6YS5vcGFjaXR5LHBvaW50ZXJFdmVudHM6YS5zdHlsZXMmJmEuc3R5bGVzLnBvaW50ZXJFdmVudHN9LHF8fGUpO3A9cS5zdHlsZTtmKGEse2NsYXNzU2V0dGVyOmZ1bmN0aW9uKGEpe3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGEpO3EuY2xhc3NOYW1lPWF9LG9uOmZ1bmN0aW9uKCl7ZFswXS5kaXYmJmIub24uYXBwbHkoe2VsZW1lbnQ6ZFswXS5kaXZ9LFxuYXJndW1lbnRzKTtyZXR1cm4gYX0sdHJhbnNsYXRlWFNldHRlcjpmdW5jdGlvbihjLGgpe3AubGVmdD1jK1wicHhcIjthW2hdPWM7YS5kb1RyYW5zZm9ybT0hMH0sdHJhbnNsYXRlWVNldHRlcjpmdW5jdGlvbihjLGgpe3AudG9wPWMrXCJweFwiO2FbaF09YzthLmRvVHJhbnNmb3JtPSEwfX0pO2MoYSxwKX0pfX1lbHNlIHE9ZTtxLmFwcGVuZENoaWxkKG4pO2IuYWRkZWQ9ITA7Yi5hbGlnbk9uQWRkJiZiLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtyZXR1cm4gYn0pO3JldHVybiBifX0pfSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDLEEsRj1hLmNyZWF0ZUVsZW1lbnQsRT1hLmNzcyxtPWEuZGVmaW5lZCxmPWEuZGVnMnJhZCxsPWEuZGlzY2FyZEVsZW1lbnQscj1hLmRvYyx1PWEuZWFjaCx0PWEuZXJhc2UsZz1hLmV4dGVuZDtDPWEuZXh0ZW5kQ2xhc3M7dmFyIGQ9YS5pc0FycmF5LGs9YS5pc051bWJlcixiPWEuaXNPYmplY3QsZT1hLm1lcmdlO0E9YS5ub29wO3ZhciB2PWEucGljayx5PWEucEludCxcbm49YS5TVkdFbGVtZW50LEQ9YS5TVkdSZW5kZXJlcixKPWEud2luO2Euc3ZnfHwoQT17ZG9jTW9kZTg6ciYmOD09PXIuZG9jdW1lbnRNb2RlLGluaXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXCJcXHgzY1wiLGIsJyBmaWxsZWRcXHgzZFwiZlwiIHN0cm9rZWRcXHgzZFwiZlwiJ10sZT1bXCJwb3NpdGlvbjogXCIsXCJhYnNvbHV0ZVwiLFwiO1wiXSxkPVwiZGl2XCI9PT1iOyhcInNoYXBlXCI9PT1ifHxkKSYmZS5wdXNoKFwibGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4O1wiKTtlLnB1c2goXCJ2aXNpYmlsaXR5OiBcIixkP1wiaGlkZGVuXCI6XCJ2aXNpYmxlXCIpO2MucHVzaCgnIHN0eWxlXFx4M2RcIicsZS5qb2luKFwiXCIpLCdcIi9cXHgzZScpO2ImJihjPWR8fFwic3BhblwiPT09Ynx8XCJpbWdcIj09PWI/Yy5qb2luKFwiXCIpOmEucHJlcFZNTChjKSx0aGlzLmVsZW1lbnQ9RihjKSk7dGhpcy5yZW5kZXJlcj1hfSxhZGQ6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5yZW5kZXJlcixiPXRoaXMuZWxlbWVudCxlPWMuYm94LGQ9YSYmYS5pbnZlcnRlZCxcbmU9YT9hLmVsZW1lbnR8fGE6ZTthJiYodGhpcy5wYXJlbnRHcm91cD1hKTtkJiZjLmludmVydENoaWxkKGIsZSk7ZS5hcHBlbmRDaGlsZChiKTt0aGlzLmFkZGVkPSEwO3RoaXMuYWxpZ25PbkFkZCYmIXRoaXMuZGVmZXJVcGRhdGVUcmFuc2Zvcm0mJnRoaXMudXBkYXRlVHJhbnNmb3JtKCk7aWYodGhpcy5vbkFkZCl0aGlzLm9uQWRkKCk7dGhpcy5jbGFzc05hbWUmJnRoaXMuYXR0cihcImNsYXNzXCIsdGhpcy5jbGFzc05hbWUpO3JldHVybiB0aGlzfSx1cGRhdGVUcmFuc2Zvcm06bi5wcm90b3R5cGUuaHRtbFVwZGF0ZVRyYW5zZm9ybSxzZXRTcGFuUm90YXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJvdGF0aW9uLGI9TWF0aC5jb3MoYSpmKSxxPU1hdGguc2luKGEqZik7RSh0aGlzLmVsZW1lbnQse2ZpbHRlcjphP1tcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExXFx4M2RcIixiLFwiLCBNMTJcXHgzZFwiLC1xLFwiLCBNMjFcXHgzZFwiLHEsXCIsIE0yMlxceDNkXCIsXG5iLFwiLCBzaXppbmdNZXRob2RcXHgzZCdhdXRvIGV4cGFuZCcpXCJdLmpvaW4oXCJcIik6XCJub25lXCJ9KX0sZ2V0U3BhbkNvcnJlY3Rpb246ZnVuY3Rpb24oYSxiLHEsZSxkKXt2YXIgYz1lP01hdGguY29zKGUqZik6MSxuPWU/TWF0aC5zaW4oZSpmKTowLGc9dih0aGlzLmVsZW1IZWlnaHQsdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCksazt0aGlzLnhDb3JyPTA+YyYmLWE7dGhpcy55Q29ycj0wPm4mJi1nO2s9MD5jKm47dGhpcy54Q29ycis9bipiKihrPzEtcTpxKTt0aGlzLnlDb3JyLT1jKmIqKGU/az9xOjEtcToxKTtkJiZcImxlZnRcIiE9PWQmJih0aGlzLnhDb3JyLT1hKnEqKDA+Yz8tMToxKSxlJiYodGhpcy55Q29yci09ZypxKigwPm4/LTE6MSkpLEUodGhpcy5lbGVtZW50LHt0ZXh0QWxpZ246ZH0pKX0scGF0aFRvVk1MOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLmxlbmd0aCxiPVtdO2MtLTspayhhW2NdKT9iW2NdPU1hdGgucm91bmQoMTAqYVtjXSktNTpcIlpcIj09PWFbY10/YltjXT1cInhcIjpcbihiW2NdPWFbY10sIWEuaXNBcmN8fFwid2FcIiE9PWFbY10mJlwiYXRcIiE9PWFbY118fChiW2MrNV09PT1iW2MrN10mJihiW2MrN10rPWFbYys3XT5hW2MrNV0/MTotMSksYltjKzZdPT09YltjKzhdJiYoYltjKzhdKz1hW2MrOF0+YVtjKzZdPzE6LTEpKSk7cmV0dXJuIGIuam9pbihcIiBcIil8fFwieFwifSxjbGlwOmZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMsYjthPyhiPWEubWVtYmVycyx0KGIsYyksYi5wdXNoKGMpLGMuZGVzdHJveUNsaXA9ZnVuY3Rpb24oKXt0KGIsYyl9LGE9YS5nZXRDU1MoYykpOihjLmRlc3Ryb3lDbGlwJiZjLmRlc3Ryb3lDbGlwKCksYT17Y2xpcDpjLmRvY01vZGU4P1wiaW5oZXJpdFwiOlwicmVjdChhdXRvKVwifSk7cmV0dXJuIGMuY3NzKGEpfSxjc3M6bi5wcm90b3R5cGUuaHRtbENzcyxzYWZlUmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSl7YS5wYXJlbnROb2RlJiZsKGEpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95Q2xpcCYmdGhpcy5kZXN0cm95Q2xpcCgpO3JldHVybiBuLnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMpfSxcbm9uOmZ1bmN0aW9uKGEsYil7dGhpcy5lbGVtZW50W1wib25cIithXT1mdW5jdGlvbigpe3ZhciBhPUouZXZlbnQ7YS50YXJnZXQ9YS5zcmNFbGVtZW50O2IoYSl9O3JldHVybiB0aGlzfSxjdXRPZmZQYXRoOmZ1bmN0aW9uKGEsYil7dmFyIGM7YT1hLnNwbGl0KC9bICxdLyk7Yz1hLmxlbmd0aDtpZig5PT09Y3x8MTE9PT1jKWFbYy00XT1hW2MtMl09eShhW2MtMl0pLTEwKmI7cmV0dXJuIGEuam9pbihcIiBcIil9LHNoYWRvdzpmdW5jdGlvbihhLGIsZSl7dmFyIGM9W10scSxwPXRoaXMuZWxlbWVudCxkPXRoaXMucmVuZGVyZXIsbixnPXAuc3R5bGUsaCx3PXAucGF0aCxrLEgsZixEO3cmJlwic3RyaW5nXCIhPT10eXBlb2Ygdy52YWx1ZSYmKHc9XCJ4XCIpO0g9dztpZihhKXtmPXYoYS53aWR0aCwzKTtEPShhLm9wYWNpdHl8fC4xNSkvZjtmb3IocT0xOzM+PXE7cSsrKWs9MipmKzEtMipxLGUmJihIPXRoaXMuY3V0T2ZmUGF0aCh3LnZhbHVlLGsrLjUpKSxoPVsnXFx4M2NzaGFwZSBpc1NoYWRvd1xceDNkXCJ0cnVlXCIgc3Ryb2tld2VpZ2h0XFx4M2RcIicsXG5rLCdcIiBmaWxsZWRcXHgzZFwiZmFsc2VcIiBwYXRoXFx4M2RcIicsSCwnXCIgY29vcmRzaXplXFx4M2RcIjEwIDEwXCIgc3R5bGVcXHgzZFwiJyxwLnN0eWxlLmNzc1RleHQsJ1wiIC9cXHgzZSddLG49RihkLnByZXBWTUwoaCksbnVsbCx7bGVmdDp5KGcubGVmdCkrdihhLm9mZnNldFgsMSksdG9wOnkoZy50b3ApK3YoYS5vZmZzZXRZLDEpfSksZSYmKG4uY3V0T2ZmPWsrMSksaD1bJ1xceDNjc3Ryb2tlIGNvbG9yXFx4M2RcIicsYS5jb2xvcnx8XCIjMDAwMDAwXCIsJ1wiIG9wYWNpdHlcXHgzZFwiJyxEKnEsJ1wiL1xceDNlJ10sRihkLnByZXBWTUwoaCksbnVsbCxudWxsLG4pLGI/Yi5lbGVtZW50LmFwcGVuZENoaWxkKG4pOnAucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobixwKSxjLnB1c2gobik7dGhpcy5zaGFkb3dzPWN9cmV0dXJuIHRoaXN9LHVwZGF0ZVNoYWRvd3M6QSxzZXRBdHRyOmZ1bmN0aW9uKGEsYil7dGhpcy5kb2NNb2RlOD90aGlzLmVsZW1lbnRbYV09Yjp0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGEsYil9LFxuY2xhc3NTZXR0ZXI6ZnVuY3Rpb24oYSl7KHRoaXMuYWRkZWQ/dGhpcy5lbGVtZW50OnRoaXMpLmNsYXNzTmFtZT1hfSxkYXNoc3R5bGVTZXR0ZXI6ZnVuY3Rpb24oYSxiLGUpeyhlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3Ryb2tlXCIpWzBdfHxGKHRoaXMucmVuZGVyZXIucHJlcFZNTChbXCJcXHgzY3N0cm9rZS9cXHgzZVwiXSksbnVsbCxudWxsLGUpKVtiXT1hfHxcInNvbGlkXCI7dGhpc1tiXT1hfSxkU2V0dGVyOmZ1bmN0aW9uKGEsYixlKXt2YXIgYz10aGlzLnNoYWRvd3M7YT1hfHxbXTt0aGlzLmQ9YS5qb2luJiZhLmpvaW4oXCIgXCIpO2UucGF0aD1hPXRoaXMucGF0aFRvVk1MKGEpO2lmKGMpZm9yKGU9Yy5sZW5ndGg7ZS0tOyljW2VdLnBhdGg9Y1tlXS5jdXRPZmY/dGhpcy5jdXRPZmZQYXRoKGEsY1tlXS5jdXRPZmYpOmE7dGhpcy5zZXRBdHRyKGIsYSl9LGZpbGxTZXR0ZXI6ZnVuY3Rpb24oYSxiLGUpe3ZhciBjPWUubm9kZU5hbWU7XCJTUEFOXCI9PT1jP2Uuc3R5bGUuY29sb3I9YTpcIklNR1wiIT09XG5jJiYoZS5maWxsZWQ9XCJub25lXCIhPT1hLHRoaXMuc2V0QXR0cihcImZpbGxjb2xvclwiLHRoaXMucmVuZGVyZXIuY29sb3IoYSxlLGIsdGhpcykpKX0sXCJmaWxsLW9wYWNpdHlTZXR0ZXJcIjpmdW5jdGlvbihhLGIsZSl7Rih0aGlzLnJlbmRlcmVyLnByZXBWTUwoW1wiXFx4M2NcIixiLnNwbGl0KFwiLVwiKVswXSwnIG9wYWNpdHlcXHgzZFwiJyxhLCdcIi9cXHgzZSddKSxudWxsLG51bGwsZSl9LG9wYWNpdHlTZXR0ZXI6QSxyb3RhdGlvblNldHRlcjpmdW5jdGlvbihhLGIsZSl7ZT1lLnN0eWxlO3RoaXNbYl09ZVtiXT1hO2UubGVmdD0tTWF0aC5yb3VuZChNYXRoLnNpbihhKmYpKzEpK1wicHhcIjtlLnRvcD1NYXRoLnJvdW5kKE1hdGguY29zKGEqZikpK1wicHhcIn0sc3Ryb2tlU2V0dGVyOmZ1bmN0aW9uKGEsYixlKXt0aGlzLnNldEF0dHIoXCJzdHJva2Vjb2xvclwiLHRoaXMucmVuZGVyZXIuY29sb3IoYSxlLGIsdGhpcykpfSxcInN0cm9rZS13aWR0aFNldHRlclwiOmZ1bmN0aW9uKGEsYixlKXtlLnN0cm9rZWQ9ISFhO1xudGhpc1tiXT1hO2soYSkmJihhKz1cInB4XCIpO3RoaXMuc2V0QXR0cihcInN0cm9rZXdlaWdodFwiLGEpfSx0aXRsZVNldHRlcjpmdW5jdGlvbihhLGIpe3RoaXMuc2V0QXR0cihiLGEpfSx2aXNpYmlsaXR5U2V0dGVyOmZ1bmN0aW9uKGEsYixlKXtcImluaGVyaXRcIj09PWEmJihhPVwidmlzaWJsZVwiKTt0aGlzLnNoYWRvd3MmJnUodGhpcy5zaGFkb3dzLGZ1bmN0aW9uKGMpe2Muc3R5bGVbYl09YX0pO1wiRElWXCI9PT1lLm5vZGVOYW1lJiYoYT1cImhpZGRlblwiPT09YT9cIi05OTllbVwiOjAsdGhpcy5kb2NNb2RlOHx8KGUuc3R5bGVbYl09YT9cInZpc2libGVcIjpcImhpZGRlblwiKSxiPVwidG9wXCIpO2Uuc3R5bGVbYl09YX0seFNldHRlcjpmdW5jdGlvbihhLGIsZSl7dGhpc1tiXT1hO1wieFwiPT09Yj9iPVwibGVmdFwiOlwieVwiPT09YiYmKGI9XCJ0b3BcIik7dGhpcy51cGRhdGVDbGlwcGluZz8odGhpc1tiXT1hLHRoaXMudXBkYXRlQ2xpcHBpbmcoKSk6ZS5zdHlsZVtiXT1hfSx6SW5kZXhTZXR0ZXI6ZnVuY3Rpb24oYSxcbmIsZSl7ZS5zdHlsZVtiXT1hfX0sQVtcInN0cm9rZS1vcGFjaXR5U2V0dGVyXCJdPUFbXCJmaWxsLW9wYWNpdHlTZXR0ZXJcIl0sYS5WTUxFbGVtZW50PUE9QyhuLEEpLEEucHJvdG90eXBlLnlTZXR0ZXI9QS5wcm90b3R5cGUud2lkdGhTZXR0ZXI9QS5wcm90b3R5cGUuaGVpZ2h0U2V0dGVyPUEucHJvdG90eXBlLnhTZXR0ZXIsQT17RWxlbWVudDpBLGlzSUU4Oi0xPEoubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRSA4LjBcIiksaW5pdDpmdW5jdGlvbihhLGIsZSl7dmFyIGMsZDt0aGlzLmFsaWduZWRPYmplY3RzPVtdO2M9dGhpcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwifSk7ZD1jLmVsZW1lbnQ7YS5hcHBlbmRDaGlsZChjLmVsZW1lbnQpO3RoaXMuaXNWTUw9ITA7dGhpcy5ib3g9ZDt0aGlzLmJveFdyYXBwZXI9Yzt0aGlzLmdyYWRpZW50cz17fTt0aGlzLmNhY2hlPXt9O3RoaXMuY2FjaGVLZXlzPVtdO3RoaXMuaW1nQ291bnQ9MDt0aGlzLnNldFNpemUoYixcbmUsITEpO2lmKCFyLm5hbWVzcGFjZXMuaGN2KXtyLm5hbWVzcGFjZXMuYWRkKFwiaGN2XCIsXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiKTt0cnl7ci5jcmVhdGVTdHlsZVNoZWV0KCkuY3NzVGV4dD1cImhjdlxcXFw6ZmlsbCwgaGN2XFxcXDpwYXRoLCBoY3ZcXFxcOnNoYXBlLCBoY3ZcXFxcOnN0cm9rZXsgYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCk7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgfSBcIn1jYXRjaChwKXtyLnN0eWxlU2hlZXRzWzBdLmNzc1RleHQrPVwiaGN2XFxcXDpmaWxsLCBoY3ZcXFxcOnBhdGgsIGhjdlxcXFw6c2hhcGUsIGhjdlxcXFw6c3Ryb2tleyBiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9IFwifX19LGlzSGlkZGVuOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuYm94Lm9mZnNldFdpZHRofSxjbGlwUmVjdDpmdW5jdGlvbihhLGUsZCxuKXt2YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoKSxwPWIoYSk7cmV0dXJuIGcoYyx7bWVtYmVyczpbXSxcbmNvdW50OjAsbGVmdDoocD9hLng6YSkrMSx0b3A6KHA/YS55OmUpKzEsd2lkdGg6KHA/YS53aWR0aDpkKS0xLGhlaWdodDoocD9hLmhlaWdodDpuKS0xLGdldENTUzpmdW5jdGlvbihhKXt2YXIgYz1hLmVsZW1lbnQsYj1jLm5vZGVOYW1lLGg9YS5pbnZlcnRlZCx3PXRoaXMudG9wLShcInNoYXBlXCI9PT1iP2Mub2Zmc2V0VG9wOjApLHA9dGhpcy5sZWZ0LGM9cCt0aGlzLndpZHRoLGU9dyt0aGlzLmhlaWdodCx3PXtjbGlwOlwicmVjdChcIitNYXRoLnJvdW5kKGg/cDp3KStcInB4LFwiK01hdGgucm91bmQoaD9lOmMpK1wicHgsXCIrTWF0aC5yb3VuZChoP2M6ZSkrXCJweCxcIitNYXRoLnJvdW5kKGg/dzpwKStcInB4KVwifTshaCYmYS5kb2NNb2RlOCYmXCJESVZcIj09PWImJmcodyx7d2lkdGg6YytcInB4XCIsaGVpZ2h0OmUrXCJweFwifSk7cmV0dXJuIHd9LHVwZGF0ZUNsaXBwaW5nOmZ1bmN0aW9uKCl7dShjLm1lbWJlcnMsZnVuY3Rpb24oYSl7YS5lbGVtZW50JiZhLmNzcyhjLmdldENTUyhhKSl9KX19KX0sY29sb3I6ZnVuY3Rpb24oYyxcbmIsZSxkKXt2YXIgcT10aGlzLHAsbj0vXnJnYmEvLGcsayxoPVwibm9uZVwiO2MmJmMubGluZWFyR3JhZGllbnQ/az1cImdyYWRpZW50XCI6YyYmYy5yYWRpYWxHcmFkaWVudCYmKGs9XCJwYXR0ZXJuXCIpO2lmKGspe3ZhciB3LHYsSD1jLmxpbmVhckdyYWRpZW50fHxjLnJhZGlhbEdyYWRpZW50LGYsRCx5LHgscixCPVwiXCI7Yz1jLnN0b3BzO3ZhciBsLEc9W10sbT1mdW5jdGlvbigpe2c9WydcXHgzY2ZpbGwgY29sb3JzXFx4M2RcIicrRy5qb2luKFwiLFwiKSsnXCIgb3BhY2l0eVxceDNkXCInLHksJ1wiIG86b3BhY2l0eTJcXHgzZFwiJyxELCdcIiB0eXBlXFx4M2RcIicsaywnXCIgJyxCLCdmb2N1c1xceDNkXCIxMDAlXCIgbWV0aG9kXFx4M2RcImFueVwiIC9cXHgzZSddO0YocS5wcmVwVk1MKGcpLG51bGwsbnVsbCxiKX07Zj1jWzBdO2w9Y1tjLmxlbmd0aC0xXTswPGZbMF0mJmMudW5zaGlmdChbMCxmWzFdXSk7MT5sWzBdJiZjLnB1c2goWzEsbFsxXV0pO3UoYyxmdW5jdGlvbihoLGMpe24udGVzdChoWzFdKT8ocD1hLmNvbG9yKGhbMV0pLFxudz1wLmdldChcInJnYlwiKSx2PXAuZ2V0KFwiYVwiKSk6KHc9aFsxXSx2PTEpO0cucHVzaCgxMDAqaFswXStcIiUgXCIrdyk7Yz8oeT12LHg9dyk6KEQ9dixyPXcpfSk7aWYoXCJmaWxsXCI9PT1lKWlmKFwiZ3JhZGllbnRcIj09PWspZT1ILngxfHxIWzBdfHwwLGM9SC55MXx8SFsxXXx8MCxmPUgueDJ8fEhbMl18fDAsSD1ILnkyfHxIWzNdfHwwLEI9J2FuZ2xlXFx4M2RcIicrKDkwLTE4MCpNYXRoLmF0YW4oKEgtYykvKGYtZSkpL01hdGguUEkpKydcIicsbSgpO2Vsc2V7dmFyIGg9SC5yLHQ9MipoLEo9MipoLEE9SC5jeCxDPUguY3ksRT1iLnJhZGlhbFJlZmVyZW5jZSxNLGg9ZnVuY3Rpb24oKXtFJiYoTT1kLmdldEJCb3goKSxBKz0oRVswXS1NLngpL00ud2lkdGgtLjUsQys9KEVbMV0tTS55KS9NLmhlaWdodC0uNSx0Kj1FWzJdL00ud2lkdGgsSio9RVsyXS9NLmhlaWdodCk7Qj0nc3JjXFx4M2RcIicrYS5nZXRPcHRpb25zKCkuZ2xvYmFsLlZNTFJhZGlhbEdyYWRpZW50VVJMKydcIiBzaXplXFx4M2RcIicrdCtcIixcIitcbkorJ1wiIG9yaWdpblxceDNkXCIwLjUsMC41XCIgcG9zaXRpb25cXHgzZFwiJytBK1wiLFwiK0MrJ1wiIGNvbG9yMlxceDNkXCInK3IrJ1wiICc7bSgpfTtkLmFkZGVkP2goKTpkLm9uQWRkPWg7aD14fWVsc2UgaD13fWVsc2Ugbi50ZXN0KGMpJiZcIklNR1wiIT09Yi50YWdOYW1lPyhwPWEuY29sb3IoYyksZFtlK1wiLW9wYWNpdHlTZXR0ZXJcIl0ocC5nZXQoXCJhXCIpLGUsYiksaD1wLmdldChcInJnYlwiKSk6KGg9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZShlKSxoLmxlbmd0aCYmKGhbMF0ub3BhY2l0eT0xLGhbMF0udHlwZT1cInNvbGlkXCIpLGg9Yyk7cmV0dXJuIGh9LHByZXBWTUw6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5pc0lFODthPWEuam9pbihcIlwiKTtjPyhhPWEucmVwbGFjZShcIi9cXHgzZVwiLCcgeG1sbnNcXHgzZFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIiAvXFx4M2UnKSxhPS0xPT09YS5pbmRleE9mKCdzdHlsZVxceDNkXCInKT9hLnJlcGxhY2UoXCIvXFx4M2VcIiwnIHN0eWxlXFx4M2RcImRpc3BsYXk6aW5saW5lLWJsb2NrO2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpO1wiIC9cXHgzZScpOlxuYS5yZXBsYWNlKCdzdHlsZVxceDNkXCInLCdzdHlsZVxceDNkXCJkaXNwbGF5OmlubGluZS1ibG9jaztiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsnKSk6YT1hLnJlcGxhY2UoXCJcXHgzY1wiLFwiXFx4M2NoY3Y6XCIpO3JldHVybiBhfSx0ZXh0OkQucHJvdG90eXBlLmh0bWwscGF0aDpmdW5jdGlvbihhKXt2YXIgYz17Y29vcmRzaXplOlwiMTAgMTBcIn07ZChhKT9jLmQ9YTpiKGEpJiZnKGMsYSk7cmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudChcInNoYXBlXCIpLmF0dHIoYyl9LGNpcmNsZTpmdW5jdGlvbihhLGUsZCl7dmFyIGM9dGhpcy5zeW1ib2woXCJjaXJjbGVcIik7YihhKSYmKGQ9YS5yLGU9YS55LGE9YS54KTtjLmlzQ2lyY2xlPSEwO2Mucj1kO3JldHVybiBjLmF0dHIoe3g6YSx5OmV9KX0sZzpmdW5jdGlvbihhKXt2YXIgYzthJiYoYz17Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1cIithLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYX0pO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuYXR0cihjKX0sXG5pbWFnZTpmdW5jdGlvbihhLGIsZSxkLG4pe3ZhciBjPXRoaXMuY3JlYXRlRWxlbWVudChcImltZ1wiKS5hdHRyKHtzcmM6YX0pOzE8YXJndW1lbnRzLmxlbmd0aCYmYy5hdHRyKHt4OmIseTplLHdpZHRoOmQsaGVpZ2h0Om59KTtyZXR1cm4gY30sY3JlYXRlRWxlbWVudDpmdW5jdGlvbihhKXtyZXR1cm5cInJlY3RcIj09PWE/dGhpcy5zeW1ib2woYSk6RC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsYSl9LGludmVydENoaWxkOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztiPWIuc3R5bGU7dmFyIGU9XCJJTUdcIj09PWEudGFnTmFtZSYmYS5zdHlsZTtFKGEse2ZsaXA6XCJ4XCIsbGVmdDp5KGIud2lkdGgpLShlP3koZS50b3ApOjEpLHRvcDp5KGIuaGVpZ2h0KS0oZT95KGUubGVmdCk6MSkscm90YXRpb246LTkwfSk7dShhLmNoaWxkTm9kZXMsZnVuY3Rpb24oYil7Yy5pbnZlcnRDaGlsZChiLGEpfSl9LHN5bWJvbHM6e2FyYzpmdW5jdGlvbihhLGIsZSxkLG4pe3ZhciBjPW4uc3RhcnQsXG5xPW4uZW5kLGc9bi5yfHxlfHxkO2U9bi5pbm5lclI7ZD1NYXRoLmNvcyhjKTt2YXIgaz1NYXRoLnNpbihjKSxoPU1hdGguY29zKHEpLHc9TWF0aC5zaW4ocSk7aWYoMD09PXEtYylyZXR1cm5bXCJ4XCJdO2M9W1wid2FcIixhLWcsYi1nLGErZyxiK2csYStnKmQsYitnKmssYStnKmgsYitnKnddO24ub3BlbiYmIWUmJmMucHVzaChcImVcIixcIk1cIixhLGIpO2MucHVzaChcImF0XCIsYS1lLGItZSxhK2UsYitlLGErZSpoLGIrZSp3LGErZSpkLGIrZSprLFwieFwiLFwiZVwiKTtjLmlzQXJjPSEwO3JldHVybiBjfSxjaXJjbGU6ZnVuY3Rpb24oYSxiLGUsZCxuKXtuJiZtKG4ucikmJihlPWQ9MipuLnIpO24mJm4uaXNDaXJjbGUmJihhLT1lLzIsYi09ZC8yKTtyZXR1cm5bXCJ3YVwiLGEsYixhK2UsYitkLGErZSxiK2QvMixhK2UsYitkLzIsXCJlXCJdfSxyZWN0OmZ1bmN0aW9uKGEsYixlLGQsbil7cmV0dXJuIEQucHJvdG90eXBlLnN5bWJvbHNbbShuKSYmbi5yP1wiY2FsbG91dFwiOlwic3F1YXJlXCJdLmNhbGwoMCxhLGIsXG5lLGQsbil9fX0sYS5WTUxSZW5kZXJlcj1DPWZ1bmN0aW9uKCl7dGhpcy5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sQy5wcm90b3R5cGU9ZShELnByb3RvdHlwZSxBKSxhLlJlbmRlcmVyPUMpO0QucHJvdG90eXBlLm1lYXN1cmVTcGFuV2lkdGg9ZnVuY3Rpb24oYSxiKXt2YXIgYz1yLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2E9ci5jcmVhdGVUZXh0Tm9kZShhKTtjLmFwcGVuZENoaWxkKGEpO0UoYyxiKTt0aGlzLmJveC5hcHBlbmRDaGlsZChjKTtiPWMub2Zmc2V0V2lkdGg7bChjKTtyZXR1cm4gYn19KShNKTsoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gQygpe3ZhciBmPWEuZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLGw9ci5tb21lbnQ7aWYoZi50aW1lem9uZSl7aWYobClyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuLWwudHooYSxmLnRpbWV6b25lKS51dGNPZmZzZXQoKX07YS5lcnJvcigyNSl9cmV0dXJuIGYudXNlVVRDJiZmLmdldFRpbWV6b25lT2Zmc2V0fWZ1bmN0aW9uIEEoKXt2YXIgZj1cbmEuZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLHQsZz1mLnVzZVVUQyxkPWc/XCJnZXRVVENcIjpcImdldFwiLGs9Zz9cInNldFVUQ1wiOlwic2V0XCI7YS5EYXRlPXQ9Zi5EYXRlfHxyLkRhdGU7dC5oY1RpbWV6b25lT2Zmc2V0PWcmJmYudGltZXpvbmVPZmZzZXQ7dC5oY0dldFRpbWV6b25lT2Zmc2V0PUMoKTt0LmhjTWFrZVRpbWU9ZnVuY3Rpb24oYSxlLGQsayxuLGYpe3ZhciBiO2c/KGI9dC5VVEMuYXBwbHkoMCxhcmd1bWVudHMpLGIrPW0oYikpOmI9KG5ldyB0KGEsZSxsKGQsMSksbChrLDApLGwobiwwKSxsKGYsMCkpKS5nZXRUaW1lKCk7cmV0dXJuIGJ9O0UoXCJNaW51dGVzIEhvdXJzIERheSBEYXRlIE1vbnRoIEZ1bGxZZWFyXCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGEpe3RbXCJoY0dldFwiK2FdPWQrYX0pO0UoXCJNaWxsaXNlY29uZHMgU2Vjb25kcyBNaW51dGVzIEhvdXJzIERhdGUgTW9udGggRnVsbFllYXJcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oYSl7dFtcImhjU2V0XCIrYV09aythfSl9dmFyIEY9YS5jb2xvcixcbkU9YS5lYWNoLG09YS5nZXRUWk9mZnNldCxmPWEubWVyZ2UsbD1hLnBpY2sscj1hLndpbjthLmRlZmF1bHRPcHRpb25zPXtjb2xvcnM6XCIjN2NiNWVjICM0MzQzNDggIzkwZWQ3ZCAjZjdhMzVjICM4MDg1ZTkgI2YxNWM4MCAjZTRkMzU0ICMyYjkwOGYgI2Y0NWI1YiAjOTFlOGUxXCIuc3BsaXQoXCIgXCIpLHN5bWJvbHM6W1wiY2lyY2xlXCIsXCJkaWFtb25kXCIsXCJzcXVhcmVcIixcInRyaWFuZ2xlXCIsXCJ0cmlhbmdsZS1kb3duXCJdLGxhbmc6e2xvYWRpbmc6XCJMb2FkaW5nLi4uXCIsbW9udGhzOlwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpLHdlZWtkYXlzOlwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksXG5kZWNpbWFsUG9pbnQ6XCIuXCIsbnVtZXJpY1N5bWJvbHM6XCJrTUdUUEVcIi5zcGxpdChcIlwiKSxyZXNldFpvb206XCJSZXNldCB6b29tXCIscmVzZXRab29tVGl0bGU6XCJSZXNldCB6b29tIGxldmVsIDE6MVwiLHRob3VzYW5kc1NlcDpcIiBcIn0sZ2xvYmFsOnt1c2VVVEM6ITAsVk1MUmFkaWFsR3JhZGllbnRVUkw6XCJodHRwOi8vY29kZS5oaWdoY2hhcnRzLmNvbS81LjAuMTQvZ2Z4L3ZtbC1yYWRpYWwtZ3JhZGllbnQucG5nXCJ9LGNoYXJ0Ontib3JkZXJSYWRpdXM6MCxkZWZhdWx0U2VyaWVzVHlwZTpcImxpbmVcIixpZ25vcmVIaWRkZW5TZXJpZXM6ITAsc3BhY2luZzpbMTAsMTAsMTUsMTBdLHJlc2V0Wm9vbUJ1dHRvbjp7dGhlbWU6e3pJbmRleDoyMH0scG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx5OjEwfX0sd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbCxib3JkZXJDb2xvcjpcIiMzMzVjYWRcIixiYWNrZ3JvdW5kQ29sb3I6XCIjZmZmZmZmXCIscGxvdEJvcmRlckNvbG9yOlwiI2NjY2NjY1wifSx0aXRsZTp7dGV4dDpcIkNoYXJ0IHRpdGxlXCIsXG5hbGlnbjpcImNlbnRlclwiLG1hcmdpbjoxNSx3aWR0aEFkanVzdDotNDR9LHN1YnRpdGxlOnt0ZXh0OlwiXCIsYWxpZ246XCJjZW50ZXJcIix3aWR0aEFkanVzdDotNDR9LHBsb3RPcHRpb25zOnt9LGxhYmVsczp7c3R5bGU6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixjb2xvcjpcIiMzMzMzMzNcIn19LGxlZ2VuZDp7ZW5hYmxlZDohMCxhbGlnbjpcImNlbnRlclwiLGxheW91dDpcImhvcml6b250YWxcIixsYWJlbEZvcm1hdHRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9LGJvcmRlckNvbG9yOlwiIzk5OTk5OVwiLGJvcmRlclJhZGl1czowLG5hdmlnYXRpb246e2FjdGl2ZUNvbG9yOlwiIzAwMzM5OVwiLGluYWN0aXZlQ29sb3I6XCIjY2NjY2NjXCJ9LGl0ZW1TdHlsZTp7Y29sb3I6XCIjMzMzMzMzXCIsZm9udFNpemU6XCIxMnB4XCIsZm9udFdlaWdodDpcImJvbGRcIix0ZXh0T3ZlcmZsb3c6XCJlbGxpcHNpc1wifSxpdGVtSG92ZXJTdHlsZTp7Y29sb3I6XCIjMDAwMDAwXCJ9LGl0ZW1IaWRkZW5TdHlsZTp7Y29sb3I6XCIjY2NjY2NjXCJ9LFxuc2hhZG93OiExLGl0ZW1DaGVja2JveFN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxM3B4XCIsaGVpZ2h0OlwiMTNweFwifSxzcXVhcmVTeW1ib2w6ITAsc3ltYm9sUGFkZGluZzo1LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowLHRpdGxlOntzdHlsZTp7Zm9udFdlaWdodDpcImJvbGRcIn19fSxsb2FkaW5nOntsYWJlbFN0eWxlOntmb250V2VpZ2h0OlwiYm9sZFwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIix0b3A6XCI0NSVcIn0sc3R5bGU6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixiYWNrZ3JvdW5kQ29sb3I6XCIjZmZmZmZmXCIsb3BhY2l0eTouNSx0ZXh0QWxpZ246XCJjZW50ZXJcIn19LHRvb2x0aXA6e2VuYWJsZWQ6ITAsYW5pbWF0aW9uOmEuc3ZnLGJvcmRlclJhZGl1czozLGRhdGVUaW1lTGFiZWxGb3JtYXRzOnttaWxsaXNlY29uZDpcIiVBLCAlYiAlZSwgJUg6JU06JVMuJUxcIixzZWNvbmQ6XCIlQSwgJWIgJWUsICVIOiVNOiVTXCIsbWludXRlOlwiJUEsICViICVlLCAlSDolTVwiLGhvdXI6XCIlQSwgJWIgJWUsICVIOiVNXCIsXG5kYXk6XCIlQSwgJWIgJWUsICVZXCIsd2VlazpcIldlZWsgZnJvbSAlQSwgJWIgJWUsICVZXCIsbW9udGg6XCIlQiAlWVwiLHllYXI6XCIlWVwifSxmb290ZXJGb3JtYXQ6XCJcIixwYWRkaW5nOjgsc25hcDphLmlzVG91Y2hEZXZpY2U/MjU6MTAsYmFja2dyb3VuZENvbG9yOkYoXCIjZjdmN2Y3XCIpLnNldE9wYWNpdHkoLjg1KS5nZXQoKSxib3JkZXJXaWR0aDoxLGhlYWRlckZvcm1hdDonXFx4M2NzcGFuIHN0eWxlXFx4M2RcImZvbnQtc2l6ZTogMTBweFwiXFx4M2V7cG9pbnQua2V5fVxceDNjL3NwYW5cXHgzZVxceDNjYnIvXFx4M2UnLHBvaW50Rm9ybWF0OidcXHgzY3NwYW4gc3R5bGVcXHgzZFwiY29sb3I6e3BvaW50LmNvbG9yfVwiXFx4M2VcXHUyNWNmXFx4M2Mvc3BhblxceDNlIHtzZXJpZXMubmFtZX06IFxceDNjYlxceDNle3BvaW50Lnl9XFx4M2MvYlxceDNlXFx4M2Nici9cXHgzZScsc2hhZG93OiEwLHN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMnB4XCIscG9pbnRlckV2ZW50czpcIm5vbmVcIixcbndoaXRlU3BhY2U6XCJub3dyYXBcIn19LGNyZWRpdHM6e2VuYWJsZWQ6ITAsaHJlZjpcImh0dHA6Ly93d3cuaGlnaGNoYXJ0cy5jb21cIixwb3NpdGlvbjp7YWxpZ246XCJyaWdodFwiLHg6LTEwLHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix5Oi01fSxzdHlsZTp7Y3Vyc29yOlwicG9pbnRlclwiLGNvbG9yOlwiIzk5OTk5OVwiLGZvbnRTaXplOlwiOXB4XCJ9LHRleHQ6XCJIaWdoY2hhcnRzLmNvbVwifX07YS5zZXRPcHRpb25zPWZ1bmN0aW9uKHIpe2EuZGVmYXVsdE9wdGlvbnM9ZighMCxhLmRlZmF1bHRPcHRpb25zLHIpO0EoKTtyZXR1cm4gYS5kZWZhdWx0T3B0aW9uc307YS5nZXRPcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdE9wdGlvbnN9O2EuZGVmYXVsdFBsb3RPcHRpb25zPWEuZGVmYXVsdE9wdGlvbnMucGxvdE9wdGlvbnM7QSgpfSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDPWEuY29ycmVjdEZsb2F0LEE9YS5kZWZpbmVkLEY9YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxFPWEuaXNOdW1iZXIsXG5tPWEubWVyZ2UsZj1hLnBpY2ssbD1hLmRlZzJyYWQ7YS5UaWNrPWZ1bmN0aW9uKGEsZixsLGcpe3RoaXMuYXhpcz1hO3RoaXMucG9zPWY7dGhpcy50eXBlPWx8fFwiXCI7dGhpcy5pc05ld0xhYmVsPXRoaXMuaXNOZXc9ITA7bHx8Z3x8dGhpcy5hZGRMYWJlbCgpfTthLlRpY2sucHJvdG90eXBlPXthZGRMYWJlbDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuYXhpcyxsPWEub3B0aW9ucyx0PWEuY2hhcnQsZz1hLmNhdGVnb3JpZXMsZD1hLm5hbWVzLGs9dGhpcy5wb3MsYj1sLmxhYmVscyxlPWEudGlja1Bvc2l0aW9ucyx2PWs9PT1lWzBdLHk9az09PWVbZS5sZW5ndGgtMV0sZD1nP2YoZ1trXSxkW2tdLGspOmssZz10aGlzLmxhYmVsLGU9ZS5pbmZvLG47YS5pc0RhdGV0aW1lQXhpcyYmZSYmKG49bC5kYXRlVGltZUxhYmVsRm9ybWF0c1tlLmhpZ2hlclJhbmtzW2tdfHxlLnVuaXROYW1lXSk7dGhpcy5pc0ZpcnN0PXY7dGhpcy5pc0xhc3Q9eTtsPWEubGFiZWxGb3JtYXR0ZXIuY2FsbCh7YXhpczphLFxuY2hhcnQ6dCxpc0ZpcnN0OnYsaXNMYXN0OnksZGF0ZVRpbWVMYWJlbEZvcm1hdDpuLHZhbHVlOmEuaXNMb2c/QyhhLmxpbjJsb2coZCkpOmQscG9zOmt9KTtBKGcpP2cmJmcuYXR0cih7dGV4dDpsfSk6KHRoaXMubGFiZWxMZW5ndGg9KHRoaXMubGFiZWw9Zz1BKGwpJiZiLmVuYWJsZWQ/dC5yZW5kZXJlci50ZXh0KGwsMCwwLGIudXNlSFRNTCkuY3NzKG0oYi5zdHlsZSkpLmFkZChhLmxhYmVsR3JvdXApOm51bGwpJiZnLmdldEJCb3goKS53aWR0aCx0aGlzLnJvdGF0aW9uPTApfSxnZXRMYWJlbFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbD90aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXo/XCJoZWlnaHRcIjpcIndpZHRoXCJdOjB9LGhhbmRsZU92ZXJmbG93OmZ1bmN0aW9uKGEpe3ZhciByPXRoaXMuYXhpcyxtPWEueCxnPXIuY2hhcnQuY2hhcnRXaWR0aCxkPXIuY2hhcnQuc3BhY2luZyxrPWYoci5sYWJlbExlZnQsTWF0aC5taW4oci5wb3MsZFszXSkpLGQ9ZihyLmxhYmVsUmlnaHQsXG5NYXRoLm1heChyLnBvcytyLmxlbixnLWRbMV0pKSxiPXRoaXMubGFiZWwsZT10aGlzLnJvdGF0aW9uLHY9e2xlZnQ6MCxjZW50ZXI6LjUscmlnaHQ6MX1bci5sYWJlbEFsaWduXSx5PWIuZ2V0QkJveCgpLndpZHRoLG49ci5nZXRTbG90V2lkdGgoKSxEPW4sSj0xLGMsRz17fTtpZihlKTA+ZSYmbS12Knk8az9jPU1hdGgucm91bmQobS9NYXRoLmNvcyhlKmwpLWspOjA8ZSYmbSt2Knk+ZCYmKGM9TWF0aC5yb3VuZCgoZy1tKS9NYXRoLmNvcyhlKmwpKSk7ZWxzZSBpZihnPW0rKDEtdikqeSxtLXYqeTxrP0Q9YS54K0QqKDEtdiktazpnPmQmJihEPWQtYS54K0QqdixKPS0xKSxEPU1hdGgubWluKG4sRCksRDxuJiZcImNlbnRlclwiPT09ci5sYWJlbEFsaWduJiYoYS54Kz1KKihuLUQtdioobi1NYXRoLm1pbih5LEQpKSkpLHk+RHx8ci5hdXRvUm90YXRpb24mJihiLnN0eWxlc3x8e30pLndpZHRoKWM9RDtjJiYoRy53aWR0aD1jLChyLm9wdGlvbnMubGFiZWxzLnN0eWxlfHx7fSkudGV4dE92ZXJmbG93fHxcbihHLnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIpLGIuY3NzKEcpKX0sZ2V0UG9zaXRpb246ZnVuY3Rpb24oYSxmLGwsZyl7dmFyIGQ9dGhpcy5heGlzLGs9ZC5jaGFydCxiPWcmJmsub2xkQ2hhcnRIZWlnaHR8fGsuY2hhcnRIZWlnaHQ7cmV0dXJue3g6YT9kLnRyYW5zbGF0ZShmK2wsbnVsbCxudWxsLGcpK2QudHJhbnNCOmQubGVmdCtkLm9mZnNldCsoZC5vcHBvc2l0ZT8oZyYmay5vbGRDaGFydFdpZHRofHxrLmNoYXJ0V2lkdGgpLWQucmlnaHQtZC5sZWZ0OjApLHk6YT9iLWQuYm90dG9tK2Qub2Zmc2V0LShkLm9wcG9zaXRlP2QuaGVpZ2h0OjApOmItZC50cmFuc2xhdGUoZitsLG51bGwsbnVsbCxnKS1kLnRyYW5zQn19LGdldExhYmVsUG9zaXRpb246ZnVuY3Rpb24oYSxmLG0sZyxkLGssYixlKXt2YXIgdj10aGlzLmF4aXMseT12LnRyYW5zQSxuPXYucmV2ZXJzZWQsRD12LnN0YWdnZXJMaW5lcyxyPXYudGlja1JvdENvcnJ8fHt4OjAseTowfSxjPWQueTtBKGMpfHwoYz0wPT09di5zaWRlP1xubS5yb3RhdGlvbj8tODotbS5nZXRCQm94KCkuaGVpZ2h0OjI9PT12LnNpZGU/ci55Kzg6TWF0aC5jb3MobS5yb3RhdGlvbipsKSooci55LW0uZ2V0QkJveCghMSwwKS5oZWlnaHQvMikpO2E9YStkLngrci54LShrJiZnP2sqeSoobj8tMToxKTowKTtmPWYrYy0oayYmIWc/ayp5KihuPzE6LTEpOjApO0QmJihtPWIvKGV8fDEpJUQsdi5vcHBvc2l0ZSYmKG09RC1tLTEpLGYrPXYubGFiZWxPZmZzZXQvRCptKTtyZXR1cm57eDphLHk6TWF0aC5yb3VuZChmKX19LGdldE1hcmtQYXRoOmZ1bmN0aW9uKGEsZixsLGcsZCxrKXtyZXR1cm4gay5jcmlzcExpbmUoW1wiTVwiLGEsZixcIkxcIixhKyhkPzA6LWwpLGYrKGQ/bDowKV0sZyl9LHJlbmRlckdyaWRMaW5lOmZ1bmN0aW9uKGEsZixsKXt2YXIgZz10aGlzLmF4aXMsZD1nLm9wdGlvbnMsaz10aGlzLmdyaWRMaW5lLGI9e30sZT10aGlzLnBvcyx2PXRoaXMudHlwZSx5PWcudGlja21hcmtPZmZzZXQsbj1nLmNoYXJ0LnJlbmRlcmVyLEQ9dj92K1wiR3JpZFwiOlxuXCJncmlkXCIscj1kW0QrXCJMaW5lV2lkdGhcIl0sYz1kW0QrXCJMaW5lQ29sb3JcIl0sZD1kW0QrXCJMaW5lRGFzaFN0eWxlXCJdO2t8fChiLnN0cm9rZT1jLGJbXCJzdHJva2Utd2lkdGhcIl09cixkJiYoYi5kYXNoc3R5bGU9ZCksdnx8KGIuekluZGV4PTEpLGEmJihiLm9wYWNpdHk9MCksdGhpcy5ncmlkTGluZT1rPW4ucGF0aCgpLmF0dHIoYikuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiKyh2P3YrXCItXCI6XCJcIikrXCJncmlkLWxpbmVcIikuYWRkKGcuZ3JpZEdyb3VwKSk7aWYoIWEmJmsmJihhPWcuZ2V0UGxvdExpbmVQYXRoKGUreSxrLnN0cm9rZVdpZHRoKCkqbCxhLCEwKSkpa1t0aGlzLmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDphLG9wYWNpdHk6Zn0pfSxyZW5kZXJNYXJrOmZ1bmN0aW9uKGEsbCxtKXt2YXIgZz10aGlzLmF4aXMsZD1nLm9wdGlvbnMsaz1nLmNoYXJ0LnJlbmRlcmVyLGI9dGhpcy50eXBlLGU9Yj9iK1wiVGlja1wiOlwidGlja1wiLHY9Zy50aWNrU2l6ZShlKSx5PXRoaXMubWFyayxuPSF5LFxuRD1hLng7YT1hLnk7dmFyIHI9ZihkW2UrXCJXaWR0aFwiXSwhYiYmZy5pc1hBeGlzPzE6MCksZD1kW2UrXCJDb2xvclwiXTt2JiYoZy5vcHBvc2l0ZSYmKHZbMF09LXZbMF0pLG4mJih0aGlzLm1hcms9eT1rLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrKGI/YitcIi1cIjpcIlwiKStcInRpY2tcIikuYWRkKGcuYXhpc0dyb3VwKSx5LmF0dHIoe3N0cm9rZTpkLFwic3Ryb2tlLXdpZHRoXCI6cn0pKSx5W24/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHtkOnRoaXMuZ2V0TWFya1BhdGgoRCxhLHZbMF0seS5zdHJva2VXaWR0aCgpKm0sZy5ob3JpeixrKSxvcGFjaXR5Omx9KSl9LHJlbmRlckxhYmVsOmZ1bmN0aW9uKGEsbCxtLGcpe3ZhciBkPXRoaXMuYXhpcyxrPWQuaG9yaXosYj1kLm9wdGlvbnMsZT10aGlzLmxhYmVsLHY9Yi5sYWJlbHMseT12LnN0ZXAsbj1kLnRpY2ttYXJrT2Zmc2V0LEQ9ITAscj1hLng7YT1hLnk7ZSYmRShyKSYmKGUueHk9YT10aGlzLmdldExhYmVsUG9zaXRpb24ocixhLGUsayx2LG4sXG5nLHkpLHRoaXMuaXNGaXJzdCYmIXRoaXMuaXNMYXN0JiYhZihiLnNob3dGaXJzdExhYmVsLDEpfHx0aGlzLmlzTGFzdCYmIXRoaXMuaXNGaXJzdCYmIWYoYi5zaG93TGFzdExhYmVsLDEpP0Q9ITE6IWt8fGQuaXNSYWRpYWx8fHYuc3RlcHx8di5yb3RhdGlvbnx8bHx8MD09PW18fHRoaXMuaGFuZGxlT3ZlcmZsb3coYSkseSYmZyV5JiYoRD0hMSksRCYmRShhLnkpPyhhLm9wYWNpdHk9bSxlW3RoaXMuaXNOZXdMYWJlbD9cImF0dHJcIjpcImFuaW1hdGVcIl0oYSksdGhpcy5pc05ld0xhYmVsPSExKTooZS5hdHRyKFwieVwiLC05OTk5KSx0aGlzLmlzTmV3TGFiZWw9ITApLHRoaXMuaXNOZXc9ITEpfSxyZW5kZXI6ZnVuY3Rpb24oYSxsLG0pe3ZhciBnPXRoaXMuYXhpcyxkPWcuaG9yaXosaz10aGlzLmdldFBvc2l0aW9uKGQsdGhpcy5wb3MsZy50aWNrbWFya09mZnNldCxsKSxiPWsueCxlPWsueSxnPWQmJmI9PT1nLnBvcytnLmxlbnx8IWQmJmU9PT1nLnBvcz8tMToxO209ZihtLDEpO3RoaXMuaXNBY3RpdmU9XG4hMDt0aGlzLnJlbmRlckdyaWRMaW5lKGwsbSxnKTt0aGlzLnJlbmRlck1hcmsoayxtLGcpO3RoaXMucmVuZGVyTGFiZWwoayxsLG0sYSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtGKHRoaXMsdGhpcy5heGlzKX19fSkoTSk7dmFyIFM9ZnVuY3Rpb24oYSl7dmFyIEM9YS5hZGRFdmVudCxBPWEuYW5pbU9iamVjdCxGPWEuYXJyYXlNYXgsRT1hLmFycmF5TWluLG09YS5jb2xvcixmPWEuY29ycmVjdEZsb2F0LGw9YS5kZWZhdWx0T3B0aW9ucyxyPWEuZGVmaW5lZCx1PWEuZGVnMnJhZCx0PWEuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsZz1hLmVhY2gsZD1hLmV4dGVuZCxrPWEuZmlyZUV2ZW50LGI9YS5mb3JtYXQsZT1hLmdldE1hZ25pdHVkZSx2PWEuZ3JlcCx5PWEuaW5BcnJheSxuPWEuaXNBcnJheSxEPWEuaXNOdW1iZXIsSj1hLmlzU3RyaW5nLGM9YS5tZXJnZSxHPWEubm9ybWFsaXplVGlja0ludGVydmFsLHE9YS5vYmplY3RFYWNoLEI9YS5waWNrLEs9YS5yZW1vdmVFdmVudCxwPWEuc3BsYXQsXG56PWEuc3luY1RpbWVvdXQsST1hLlRpY2ssTD1mdW5jdGlvbigpe3RoaXMuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2EuZXh0ZW5kKEwucHJvdG90eXBlLHtkZWZhdWx0T3B0aW9uczp7ZGF0ZVRpbWVMYWJlbEZvcm1hdHM6e21pbGxpc2Vjb25kOlwiJUg6JU06JVMuJUxcIixzZWNvbmQ6XCIlSDolTTolU1wiLG1pbnV0ZTpcIiVIOiVNXCIsaG91cjpcIiVIOiVNXCIsZGF5OlwiJWUuICViXCIsd2VlazpcIiVlLiAlYlwiLG1vbnRoOlwiJWIgJyV5XCIseWVhcjpcIiVZXCJ9LGVuZE9uVGljazohMSxsYWJlbHM6e2VuYWJsZWQ6ITAsc3R5bGU6e2NvbG9yOlwiIzY2NjY2NlwiLGN1cnNvcjpcImRlZmF1bHRcIixmb250U2l6ZTpcIjExcHhcIn0seDowfSxtaW5QYWRkaW5nOi4wMSxtYXhQYWRkaW5nOi4wMSxtaW5vclRpY2tMZW5ndGg6MixtaW5vclRpY2tQb3NpdGlvbjpcIm91dHNpZGVcIixzdGFydE9mV2VlazoxLHN0YXJ0T25UaWNrOiExLHRpY2tMZW5ndGg6MTAsdGlja21hcmtQbGFjZW1lbnQ6XCJiZXR3ZWVuXCIsdGlja1BpeGVsSW50ZXJ2YWw6MTAwLFxudGlja1Bvc2l0aW9uOlwib3V0c2lkZVwiLHRpdGxlOnthbGlnbjpcIm1pZGRsZVwiLHN0eWxlOntjb2xvcjpcIiM2NjY2NjZcIn19LHR5cGU6XCJsaW5lYXJcIixtaW5vckdyaWRMaW5lQ29sb3I6XCIjZjJmMmYyXCIsbWlub3JHcmlkTGluZVdpZHRoOjEsbWlub3JUaWNrQ29sb3I6XCIjOTk5OTk5XCIsbGluZUNvbG9yOlwiI2NjZDZlYlwiLGxpbmVXaWR0aDoxLGdyaWRMaW5lQ29sb3I6XCIjZTZlNmU2XCIsdGlja0NvbG9yOlwiI2NjZDZlYlwifSxkZWZhdWx0WUF4aXNPcHRpb25zOntlbmRPblRpY2s6ITAsdGlja1BpeGVsSW50ZXJ2YWw6NzIsc2hvd0xhc3RMYWJlbDohMCxsYWJlbHM6e3g6LTh9LG1heFBhZGRpbmc6LjA1LG1pblBhZGRpbmc6LjA1LHN0YXJ0T25UaWNrOiEwLHRpdGxlOntyb3RhdGlvbjoyNzAsdGV4dDpcIlZhbHVlc1wifSxzdGFja0xhYmVsczp7YWxsb3dPdmVybGFwOiExLGVuYWJsZWQ6ITEsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGEubnVtYmVyRm9ybWF0KHRoaXMudG90YWwsLTEpfSxcbnN0eWxlOntmb250U2l6ZTpcIjExcHhcIixmb250V2VpZ2h0OlwiYm9sZFwiLGNvbG9yOlwiIzAwMDAwMFwiLHRleHRPdXRsaW5lOlwiMXB4IGNvbnRyYXN0XCJ9fSxncmlkTGluZVdpZHRoOjEsbGluZVdpZHRoOjB9LGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6e2xhYmVsczp7eDotMTV9LHRpdGxlOntyb3RhdGlvbjoyNzB9fSxkZWZhdWx0UmlnaHRBeGlzT3B0aW9uczp7bGFiZWxzOnt4OjE1fSx0aXRsZTp7cm90YXRpb246OTB9fSxkZWZhdWx0Qm90dG9tQXhpc09wdGlvbnM6e2xhYmVsczp7YXV0b1JvdGF0aW9uOlstNDVdLHg6MH0sdGl0bGU6e3JvdGF0aW9uOjB9fSxkZWZhdWx0VG9wQXhpc09wdGlvbnM6e2xhYmVsczp7YXV0b1JvdGF0aW9uOlstNDVdLHg6MH0sdGl0bGU6e3JvdGF0aW9uOjB9fSxpbml0OmZ1bmN0aW9uKGEsYyl7dmFyIGg9Yy5pc1gsYj10aGlzO2IuY2hhcnQ9YTtiLmhvcml6PWEuaW52ZXJ0ZWQmJiFiLmlzWkF4aXM/IWg6aDtiLmlzWEF4aXM9aDtiLmNvbGw9Yi5jb2xsfHwoaD9cblwieEF4aXNcIjpcInlBeGlzXCIpO2Iub3Bwb3NpdGU9Yy5vcHBvc2l0ZTtiLnNpZGU9Yy5zaWRlfHwoYi5ob3Jpej9iLm9wcG9zaXRlPzA6MjpiLm9wcG9zaXRlPzE6Myk7Yi5zZXRPcHRpb25zKGMpO3ZhciB3PXRoaXMub3B0aW9ucyxlPXcudHlwZTtiLmxhYmVsRm9ybWF0dGVyPXcubGFiZWxzLmZvcm1hdHRlcnx8Yi5kZWZhdWx0TGFiZWxGb3JtYXR0ZXI7Yi51c2VyT3B0aW9ucz1jO2IubWluUGl4ZWxQYWRkaW5nPTA7Yi5yZXZlcnNlZD13LnJldmVyc2VkO2IudmlzaWJsZT0hMSE9PXcudmlzaWJsZTtiLnpvb21FbmFibGVkPSExIT09dy56b29tRW5hYmxlZDtiLmhhc05hbWVzPVwiY2F0ZWdvcnlcIj09PWV8fCEwPT09dy5jYXRlZ29yaWVzO2IuY2F0ZWdvcmllcz13LmNhdGVnb3JpZXN8fGIuaGFzTmFtZXM7Yi5uYW1lcz1iLm5hbWVzfHxbXTtiLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzPXt9O2IuaXNMb2c9XCJsb2dhcml0aG1pY1wiPT09ZTtiLmlzRGF0ZXRpbWVBeGlzPVwiZGF0ZXRpbWVcIj09PVxuZTtiLnBvc2l0aXZlVmFsdWVzT25seT1iLmlzTG9nJiYhYi5hbGxvd05lZ2F0aXZlTG9nO2IuaXNMaW5rZWQ9cih3LmxpbmtlZFRvKTtiLnRpY2tzPXt9O2IubGFiZWxFZGdlPVtdO2IubWlub3JUaWNrcz17fTtiLnBsb3RMaW5lc0FuZEJhbmRzPVtdO2IuYWx0ZXJuYXRlQmFuZHM9e307Yi5sZW49MDtiLm1pblJhbmdlPWIudXNlck1pblJhbmdlPXcubWluUmFuZ2V8fHcubWF4Wm9vbTtiLnJhbmdlPXcucmFuZ2U7Yi5vZmZzZXQ9dy5vZmZzZXR8fDA7Yi5zdGFja3M9e307Yi5vbGRTdGFja3M9e307Yi5zdGFja3NUb3VjaGVkPTA7Yi5tYXg9bnVsbDtiLm1pbj1udWxsO2IuY3Jvc3NoYWlyPUIody5jcm9zc2hhaXIscChhLm9wdGlvbnMudG9vbHRpcC5jcm9zc2hhaXJzKVtoPzA6MV0sITEpO2M9Yi5vcHRpb25zLmV2ZW50czstMT09PXkoYixhLmF4ZXMpJiYoaD9hLmF4ZXMuc3BsaWNlKGEueEF4aXMubGVuZ3RoLDAsYik6YS5heGVzLnB1c2goYiksYVtiLmNvbGxdLnB1c2goYikpO2Iuc2VyaWVzPVxuYi5zZXJpZXN8fFtdO2EuaW52ZXJ0ZWQmJiFiLmlzWkF4aXMmJmgmJnZvaWQgMD09PWIucmV2ZXJzZWQmJihiLnJldmVyc2VkPSEwKTtxKGMsZnVuY3Rpb24oYSxoKXtDKGIsaCxhKX0pO2IubGluMmxvZz13LmxpbmVhclRvTG9nQ29udmVydGVyfHxiLmxpbjJsb2c7Yi5pc0xvZyYmKGIudmFsMmxpbj1iLmxvZzJsaW4sYi5saW4ydmFsPWIubGluMmxvZyl9LHNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dGhpcy5vcHRpb25zPWModGhpcy5kZWZhdWx0T3B0aW9ucyxcInlBeGlzXCI9PT10aGlzLmNvbGwmJnRoaXMuZGVmYXVsdFlBeGlzT3B0aW9ucyxbdGhpcy5kZWZhdWx0VG9wQXhpc09wdGlvbnMsdGhpcy5kZWZhdWx0UmlnaHRBeGlzT3B0aW9ucyx0aGlzLmRlZmF1bHRCb3R0b21BeGlzT3B0aW9ucyx0aGlzLmRlZmF1bHRMZWZ0QXhpc09wdGlvbnNdW3RoaXMuc2lkZV0sYyhsW3RoaXMuY29sbF0sYSkpfSxkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6ZnVuY3Rpb24oKXt2YXIgaD10aGlzLmF4aXMsXG5jPXRoaXMudmFsdWUsZT1oLmNhdGVnb3JpZXMscD10aGlzLmRhdGVUaW1lTGFiZWxGb3JtYXQsZD1sLmxhbmcsbj1kLm51bWVyaWNTeW1ib2xzLGQ9ZC5udW1lcmljU3ltYm9sTWFnbml0dWRlfHwxRTMscT1uJiZuLmxlbmd0aCx4LGc9aC5vcHRpb25zLmxhYmVscy5mb3JtYXQsaD1oLmlzTG9nP01hdGguYWJzKGMpOmgudGlja0ludGVydmFsO2lmKGcpeD1iKGcsdGhpcyk7ZWxzZSBpZihlKXg9YztlbHNlIGlmKHApeD1hLmRhdGVGb3JtYXQocCxjKTtlbHNlIGlmKHEmJjFFMzw9aClmb3IoO3EtLSYmdm9pZCAwPT09eDspZT1NYXRoLnBvdyhkLHErMSksaD49ZSYmMD09PTEwKmMlZSYmbnVsbCE9PW5bcV0mJjAhPT1jJiYoeD1hLm51bWJlckZvcm1hdChjL2UsLTEpK25bcV0pO3ZvaWQgMD09PXgmJih4PTFFNDw9TWF0aC5hYnMoYyk/YS5udW1iZXJGb3JtYXQoYywtMSk6YS5udW1iZXJGb3JtYXQoYywtMSx2b2lkIDAsXCJcIikpO3JldHVybiB4fSxnZXRTZXJpZXNFeHRyZW1lczpmdW5jdGlvbigpe3ZhciBhPVxudGhpcyxiPWEuY2hhcnQ7YS5oYXNWaXNpYmxlU2VyaWVzPSExO2EuZGF0YU1pbj1hLmRhdGFNYXg9YS50aHJlc2hvbGQ9bnVsbDthLnNvZnRUaHJlc2hvbGQ9IWEuaXNYQXhpczthLmJ1aWxkU3RhY2tzJiZhLmJ1aWxkU3RhY2tzKCk7ZyhhLnNlcmllcyxmdW5jdGlvbihoKXtpZihoLnZpc2libGV8fCFiLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKXt2YXIgYz1oLm9wdGlvbnMsdz1jLnRocmVzaG9sZCxlO2EuaGFzVmlzaWJsZVNlcmllcz0hMDthLnBvc2l0aXZlVmFsdWVzT25seSYmMD49dyYmKHc9bnVsbCk7aWYoYS5pc1hBeGlzKWM9aC54RGF0YSxjLmxlbmd0aCYmKGg9RShjKSxEKGgpfHxoIGluc3RhbmNlb2YgRGF0ZXx8KGM9dihjLGZ1bmN0aW9uKGEpe3JldHVybiBEKGEpfSksaD1FKGMpKSxhLmRhdGFNaW49TWF0aC5taW4oQihhLmRhdGFNaW4sY1swXSksaCksYS5kYXRhTWF4PU1hdGgubWF4KEIoYS5kYXRhTWF4LGNbMF0pLEYoYykpKTtlbHNlIGlmKGguZ2V0RXh0cmVtZXMoKSxcbmU9aC5kYXRhTWF4LGg9aC5kYXRhTWluLHIoaCkmJnIoZSkmJihhLmRhdGFNaW49TWF0aC5taW4oQihhLmRhdGFNaW4saCksaCksYS5kYXRhTWF4PU1hdGgubWF4KEIoYS5kYXRhTWF4LGUpLGUpKSxyKHcpJiYoYS50aHJlc2hvbGQ9dyksIWMuc29mdFRocmVzaG9sZHx8YS5wb3NpdGl2ZVZhbHVlc09ubHkpYS5zb2Z0VGhyZXNob2xkPSExfX0pfSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSxiLGMsZSxwLGQpe3ZhciBoPXRoaXMubGlua2VkUGFyZW50fHx0aGlzLHc9MSxuPTAscT1lP2gub2xkVHJhbnNBOmgudHJhbnNBO2U9ZT9oLm9sZE1pbjpoLm1pbjt2YXIgZz1oLm1pblBpeGVsUGFkZGluZztwPShoLmlzT3JkaW5hbHx8aC5pc0Jyb2tlbnx8aC5pc0xvZyYmcCkmJmgubGluMnZhbDtxfHwocT1oLnRyYW5zQSk7YyYmKHcqPS0xLG49aC5sZW4pO2gucmV2ZXJzZWQmJih3Kj0tMSxuLT13KihoLnNlY3Rvcnx8aC5sZW4pKTtiPyhhPShhKncrbi1nKS9xK2UscCYmKGE9aC5saW4ydmFsKGEpKSk6XG4ocCYmKGE9aC52YWwybGluKGEpKSxhPXcqKGEtZSkqcStuK3cqZysoRChkKT9xKmQ6MCkpO3JldHVybiBhfSx0b1BpeGVsczpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnRyYW5zbGF0ZShhLCExLCF0aGlzLmhvcml6LG51bGwsITApKyhiPzA6dGhpcy5wb3MpfSx0b1ZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEtKGI/MDp0aGlzLnBvcyksITAsIXRoaXMuaG9yaXosbnVsbCwhMCl9LGdldFBsb3RMaW5lUGF0aDpmdW5jdGlvbihhLGIsYyxlLHApe3ZhciBoPXRoaXMuY2hhcnQsdz10aGlzLmxlZnQsZD10aGlzLnRvcCxuLHEsZz1jJiZoLm9sZENoYXJ0SGVpZ2h0fHxoLmNoYXJ0SGVpZ2h0LGs9YyYmaC5vbGRDaGFydFdpZHRofHxoLmNoYXJ0V2lkdGgsZjtuPXRoaXMudHJhbnNCO3ZhciB2PWZ1bmN0aW9uKGEsaCxiKXtpZihhPGh8fGE+YillP2E9TWF0aC5taW4oTWF0aC5tYXgoaCxhKSxiKTpmPSEwO3JldHVybiBhfTtwPUIocCx0aGlzLnRyYW5zbGF0ZShhLFxubnVsbCxudWxsLGMpKTthPWM9TWF0aC5yb3VuZChwK24pO249cT1NYXRoLnJvdW5kKGctcC1uKTtEKHApP3RoaXMuaG9yaXo/KG49ZCxxPWctdGhpcy5ib3R0b20sYT1jPXYoYSx3LHcrdGhpcy53aWR0aCkpOihhPXcsYz1rLXRoaXMucmlnaHQsbj1xPXYobixkLGQrdGhpcy5oZWlnaHQpKTpmPSEwO3JldHVybiBmJiYhZT9udWxsOmgucmVuZGVyZXIuY3Jpc3BMaW5lKFtcIk1cIixhLG4sXCJMXCIsYyxxXSxifHwxKX0sZ2V0TGluZWFyVGlja1Bvc2l0aW9uczpmdW5jdGlvbihhLGIsYyl7dmFyIGgsdz1mKE1hdGguZmxvb3IoYi9hKSphKTtjPWYoTWF0aC5jZWlsKGMvYSkqYSk7dmFyIGU9W107aWYodGhpcy5zaW5nbGUpcmV0dXJuW2JdO2ZvcihiPXc7Yjw9Yzspe2UucHVzaChiKTtiPWYoYithKTtpZihiPT09aClicmVhaztoPWJ9cmV0dXJuIGV9LGdldE1pbm9yVGlja1Bvc2l0aW9uczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1hLnRpY2tQb3NpdGlvbnMsZT1hLm1pbm9yVGlja0ludGVydmFsLFxucD1bXSxkPWEucG9pbnRSYW5nZVBhZGRpbmd8fDAsbj1hLm1pbi1kLGQ9YS5tYXgrZCxxPWQtbjtpZihxJiZxL2U8YS5sZW4vMylpZihhLmlzTG9nKWcodGhpcy5wYWRkZWRUaWNrcyxmdW5jdGlvbihoLGIsYyl7YiYmcC5wdXNoLmFwcGx5KHAsYS5nZXRMb2dUaWNrUG9zaXRpb25zKGUsY1tiLTFdLGNbYl0sITApKX0pO2Vsc2UgaWYoYS5pc0RhdGV0aW1lQXhpcyYmXCJhdXRvXCI9PT1iLm1pbm9yVGlja0ludGVydmFsKXA9cC5jb25jYXQoYS5nZXRUaW1lVGlja3MoYS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKGUpLG4sZCxiLnN0YXJ0T2ZXZWVrKSk7ZWxzZSBmb3IoYj1uKyhjWzBdLW4pJWU7Yjw9ZCYmYiE9PXBbMF07Yis9ZSlwLnB1c2goYik7MCE9PXAubGVuZ3RoJiZhLnRyaW1UaWNrcyhwKTtyZXR1cm4gcH0sYWRqdXN0Rm9yTWluUmFuZ2U6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLm1pbixjPXRoaXMubWF4LGUscCxkLG4scSxrLGYsdjt0aGlzLmlzWEF4aXMmJlxudm9pZCAwPT09dGhpcy5taW5SYW5nZSYmIXRoaXMuaXNMb2cmJihyKGEubWluKXx8cihhLm1heCk/dGhpcy5taW5SYW5nZT1udWxsOihnKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe2s9YS54RGF0YTtmb3Iobj1mPWEueEluY3JlbWVudD8xOmsubGVuZ3RoLTE7MDxuO24tLSlpZihxPWtbbl0ta1tuLTFdLHZvaWQgMD09PWR8fHE8ZClkPXF9KSx0aGlzLm1pblJhbmdlPU1hdGgubWluKDUqZCx0aGlzLmRhdGFNYXgtdGhpcy5kYXRhTWluKSkpO2MtYjx0aGlzLm1pblJhbmdlJiYocD10aGlzLmRhdGFNYXgtdGhpcy5kYXRhTWluPj10aGlzLm1pblJhbmdlLHY9dGhpcy5taW5SYW5nZSxlPSh2LWMrYikvMixlPVtiLWUsQihhLm1pbixiLWUpXSxwJiYoZVsyXT10aGlzLmlzTG9nP3RoaXMubG9nMmxpbih0aGlzLmRhdGFNaW4pOnRoaXMuZGF0YU1pbiksYj1GKGUpLGM9W2IrdixCKGEubWF4LGIrdildLHAmJihjWzJdPXRoaXMuaXNMb2c/dGhpcy5sb2cybGluKHRoaXMuZGF0YU1heCk6dGhpcy5kYXRhTWF4KSxcbmM9RShjKSxjLWI8diYmKGVbMF09Yy12LGVbMV09QihhLm1pbixjLXYpLGI9RihlKSkpO3RoaXMubWluPWI7dGhpcy5tYXg9Y30sZ2V0Q2xvc2VzdDpmdW5jdGlvbigpe3ZhciBhO3RoaXMuY2F0ZWdvcmllcz9hPTE6Zyh0aGlzLnNlcmllcyxmdW5jdGlvbihoKXt2YXIgYj1oLmNsb3Nlc3RQb2ludFJhbmdlLGM9aC52aXNpYmxlfHwhaC5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllczshaC5ub1NoYXJlZFRvb2x0aXAmJnIoYikmJmMmJihhPXIoYSk/TWF0aC5taW4oYSxiKTpiKX0pO3JldHVybiBhfSxuYW1lVG9YOmZ1bmN0aW9uKGEpe3ZhciBoPW4odGhpcy5jYXRlZ29yaWVzKSxiPWg/dGhpcy5jYXRlZ29yaWVzOnRoaXMubmFtZXMsYz1hLm9wdGlvbnMueCxlO2Euc2VyaWVzLnJlcXVpcmVTb3J0aW5nPSExO3IoYyl8fChjPSExPT09dGhpcy5vcHRpb25zLnVuaXF1ZU5hbWVzP2Euc2VyaWVzLmF1dG9JbmNyZW1lbnQoKTp5KGEubmFtZSxiKSk7LTE9PT1jP2h8fFxuKGU9Yi5sZW5ndGgpOmU9Yzt2b2lkIDAhPT1lJiYodGhpcy5uYW1lc1tlXT1hLm5hbWUpO3JldHVybiBlfSx1cGRhdGVOYW1lczpmdW5jdGlvbigpe3ZhciBhPXRoaXM7MDx0aGlzLm5hbWVzLmxlbmd0aCYmKHRoaXMubmFtZXMubGVuZ3RoPTAsdGhpcy5taW5SYW5nZT10aGlzLnVzZXJNaW5SYW5nZSxnKHRoaXMuc2VyaWVzfHxbXSxmdW5jdGlvbihoKXtoLnhJbmNyZW1lbnQ9bnVsbDtpZighaC5wb2ludHN8fGguaXNEaXJ0eURhdGEpaC5wcm9jZXNzRGF0YSgpLGguZ2VuZXJhdGVQb2ludHMoKTtnKGgucG9pbnRzLGZ1bmN0aW9uKGIsYyl7dmFyIGU7Yi5vcHRpb25zJiYoZT1hLm5hbWVUb1goYiksdm9pZCAwIT09ZSYmZSE9PWIueCYmKGIueD1lLGgueERhdGFbY109ZSkpfSl9KSl9LHNldEF4aXNUcmFuc2xhdGlvbjpmdW5jdGlvbihhKXt2YXIgaD10aGlzLGI9aC5tYXgtaC5taW4sYz1oLmF4aXNQb2ludFJhbmdlfHwwLGUscD0wLGQ9MCxuPWgubGlua2VkUGFyZW50LHE9ISFoLmNhdGVnb3JpZXMsXG5rPWgudHJhbnNBLGY9aC5pc1hBeGlzO2lmKGZ8fHF8fGMpZT1oLmdldENsb3Nlc3QoKSxuPyhwPW4ubWluUG9pbnRPZmZzZXQsZD1uLnBvaW50UmFuZ2VQYWRkaW5nKTpnKGguc2VyaWVzLGZ1bmN0aW9uKGEpe3ZhciBiPXE/MTpmP0IoYS5vcHRpb25zLnBvaW50UmFuZ2UsZSwwKTpoLmF4aXNQb2ludFJhbmdlfHwwO2E9YS5vcHRpb25zLnBvaW50UGxhY2VtZW50O2M9TWF0aC5tYXgoYyxiKTtoLnNpbmdsZXx8KHA9TWF0aC5tYXgocCxKKGEpPzA6Yi8yKSxkPU1hdGgubWF4KGQsXCJvblwiPT09YT8wOmIpKX0pLG49aC5vcmRpbmFsU2xvcGUmJmU/aC5vcmRpbmFsU2xvcGUvZToxLGgubWluUG9pbnRPZmZzZXQ9cCo9bixoLnBvaW50UmFuZ2VQYWRkaW5nPWQqPW4saC5wb2ludFJhbmdlPU1hdGgubWluKGMsYiksZiYmKGguY2xvc2VzdFBvaW50UmFuZ2U9ZSk7YSYmKGgub2xkVHJhbnNBPWspO2gudHJhbnNsYXRpb25TbG9wZT1oLnRyYW5zQT1rPWgub3B0aW9ucy5zdGF0aWNTY2FsZXx8aC5sZW4vXG4oYitkfHwxKTtoLnRyYW5zQj1oLmhvcml6P2gubGVmdDpoLmJvdHRvbTtoLm1pblBpeGVsUGFkZGluZz1rKnB9LG1pbkZyb21SYW5nZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heC10aGlzLnJhbmdlfSxzZXRUaWNrSW50ZXJ2YWw6ZnVuY3Rpb24oaCl7dmFyIGI9dGhpcyxjPWIuY2hhcnQscD1iLm9wdGlvbnMsZD1iLmlzTG9nLG49Yi5sb2cybGluLHE9Yi5pc0RhdGV0aW1lQXhpcyx4PWIuaXNYQXhpcyx2PWIuaXNMaW5rZWQsej1wLm1heFBhZGRpbmcseT1wLm1pblBhZGRpbmcsbD1wLnRpY2tJbnRlcnZhbCxJPXAudGlja1BpeGVsSW50ZXJ2YWwsbT1iLmNhdGVnb3JpZXMsSj1iLnRocmVzaG9sZCx0PWIuc29mdFRocmVzaG9sZCxMLHUsSyxBO3F8fG18fHZ8fHRoaXMuZ2V0VGlja0Ftb3VudCgpO0s9QihiLnVzZXJNaW4scC5taW4pO0E9QihiLnVzZXJNYXgscC5tYXgpO3Y/KGIubGlua2VkUGFyZW50PWNbYi5jb2xsXVtwLmxpbmtlZFRvXSxjPWIubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCksXG5iLm1pbj1CKGMubWluLGMuZGF0YU1pbiksYi5tYXg9QihjLm1heCxjLmRhdGFNYXgpLHAudHlwZSE9PWIubGlua2VkUGFyZW50Lm9wdGlvbnMudHlwZSYmYS5lcnJvcigxMSwxKSk6KCF0JiZyKEopJiYoYi5kYXRhTWluPj1KPyhMPUoseT0wKTpiLmRhdGFNYXg8PUomJih1PUosej0wKSksYi5taW49QihLLEwsYi5kYXRhTWluKSxiLm1heD1CKEEsdSxiLmRhdGFNYXgpKTtkJiYoYi5wb3NpdGl2ZVZhbHVlc09ubHkmJiFoJiYwPj1NYXRoLm1pbihiLm1pbixCKGIuZGF0YU1pbixiLm1pbikpJiZhLmVycm9yKDEwLDEpLGIubWluPWYobihiLm1pbiksMTUpLGIubWF4PWYobihiLm1heCksMTUpKTtiLnJhbmdlJiZyKGIubWF4KSYmKGIudXNlck1pbj1iLm1pbj1LPU1hdGgubWF4KGIuZGF0YU1pbixiLm1pbkZyb21SYW5nZSgpKSxiLnVzZXJNYXg9QT1iLm1heCxiLnJhbmdlPW51bGwpO2soYixcImZvdW5kRXh0cmVtZXNcIik7Yi5iZWZvcmVQYWRkaW5nJiZiLmJlZm9yZVBhZGRpbmcoKTtiLmFkanVzdEZvck1pblJhbmdlKCk7XG4hKG18fGIuYXhpc1BvaW50UmFuZ2V8fGIudXNlUGVyY2VudGFnZXx8dikmJnIoYi5taW4pJiZyKGIubWF4KSYmKG49Yi5tYXgtYi5taW4pJiYoIXIoSykmJnkmJihiLm1pbi09bip5KSwhcihBKSYmeiYmKGIubWF4Kz1uKnopKTtEKHAuc29mdE1pbikmJihiLm1pbj1NYXRoLm1pbihiLm1pbixwLnNvZnRNaW4pKTtEKHAuc29mdE1heCkmJihiLm1heD1NYXRoLm1heChiLm1heCxwLnNvZnRNYXgpKTtEKHAuZmxvb3IpJiYoYi5taW49TWF0aC5tYXgoYi5taW4scC5mbG9vcikpO0QocC5jZWlsaW5nKSYmKGIubWF4PU1hdGgubWluKGIubWF4LHAuY2VpbGluZykpO3QmJnIoYi5kYXRhTWluKSYmKEo9Snx8MCwhcihLKSYmYi5taW48SiYmYi5kYXRhTWluPj1KP2IubWluPUo6IXIoQSkmJmIubWF4PkomJmIuZGF0YU1heDw9SiYmKGIubWF4PUopKTtiLnRpY2tJbnRlcnZhbD1iLm1pbj09PWIubWF4fHx2b2lkIDA9PT1iLm1pbnx8dm9pZCAwPT09Yi5tYXg/MTp2JiYhbCYmST09PWIubGlua2VkUGFyZW50Lm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWw/XG5sPWIubGlua2VkUGFyZW50LnRpY2tJbnRlcnZhbDpCKGwsdGhpcy50aWNrQW1vdW50PyhiLm1heC1iLm1pbikvTWF0aC5tYXgodGhpcy50aWNrQW1vdW50LTEsMSk6dm9pZCAwLG0/MTooYi5tYXgtYi5taW4pKkkvTWF0aC5tYXgoYi5sZW4sSSkpO3gmJiFoJiZnKGIuc2VyaWVzLGZ1bmN0aW9uKGEpe2EucHJvY2Vzc0RhdGEoYi5taW4hPT1iLm9sZE1pbnx8Yi5tYXghPT1iLm9sZE1heCl9KTtiLnNldEF4aXNUcmFuc2xhdGlvbighMCk7Yi5iZWZvcmVTZXRUaWNrUG9zaXRpb25zJiZiLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMoKTtiLnBvc3RQcm9jZXNzVGlja0ludGVydmFsJiYoYi50aWNrSW50ZXJ2YWw9Yi5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbChiLnRpY2tJbnRlcnZhbCkpO2IucG9pbnRSYW5nZSYmIWwmJihiLnRpY2tJbnRlcnZhbD1NYXRoLm1heChiLnBvaW50UmFuZ2UsYi50aWNrSW50ZXJ2YWwpKTtoPUIocC5taW5UaWNrSW50ZXJ2YWwsYi5pc0RhdGV0aW1lQXhpcyYmYi5jbG9zZXN0UG9pbnRSYW5nZSk7XG4hbCYmYi50aWNrSW50ZXJ2YWw8aCYmKGIudGlja0ludGVydmFsPWgpO3F8fGR8fGx8fChiLnRpY2tJbnRlcnZhbD1HKGIudGlja0ludGVydmFsLG51bGwsZShiLnRpY2tJbnRlcnZhbCksQihwLmFsbG93RGVjaW1hbHMsISguNTxiLnRpY2tJbnRlcnZhbCYmNT5iLnRpY2tJbnRlcnZhbCYmMUUzPGIubWF4JiY5OTk5PmIubWF4KSksISF0aGlzLnRpY2tBbW91bnQpKTt0aGlzLnRpY2tBbW91bnR8fChiLnRpY2tJbnRlcnZhbD1iLnVuc3F1aXNoKCkpO3RoaXMuc2V0VGlja1Bvc2l0aW9ucygpfSxzZXRUaWNrUG9zaXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGIsYz1hLnRpY2tQb3NpdGlvbnMsZT1hLnRpY2tQb3NpdGlvbmVyLHA9YS5zdGFydE9uVGljayxkPWEuZW5kT25UaWNrO3RoaXMudGlja21hcmtPZmZzZXQ9dGhpcy5jYXRlZ29yaWVzJiZcImJldHdlZW5cIj09PWEudGlja21hcmtQbGFjZW1lbnQmJjE9PT10aGlzLnRpY2tJbnRlcnZhbD8uNTowO3RoaXMubWlub3JUaWNrSW50ZXJ2YWw9XG5cImF1dG9cIj09PWEubWlub3JUaWNrSW50ZXJ2YWwmJnRoaXMudGlja0ludGVydmFsP3RoaXMudGlja0ludGVydmFsLzU6YS5taW5vclRpY2tJbnRlcnZhbDt0aGlzLnNpbmdsZT10aGlzLm1pbj09PXRoaXMubWF4JiZyKHRoaXMubWluKSYmIXRoaXMudGlja0Ftb3VudCYmKHBhcnNlSW50KHRoaXMubWluLDEwKT09PXRoaXMubWlufHwhMSE9PWEuYWxsb3dEZWNpbWFscyk7dGhpcy50aWNrUG9zaXRpb25zPWI9YyYmYy5zbGljZSgpOyFiJiYoYj10aGlzLmlzRGF0ZXRpbWVBeGlzP3RoaXMuZ2V0VGltZVRpY2tzKHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0aGlzLnRpY2tJbnRlcnZhbCxhLnVuaXRzKSx0aGlzLm1pbix0aGlzLm1heCxhLnN0YXJ0T2ZXZWVrLHRoaXMub3JkaW5hbFBvc2l0aW9ucyx0aGlzLmNsb3Nlc3RQb2ludFJhbmdlLCEwKTp0aGlzLmlzTG9nP3RoaXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCx0aGlzLm1pbix0aGlzLm1heCk6dGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLFxudGhpcy5taW4sdGhpcy5tYXgpLGIubGVuZ3RoPnRoaXMubGVuJiYoYj1bYlswXSxiLnBvcCgpXSksdGhpcy50aWNrUG9zaXRpb25zPWIsZSYmKGU9ZS5hcHBseSh0aGlzLFt0aGlzLm1pbix0aGlzLm1heF0pKSkmJih0aGlzLnRpY2tQb3NpdGlvbnM9Yj1lKTt0aGlzLnBhZGRlZFRpY2tzPWIuc2xpY2UoMCk7dGhpcy50cmltVGlja3MoYixwLGQpO3RoaXMuaXNMaW5rZWR8fCh0aGlzLnNpbmdsZSYmMj5iLmxlbmd0aCYmKHRoaXMubWluLT0uNSx0aGlzLm1heCs9LjUpLGN8fGV8fHRoaXMuYWRqdXN0VGlja0Ftb3VudCgpKX0sdHJpbVRpY2tzOmZ1bmN0aW9uKGEsYixjKXt2YXIgaD1hWzBdLGU9YVthLmxlbmd0aC0xXSxwPXRoaXMubWluUG9pbnRPZmZzZXR8fDA7aWYoIXRoaXMuaXNMaW5rZWQpe2lmKGImJi1JbmZpbml0eSE9PWgpdGhpcy5taW49aDtlbHNlIGZvcig7dGhpcy5taW4tcD5hWzBdOylhLnNoaWZ0KCk7aWYoYyl0aGlzLm1heD1lO2Vsc2UgZm9yKDt0aGlzLm1heCtwPGFbYS5sZW5ndGgtXG4xXTspYS5wb3AoKTswPT09YS5sZW5ndGgmJnIoaCkmJmEucHVzaCgoZStoKS8yKX19LGFsaWduVG9PdGhlcnM6ZnVuY3Rpb24oKXt2YXIgYT17fSxiLGM9dGhpcy5vcHRpb25zOyExPT09dGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LmFsaWduVGlja3N8fCExPT09Yy5hbGlnblRpY2tzfHx0aGlzLmlzTG9nfHxnKHRoaXMuY2hhcnRbdGhpcy5jb2xsXSxmdW5jdGlvbihoKXt2YXIgYz1oLm9wdGlvbnMsYz1baC5ob3Jpej9jLmxlZnQ6Yy50b3AsYy53aWR0aCxjLmhlaWdodCxjLnBhbmVdLmpvaW4oKTtoLnNlcmllcy5sZW5ndGgmJihhW2NdP2I9ITA6YVtjXT0xKX0pO3JldHVybiBifSxnZXRUaWNrQW1vdW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9YS50aWNrQW1vdW50LGM9YS50aWNrUGl4ZWxJbnRlcnZhbDshcihhLnRpY2tJbnRlcnZhbCkmJnRoaXMubGVuPGMmJiF0aGlzLmlzUmFkaWFsJiYhdGhpcy5pc0xvZyYmYS5zdGFydE9uVGljayYmYS5lbmRPblRpY2smJihiPVxuMik7IWImJnRoaXMuYWxpZ25Ub090aGVycygpJiYoYj1NYXRoLmNlaWwodGhpcy5sZW4vYykrMSk7ND5iJiYodGhpcy5maW5hbFRpY2tBbXQ9YixiPTUpO3RoaXMudGlja0Ftb3VudD1ifSxhZGp1c3RUaWNrQW1vdW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50aWNrSW50ZXJ2YWwsYj10aGlzLnRpY2tQb3NpdGlvbnMsYz10aGlzLnRpY2tBbW91bnQsZT10aGlzLmZpbmFsVGlja0FtdCxwPWImJmIubGVuZ3RoO2lmKHA8Yyl7Zm9yKDtiLmxlbmd0aDxjOyliLnB1c2goZihiW2IubGVuZ3RoLTFdK2EpKTt0aGlzLnRyYW5zQSo9KHAtMSkvKGMtMSk7dGhpcy5tYXg9YltiLmxlbmd0aC0xXX1lbHNlIHA+YyYmKHRoaXMudGlja0ludGVydmFsKj0yLHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpKTtpZihyKGUpKXtmb3IoYT1jPWIubGVuZ3RoO2EtLTspKDM9PT1lJiYxPT09YSUyfHwyPj1lJiYwPGEmJmE8Yy0xKSYmYi5zcGxpY2UoYSwxKTt0aGlzLmZpbmFsVGlja0FtdD12b2lkIDB9fSxzZXRTY2FsZTpmdW5jdGlvbigpe3ZhciBhLFxuYjt0aGlzLm9sZE1pbj10aGlzLm1pbjt0aGlzLm9sZE1heD10aGlzLm1heDt0aGlzLm9sZEF4aXNMZW5ndGg9dGhpcy5sZW47dGhpcy5zZXRBeGlzU2l6ZSgpO2I9dGhpcy5sZW4hPT10aGlzLm9sZEF4aXNMZW5ndGg7Zyh0aGlzLnNlcmllcyxmdW5jdGlvbihiKXtpZihiLmlzRGlydHlEYXRhfHxiLmlzRGlydHl8fGIueEF4aXMuaXNEaXJ0eSlhPSEwfSk7Ynx8YXx8dGhpcy5pc0xpbmtlZHx8dGhpcy5mb3JjZVJlZHJhd3x8dGhpcy51c2VyTWluIT09dGhpcy5vbGRVc2VyTWlufHx0aGlzLnVzZXJNYXghPT10aGlzLm9sZFVzZXJNYXh8fHRoaXMuYWxpZ25Ub090aGVycygpPyh0aGlzLnJlc2V0U3RhY2tzJiZ0aGlzLnJlc2V0U3RhY2tzKCksdGhpcy5mb3JjZVJlZHJhdz0hMSx0aGlzLmdldFNlcmllc0V4dHJlbWVzKCksdGhpcy5zZXRUaWNrSW50ZXJ2YWwoKSx0aGlzLm9sZFVzZXJNaW49dGhpcy51c2VyTWluLHRoaXMub2xkVXNlck1heD10aGlzLnVzZXJNYXgsdGhpcy5pc0RpcnR5fHxcbih0aGlzLmlzRGlydHk9Ynx8dGhpcy5taW4hPT10aGlzLm9sZE1pbnx8dGhpcy5tYXghPT10aGlzLm9sZE1heCkpOnRoaXMuY2xlYW5TdGFja3MmJnRoaXMuY2xlYW5TdGFja3MoKX0sc2V0RXh0cmVtZXM6ZnVuY3Rpb24oYSxiLGMsZSxwKXt2YXIgaD10aGlzLG49aC5jaGFydDtjPUIoYywhMCk7ZyhoLnNlcmllcyxmdW5jdGlvbihhKXtkZWxldGUgYS5rZFRyZWV9KTtwPWQocCx7bWluOmEsbWF4OmJ9KTtrKGgsXCJzZXRFeHRyZW1lc1wiLHAsZnVuY3Rpb24oKXtoLnVzZXJNaW49YTtoLnVzZXJNYXg9YjtoLmV2ZW50QXJncz1wO2MmJm4ucmVkcmF3KGUpfSl9LHpvb206ZnVuY3Rpb24oYSxiKXt2YXIgaD10aGlzLmRhdGFNaW4sYz10aGlzLmRhdGFNYXgsZT10aGlzLm9wdGlvbnMscD1NYXRoLm1pbihoLEIoZS5taW4saCkpLGU9TWF0aC5tYXgoYyxCKGUubWF4LGMpKTtpZihhIT09dGhpcy5taW58fGIhPT10aGlzLm1heCl0aGlzLmFsbG93Wm9vbU91dHNpZGV8fChyKGgpJiYoYTxwJiYoYT1cbnApLGE+ZSYmKGE9ZSkpLHIoYykmJihiPHAmJihiPXApLGI+ZSYmKGI9ZSkpKSx0aGlzLmRpc3BsYXlCdG49dm9pZCAwIT09YXx8dm9pZCAwIT09Yix0aGlzLnNldEV4dHJlbWVzKGEsYiwhMSx2b2lkIDAse3RyaWdnZXI6XCJ6b29tXCJ9KTtyZXR1cm4hMH0sc2V0QXhpc1NpemU6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5vcHRpb25zLGU9Yy5vZmZzZXRzfHxbMCwwLDAsMF0scD10aGlzLmhvcml6LGQ9dGhpcy53aWR0aD1NYXRoLnJvdW5kKGEucmVsYXRpdmVMZW5ndGgoQihjLndpZHRoLGIucGxvdFdpZHRoLWVbM10rZVsxXSksYi5wbG90V2lkdGgpKSxuPXRoaXMuaGVpZ2h0PU1hdGgucm91bmQoYS5yZWxhdGl2ZUxlbmd0aChCKGMuaGVpZ2h0LGIucGxvdEhlaWdodC1lWzBdK2VbMl0pLGIucGxvdEhlaWdodCkpLHE9dGhpcy50b3A9TWF0aC5yb3VuZChhLnJlbGF0aXZlTGVuZ3RoKEIoYy50b3AsYi5wbG90VG9wK2VbMF0pLGIucGxvdEhlaWdodCxiLnBsb3RUb3ApKSxcbmM9dGhpcy5sZWZ0PU1hdGgucm91bmQoYS5yZWxhdGl2ZUxlbmd0aChCKGMubGVmdCxiLnBsb3RMZWZ0K2VbM10pLGIucGxvdFdpZHRoLGIucGxvdExlZnQpKTt0aGlzLmJvdHRvbT1iLmNoYXJ0SGVpZ2h0LW4tcTt0aGlzLnJpZ2h0PWIuY2hhcnRXaWR0aC1kLWM7dGhpcy5sZW49TWF0aC5tYXgocD9kOm4sMCk7dGhpcy5wb3M9cD9jOnF9LGdldEV4dHJlbWVzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5pc0xvZyxiPXRoaXMubGluMmxvZztyZXR1cm57bWluOmE/ZihiKHRoaXMubWluKSk6dGhpcy5taW4sbWF4OmE/ZihiKHRoaXMubWF4KSk6dGhpcy5tYXgsZGF0YU1pbjp0aGlzLmRhdGFNaW4sZGF0YU1heDp0aGlzLmRhdGFNYXgsdXNlck1pbjp0aGlzLnVzZXJNaW4sdXNlck1heDp0aGlzLnVzZXJNYXh9fSxnZXRUaHJlc2hvbGQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pc0xvZyxoPXRoaXMubGluMmxvZyxjPWI/aCh0aGlzLm1pbik6dGhpcy5taW4sYj1iP2godGhpcy5tYXgpOnRoaXMubWF4O1xubnVsbD09PWE/YT1jOmM+YT9hPWM6YjxhJiYoYT1iKTtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwwLDEsMCwxKX0sYXV0b0xhYmVsQWxpZ246ZnVuY3Rpb24oYSl7YT0oQihhLDApLTkwKnRoaXMuc2lkZSs3MjApJTM2MDtyZXR1cm4gMTU8YSYmMTY1PmE/XCJyaWdodFwiOjE5NTxhJiYzNDU+YT9cImxlZnRcIjpcImNlbnRlclwifSx0aWNrU2l6ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsaD1iW2ErXCJMZW5ndGhcIl0sYz1CKGJbYStcIldpZHRoXCJdLFwidGlja1wiPT09YSYmdGhpcy5pc1hBeGlzPzE6MCk7aWYoYyYmaClyZXR1cm5cImluc2lkZVwiPT09YlthK1wiUG9zaXRpb25cIl0mJihoPS1oKSxbaCxjXX0sbGFiZWxNZXRyaWNzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50aWNrUG9zaXRpb25zJiZ0aGlzLnRpY2tQb3NpdGlvbnNbMF18fDA7cmV0dXJuIHRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3ModGhpcy5vcHRpb25zLmxhYmVscy5zdHlsZSYmdGhpcy5vcHRpb25zLmxhYmVscy5zdHlsZS5mb250U2l6ZSxcbnRoaXMudGlja3NbYV0mJnRoaXMudGlja3NbYV0ubGFiZWwpfSx1bnNxdWlzaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5sYWJlbHMsYj10aGlzLmhvcml6LGM9dGhpcy50aWNrSW50ZXJ2YWwsZT1jLHA9dGhpcy5sZW4vKCgodGhpcy5jYXRlZ29yaWVzPzE6MCkrdGhpcy5tYXgtdGhpcy5taW4pL2MpLGQsbj1hLnJvdGF0aW9uLHE9dGhpcy5sYWJlbE1ldHJpY3MoKSxrLGY9TnVtYmVyLk1BWF9WQUxVRSx2LHo9ZnVuY3Rpb24oYSl7YS89cHx8MTthPTE8YT9NYXRoLmNlaWwoYSk6MTtyZXR1cm4gYSpjfTtiPyh2PSFhLnN0YWdnZXJMaW5lcyYmIWEuc3RlcCYmKHIobik/W25dOnA8QihhLmF1dG9Sb3RhdGlvbkxpbWl0LDgwKSYmYS5hdXRvUm90YXRpb24pKSYmZyh2LGZ1bmN0aW9uKGEpe3ZhciBiO2lmKGE9PT1ufHxhJiYtOTA8PWEmJjkwPj1hKWs9eihNYXRoLmFicyhxLmgvTWF0aC5zaW4odSphKSkpLGI9aytNYXRoLmFicyhhLzM2MCksYjxmJiYoZj1iLGQ9YSxlPWspfSk6XG5hLnN0ZXB8fChlPXoocS5oKSk7dGhpcy5hdXRvUm90YXRpb249djt0aGlzLmxhYmVsUm90YXRpb249QihkLG4pO3JldHVybiBlfSxnZXRTbG90V2lkdGg6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9dGhpcy5ob3JpeixjPXRoaXMub3B0aW9ucy5sYWJlbHMsZT1NYXRoLm1heCh0aGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoLSh0aGlzLmNhdGVnb3JpZXM/MDoxKSwxKSxwPWEubWFyZ2luWzNdO3JldHVybiBiJiYyPihjLnN0ZXB8fDApJiYhYy5yb3RhdGlvbiYmKHRoaXMuc3RhZ2dlckxpbmVzfHwxKSp0aGlzLmxlbi9lfHwhYiYmKHAmJnAtYS5zcGFjaW5nWzNdfHwuMzMqYS5jaGFydFdpZHRoKX0scmVuZGVyVW5zcXVpc2g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS5yZW5kZXJlcixlPXRoaXMudGlja1Bvc2l0aW9ucyxwPXRoaXMudGlja3MsZD10aGlzLm9wdGlvbnMubGFiZWxzLG49dGhpcy5ob3JpeixxPXRoaXMuZ2V0U2xvdFdpZHRoKCksaz1NYXRoLm1heCgxLFxuTWF0aC5yb3VuZChxLTIqKGQucGFkZGluZ3x8NSkpKSxmPXt9LHY9dGhpcy5sYWJlbE1ldHJpY3MoKSx6PWQuc3R5bGUmJmQuc3R5bGUudGV4dE92ZXJmbG93LEQseT0wLGwsSTtKKGQucm90YXRpb24pfHwoZi5yb3RhdGlvbj1kLnJvdGF0aW9ufHwwKTtnKGUsZnVuY3Rpb24oYSl7KGE9cFthXSkmJmEubGFiZWxMZW5ndGg+eSYmKHk9YS5sYWJlbExlbmd0aCl9KTt0aGlzLm1heExhYmVsTGVuZ3RoPXk7aWYodGhpcy5hdXRvUm90YXRpb24peT5rJiZ5PnYuaD9mLnJvdGF0aW9uPXRoaXMubGFiZWxSb3RhdGlvbjp0aGlzLmxhYmVsUm90YXRpb249MDtlbHNlIGlmKHEmJihEPXt3aWR0aDprK1wicHhcIn0sIXopKWZvcihELnRleHRPdmVyZmxvdz1cImNsaXBcIixsPWUubGVuZ3RoOyFuJiZsLS07KWlmKEk9ZVtsXSxrPXBbSV0ubGFiZWwpay5zdHlsZXMmJlwiZWxsaXBzaXNcIj09PWsuc3R5bGVzLnRleHRPdmVyZmxvdz9rLmNzcyh7dGV4dE92ZXJmbG93OlwiY2xpcFwifSk6cFtJXS5sYWJlbExlbmd0aD5cbnEmJmsuY3NzKHt3aWR0aDpxK1wicHhcIn0pLGsuZ2V0QkJveCgpLmhlaWdodD50aGlzLmxlbi9lLmxlbmd0aC0odi5oLXYuZikmJihrLnNwZWNDc3M9e3RleHRPdmVyZmxvdzpcImVsbGlwc2lzXCJ9KTtmLnJvdGF0aW9uJiYoRD17d2lkdGg6KHk+LjUqYS5jaGFydEhlaWdodD8uMzMqYS5jaGFydEhlaWdodDphLmNoYXJ0SGVpZ2h0KStcInB4XCJ9LHp8fChELnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIpKTtpZih0aGlzLmxhYmVsQWxpZ249ZC5hbGlnbnx8dGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pKWYuYWxpZ249dGhpcy5sYWJlbEFsaWduO2coZSxmdW5jdGlvbihhKXt2YXIgYj0oYT1wW2FdKSYmYS5sYWJlbDtiJiYoYi5hdHRyKGYpLEQmJmIuY3NzKGMoRCxiLnNwZWNDc3MpKSxkZWxldGUgYi5zcGVjQ3NzLGEucm90YXRpb249Zi5yb3RhdGlvbil9KTt0aGlzLnRpY2tSb3RDb3JyPWIucm90Q29ycih2LmIsdGhpcy5sYWJlbFJvdGF0aW9ufHwwLDAhPT10aGlzLnNpZGUpfSxcbmhhc0RhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNWaXNpYmxlU2VyaWVzfHxyKHRoaXMubWluKSYmcih0aGlzLm1heCkmJiEhdGhpcy50aWNrUG9zaXRpb25zfSxhZGRUaXRsZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LnJlbmRlcmVyLGM9dGhpcy5ob3JpeixoPXRoaXMub3Bwb3NpdGUsZT10aGlzLm9wdGlvbnMudGl0bGUscDt0aGlzLmF4aXNUaXRsZXx8KChwPWUudGV4dEFsaWduKXx8KHA9KGM/e2xvdzpcImxlZnRcIixtaWRkbGU6XCJjZW50ZXJcIixoaWdoOlwicmlnaHRcIn06e2xvdzpoP1wicmlnaHRcIjpcImxlZnRcIixtaWRkbGU6XCJjZW50ZXJcIixoaWdoOmg/XCJsZWZ0XCI6XCJyaWdodFwifSlbZS5hbGlnbl0pLHRoaXMuYXhpc1RpdGxlPWIudGV4dChlLnRleHQsMCwwLGUudXNlSFRNTCkuYXR0cih7ekluZGV4Ojcscm90YXRpb246ZS5yb3RhdGlvbnx8MCxhbGlnbjpwfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWF4aXMtdGl0bGVcIikuY3NzKGUuc3R5bGUpLmFkZCh0aGlzLmF4aXNHcm91cCksXG50aGlzLmF4aXNUaXRsZS5pc05ldz0hMCk7ZS5zdHlsZS53aWR0aHx8dGhpcy5pc1JhZGlhbHx8dGhpcy5heGlzVGl0bGUuY3NzKHt3aWR0aDp0aGlzLmxlbn0pO3RoaXMuYXhpc1RpdGxlW2E/XCJzaG93XCI6XCJoaWRlXCJdKCEwKX0sZ2VuZXJhdGVUaWNrOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMudGlja3M7YlthXT9iW2FdLmFkZExhYmVsKCk6YlthXT1uZXcgSSh0aGlzLGEpfSxnZXRPZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWIucmVuZGVyZXIsZT1hLm9wdGlvbnMscD1hLnRpY2tQb3NpdGlvbnMsZD1hLnRpY2tzLG49YS5ob3JpeixrPWEuc2lkZSxmPWIuaW52ZXJ0ZWQmJiFhLmlzWkF4aXM/WzEsMCwzLDJdW2tdOmssdix6LEQ9MCx5LGw9MCxJPWUudGl0bGUsbT1lLmxhYmVscyxHPTAsSj1iLmF4aXNPZmZzZXQsYj1iLmNsaXBPZmZzZXQsdD1bLTEsMSwxLC0xXVtrXSxMPWUuY2xhc3NOYW1lLHU9YS5heGlzUGFyZW50LEs9dGhpcy50aWNrU2l6ZShcInRpY2tcIik7XG52PWEuaGFzRGF0YSgpO2Euc2hvd0F4aXM9ej12fHxCKGUuc2hvd0VtcHR5LCEwKTthLnN0YWdnZXJMaW5lcz1hLmhvcml6JiZtLnN0YWdnZXJMaW5lczthLmF4aXNHcm91cHx8KGEuZ3JpZEdyb3VwPWMuZyhcImdyaWRcIikuYXR0cih7ekluZGV4OmUuZ3JpZFpJbmRleHx8MX0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIit0aGlzLmNvbGwudG9Mb3dlckNhc2UoKStcIi1ncmlkIFwiKyhMfHxcIlwiKSkuYWRkKHUpLGEuYXhpc0dyb3VwPWMuZyhcImF4aXNcIikuYXR0cih7ekluZGV4OmUuekluZGV4fHwyfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiK3RoaXMuY29sbC50b0xvd2VyQ2FzZSgpK1wiIFwiKyhMfHxcIlwiKSkuYWRkKHUpLGEubGFiZWxHcm91cD1jLmcoXCJheGlzLWxhYmVsc1wiKS5hdHRyKHt6SW5kZXg6bS56SW5kZXh8fDd9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrYS5jb2xsLnRvTG93ZXJDYXNlKCkrXCItbGFiZWxzIFwiKyhMfHxcIlwiKSkuYWRkKHUpKTt2fHxhLmlzTGlua2VkPyhnKHAsZnVuY3Rpb24oYixcbmMpe2EuZ2VuZXJhdGVUaWNrKGIsYyl9KSxhLnJlbmRlclVuc3F1aXNoKCksITE9PT1tLnJlc2VydmVTcGFjZXx8MCE9PWsmJjIhPT1rJiZ7MTpcImxlZnRcIiwzOlwicmlnaHRcIn1ba10hPT1hLmxhYmVsQWxpZ24mJlwiY2VudGVyXCIhPT1hLmxhYmVsQWxpZ258fGcocCxmdW5jdGlvbihhKXtHPU1hdGgubWF4KGRbYV0uZ2V0TGFiZWxTaXplKCksRyl9KSxhLnN0YWdnZXJMaW5lcyYmKEcqPWEuc3RhZ2dlckxpbmVzLGEubGFiZWxPZmZzZXQ9RyooYS5vcHBvc2l0ZT8tMToxKSkpOnEoZCxmdW5jdGlvbihhLGIpe2EuZGVzdHJveSgpO2RlbGV0ZSBkW2JdfSk7SSYmSS50ZXh0JiYhMSE9PUkuZW5hYmxlZCYmKGEuYWRkVGl0bGUoeikseiYmITEhPT1JLnJlc2VydmVTcGFjZSYmKGEudGl0bGVPZmZzZXQ9RD1hLmF4aXNUaXRsZS5nZXRCQm94KClbbj9cImhlaWdodFwiOlwid2lkdGhcIl0seT1JLm9mZnNldCxsPXIoeSk/MDpCKEkubWFyZ2luLG4/NToxMCkpKTthLnJlbmRlckxpbmUoKTthLm9mZnNldD1cbnQqQihlLm9mZnNldCxKW2tdKTthLnRpY2tSb3RDb3JyPWEudGlja1JvdENvcnJ8fHt4OjAseTowfTtjPTA9PT1rPy1hLmxhYmVsTWV0cmljcygpLmg6Mj09PWs/YS50aWNrUm90Q29yci55OjA7bD1NYXRoLmFicyhHKStsO0cmJihsPWwtYyt0KihuP0IobS55LGEudGlja1JvdENvcnIueSs4KnQpOm0ueCkpO2EuYXhpc1RpdGxlTWFyZ2luPUIoeSxsKTtKW2tdPU1hdGgubWF4KEpba10sYS5heGlzVGl0bGVNYXJnaW4rRCt0KmEub2Zmc2V0LGwsdiYmcC5sZW5ndGgmJks/S1swXSt0KmEub2Zmc2V0OjApO3A9MipNYXRoLmZsb29yKGEuYXhpc0xpbmUuc3Ryb2tlV2lkdGgoKS8yKTswPGUub2Zmc2V0JiYocC09MiplLm9mZnNldCk7YltmXT1NYXRoLm1heChiW2ZdfHxwLHApfSxnZXRMaW5lUGF0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5vcHBvc2l0ZSxoPXRoaXMub2Zmc2V0LGU9dGhpcy5ob3JpeixwPXRoaXMubGVmdCsoYz90aGlzLndpZHRoOjApK2gsaD1iLmNoYXJ0SGVpZ2h0LVxudGhpcy5ib3R0b20tKGM/dGhpcy5oZWlnaHQ6MCkraDtjJiYoYSo9LTEpO3JldHVybiBiLnJlbmRlcmVyLmNyaXNwTGluZShbXCJNXCIsZT90aGlzLmxlZnQ6cCxlP2g6dGhpcy50b3AsXCJMXCIsZT9iLmNoYXJ0V2lkdGgtdGhpcy5yaWdodDpwLGU/aDpiLmNoYXJ0SGVpZ2h0LXRoaXMuYm90dG9tXSxhKX0scmVuZGVyTGluZTpmdW5jdGlvbigpe3RoaXMuYXhpc0xpbmV8fCh0aGlzLmF4aXNMaW5lPXRoaXMuY2hhcnQucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1heGlzLWxpbmVcIikuYWRkKHRoaXMuYXhpc0dyb3VwKSx0aGlzLmF4aXNMaW5lLmF0dHIoe3N0cm9rZTp0aGlzLm9wdGlvbnMubGluZUNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6dGhpcy5vcHRpb25zLmxpbmVXaWR0aCx6SW5kZXg6N30pKX0sZ2V0VGl0bGVQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuaG9yaXosYj10aGlzLmxlZnQsYz10aGlzLnRvcCxlPXRoaXMubGVuLHA9dGhpcy5vcHRpb25zLnRpdGxlLFxuZD1hP2I6YyxuPXRoaXMub3Bwb3NpdGUscT10aGlzLm9mZnNldCxrPXAueHx8MCxnPXAueXx8MCxmPXRoaXMuYXhpc1RpdGxlLHY9dGhpcy5jaGFydC5yZW5kZXJlci5mb250TWV0cmljcyhwLnN0eWxlJiZwLnN0eWxlLmZvbnRTaXplLGYpLGY9TWF0aC5tYXgoZi5nZXRCQm94KG51bGwsMCkuaGVpZ2h0LXYuaC0xLDApLGU9e2xvdzpkKyhhPzA6ZSksbWlkZGxlOmQrZS8yLGhpZ2g6ZCsoYT9lOjApfVtwLmFsaWduXSxiPShhP2MrdGhpcy5oZWlnaHQ6YikrKGE/MTotMSkqKG4/LTE6MSkqdGhpcy5heGlzVGl0bGVNYXJnaW4rWy1mLGYsdi5mLC1mXVt0aGlzLnNpZGVdO3JldHVybnt4OmE/ZStrOmIrKG4/dGhpcy53aWR0aDowKStxK2sseTphP2IrZy0obj90aGlzLmhlaWdodDowKStxOmUrZ319LHJlbmRlck1pbm9yVGljazpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0Lmhhc1JlbmRlcmVkJiZEKHRoaXMub2xkTWluKSxjPXRoaXMubWlub3JUaWNrcztjW2FdfHwoY1thXT1uZXcgSSh0aGlzLFxuYSxcIm1pbm9yXCIpKTtiJiZjW2FdLmlzTmV3JiZjW2FdLnJlbmRlcihudWxsLCEwKTtjW2FdLnJlbmRlcihudWxsLCExLDEpfSxyZW5kZXJUaWNrOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5pc0xpbmtlZCxlPXRoaXMudGlja3MsaD10aGlzLmNoYXJ0Lmhhc1JlbmRlcmVkJiZEKHRoaXMub2xkTWluKTtpZighY3x8YT49dGhpcy5taW4mJmE8PXRoaXMubWF4KWVbYV18fChlW2FdPW5ldyBJKHRoaXMsYSkpLGgmJmVbYV0uaXNOZXcmJmVbYV0ucmVuZGVyKGIsITAsLjEpLGVbYV0ucmVuZGVyKGIpfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi5jaGFydCxlPWIub3B0aW9ucyxwPWIuaXNMb2csZD1iLmxpbjJsb2csbj1iLmlzTGlua2VkLGs9Yi50aWNrUG9zaXRpb25zLGY9Yi5heGlzVGl0bGUsdj1iLnRpY2tzLHk9Yi5taW5vclRpY2tzLGw9Yi5hbHRlcm5hdGVCYW5kcyxtPWUuc3RhY2tMYWJlbHMscj1lLmFsdGVybmF0ZUdyaWRDb2xvcixCPWIudGlja21hcmtPZmZzZXQsXG5HPWIuYXhpc0xpbmUsSj1iLnNob3dBeGlzLHQ9QShjLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiksTCx1O2IubGFiZWxFZGdlLmxlbmd0aD0wO2Iub3ZlcmxhcD0hMTtnKFt2LHksbF0sZnVuY3Rpb24oYSl7cShhLGZ1bmN0aW9uKGEpe2EuaXNBY3RpdmU9ITF9KX0pO2lmKGIuaGFzRGF0YSgpfHxuKWIubWlub3JUaWNrSW50ZXJ2YWwmJiFiLmNhdGVnb3JpZXMmJmcoYi5nZXRNaW5vclRpY2tQb3NpdGlvbnMoKSxmdW5jdGlvbihhKXtiLnJlbmRlck1pbm9yVGljayhhKX0pLGsubGVuZ3RoJiYoZyhrLGZ1bmN0aW9uKGEsYyl7Yi5yZW5kZXJUaWNrKGEsYyl9KSxCJiYoMD09PWIubWlufHxiLnNpbmdsZSkmJih2Wy0xXXx8KHZbLTFdPW5ldyBJKGIsLTEsbnVsbCwhMCkpLHZbLTFdLnJlbmRlcigtMSkpKSxyJiZnKGssZnVuY3Rpb24oZSxoKXt1PXZvaWQgMCE9PWtbaCsxXT9rW2grMV0rQjpiLm1heC1COzA9PT1oJTImJmU8Yi5tYXgmJnU8PWIubWF4KyhjLnBvbGFyPy1COkIpJiYobFtlXXx8XG4obFtlXT1uZXcgYS5QbG90TGluZU9yQmFuZChiKSksTD1lK0IsbFtlXS5vcHRpb25zPXtmcm9tOnA/ZChMKTpMLHRvOnA/ZCh1KTp1LGNvbG9yOnJ9LGxbZV0ucmVuZGVyKCksbFtlXS5pc0FjdGl2ZT0hMCl9KSxiLl9hZGRlZFBsb3RMQnx8KGcoKGUucGxvdExpbmVzfHxbXSkuY29uY2F0KGUucGxvdEJhbmRzfHxbXSksZnVuY3Rpb24oYSl7Yi5hZGRQbG90QmFuZE9yTGluZShhKX0pLGIuX2FkZGVkUGxvdExCPSEwKTtnKFt2LHksbF0sZnVuY3Rpb24oYSl7dmFyIGIsZT1bXSxoPXQuZHVyYXRpb247cShhLGZ1bmN0aW9uKGEsYil7YS5pc0FjdGl2ZXx8KGEucmVuZGVyKGIsITEsMCksYS5pc0FjdGl2ZT0hMSxlLnB1c2goYikpfSk7eihmdW5jdGlvbigpe2ZvcihiPWUubGVuZ3RoO2ItLTspYVtlW2JdXSYmIWFbZVtiXV0uaXNBY3RpdmUmJihhW2VbYl1dLmRlc3Ryb3koKSxkZWxldGUgYVtlW2JdXSl9LGEhPT1sJiZjLmhhc1JlbmRlcmVkJiZoP2g6MCl9KTtHJiYoR1tHLmlzUGxhY2VkP1xuXCJhbmltYXRlXCI6XCJhdHRyXCJdKHtkOnRoaXMuZ2V0TGluZVBhdGgoRy5zdHJva2VXaWR0aCgpKX0pLEcuaXNQbGFjZWQ9ITAsR1tKP1wic2hvd1wiOlwiaGlkZVwiXSghMCkpO2YmJkomJihlPWIuZ2V0VGl0bGVQb3NpdGlvbigpLEQoZS55KT8oZltmLmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXShlKSxmLmlzTmV3PSExKTooZi5hdHRyKFwieVwiLC05OTk5KSxmLmlzTmV3PSEwKSk7bSYmbS5lbmFibGVkJiZiLnJlbmRlclN0YWNrVG90YWxzKCk7Yi5pc0RpcnR5PSExfSxyZWRyYXc6ZnVuY3Rpb24oKXt0aGlzLnZpc2libGUmJih0aGlzLnJlbmRlcigpLGcodGhpcy5wbG90TGluZXNBbmRCYW5kcyxmdW5jdGlvbihhKXthLnJlbmRlcigpfSkpO2codGhpcy5zZXJpZXMsZnVuY3Rpb24oYSl7YS5pc0RpcnR5PSEwfSl9LGtlZXBQcm9wczpcImV4dEtleSBoY0V2ZW50cyBuYW1lcyBzZXJpZXMgdXNlck1heCB1c2VyTWluXCIuc3BsaXQoXCIgXCIpLGRlc3Ryb3k6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIuc3RhY2tzLFxuZT1iLnBsb3RMaW5lc0FuZEJhbmRzLGg7YXx8SyhiKTtxKGMsZnVuY3Rpb24oYSxiKXt0KGEpO2NbYl09bnVsbH0pO2coW2IudGlja3MsYi5taW5vclRpY2tzLGIuYWx0ZXJuYXRlQmFuZHNdLGZ1bmN0aW9uKGEpe3QoYSl9KTtpZihlKWZvcihhPWUubGVuZ3RoO2EtLTspZVthXS5kZXN0cm95KCk7ZyhcInN0YWNrVG90YWxHcm91cCBheGlzTGluZSBheGlzVGl0bGUgYXhpc0dyb3VwIGdyaWRHcm91cCBsYWJlbEdyb3VwIGNyb3NzXCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGEpe2JbYV0mJihiW2FdPWJbYV0uZGVzdHJveSgpKX0pO2ZvcihoIGluIGIucGxvdExpbmVzQW5kQmFuZHNHcm91cHMpYi5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1toXT1iLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW2hdLmRlc3Ryb3koKTtxKGIsZnVuY3Rpb24oYSxjKXstMT09PXkoYyxiLmtlZXBQcm9wcykmJmRlbGV0ZSBiW2NdfSl9LGRyYXdDcm9zc2hhaXI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxlPXRoaXMuY3Jvc3NoYWlyLFxuaD1CKGUuc25hcCwhMCkscCxkPXRoaXMuY3Jvc3M7YXx8KGE9dGhpcy5jcm9zcyYmdGhpcy5jcm9zcy5lKTt0aGlzLmNyb3NzaGFpciYmITEhPT0ocihiKXx8IWgpPyhoP3IoYikmJihwPXRoaXMuaXNYQXhpcz9iLnBsb3RYOnRoaXMubGVuLWIucGxvdFkpOnA9YSYmKHRoaXMuaG9yaXo/YS5jaGFydFgtdGhpcy5wb3M6dGhpcy5sZW4tYS5jaGFydFkrdGhpcy5wb3MpLHIocCkmJihjPXRoaXMuZ2V0UGxvdExpbmVQYXRoKGImJih0aGlzLmlzWEF4aXM/Yi54OkIoYi5zdGFja1ksYi55KSksbnVsbCxudWxsLG51bGwscCl8fG51bGwpLHIoYyk/KGI9dGhpcy5jYXRlZ29yaWVzJiYhdGhpcy5pc1JhZGlhbCxkfHwodGhpcy5jcm9zcz1kPXRoaXMuY2hhcnQucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jcm9zc2hhaXIgaGlnaGNoYXJ0cy1jcm9zc2hhaXItXCIrKGI/XCJjYXRlZ29yeSBcIjpcInRoaW4gXCIpK2UuY2xhc3NOYW1lKS5hdHRyKHt6SW5kZXg6QihlLnpJbmRleCwyKX0pLmFkZCgpLFxuZC5hdHRyKHtzdHJva2U6ZS5jb2xvcnx8KGI/bShcIiNjY2Q2ZWJcIikuc2V0T3BhY2l0eSguMjUpLmdldCgpOlwiI2NjY2NjY1wiKSxcInN0cm9rZS13aWR0aFwiOkIoZS53aWR0aCwxKX0pLGUuZGFzaFN0eWxlJiZkLmF0dHIoe2Rhc2hzdHlsZTplLmRhc2hTdHlsZX0pKSxkLnNob3coKS5hdHRyKHtkOmN9KSxiJiYhZS53aWR0aCYmZC5hdHRyKHtcInN0cm9rZS13aWR0aFwiOnRoaXMudHJhbnNBfSksdGhpcy5jcm9zcy5lPWEpOnRoaXMuaGlkZUNyb3NzaGFpcigpKTp0aGlzLmhpZGVDcm9zc2hhaXIoKX0saGlkZUNyb3NzaGFpcjpmdW5jdGlvbigpe3RoaXMuY3Jvc3MmJnRoaXMuY3Jvc3MuaGlkZSgpfX0pO3JldHVybiBhLkF4aXM9TH0oTSk7KGZ1bmN0aW9uKGEpe3ZhciBDPWEuQXhpcyxBPWEuRGF0ZSxGPWEuZGF0ZUZvcm1hdCxFPWEuZGVmYXVsdE9wdGlvbnMsbT1hLmRlZmluZWQsZj1hLmVhY2gsbD1hLmV4dGVuZCxyPWEuZ2V0TWFnbml0dWRlLHU9YS5nZXRUWk9mZnNldCx0PWEubm9ybWFsaXplVGlja0ludGVydmFsLFxuZz1hLnBpY2ssZD1hLnRpbWVVbml0cztDLnByb3RvdHlwZS5nZXRUaW1lVGlja3M9ZnVuY3Rpb24oYSxiLGUsdil7dmFyIGs9W10sbj17fSxEPUUuZ2xvYmFsLnVzZVVUQyxyLGM9bmV3IEEoYi1NYXRoLm1heCh1KGIpLHUoZSkpKSxHPUEuaGNNYWtlVGltZSxxPWEudW5pdFJhbmdlLEI9YS5jb3VudCx0LHA7aWYobShiKSl7Y1tBLmhjU2V0TWlsbGlzZWNvbmRzXShxPj1kLnNlY29uZD8wOkIqTWF0aC5mbG9vcihjLmdldE1pbGxpc2Vjb25kcygpL0IpKTtpZihxPj1kLnNlY29uZCljW0EuaGNTZXRTZWNvbmRzXShxPj1kLm1pbnV0ZT8wOkIqTWF0aC5mbG9vcihjLmdldFNlY29uZHMoKS9CKSk7aWYocT49ZC5taW51dGUpY1tBLmhjU2V0TWludXRlc10ocT49ZC5ob3VyPzA6QipNYXRoLmZsb29yKGNbQS5oY0dldE1pbnV0ZXNdKCkvQikpO2lmKHE+PWQuaG91ciljW0EuaGNTZXRIb3Vyc10ocT49ZC5kYXk/MDpCKk1hdGguZmxvb3IoY1tBLmhjR2V0SG91cnNdKCkvQikpO2lmKHE+PWQuZGF5KWNbQS5oY1NldERhdGVdKHE+PVxuZC5tb250aD8xOkIqTWF0aC5mbG9vcihjW0EuaGNHZXREYXRlXSgpL0IpKTtxPj1kLm1vbnRoJiYoY1tBLmhjU2V0TW9udGhdKHE+PWQueWVhcj8wOkIqTWF0aC5mbG9vcihjW0EuaGNHZXRNb250aF0oKS9CKSkscj1jW0EuaGNHZXRGdWxsWWVhcl0oKSk7aWYocT49ZC55ZWFyKWNbQS5oY1NldEZ1bGxZZWFyXShyLXIlQik7aWYocT09PWQud2VlayljW0EuaGNTZXREYXRlXShjW0EuaGNHZXREYXRlXSgpLWNbQS5oY0dldERheV0oKStnKHYsMSkpO3I9Y1tBLmhjR2V0RnVsbFllYXJdKCk7dj1jW0EuaGNHZXRNb250aF0oKTt2YXIgej1jW0EuaGNHZXREYXRlXSgpLEk9Y1tBLmhjR2V0SG91cnNdKCk7aWYoQS5oY1RpbWV6b25lT2Zmc2V0fHxBLmhjR2V0VGltZXpvbmVPZmZzZXQpcD0oIUR8fCEhQS5oY0dldFRpbWV6b25lT2Zmc2V0KSYmKGUtYj40KmQubW9udGh8fHUoYikhPT11KGUpKSxjPWMuZ2V0VGltZSgpLHQ9dShjKSxjPW5ldyBBKGMrdCk7RD1jLmdldFRpbWUoKTtmb3IoYj0xO0Q8XG5lOylrLnB1c2goRCksRD1xPT09ZC55ZWFyP0cocitiKkIsMCk6cT09PWQubW9udGg/RyhyLHYrYipCKTohcHx8cSE9PWQuZGF5JiZxIT09ZC53ZWVrP3AmJnE9PT1kLmhvdXI/RyhyLHYseixJK2IqQiwwLDAsdCktdDpEK3EqQjpHKHIsdix6K2IqQioocT09PWQuZGF5PzE6NykpLGIrKztrLnB1c2goRCk7cTw9ZC5ob3VyJiYxRTQ+ay5sZW5ndGgmJmYoayxmdW5jdGlvbihhKXswPT09YSUxOEU1JiZcIjAwMDAwMDAwMFwiPT09RihcIiVIJU0lUyVMXCIsYSkmJihuW2FdPVwiZGF5XCIpfSl9ay5pbmZvPWwoYSx7aGlnaGVyUmFua3M6bix0b3RhbFJhbmdlOnEqQn0pO3JldHVybiBrfTtDLnByb3RvdHlwZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsPWZ1bmN0aW9uKGEsYil7dmFyIGU9Ynx8W1tcIm1pbGxpc2Vjb25kXCIsWzEsMiw1LDEwLDIwLDI1LDUwLDEwMCwyMDAsNTAwXV0sW1wic2Vjb25kXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wibWludXRlXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wiaG91clwiLFsxLFxuMiwzLDQsNiw4LDEyXV0sW1wiZGF5XCIsWzEsMl1dLFtcIndlZWtcIixbMSwyXV0sW1wibW9udGhcIixbMSwyLDMsNCw2XV0sW1wieWVhclwiLG51bGxdXTtiPWVbZS5sZW5ndGgtMV07dmFyIGs9ZFtiWzBdXSxnPWJbMV0sbjtmb3Iobj0wO248ZS5sZW5ndGgmJiEoYj1lW25dLGs9ZFtiWzBdXSxnPWJbMV0sZVtuKzFdJiZhPD0oaypnW2cubGVuZ3RoLTFdK2RbZVtuKzFdWzBdXSkvMik7bisrKTtrPT09ZC55ZWFyJiZhPDUqayYmKGc9WzEsMiw1XSk7YT10KGEvayxnLFwieWVhclwiPT09YlswXT9NYXRoLm1heChyKGEvayksMSk6MSk7cmV0dXJue3VuaXRSYW5nZTprLGNvdW50OmEsdW5pdE5hbWU6YlswXX19fSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDPWEuQXhpcyxBPWEuZ2V0TWFnbml0dWRlLEY9YS5tYXAsRT1hLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCxtPWEucGljaztDLnByb3RvdHlwZS5nZXRMb2dUaWNrUG9zaXRpb25zPWZ1bmN0aW9uKGEsbCxyLHUpe3ZhciBmPXRoaXMub3B0aW9ucyxnPXRoaXMubGVuLFxuZD10aGlzLmxpbjJsb2csaz10aGlzLmxvZzJsaW4sYj1bXTt1fHwodGhpcy5fbWlub3JBdXRvSW50ZXJ2YWw9bnVsbCk7aWYoLjU8PWEpYT1NYXRoLnJvdW5kKGEpLGI9dGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGEsbCxyKTtlbHNlIGlmKC4wODw9YSlmb3IodmFyIGc9TWF0aC5mbG9vcihsKSxlLHYseSxuLEQsZj0uMzxhP1sxLDIsNF06LjE1PGE/WzEsMiw0LDYsOF06WzEsMiwzLDQsNSw2LDcsOCw5XTtnPHIrMSYmIUQ7ZysrKWZvcih2PWYubGVuZ3RoLGU9MDtlPHYmJiFEO2UrKyl5PWsoZChnKSpmW2VdKSx5PmwmJighdXx8bjw9cikmJnZvaWQgMCE9PW4mJmIucHVzaChuKSxuPnImJihEPSEwKSxuPXk7ZWxzZSBsPWQobCkscj1kKHIpLGE9Zlt1P1wibWlub3JUaWNrSW50ZXJ2YWxcIjpcInRpY2tJbnRlcnZhbFwiXSxhPW0oXCJhdXRvXCI9PT1hP251bGw6YSx0aGlzLl9taW5vckF1dG9JbnRlcnZhbCxmLnRpY2tQaXhlbEludGVydmFsLyh1PzU6MSkqKHItbCkvKCh1P2cvdGhpcy50aWNrUG9zaXRpb25zLmxlbmd0aDpcbmcpfHwxKSksYT1FKGEsbnVsbCxBKGEpKSxiPUYodGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGEsbCxyKSxrKSx1fHwodGhpcy5fbWlub3JBdXRvSW50ZXJ2YWw9YS81KTt1fHwodGhpcy50aWNrSW50ZXJ2YWw9YSk7cmV0dXJuIGJ9O0MucHJvdG90eXBlLmxvZzJsaW49ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgubG9nKGEpL01hdGguTE4xMH07Qy5wcm90b3R5cGUubGluMmxvZz1mdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5wb3coMTAsYSl9fSkoTSk7KGZ1bmN0aW9uKGEsQyl7dmFyIEE9YS5hcnJheU1heCxGPWEuYXJyYXlNaW4sRT1hLmRlZmluZWQsbT1hLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLGY9YS5lYWNoLGw9YS5lcmFzZSxyPWEubWVyZ2UsdT1hLnBpY2s7YS5QbG90TGluZU9yQmFuZD1mdW5jdGlvbihhLGcpe3RoaXMuYXhpcz1hO2cmJih0aGlzLm9wdGlvbnM9Zyx0aGlzLmlkPWcuaWQpfTthLlBsb3RMaW5lT3JCYW5kLnByb3RvdHlwZT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGY9XG50aGlzLGc9Zi5heGlzLGQ9Zy5ob3JpeixrPWYub3B0aW9ucyxiPWsubGFiZWwsZT1mLmxhYmVsLHY9ay50byxsPWsuZnJvbSxuPWsudmFsdWUsRD1FKGwpJiZFKHYpLG09RShuKSxjPWYuc3ZnRWxlbSxHPSFjLHE9W10sQj1rLmNvbG9yLEs9dShrLnpJbmRleCwwKSxwPWsuZXZlbnRzLHE9e1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtcGxvdC1cIisoRD9cImJhbmQgXCI6XCJsaW5lIFwiKSsoay5jbGFzc05hbWV8fFwiXCIpfSx6PXt9LEk9Zy5jaGFydC5yZW5kZXJlcixMPUQ/XCJiYW5kc1wiOlwibGluZXNcIixoPWcubG9nMmxpbjtnLmlzTG9nJiYobD1oKGwpLHY9aCh2KSxuPWgobikpO20/KHE9e3N0cm9rZTpCLFwic3Ryb2tlLXdpZHRoXCI6ay53aWR0aH0say5kYXNoU3R5bGUmJihxLmRhc2hzdHlsZT1rLmRhc2hTdHlsZSkpOkQmJihCJiYocS5maWxsPUIpLGsuYm9yZGVyV2lkdGgmJihxLnN0cm9rZT1rLmJvcmRlckNvbG9yLHFbXCJzdHJva2Utd2lkdGhcIl09ay5ib3JkZXJXaWR0aCkpO3ouekluZGV4PUs7TCs9XG5cIi1cIitLOyhCPWcucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbTF0pfHwoZy5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tMXT1CPUkuZyhcInBsb3QtXCIrTCkuYXR0cih6KS5hZGQoKSk7RyYmKGYuc3ZnRWxlbT1jPUkucGF0aCgpLmF0dHIocSkuYWRkKEIpKTtpZihtKXE9Zy5nZXRQbG90TGluZVBhdGgobixjLnN0cm9rZVdpZHRoKCkpO2Vsc2UgaWYoRClxPWcuZ2V0UGxvdEJhbmRQYXRoKGwsdixrKTtlbHNlIHJldHVybjtHJiZxJiZxLmxlbmd0aD8oYy5hdHRyKHtkOnF9KSxwJiZhLm9iamVjdEVhY2gocCxmdW5jdGlvbihhLGIpe2Mub24oYixmdW5jdGlvbihhKXtwW2JdLmFwcGx5KGYsW2FdKX0pfSkpOmMmJihxPyhjLnNob3coKSxjLmFuaW1hdGUoe2Q6cX0pKTooYy5oaWRlKCksZSYmKGYubGFiZWw9ZT1lLmRlc3Ryb3koKSkpKTtiJiZFKGIudGV4dCkmJnEmJnEubGVuZ3RoJiYwPGcud2lkdGgmJjA8Zy5oZWlnaHQmJiFxLmZsYXQ/KGI9cih7YWxpZ246ZCYmRCYmXCJjZW50ZXJcIix4OmQ/XG4hRCYmNDoxMCx2ZXJ0aWNhbEFsaWduOiFkJiZEJiZcIm1pZGRsZVwiLHk6ZD9EPzE2OjEwOkQ/NjotNCxyb3RhdGlvbjpkJiYhRCYmOTB9LGIpLHRoaXMucmVuZGVyTGFiZWwoYixxLEQsSykpOmUmJmUuaGlkZSgpO3JldHVybiBmfSxyZW5kZXJMYWJlbDpmdW5jdGlvbihhLGcsZCxrKXt2YXIgYj10aGlzLmxhYmVsLGU9dGhpcy5heGlzLmNoYXJ0LnJlbmRlcmVyO2J8fChiPXthbGlnbjphLnRleHRBbGlnbnx8YS5hbGlnbixyb3RhdGlvbjphLnJvdGF0aW9uLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtcGxvdC1cIisoZD9cImJhbmRcIjpcImxpbmVcIikrXCItbGFiZWwgXCIrKGEuY2xhc3NOYW1lfHxcIlwiKX0sYi56SW5kZXg9ayx0aGlzLmxhYmVsPWI9ZS50ZXh0KGEudGV4dCwwLDAsYS51c2VIVE1MKS5hdHRyKGIpLmFkZCgpLGIuY3NzKGEuc3R5bGUpKTtrPVtnWzFdLGdbNF0sZD9nWzZdOmdbMV1dO2c9W2dbMl0sZ1s1XSxkP2dbN106Z1syXV07ZD1GKGspO2U9RihnKTtiLmFsaWduKGEsITEse3g6ZCx5OmUsXG53aWR0aDpBKGspLWQsaGVpZ2h0OkEoZyktZX0pO2Iuc2hvdygpfSxkZXN0cm95OmZ1bmN0aW9uKCl7bCh0aGlzLmF4aXMucGxvdExpbmVzQW5kQmFuZHMsdGhpcyk7ZGVsZXRlIHRoaXMuYXhpczttKHRoaXMpfX07YS5leHRlbmQoQy5wcm90b3R5cGUse2dldFBsb3RCYW5kUGF0aDpmdW5jdGlvbihhLGcpe3ZhciBkPXRoaXMuZ2V0UGxvdExpbmVQYXRoKGcsbnVsbCxudWxsLCEwKSxrPXRoaXMuZ2V0UGxvdExpbmVQYXRoKGEsbnVsbCxudWxsLCEwKSxiPXRoaXMuaG9yaXosZT0xO2E9YTx0aGlzLm1pbiYmZzx0aGlzLm1pbnx8YT50aGlzLm1heCYmZz50aGlzLm1heDtrJiZkPyhhJiYoay5mbGF0PWsudG9TdHJpbmcoKT09PWQudG9TdHJpbmcoKSxlPTApLGsucHVzaChiJiZkWzRdPT09a1s0XT9kWzRdK2U6ZFs0XSxifHxkWzVdIT09a1s1XT9kWzVdOmRbNV0rZSxiJiZkWzFdPT09a1sxXT9kWzFdK2U6ZFsxXSxifHxkWzJdIT09a1syXT9kWzJdOmRbMl0rZSkpOms9bnVsbDtyZXR1cm4ga30sXG5hZGRQbG90QmFuZDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShhLFwicGxvdEJhbmRzXCIpfSxhZGRQbG90TGluZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShhLFwicGxvdExpbmVzXCIpfSxhZGRQbG90QmFuZE9yTGluZTpmdW5jdGlvbihmLGcpe3ZhciBkPShuZXcgYS5QbG90TGluZU9yQmFuZCh0aGlzLGYpKS5yZW5kZXIoKSxrPXRoaXMudXNlck9wdGlvbnM7ZCYmKGcmJihrW2ddPWtbZ118fFtdLGtbZ10ucHVzaChmKSksdGhpcy5wbG90TGluZXNBbmRCYW5kcy5wdXNoKGQpKTtyZXR1cm4gZH0scmVtb3ZlUGxvdEJhbmRPckxpbmU6ZnVuY3Rpb24oYSl7Zm9yKHZhciBnPXRoaXMucGxvdExpbmVzQW5kQmFuZHMsZD10aGlzLm9wdGlvbnMsaz10aGlzLnVzZXJPcHRpb25zLGI9Zy5sZW5ndGg7Yi0tOylnW2JdLmlkPT09YSYmZ1tiXS5kZXN0cm95KCk7ZihbZC5wbG90TGluZXN8fFtdLGsucGxvdExpbmVzfHxbXSxkLnBsb3RCYW5kc3x8XG5bXSxrLnBsb3RCYW5kc3x8W11dLGZ1bmN0aW9uKGUpe2ZvcihiPWUubGVuZ3RoO2ItLTspZVtiXS5pZD09PWEmJmwoZSxlW2JdKX0pfSxyZW1vdmVQbG90QmFuZDpmdW5jdGlvbihhKXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGEpfSxyZW1vdmVQbG90TGluZTpmdW5jdGlvbihhKXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGEpfX0pfSkoTSxTKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5kYXRlRm9ybWF0LEE9YS5lYWNoLEY9YS5leHRlbmQsRT1hLmZvcm1hdCxtPWEuaXNOdW1iZXIsZj1hLm1hcCxsPWEubWVyZ2Uscj1hLnBpY2ssdT1hLnNwbGF0LHQ9YS5zeW5jVGltZW91dCxnPWEudGltZVVuaXRzO2EuVG9vbHRpcD1mdW5jdGlvbigpe3RoaXMuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2EuVG9vbHRpcC5wcm90b3R5cGU9e2luaXQ6ZnVuY3Rpb24oYSxrKXt0aGlzLmNoYXJ0PWE7dGhpcy5vcHRpb25zPWs7dGhpcy5jcm9zc2hhaXJzPVtdO3RoaXMubm93PXt4OjAseTowfTtcbnRoaXMuaXNIaWRkZW49ITA7dGhpcy5zcGxpdD1rLnNwbGl0JiYhYS5pbnZlcnRlZDt0aGlzLnNoYXJlZD1rLnNoYXJlZHx8dGhpcy5zcGxpdH0sY2xlYW5TcGxpdDpmdW5jdGlvbihhKXtBKHRoaXMuY2hhcnQuc2VyaWVzLGZ1bmN0aW9uKGQpe3ZhciBiPWQmJmQudHQ7YiYmKCFiLmlzQWN0aXZlfHxhP2QudHQ9Yi5kZXN0cm95KCk6Yi5pc0FjdGl2ZT0hMSl9KX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LnJlbmRlcmVyLGs9dGhpcy5vcHRpb25zO3RoaXMubGFiZWx8fCh0aGlzLnNwbGl0P3RoaXMubGFiZWw9YS5nKFwidG9vbHRpcFwiKToodGhpcy5sYWJlbD1hLmxhYmVsKFwiXCIsMCwwLGsuc2hhcGV8fFwiY2FsbG91dFwiLG51bGwsbnVsbCxrLnVzZUhUTUwsbnVsbCxcInRvb2x0aXBcIikuYXR0cih7cGFkZGluZzprLnBhZGRpbmcscjprLmJvcmRlclJhZGl1c30pLHRoaXMubGFiZWwuYXR0cih7ZmlsbDprLmJhY2tncm91bmRDb2xvcixcInN0cm9rZS13aWR0aFwiOmsuYm9yZGVyV2lkdGh9KS5jc3Moay5zdHlsZSkuc2hhZG93KGsuc2hhZG93KSksXG50aGlzLmxhYmVsLmF0dHIoe3pJbmRleDo4fSkuYWRkKCkpO3JldHVybiB0aGlzLmxhYmVsfSx1cGRhdGU6ZnVuY3Rpb24oYSl7dGhpcy5kZXN0cm95KCk7bCghMCx0aGlzLmNoYXJ0Lm9wdGlvbnMudG9vbHRpcC51c2VyT3B0aW9ucyxhKTt0aGlzLmluaXQodGhpcy5jaGFydCxsKCEwLHRoaXMub3B0aW9ucyxhKSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmxhYmVsJiYodGhpcy5sYWJlbD10aGlzLmxhYmVsLmRlc3Ryb3koKSk7dGhpcy5zcGxpdCYmdGhpcy50dCYmKHRoaXMuY2xlYW5TcGxpdCh0aGlzLmNoYXJ0LCEwKSx0aGlzLnR0PXRoaXMudHQuZGVzdHJveSgpKTtjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO2NsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KX0sbW92ZTpmdW5jdGlvbihhLGssYixlKXt2YXIgZD10aGlzLGc9ZC5ub3csbj0hMSE9PWQub3B0aW9ucy5hbmltYXRpb24mJiFkLmlzSGlkZGVuJiYoMTxNYXRoLmFicyhhLWcueCl8fDE8TWF0aC5hYnMoay1cbmcueSkpLGY9ZC5mb2xsb3dQb2ludGVyfHwxPGQubGVuO0YoZyx7eDpuPygyKmcueCthKS8zOmEseTpuPyhnLnkraykvMjprLGFuY2hvclg6Zj92b2lkIDA6bj8oMipnLmFuY2hvclgrYikvMzpiLGFuY2hvclk6Zj92b2lkIDA6bj8oZy5hbmNob3JZK2UpLzI6ZX0pO2QuZ2V0TGFiZWwoKS5hdHRyKGcpO24mJihjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCksdGhpcy50b29sdGlwVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZCYmZC5tb3ZlKGEsayxiLGUpfSwzMikpfSxoaWRlOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXM7Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTthPXIoYSx0aGlzLm9wdGlvbnMuaGlkZURlbGF5LDUwMCk7dGhpcy5pc0hpZGRlbnx8KHRoaXMuaGlkZVRpbWVyPXQoZnVuY3Rpb24oKXtkLmdldExhYmVsKClbYT9cImZhZGVPdXRcIjpcImhpZGVcIl0oKTtkLmlzSGlkZGVuPSEwfSxhKSl9LGdldEFuY2hvcjpmdW5jdGlvbihhLGspe3ZhciBiLGU9dGhpcy5jaGFydCxcbmQ9ZS5pbnZlcnRlZCxnPWUucGxvdFRvcCxuPWUucGxvdExlZnQsbD0wLG09MCxjLHI7YT11KGEpO2I9YVswXS50b29sdGlwUG9zO3RoaXMuZm9sbG93UG9pbnRlciYmayYmKHZvaWQgMD09PWsuY2hhcnRYJiYoaz1lLnBvaW50ZXIubm9ybWFsaXplKGspKSxiPVtrLmNoYXJ0WC1lLnBsb3RMZWZ0LGsuY2hhcnRZLWddKTtifHwoQShhLGZ1bmN0aW9uKGEpe2M9YS5zZXJpZXMueUF4aXM7cj1hLnNlcmllcy54QXhpcztsKz1hLnBsb3RYKyghZCYmcj9yLmxlZnQtbjowKTttKz0oYS5wbG90TG93PyhhLnBsb3RMb3crYS5wbG90SGlnaCkvMjphLnBsb3RZKSsoIWQmJmM/Yy50b3AtZzowKX0pLGwvPWEubGVuZ3RoLG0vPWEubGVuZ3RoLGI9W2Q/ZS5wbG90V2lkdGgtbTpsLHRoaXMuc2hhcmVkJiYhZCYmMTxhLmxlbmd0aCYmaz9rLmNoYXJ0WS1nOmQ/ZS5wbG90SGVpZ2h0LWw6bV0pO3JldHVybiBmKGIsTWF0aC5yb3VuZCl9LGdldFBvc2l0aW9uOmZ1bmN0aW9uKGEsZyxiKXt2YXIgZT10aGlzLmNoYXJ0LFxuZD10aGlzLmRpc3RhbmNlLGs9e30sbj1iLmh8fDAsZixsPVtcInlcIixlLmNoYXJ0SGVpZ2h0LGcsYi5wbG90WStlLnBsb3RUb3AsZS5wbG90VG9wLGUucGxvdFRvcCtlLnBsb3RIZWlnaHRdLGM9W1wieFwiLGUuY2hhcnRXaWR0aCxhLGIucGxvdFgrZS5wbG90TGVmdCxlLnBsb3RMZWZ0LGUucGxvdExlZnQrZS5wbG90V2lkdGhdLG09IXRoaXMuZm9sbG93UG9pbnRlciYmcihiLnR0QmVsb3csIWUuaW52ZXJ0ZWQ9PT0hIWIubmVnYXRpdmUpLHE9ZnVuY3Rpb24oYSxiLGMsZSxwLHEpe3ZhciBoPWM8ZS1kLGc9ZStkK2M8YixmPWUtZC1jO2UrPWQ7aWYobSYmZylrW2FdPWU7ZWxzZSBpZighbSYmaClrW2FdPWY7ZWxzZSBpZihoKWtbYV09TWF0aC5taW4ocS1jLDA+Zi1uP2Y6Zi1uKTtlbHNlIGlmKGcpa1thXT1NYXRoLm1heChwLGUrbitjPmI/ZTplK24pO2Vsc2UgcmV0dXJuITF9LEI9ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGg7ZTxkfHxlPmItZD9oPSExOmtbYV09ZTxjLzI/MTplPmItYy8yP1xuYi1jLTI6ZS1jLzI7cmV0dXJuIGh9LHQ9ZnVuY3Rpb24oYSl7dmFyIGI9bDtsPWM7Yz1iO2Y9YX0scD1mdW5jdGlvbigpeyExIT09cS5hcHBseSgwLGwpPyExIT09Qi5hcHBseSgwLGMpfHxmfHwodCghMCkscCgpKTpmP2sueD1rLnk9MDoodCghMCkscCgpKX07KGUuaW52ZXJ0ZWR8fDE8dGhpcy5sZW4pJiZ0KCk7cCgpO3JldHVybiBrfSxkZWZhdWx0Rm9ybWF0dGVyOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMucG9pbnRzfHx1KHRoaXMpLGI7Yj1bYS50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGRbMF0pXTtiPWIuY29uY2F0KGEuYm9keUZvcm1hdHRlcihkKSk7Yi5wdXNoKGEudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihkWzBdLCEwKSk7cmV0dXJuIGJ9LHJlZnJlc2g6ZnVuY3Rpb24oYSxnKXt2YXIgYixlPXRoaXMub3B0aW9ucyxkLGs9YSxuLGY9e30sbD1bXTtiPWUuZm9ybWF0dGVyfHx0aGlzLmRlZmF1bHRGb3JtYXR0ZXI7dmFyIGY9dGhpcy5zaGFyZWQsYztlLmVuYWJsZWQmJlxuKGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lciksdGhpcy5mb2xsb3dQb2ludGVyPXUoaylbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXIsbj10aGlzLmdldEFuY2hvcihrLGcpLGc9blswXSxkPW5bMV0sIWZ8fGsuc2VyaWVzJiZrLnNlcmllcy5ub1NoYXJlZFRvb2x0aXA/Zj1rLmdldExhYmVsQ29uZmlnKCk6KEEoayxmdW5jdGlvbihhKXthLnNldFN0YXRlKFwiaG92ZXJcIik7bC5wdXNoKGEuZ2V0TGFiZWxDb25maWcoKSl9KSxmPXt4OmtbMF0uY2F0ZWdvcnkseTprWzBdLnl9LGYucG9pbnRzPWwsaz1rWzBdKSx0aGlzLmxlbj1sLmxlbmd0aCxmPWIuY2FsbChmLHRoaXMpLGM9ay5zZXJpZXMsdGhpcy5kaXN0YW5jZT1yKGMudG9vbHRpcE9wdGlvbnMuZGlzdGFuY2UsMTYpLCExPT09Zj90aGlzLmhpZGUoKTooYj10aGlzLmdldExhYmVsKCksdGhpcy5pc0hpZGRlbiYmYi5hdHRyKHtvcGFjaXR5OjF9KS5zaG93KCksdGhpcy5zcGxpdD90aGlzLnJlbmRlclNwbGl0KGYsXG5hKTooZS5zdHlsZS53aWR0aHx8Yi5jc3Moe3dpZHRoOnRoaXMuY2hhcnQuc3BhY2luZ0JveC53aWR0aH0pLGIuYXR0cih7dGV4dDpmJiZmLmpvaW4/Zi5qb2luKFwiXCIpOmZ9KSxiLnJlbW92ZUNsYXNzKC9oaWdoY2hhcnRzLWNvbG9yLVtcXGRdKy9nKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtY29sb3ItXCIrcihrLmNvbG9ySW5kZXgsYy5jb2xvckluZGV4KSksYi5hdHRyKHtzdHJva2U6ZS5ib3JkZXJDb2xvcnx8ay5jb2xvcnx8Yy5jb2xvcnx8XCIjNjY2NjY2XCJ9KSx0aGlzLnVwZGF0ZVBvc2l0aW9uKHtwbG90WDpnLHBsb3RZOmQsbmVnYXRpdmU6ay5uZWdhdGl2ZSx0dEJlbG93OmsudHRCZWxvdyxoOm5bMl18fDB9KSksdGhpcy5pc0hpZGRlbj0hMSkpfSxyZW5kZXJTcGxpdDpmdW5jdGlvbihkLGspe3ZhciBiPXRoaXMsZT1bXSxnPXRoaXMuY2hhcnQsZj1nLnJlbmRlcmVyLG49ITAsbD10aGlzLm9wdGlvbnMsbT0wLGM9dGhpcy5nZXRMYWJlbCgpO0EoZC5zbGljZSgwLGsubGVuZ3RoKzEpLFxuZnVuY3Rpb24oYSxkKXtpZighMSE9PWEpe2Q9a1tkLTFdfHx7aXNIZWFkZXI6ITAscGxvdFg6a1swXS5wbG90WH07dmFyIHE9ZC5zZXJpZXN8fGIsdj1xLnR0LHA9ZC5zZXJpZXN8fHt9LHo9XCJoaWdoY2hhcnRzLWNvbG9yLVwiK3IoZC5jb2xvckluZGV4LHAuY29sb3JJbmRleCxcIm5vbmVcIik7dnx8KHEudHQ9dj1mLmxhYmVsKG51bGwsbnVsbCxudWxsLFwiY2FsbG91dFwiKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdG9vbHRpcC1ib3ggXCIreikuYXR0cih7cGFkZGluZzpsLnBhZGRpbmcscjpsLmJvcmRlclJhZGl1cyxmaWxsOmwuYmFja2dyb3VuZENvbG9yLHN0cm9rZTpsLmJvcmRlckNvbG9yfHxkLmNvbG9yfHxwLmNvbG9yfHxcIiMzMzMzMzNcIixcInN0cm9rZS13aWR0aFwiOmwuYm9yZGVyV2lkdGh9KS5hZGQoYykpO3YuaXNBY3RpdmU9ITA7di5hdHRyKHt0ZXh0OmF9KTt2LmNzcyhsLnN0eWxlKS5zaGFkb3cobC5zaGFkb3cpO2E9di5nZXRCQm94KCk7cD1hLndpZHRoK3Yuc3Ryb2tlV2lkdGgoKTtcbmQuaXNIZWFkZXI/KG09YS5oZWlnaHQscD1NYXRoLm1heCgwLE1hdGgubWluKGQucGxvdFgrZy5wbG90TGVmdC1wLzIsZy5jaGFydFdpZHRoLXApKSk6cD1kLnBsb3RYK2cucGxvdExlZnQtcihsLmRpc3RhbmNlLDE2KS1wOzA+cCYmKG49ITEpO2E9KGQuc2VyaWVzJiZkLnNlcmllcy55QXhpcyYmZC5zZXJpZXMueUF4aXMucG9zKSsoZC5wbG90WXx8MCk7YS09Zy5wbG90VG9wO2UucHVzaCh7dGFyZ2V0OmQuaXNIZWFkZXI/Zy5wbG90SGVpZ2h0K206YSxyYW5rOmQuaXNIZWFkZXI/MTowLHNpemU6cS50dC5nZXRCQm94KCkuaGVpZ2h0KzEscG9pbnQ6ZCx4OnAsdHQ6dn0pfX0pO3RoaXMuY2xlYW5TcGxpdCgpO2EuZGlzdHJpYnV0ZShlLGcucGxvdEhlaWdodCttKTtBKGUsZnVuY3Rpb24oYSl7dmFyIGI9YS5wb2ludCxjPWIuc2VyaWVzO2EudHQuYXR0cih7dmlzaWJpbGl0eTp2b2lkIDA9PT1hLnBvcz9cImhpZGRlblwiOlwiaW5oZXJpdFwiLHg6bnx8Yi5pc0hlYWRlcj9hLng6Yi5wbG90WCtcbmcucGxvdExlZnQrcihsLmRpc3RhbmNlLDE2KSx5OmEucG9zK2cucGxvdFRvcCxhbmNob3JYOmIuaXNIZWFkZXI/Yi5wbG90WCtnLnBsb3RMZWZ0OmIucGxvdFgrYy54QXhpcy5wb3MsYW5jaG9yWTpiLmlzSGVhZGVyP2EucG9zK2cucGxvdFRvcC0xNTpiLnBsb3RZK2MueUF4aXMucG9zfSl9KX0sdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5jaGFydCxiPXRoaXMuZ2V0TGFiZWwoKSxiPSh0aGlzLm9wdGlvbnMucG9zaXRpb25lcnx8dGhpcy5nZXRQb3NpdGlvbikuY2FsbCh0aGlzLGIud2lkdGgsYi5oZWlnaHQsYSk7dGhpcy5tb3ZlKE1hdGgucm91bmQoYi54KSxNYXRoLnJvdW5kKGIueXx8MCksYS5wbG90WCtkLnBsb3RMZWZ0LGEucGxvdFkrZC5wbG90VG9wKX0sZ2V0RGF0ZUZvcm1hdDpmdW5jdGlvbihhLGssYixlKXt2YXIgZD1DKFwiJW0tJWQgJUg6JU06JVMuJUxcIixrKSxmLG4sbD17bWlsbGlzZWNvbmQ6MTUsc2Vjb25kOjEyLG1pbnV0ZTo5LGhvdXI6NixkYXk6M30sXG5tPVwibWlsbGlzZWNvbmRcIjtmb3IobiBpbiBnKXtpZihhPT09Zy53ZWVrJiYrQyhcIiV3XCIsayk9PT1iJiZcIjAwOjAwOjAwLjAwMFwiPT09ZC5zdWJzdHIoNikpe249XCJ3ZWVrXCI7YnJlYWt9aWYoZ1tuXT5hKXtuPW07YnJlYWt9aWYobFtuXSYmZC5zdWJzdHIobFtuXSkhPT1cIjAxLTAxIDAwOjAwOjAwLjAwMFwiLnN1YnN0cihsW25dKSlicmVhaztcIndlZWtcIiE9PW4mJihtPW4pfW4mJihmPWVbbl0pO3JldHVybiBmfSxnZXRYRGF0ZUZvcm1hdDpmdW5jdGlvbihhLGcsYil7Zz1nLmRhdGVUaW1lTGFiZWxGb3JtYXRzO3ZhciBlPWImJmIuY2xvc2VzdFBvaW50UmFuZ2U7cmV0dXJuKGU/dGhpcy5nZXREYXRlRm9ybWF0KGUsYS54LGIub3B0aW9ucy5zdGFydE9mV2VlayxnKTpnLmRheSl8fGcueWVhcn0sdG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcjpmdW5jdGlvbihhLGcpe3ZhciBiPWc/XCJmb290ZXJcIjpcImhlYWRlclwiO2c9YS5zZXJpZXM7dmFyIGU9Zy50b29sdGlwT3B0aW9ucyxkPWUueERhdGVGb3JtYXQsXG5rPWcueEF4aXMsbj1rJiZcImRhdGV0aW1lXCI9PT1rLm9wdGlvbnMudHlwZSYmbShhLmtleSksYj1lW2IrXCJGb3JtYXRcIl07biYmIWQmJihkPXRoaXMuZ2V0WERhdGVGb3JtYXQoYSxlLGspKTtuJiZkJiYoYj1iLnJlcGxhY2UoXCJ7cG9pbnQua2V5fVwiLFwie3BvaW50LmtleTpcIitkK1wifVwiKSk7cmV0dXJuIEUoYix7cG9pbnQ6YSxzZXJpZXM6Z30pfSxib2R5Rm9ybWF0dGVyOmZ1bmN0aW9uKGEpe3JldHVybiBmKGEsZnVuY3Rpb24oYSl7dmFyIGI9YS5zZXJpZXMudG9vbHRpcE9wdGlvbnM7cmV0dXJuKGIucG9pbnRGb3JtYXR0ZXJ8fGEucG9pbnQudG9vbHRpcEZvcm1hdHRlcikuY2FsbChhLnBvaW50LGIucG9pbnRGb3JtYXQpfSl9fX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1hLmFkZEV2ZW50LEE9YS5hdHRyLEY9YS5jaGFydHMsRT1hLmNvbG9yLG09YS5jc3MsZj1hLmRlZmluZWQsbD1hLmVhY2gscj1hLmV4dGVuZCx1PWEuZmluZCx0PWEuZmlyZUV2ZW50LGc9YS5pc09iamVjdCxkPWEub2Zmc2V0LFxuaz1hLnBpY2ssYj1hLnJlbW92ZUV2ZW50LGU9YS5zcGxhdCx2PWEuVG9vbHRpcCx5PWEud2luO2EuUG9pbnRlcj1mdW5jdGlvbihhLGIpe3RoaXMuaW5pdChhLGIpfTthLlBvaW50ZXIucHJvdG90eXBlPXtpbml0OmZ1bmN0aW9uKGEsYil7dGhpcy5vcHRpb25zPWI7dGhpcy5jaGFydD1hO3RoaXMucnVuQ2hhcnRDbGljaz1iLmNoYXJ0LmV2ZW50cyYmISFiLmNoYXJ0LmV2ZW50cy5jbGljazt0aGlzLnBpbmNoRG93bj1bXTt0aGlzLmxhc3RWYWxpZFRvdWNoPXt9O3YmJihhLnRvb2x0aXA9bmV3IHYoYSxiLnRvb2x0aXApLHRoaXMuZm9sbG93VG91Y2hNb3ZlPWsoYi50b29sdGlwLmZvbGxvd1RvdWNoTW92ZSwhMCkpO3RoaXMuc2V0RE9NRXZlbnRzKCl9LHpvb21PcHRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxlPWIub3B0aW9ucy5jaGFydCxjPWUuem9vbVR5cGV8fFwiXCIsYj1iLmludmVydGVkOy90b3VjaC8udGVzdChhLnR5cGUpJiYoYz1rKGUucGluY2hUeXBlLGMpKTtcbnRoaXMuem9vbVg9YT0veC8udGVzdChjKTt0aGlzLnpvb21ZPWM9L3kvLnRlc3QoYyk7dGhpcy56b29tSG9yPWEmJiFifHxjJiZiO3RoaXMuem9vbVZlcnQ9YyYmIWJ8fGEmJmI7dGhpcy5oYXNab29tPWF8fGN9LG5vcm1hbGl6ZTpmdW5jdGlvbihhLGIpe3ZhciBlLGM7YT1hfHx5LmV2ZW50O2EudGFyZ2V0fHwoYS50YXJnZXQ9YS5zcmNFbGVtZW50KTtjPWEudG91Y2hlcz9hLnRvdWNoZXMubGVuZ3RoP2EudG91Y2hlcy5pdGVtKDApOmEuY2hhbmdlZFRvdWNoZXNbMF06YTtifHwodGhpcy5jaGFydFBvc2l0aW9uPWI9ZCh0aGlzLmNoYXJ0LmNvbnRhaW5lcikpO3ZvaWQgMD09PWMucGFnZVg/KGU9TWF0aC5tYXgoYS54LGEuY2xpZW50WC1iLmxlZnQpLGI9YS55KTooZT1jLnBhZ2VYLWIubGVmdCxiPWMucGFnZVktYi50b3ApO3JldHVybiByKGEse2NoYXJ0WDpNYXRoLnJvdW5kKGUpLGNoYXJ0WTpNYXRoLnJvdW5kKGIpfSl9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKGEpe3ZhciBiPVxue3hBeGlzOltdLHlBeGlzOltdfTtsKHRoaXMuY2hhcnQuYXhlcyxmdW5jdGlvbihlKXtiW2UuaXNYQXhpcz9cInhBeGlzXCI6XCJ5QXhpc1wiXS5wdXNoKHtheGlzOmUsdmFsdWU6ZS50b1ZhbHVlKGFbZS5ob3Jpej9cImNoYXJ0WFwiOlwiY2hhcnRZXCJdKX0pfSk7cmV0dXJuIGJ9LGZpbmROZWFyZXN0S0RQb2ludDpmdW5jdGlvbihhLGIsZSl7dmFyIGM7bChhLGZ1bmN0aW9uKGEpe3ZhciBkPSEoYS5ub1NoYXJlZFRvb2x0aXAmJmIpJiYwPmEub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik7YT1hLnNlYXJjaFBvaW50KGUsZCk7aWYoKGQ9ZyhhLCEwKSkmJiEoZD0hZyhjLCEwKSkpdmFyIGQ9Yy5kaXN0WC1hLmRpc3RYLG49Yy5kaXN0LWEuZGlzdCxrPShhLnNlcmllcy5ncm91cCYmYS5zZXJpZXMuZ3JvdXAuekluZGV4KS0oYy5zZXJpZXMuZ3JvdXAmJmMuc2VyaWVzLmdyb3VwLnpJbmRleCksZD0wPCgwIT09ZCYmYj9kOjAhPT1uP246MCE9PWs/azpjLnNlcmllcy5pbmRleD5cbmEuc2VyaWVzLmluZGV4Py0xOjEpO2QmJihjPWEpfSk7cmV0dXJuIGN9LGdldFBvaW50RnJvbUV2ZW50OmZ1bmN0aW9uKGEpe2E9YS50YXJnZXQ7Zm9yKHZhciBiO2EmJiFiOyliPWEucG9pbnQsYT1hLnBhcmVudE5vZGU7cmV0dXJuIGJ9LGdldENoYXJ0Q29vcmRpbmF0ZXNGcm9tUG9pbnQ6ZnVuY3Rpb24oYSxiKXt2YXIgZT1hLnNlcmllcyxjPWUueEF4aXMsZT1lLnlBeGlzO2lmKGMmJmUpcmV0dXJuIGI/e2NoYXJ0WDpjLmxlbitjLnBvcy1hLmNsaWVudFgsY2hhcnRZOmUubGVuK2UucG9zLWEucGxvdFl9OntjaGFydFg6YS5jbGllbnRYK2MucG9zLGNoYXJ0WTphLnBsb3RZK2UucG9zfX0sZ2V0SG92ZXJEYXRhOmZ1bmN0aW9uKGIsZSxkLGMsZixxKXt2YXIgbix2PVtdO2M9ISghY3x8IWIpO3ZhciBwPWUmJiFlLnN0aWNreVRyYWNraW5nP1tlXTphLmdyZXAoZCxmdW5jdGlvbihhKXtyZXR1cm4gYS52aXNpYmxlJiYhKCFmJiZhLmRpcmVjdFRvdWNoKSYmayhhLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZyxcbiEwKSYmYS5zdGlja3lUcmFja2luZ30pO2U9KG49Yz9iOnRoaXMuZmluZE5lYXJlc3RLRFBvaW50KHAsZixxKSkmJm4uc2VyaWVzO24mJihmJiYhZS5ub1NoYXJlZFRvb2x0aXA/KHA9YS5ncmVwKGQsZnVuY3Rpb24oYSl7cmV0dXJuIGEudmlzaWJsZSYmISghZiYmYS5kaXJlY3RUb3VjaCkmJmsoYS5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcsITApJiYhYS5ub1NoYXJlZFRvb2x0aXB9KSxsKHAsZnVuY3Rpb24oYSl7YT11KGEucG9pbnRzLGZ1bmN0aW9uKGEpe3JldHVybiBhLng9PT1uLnh9KTtnKGEpJiYhYS5pc051bGwmJnYucHVzaChhKX0pKTp2LnB1c2gobikpO3JldHVybntob3ZlclBvaW50Om4saG92ZXJTZXJpZXM6ZSxob3ZlclBvaW50czp2fX0scnVuUG9pbnRBY3Rpb25zOmZ1bmN0aW9uKGIsZSl7dmFyIGQ9dGhpcy5jaGFydCxjPWQudG9vbHRpcCxnPWM/Yy5zaGFyZWQ6ITEsbj1lfHxkLmhvdmVyUG9pbnQsZj1uJiZuLnNlcmllc3x8ZC5ob3ZlclNlcmllcyxmPXRoaXMuZ2V0SG92ZXJEYXRhKG4sXG5mLGQuc2VyaWVzLCEhZXx8ZiYmZi5kaXJlY3RUb3VjaCYmdGhpcy5pc0RpcmVjdFRvdWNoLGcsYiksdixuPWYuaG92ZXJQb2ludDt2PWYuaG92ZXJQb2ludHM7ZT0oZj1mLmhvdmVyU2VyaWVzKSYmZi50b29sdGlwT3B0aW9ucy5mb2xsb3dQb2ludGVyO2c9ZyYmZiYmIWYubm9TaGFyZWRUb29sdGlwO2lmKG4mJihuIT09ZC5ob3ZlclBvaW50fHxjJiZjLmlzSGlkZGVuKSl7bChkLmhvdmVyUG9pbnRzfHxbXSxmdW5jdGlvbihiKXstMT09PWEuaW5BcnJheShiLHYpJiZiLnNldFN0YXRlKCl9KTtsKHZ8fFtdLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoXCJob3ZlclwiKX0pO2lmKGQuaG92ZXJTZXJpZXMhPT1mKWYub25Nb3VzZU92ZXIoKTtkLmhvdmVyUG9pbnQmJmQuaG92ZXJQb2ludC5maXJlUG9pbnRFdmVudChcIm1vdXNlT3V0XCIpO24uZmlyZVBvaW50RXZlbnQoXCJtb3VzZU92ZXJcIik7ZC5ob3ZlclBvaW50cz12O2QuaG92ZXJQb2ludD1uO2MmJmMucmVmcmVzaChnP3Y6bixiKX1lbHNlIGUmJlxuYyYmIWMuaXNIaWRkZW4mJihuPWMuZ2V0QW5jaG9yKFt7fV0sYiksYy51cGRhdGVQb3NpdGlvbih7cGxvdFg6blswXSxwbG90WTpuWzFdfSkpO3RoaXMudW5Eb2NNb3VzZU1vdmV8fCh0aGlzLnVuRG9jTW91c2VNb3ZlPUMoZC5jb250YWluZXIub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKGIpe3ZhciBjPUZbYS5ob3ZlckNoYXJ0SW5kZXhdO2lmKGMpYy5wb2ludGVyLm9uRG9jdW1lbnRNb3VzZU1vdmUoYil9KSk7bChkLmF4ZXMsZnVuY3Rpb24oYyl7dmFyIGU9ayhjLmNyb3NzaGFpci5zbmFwLCEwKSxwPWU/YS5maW5kKHYsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2VyaWVzW2MuY29sbF09PT1jfSk6dm9pZCAwO3B8fCFlP2MuZHJhd0Nyb3NzaGFpcihiLHApOmMuaGlkZUNyb3NzaGFpcigpfSl9LHJlc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGQ9dGhpcy5jaGFydCxjPWQuaG92ZXJTZXJpZXMsZz1kLmhvdmVyUG9pbnQsbj1kLmhvdmVyUG9pbnRzLGY9ZC50b29sdGlwLGs9XG5mJiZmLnNoYXJlZD9uOmc7YSYmayYmbChlKGspLGZ1bmN0aW9uKGIpe2Iuc2VyaWVzLmlzQ2FydGVzaWFuJiZ2b2lkIDA9PT1iLnBsb3RYJiYoYT0hMSl9KTtpZihhKWYmJmsmJihmLnJlZnJlc2goayksZyYmKGcuc2V0U3RhdGUoZy5zdGF0ZSwhMCksbChkLmF4ZXMsZnVuY3Rpb24oYSl7YS5jcm9zc2hhaXImJmEuZHJhd0Nyb3NzaGFpcihudWxsLGcpfSkpKTtlbHNle2lmKGcpZy5vbk1vdXNlT3V0KCk7biYmbChuLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoKX0pO2lmKGMpYy5vbk1vdXNlT3V0KCk7ZiYmZi5oaWRlKGIpO3RoaXMudW5Eb2NNb3VzZU1vdmUmJih0aGlzLnVuRG9jTW91c2VNb3ZlPXRoaXMudW5Eb2NNb3VzZU1vdmUoKSk7bChkLmF4ZXMsZnVuY3Rpb24oYSl7YS5oaWRlQ3Jvc3NoYWlyKCl9KTt0aGlzLmhvdmVyWD1kLmhvdmVyUG9pbnRzPWQuaG92ZXJQb2ludD1udWxsfX0sc2NhbGVHcm91cHM6ZnVuY3Rpb24oYSxiKXt2YXIgZT10aGlzLmNoYXJ0LGM7bChlLnNlcmllcyxcbmZ1bmN0aW9uKGQpe2M9YXx8ZC5nZXRQbG90Qm94KCk7ZC54QXhpcyYmZC54QXhpcy56b29tRW5hYmxlZCYmZC5ncm91cCYmKGQuZ3JvdXAuYXR0cihjKSxkLm1hcmtlckdyb3VwJiYoZC5tYXJrZXJHcm91cC5hdHRyKGMpLGQubWFya2VyR3JvdXAuY2xpcChiP2UuY2xpcFJlY3Q6bnVsbCkpLGQuZGF0YUxhYmVsc0dyb3VwJiZkLmRhdGFMYWJlbHNHcm91cC5hdHRyKGMpKX0pO2UuY2xpcFJlY3QuYXR0cihifHxlLmNsaXBCb3gpfSxkcmFnU3RhcnQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydDtiLm1vdXNlSXNEb3duPWEudHlwZTtiLmNhbmNlbENsaWNrPSExO2IubW91c2VEb3duWD10aGlzLm1vdXNlRG93blg9YS5jaGFydFg7Yi5tb3VzZURvd25ZPXRoaXMubW91c2VEb3duWT1hLmNoYXJ0WX0sZHJhZzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGU9Yi5vcHRpb25zLmNoYXJ0LGM9YS5jaGFydFgsZD1hLmNoYXJ0WSxnPXRoaXMuem9vbUhvcixuPXRoaXMuem9vbVZlcnQsXG5mPWIucGxvdExlZnQscD1iLnBsb3RUb3Asaz1iLnBsb3RXaWR0aCx2PWIucGxvdEhlaWdodCxsLGg9dGhpcy5zZWxlY3Rpb25NYXJrZXIsdz10aGlzLm1vdXNlRG93blgsbT10aGlzLm1vdXNlRG93blkscj1lLnBhbktleSYmYVtlLnBhbktleStcIktleVwiXTtoJiZoLnRvdWNofHwoYzxmP2M9ZjpjPmYrayYmKGM9ZitrKSxkPHA/ZD1wOmQ+cCt2JiYoZD1wK3YpLHRoaXMuaGFzRHJhZ2dlZD1NYXRoLnNxcnQoTWF0aC5wb3cody1jLDIpK01hdGgucG93KG0tZCwyKSksMTA8dGhpcy5oYXNEcmFnZ2VkJiYobD1iLmlzSW5zaWRlUGxvdCh3LWYsbS1wKSxiLmhhc0NhcnRlc2lhblNlcmllcyYmKHRoaXMuem9vbVh8fHRoaXMuem9vbVkpJiZsJiYhciYmIWgmJih0aGlzLnNlbGVjdGlvbk1hcmtlcj1oPWIucmVuZGVyZXIucmVjdChmLHAsZz8xOmssbj8xOnYsMCkuYXR0cih7ZmlsbDplLnNlbGVjdGlvbk1hcmtlckZpbGx8fEUoXCIjMzM1Y2FkXCIpLnNldE9wYWNpdHkoLjI1KS5nZXQoKSxcImNsYXNzXCI6XCJoaWdoY2hhcnRzLXNlbGVjdGlvbi1tYXJrZXJcIixcbnpJbmRleDo3fSkuYWRkKCkpLGgmJmcmJihjLT13LGguYXR0cih7d2lkdGg6TWF0aC5hYnMoYykseDooMDxjPzA6Yykrd30pKSxoJiZuJiYoYz1kLW0saC5hdHRyKHtoZWlnaHQ6TWF0aC5hYnMoYykseTooMDxjPzA6YykrbX0pKSxsJiYhaCYmZS5wYW5uaW5nJiZiLnBhbihhLGUucGFubmluZykpKX0sZHJvcDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGU9dGhpcy5jaGFydCxjPXRoaXMuaGFzUGluY2hlZDtpZih0aGlzLnNlbGVjdGlvbk1hcmtlcil7dmFyIGQ9e29yaWdpbmFsRXZlbnQ6YSx4QXhpczpbXSx5QXhpczpbXX0sZz10aGlzLnNlbGVjdGlvbk1hcmtlcixuPWcuYXR0cj9nLmF0dHIoXCJ4XCIpOmcueCxrPWcuYXR0cj9nLmF0dHIoXCJ5XCIpOmcueSxwPWcuYXR0cj9nLmF0dHIoXCJ3aWR0aFwiKTpnLndpZHRoLHY9Zy5hdHRyP2cuYXR0cihcImhlaWdodFwiKTpnLmhlaWdodCxJO2lmKHRoaXMuaGFzRHJhZ2dlZHx8YylsKGUuYXhlcyxmdW5jdGlvbihlKXtpZihlLnpvb21FbmFibGVkJiZmKGUubWluKSYmXG4oY3x8Ylt7eEF4aXM6XCJ6b29tWFwiLHlBeGlzOlwiem9vbVlcIn1bZS5jb2xsXV0pKXt2YXIgaD1lLmhvcml6LGc9XCJ0b3VjaGVuZFwiPT09YS50eXBlP2UubWluUGl4ZWxQYWRkaW5nOjAscT1lLnRvVmFsdWUoKGg/bjprKStnKSxoPWUudG9WYWx1ZSgoaD9uK3A6ayt2KS1nKTtkW2UuY29sbF0ucHVzaCh7YXhpczplLG1pbjpNYXRoLm1pbihxLGgpLG1heDpNYXRoLm1heChxLGgpfSk7ST0hMH19KSxJJiZ0KGUsXCJzZWxlY3Rpb25cIixkLGZ1bmN0aW9uKGEpe2Uuem9vbShyKGEsYz97YW5pbWF0aW9uOiExfTpudWxsKSl9KTt0aGlzLnNlbGVjdGlvbk1hcmtlcj10aGlzLnNlbGVjdGlvbk1hcmtlci5kZXN0cm95KCk7YyYmdGhpcy5zY2FsZUdyb3VwcygpfWUmJihtKGUuY29udGFpbmVyLHtjdXJzb3I6ZS5fY3Vyc29yfSksZS5jYW5jZWxDbGljaz0xMDx0aGlzLmhhc0RyYWdnZWQsZS5tb3VzZUlzRG93bj10aGlzLmhhc0RyYWdnZWQ9dGhpcy5oYXNQaW5jaGVkPSExLHRoaXMucGluY2hEb3duPVxuW10pfSxvbkNvbnRhaW5lck1vdXNlRG93bjpmdW5jdGlvbihhKXthPXRoaXMubm9ybWFsaXplKGEpO3RoaXMuem9vbU9wdGlvbihhKTthLnByZXZlbnREZWZhdWx0JiZhLnByZXZlbnREZWZhdWx0KCk7dGhpcy5kcmFnU3RhcnQoYSl9LG9uRG9jdW1lbnRNb3VzZVVwOmZ1bmN0aW9uKGIpe0ZbYS5ob3ZlckNoYXJ0SW5kZXhdJiZGW2EuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoYil9LG9uRG9jdW1lbnRNb3VzZU1vdmU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxlPXRoaXMuY2hhcnRQb3NpdGlvbjthPXRoaXMubm9ybWFsaXplKGEsZSk7IWV8fHRoaXMuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKXx8Yi5pc0luc2lkZVBsb3QoYS5jaGFydFgtYi5wbG90TGVmdCxhLmNoYXJ0WS1iLnBsb3RUb3ApfHx0aGlzLnJlc2V0KCl9LG9uQ29udGFpbmVyTW91c2VMZWF2ZTpmdW5jdGlvbihiKXt2YXIgZT1GW2EuaG92ZXJDaGFydEluZGV4XTtlJiYoYi5yZWxhdGVkVGFyZ2V0fHxcbmIudG9FbGVtZW50KSYmKGUucG9pbnRlci5yZXNldCgpLGUucG9pbnRlci5jaGFydFBvc2l0aW9uPW51bGwpfSxvbkNvbnRhaW5lck1vdXNlTW92ZTpmdW5jdGlvbihiKXt2YXIgZT10aGlzLmNoYXJ0O2YoYS5ob3ZlckNoYXJ0SW5kZXgpJiZGW2EuaG92ZXJDaGFydEluZGV4XSYmRlthLmhvdmVyQ2hhcnRJbmRleF0ubW91c2VJc0Rvd258fChhLmhvdmVyQ2hhcnRJbmRleD1lLmluZGV4KTtiPXRoaXMubm9ybWFsaXplKGIpO2IucmV0dXJuVmFsdWU9ITE7XCJtb3VzZWRvd25cIj09PWUubW91c2VJc0Rvd24mJnRoaXMuZHJhZyhiKTshdGhpcy5pbkNsYXNzKGIudGFyZ2V0LFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpJiYhZS5pc0luc2lkZVBsb3QoYi5jaGFydFgtZS5wbG90TGVmdCxiLmNoYXJ0WS1lLnBsb3RUb3ApfHxlLm9wZW5NZW51fHx0aGlzLnJ1blBvaW50QWN0aW9ucyhiKX0saW5DbGFzczpmdW5jdGlvbihhLGIpe2Zvcih2YXIgZTthOyl7aWYoZT1BKGEsXCJjbGFzc1wiKSl7aWYoLTEhPT1cbmUuaW5kZXhPZihiKSlyZXR1cm4hMDtpZigtMSE9PWUuaW5kZXhPZihcImhpZ2hjaGFydHMtY29udGFpbmVyXCIpKXJldHVybiExfWE9YS5wYXJlbnROb2RlfX0sb25UcmFja2VyTW91c2VPdXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydC5ob3ZlclNlcmllczthPWEucmVsYXRlZFRhcmdldHx8YS50b0VsZW1lbnQ7dGhpcy5pc0RpcmVjdFRvdWNoPSExO2lmKCEoIWJ8fCFhfHxiLnN0aWNreVRyYWNraW5nfHx0aGlzLmluQ2xhc3MoYSxcImhpZ2hjaGFydHMtdG9vbHRpcFwiKXx8dGhpcy5pbkNsYXNzKGEsXCJoaWdoY2hhcnRzLXNlcmllcy1cIitiLmluZGV4KSYmdGhpcy5pbkNsYXNzKGEsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikpKWIub25Nb3VzZU91dCgpfSxvbkNvbnRhaW5lckNsaWNrOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsZT1iLmhvdmVyUG9pbnQsYz1iLnBsb3RMZWZ0LGQ9Yi5wbG90VG9wO2E9dGhpcy5ub3JtYWxpemUoYSk7Yi5jYW5jZWxDbGlja3x8KGUmJnRoaXMuaW5DbGFzcyhhLnRhcmdldCxcblwiaGlnaGNoYXJ0cy10cmFja2VyXCIpPyh0KGUuc2VyaWVzLFwiY2xpY2tcIixyKGEse3BvaW50OmV9KSksYi5ob3ZlclBvaW50JiZlLmZpcmVQb2ludEV2ZW50KFwiY2xpY2tcIixhKSk6KHIoYSx0aGlzLmdldENvb3JkaW5hdGVzKGEpKSxiLmlzSW5zaWRlUGxvdChhLmNoYXJ0WC1jLGEuY2hhcnRZLWQpJiZ0KGIsXCJjbGlja1wiLGEpKSl9LHNldERPTUV2ZW50czpmdW5jdGlvbigpe3ZhciBiPXRoaXMsZT1iLmNoYXJ0LmNvbnRhaW5lcixkPWUub3duZXJEb2N1bWVudDtlLm9ubW91c2Vkb3duPWZ1bmN0aW9uKGEpe2Iub25Db250YWluZXJNb3VzZURvd24oYSl9O2Uub25tb3VzZW1vdmU9ZnVuY3Rpb24oYSl7Yi5vbkNvbnRhaW5lck1vdXNlTW92ZShhKX07ZS5vbmNsaWNrPWZ1bmN0aW9uKGEpe2Iub25Db250YWluZXJDbGljayhhKX07QyhlLFwibW91c2VsZWF2ZVwiLGIub25Db250YWluZXJNb3VzZUxlYXZlKTsxPT09YS5jaGFydENvdW50JiZDKGQsXCJtb3VzZXVwXCIsYi5vbkRvY3VtZW50TW91c2VVcCk7XG5hLmhhc1RvdWNoJiYoZS5vbnRvdWNoc3RhcnQ9ZnVuY3Rpb24oYSl7Yi5vbkNvbnRhaW5lclRvdWNoU3RhcnQoYSl9LGUub250b3VjaG1vdmU9ZnVuY3Rpb24oYSl7Yi5vbkNvbnRhaW5lclRvdWNoTW92ZShhKX0sMT09PWEuY2hhcnRDb3VudCYmQyhkLFwidG91Y2hlbmRcIixiLm9uRG9jdW1lbnRUb3VjaEVuZCkpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxkPXRoaXMuY2hhcnQuY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7ZS51bkRvY01vdXNlTW92ZSYmZS51bkRvY01vdXNlTW92ZSgpO2IoZS5jaGFydC5jb250YWluZXIsXCJtb3VzZWxlYXZlXCIsZS5vbkNvbnRhaW5lck1vdXNlTGVhdmUpO2EuY2hhcnRDb3VudHx8KGIoZCxcIm1vdXNldXBcIixlLm9uRG9jdW1lbnRNb3VzZVVwKSxhLmhhc1RvdWNoJiZiKGQsXCJ0b3VjaGVuZFwiLGUub25Eb2N1bWVudFRvdWNoRW5kKSk7Y2xlYXJJbnRlcnZhbChlLnRvb2x0aXBUaW1lb3V0KTthLm9iamVjdEVhY2goZSxmdW5jdGlvbihhLGIpe2VbYl09XG5udWxsfSl9fX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1hLmNoYXJ0cyxBPWEuZWFjaCxGPWEuZXh0ZW5kLEU9YS5tYXAsbT1hLm5vb3AsZj1hLnBpY2s7RihhLlBvaW50ZXIucHJvdG90eXBlLHtwaW5jaFRyYW5zbGF0ZTpmdW5jdGlvbihhLGYsbSx0LGcsZCl7dGhpcy56b29tSG9yJiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCEwLGEsZixtLHQsZyxkKTt0aGlzLnpvb21WZXJ0JiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCExLGEsZixtLHQsZyxkKX0scGluY2hUcmFuc2xhdGVEaXJlY3Rpb246ZnVuY3Rpb24oYSxmLG0sdCxnLGQsayxiKXt2YXIgZT10aGlzLmNoYXJ0LHY9YT9cInhcIjpcInlcIixsPWE/XCJYXCI6XCJZXCIsbj1cImNoYXJ0XCIrbCxyPWE/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsdT1lW1wicGxvdFwiKyhhP1wiTGVmdFwiOlwiVG9wXCIpXSxjLEcscT1ifHwxLEI9ZS5pbnZlcnRlZCxLPWUuYm91bmRzW2E/XCJoXCI6XCJ2XCJdLHA9MT09PWYubGVuZ3RoLHo9ZlswXVtuXSxJPW1bMF1bbl0sXG5MPSFwJiZmWzFdW25dLGg9IXAmJm1bMV1bbl0sdzttPWZ1bmN0aW9uKCl7IXAmJjIwPE1hdGguYWJzKHotTCkmJihxPWJ8fE1hdGguYWJzKEktaCkvTWF0aC5hYnMoei1MKSk7Rz0odS1JKS9xK3o7Yz1lW1wicGxvdFwiKyhhP1wiV2lkdGhcIjpcIkhlaWdodFwiKV0vcX07bSgpO2Y9RztmPEsubWluPyhmPUsubWluLHc9ITApOmYrYz5LLm1heCYmKGY9Sy5tYXgtYyx3PSEwKTt3PyhJLT0uOCooSS1rW3ZdWzBdKSxwfHwoaC09LjgqKGgta1t2XVsxXSkpLG0oKSk6a1t2XT1bSSxoXTtCfHwoZFt2XT1HLXUsZFtyXT1jKTtkPUI/MS9xOnE7Z1tyXT1jO2dbdl09Zjt0W0I/YT9cInNjYWxlWVwiOlwic2NhbGVYXCI6XCJzY2FsZVwiK2xdPXE7dFtcInRyYW5zbGF0ZVwiK2xdPWQqdSsoSS1kKnopfSxwaW5jaDpmdW5jdGlvbihhKXt2YXIgbD10aGlzLHU9bC5jaGFydCx0PWwucGluY2hEb3duLGc9YS50b3VjaGVzLGQ9Zy5sZW5ndGgsaz1sLmxhc3RWYWxpZFRvdWNoLGI9bC5oYXNab29tLGU9bC5zZWxlY3Rpb25NYXJrZXIsXG52PXt9LHk9MT09PWQmJihsLmluQ2xhc3MoYS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikmJnUucnVuVHJhY2tlckNsaWNrfHxsLnJ1bkNoYXJ0Q2xpY2spLG49e307MTxkJiYobC5pbml0aWF0ZWQ9ITApO2ImJmwuaW5pdGlhdGVkJiYheSYmYS5wcmV2ZW50RGVmYXVsdCgpO0UoZyxmdW5jdGlvbihhKXtyZXR1cm4gbC5ub3JtYWxpemUoYSl9KTtcInRvdWNoc3RhcnRcIj09PWEudHlwZT8oQShnLGZ1bmN0aW9uKGEsYil7dFtiXT17Y2hhcnRYOmEuY2hhcnRYLGNoYXJ0WTphLmNoYXJ0WX19KSxrLng9W3RbMF0uY2hhcnRYLHRbMV0mJnRbMV0uY2hhcnRYXSxrLnk9W3RbMF0uY2hhcnRZLHRbMV0mJnRbMV0uY2hhcnRZXSxBKHUuYXhlcyxmdW5jdGlvbihhKXtpZihhLnpvb21FbmFibGVkKXt2YXIgYj11LmJvdW5kc1thLmhvcml6P1wiaFwiOlwidlwiXSxlPWEubWluUGl4ZWxQYWRkaW5nLGQ9YS50b1BpeGVscyhmKGEub3B0aW9ucy5taW4sYS5kYXRhTWluKSksZz1hLnRvUGl4ZWxzKGYoYS5vcHRpb25zLm1heCxcbmEuZGF0YU1heCkpLGs9TWF0aC5tYXgoZCxnKTtiLm1pbj1NYXRoLm1pbihhLnBvcyxNYXRoLm1pbihkLGcpLWUpO2IubWF4PU1hdGgubWF4KGEucG9zK2EubGVuLGsrZSl9fSksbC5yZXM9ITApOmwuZm9sbG93VG91Y2hNb3ZlJiYxPT09ZD90aGlzLnJ1blBvaW50QWN0aW9ucyhsLm5vcm1hbGl6ZShhKSk6dC5sZW5ndGgmJihlfHwobC5zZWxlY3Rpb25NYXJrZXI9ZT1GKHtkZXN0cm95Om0sdG91Y2g6ITB9LHUucGxvdEJveCkpLGwucGluY2hUcmFuc2xhdGUodCxnLHYsZSxuLGspLGwuaGFzUGluY2hlZD1iLGwuc2NhbGVHcm91cHModixuKSxsLnJlcyYmKGwucmVzPSExLHRoaXMucmVzZXQoITEsMCkpKX0sdG91Y2g6ZnVuY3Rpb24obCxtKXt2YXIgcj10aGlzLmNoYXJ0LHQsZztpZihyLmluZGV4IT09YS5ob3ZlckNoYXJ0SW5kZXgpdGhpcy5vbkNvbnRhaW5lck1vdXNlTGVhdmUoe3JlbGF0ZWRUYXJnZXQ6ITB9KTthLmhvdmVyQ2hhcnRJbmRleD1yLmluZGV4OzE9PT1sLnRvdWNoZXMubGVuZ3RoP1xuKGw9dGhpcy5ub3JtYWxpemUobCksKGc9ci5pc0luc2lkZVBsb3QobC5jaGFydFgtci5wbG90TGVmdCxsLmNoYXJ0WS1yLnBsb3RUb3ApKSYmIXIub3Blbk1lbnU/KG0mJnRoaXMucnVuUG9pbnRBY3Rpb25zKGwpLFwidG91Y2htb3ZlXCI9PT1sLnR5cGUmJihtPXRoaXMucGluY2hEb3duLHQ9bVswXT80PD1NYXRoLnNxcnQoTWF0aC5wb3cobVswXS5jaGFydFgtbC5jaGFydFgsMikrTWF0aC5wb3cobVswXS5jaGFydFktbC5jaGFydFksMikpOiExKSxmKHQsITApJiZ0aGlzLnBpbmNoKGwpKTptJiZ0aGlzLnJlc2V0KCkpOjI9PT1sLnRvdWNoZXMubGVuZ3RoJiZ0aGlzLnBpbmNoKGwpfSxvbkNvbnRhaW5lclRvdWNoU3RhcnQ6ZnVuY3Rpb24oYSl7dGhpcy56b29tT3B0aW9uKGEpO3RoaXMudG91Y2goYSwhMCl9LG9uQ29udGFpbmVyVG91Y2hNb3ZlOmZ1bmN0aW9uKGEpe3RoaXMudG91Y2goYSl9LG9uRG9jdW1lbnRUb3VjaEVuZDpmdW5jdGlvbihmKXtDW2EuaG92ZXJDaGFydEluZGV4XSYmXG5DW2EuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZil9fSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5hZGRFdmVudCxBPWEuY2hhcnRzLEY9YS5jc3MsRT1hLmRvYyxtPWEuZXh0ZW5kLGY9YS5ub29wLGw9YS5Qb2ludGVyLHI9YS5yZW1vdmVFdmVudCx1PWEud2luLHQ9YS53cmFwO2lmKCFhLmhhc1RvdWNoJiYodS5Qb2ludGVyRXZlbnR8fHUuTVNQb2ludGVyRXZlbnQpKXt2YXIgZz17fSxkPSEhdS5Qb2ludGVyRXZlbnQsaz1mdW5jdGlvbigpe3ZhciBiPVtdO2IuaXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpc1thXX07YS5vYmplY3RFYWNoKGcsZnVuY3Rpb24oYSl7Yi5wdXNoKHtwYWdlWDphLnBhZ2VYLHBhZ2VZOmEucGFnZVksdGFyZ2V0OmEudGFyZ2V0fSl9KTtyZXR1cm4gYn0sYj1mdW5jdGlvbihiLGQsZyxuKXtcInRvdWNoXCIhPT1iLnBvaW50ZXJUeXBlJiZiLnBvaW50ZXJUeXBlIT09Yi5NU1BPSU5URVJfVFlQRV9UT1VDSHx8IUFbYS5ob3ZlckNoYXJ0SW5kZXhdfHxcbihuKGIpLG49QVthLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlcixuW2RdKHt0eXBlOmcsdGFyZ2V0OmIuY3VycmVudFRhcmdldCxwcmV2ZW50RGVmYXVsdDpmLHRvdWNoZXM6aygpfSkpfTttKGwucHJvdG90eXBlLHtvbkNvbnRhaW5lclBvaW50ZXJEb3duOmZ1bmN0aW9uKGEpe2IoYSxcIm9uQ29udGFpbmVyVG91Y2hTdGFydFwiLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGEpe2dbYS5wb2ludGVySWRdPXtwYWdlWDphLnBhZ2VYLHBhZ2VZOmEucGFnZVksdGFyZ2V0OmEuY3VycmVudFRhcmdldH19KX0sb25Db250YWluZXJQb2ludGVyTW92ZTpmdW5jdGlvbihhKXtiKGEsXCJvbkNvbnRhaW5lclRvdWNoTW92ZVwiLFwidG91Y2htb3ZlXCIsZnVuY3Rpb24oYSl7Z1thLnBvaW50ZXJJZF09e3BhZ2VYOmEucGFnZVgscGFnZVk6YS5wYWdlWX07Z1thLnBvaW50ZXJJZF0udGFyZ2V0fHwoZ1thLnBvaW50ZXJJZF0udGFyZ2V0PWEuY3VycmVudFRhcmdldCl9KX0sb25Eb2N1bWVudFBvaW50ZXJVcDpmdW5jdGlvbihhKXtiKGEsXG5cIm9uRG9jdW1lbnRUb3VjaEVuZFwiLFwidG91Y2hlbmRcIixmdW5jdGlvbihhKXtkZWxldGUgZ1thLnBvaW50ZXJJZF19KX0sYmF0Y2hNU0V2ZW50czpmdW5jdGlvbihhKXthKHRoaXMuY2hhcnQuY29udGFpbmVyLGQ/XCJwb2ludGVyZG93blwiOlwiTVNQb2ludGVyRG93blwiLHRoaXMub25Db250YWluZXJQb2ludGVyRG93bik7YSh0aGlzLmNoYXJ0LmNvbnRhaW5lcixkP1wicG9pbnRlcm1vdmVcIjpcIk1TUG9pbnRlck1vdmVcIix0aGlzLm9uQ29udGFpbmVyUG9pbnRlck1vdmUpO2EoRSxkP1wicG9pbnRlcnVwXCI6XCJNU1BvaW50ZXJVcFwiLHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCl9fSk7dChsLnByb3RvdHlwZSxcImluaXRcIixmdW5jdGlvbihhLGIsZCl7YS5jYWxsKHRoaXMsYixkKTt0aGlzLmhhc1pvb20mJkYoYi5jb250YWluZXIse1wiLW1zLXRvdWNoLWFjdGlvblwiOlwibm9uZVwiLFwidG91Y2gtYWN0aW9uXCI6XCJub25lXCJ9KX0pO3QobC5wcm90b3R5cGUsXCJzZXRET01FdmVudHNcIixmdW5jdGlvbihhKXthLmFwcGx5KHRoaXMpO1xuKHRoaXMuaGFzWm9vbXx8dGhpcy5mb2xsb3dUb3VjaE1vdmUpJiZ0aGlzLmJhdGNoTVNFdmVudHMoQyl9KTt0KGwucHJvdG90eXBlLFwiZGVzdHJveVwiLGZ1bmN0aW9uKGEpe3RoaXMuYmF0Y2hNU0V2ZW50cyhyKTthLmNhbGwodGhpcyl9KX19KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5hZGRFdmVudCxBPWEuY3NzLEY9YS5kaXNjYXJkRWxlbWVudCxFPWEuZGVmaW5lZCxtPWEuZWFjaCxmPWEuaXNGaXJlZm94LGw9YS5tYXJnaW5OYW1lcyxyPWEubWVyZ2UsdT1hLnBpY2ssdD1hLnNldEFuaW1hdGlvbixnPWEuc3RhYmxlU29ydCxkPWEud2luLGs9YS53cmFwO2EuTGVnZW5kPWZ1bmN0aW9uKGEsZSl7dGhpcy5pbml0KGEsZSl9O2EuTGVnZW5kLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGUpe3RoaXMuY2hhcnQ9YTt0aGlzLnNldE9wdGlvbnMoZSk7ZS5lbmFibGVkJiYodGhpcy5yZW5kZXIoKSxDKHRoaXMuY2hhcnQsXCJlbmRSZXNpemVcIixmdW5jdGlvbigpe3RoaXMubGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpfSkpfSxcbnNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGI9dShhLnBhZGRpbmcsOCk7dGhpcy5vcHRpb25zPWE7dGhpcy5pdGVtU3R5bGU9YS5pdGVtU3R5bGU7dGhpcy5pdGVtSGlkZGVuU3R5bGU9cih0aGlzLml0ZW1TdHlsZSxhLml0ZW1IaWRkZW5TdHlsZSk7dGhpcy5pdGVtTWFyZ2luVG9wPWEuaXRlbU1hcmdpblRvcHx8MDt0aGlzLnBhZGRpbmc9Yjt0aGlzLmluaXRpYWxJdGVtWT1iLTU7dGhpcy5pdGVtSGVpZ2h0PXRoaXMubWF4SXRlbVdpZHRoPTA7dGhpcy5zeW1ib2xXaWR0aD11KGEuc3ltYm9sV2lkdGgsMTYpO3RoaXMucGFnZXM9W119LHVwZGF0ZTpmdW5jdGlvbihhLGUpe3ZhciBiPXRoaXMuY2hhcnQ7dGhpcy5zZXRPcHRpb25zKHIoITAsdGhpcy5vcHRpb25zLGEpKTt0aGlzLmRlc3Ryb3koKTtiLmlzRGlydHlMZWdlbmQ9Yi5pc0RpcnR5Qm94PSEwO3UoZSwhMCkmJmIucmVkcmF3KCl9LGNvbG9yaXplSXRlbTpmdW5jdGlvbihhLGUpe2EubGVnZW5kR3JvdXBbZT9cInJlbW92ZUNsYXNzXCI6XG5cImFkZENsYXNzXCJdKFwiaGlnaGNoYXJ0cy1sZWdlbmQtaXRlbS1oaWRkZW5cIik7dmFyIGI9dGhpcy5vcHRpb25zLGQ9YS5sZWdlbmRJdGVtLGc9YS5sZWdlbmRMaW5lLGY9YS5sZWdlbmRTeW1ib2wsaz10aGlzLml0ZW1IaWRkZW5TdHlsZS5jb2xvcixiPWU/Yi5pdGVtU3R5bGUuY29sb3I6ayxjPWU/YS5jb2xvcnx8azprLGw9YS5vcHRpb25zJiZhLm9wdGlvbnMubWFya2VyLHE9e2ZpbGw6Y307ZCYmZC5jc3Moe2ZpbGw6Yixjb2xvcjpifSk7ZyYmZy5hdHRyKHtzdHJva2U6Y30pO2YmJihsJiZmLmlzTWFya2VyJiYocT1hLnBvaW50QXR0cmlicygpLGV8fChxLnN0cm9rZT1xLmZpbGw9aykpLGYuYXR0cihxKSl9LHBvc2l0aW9uSXRlbTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsZD1iLnN5bWJvbFBhZGRpbmcsYj0hYi5ydGwsZz1hLl9sZWdlbmRJdGVtUG9zLGY9Z1swXSxnPWdbMV0saz1hLmNoZWNrYm94OyhhPWEubGVnZW5kR3JvdXApJiZhLmVsZW1lbnQmJmEudHJhbnNsYXRlKGI/XG5mOnRoaXMubGVnZW5kV2lkdGgtZi0yKmQtNCxnKTtrJiYoay54PWYsay55PWcpfSxkZXN0cm95SXRlbTpmdW5jdGlvbihhKXt2YXIgYj1hLmNoZWNrYm94O20oW1wibGVnZW5kSXRlbVwiLFwibGVnZW5kTGluZVwiLFwibGVnZW5kU3ltYm9sXCIsXCJsZWdlbmRHcm91cFwiXSxmdW5jdGlvbihiKXthW2JdJiYoYVtiXT1hW2JdLmRlc3Ryb3koKSl9KTtiJiZGKGEuY2hlY2tib3gpfSxkZXN0cm95OmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt0aGlzW2FdJiYodGhpc1thXT10aGlzW2FdLmRlc3Ryb3koKSl9bSh0aGlzLmdldEFsbEl0ZW1zKCksZnVuY3Rpb24oYil7bShbXCJsZWdlbmRJdGVtXCIsXCJsZWdlbmRHcm91cFwiXSxhLGIpfSk7bShcImNsaXBSZWN0IHVwIGRvd24gcGFnZXIgbmF2IGJveCB0aXRsZSBncm91cFwiLnNwbGl0KFwiIFwiKSxhLHRoaXMpO3RoaXMuZGlzcGxheT1udWxsfSxwb3NpdGlvbkNoZWNrYm94ZXM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncm91cCYmdGhpcy5ncm91cC5hbGlnbkF0dHIsXG5kLGc9dGhpcy5jbGlwSGVpZ2h0fHx0aGlzLmxlZ2VuZEhlaWdodCxmPXRoaXMudGl0bGVIZWlnaHQ7YiYmKGQ9Yi50cmFuc2xhdGVZLG0odGhpcy5hbGxJdGVtcyxmdW5jdGlvbihlKXt2YXIgaz1lLmNoZWNrYm94LGM7ayYmKGM9ZCtmK2sueSsoYXx8MCkrMyxBKGsse2xlZnQ6Yi50cmFuc2xhdGVYK2UuY2hlY2tib3hPZmZzZXQray54LTIwK1wicHhcIix0b3A6YytcInB4XCIsZGlzcGxheTpjPmQtNiYmYzxkK2ctNj9cIlwiOlwibm9uZVwifSkpfSkpfSxyZW5kZXJUaXRsZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxlPXRoaXMucGFkZGluZyxkPWEudGl0bGUsZz0wO2QudGV4dCYmKHRoaXMudGl0bGV8fCh0aGlzLnRpdGxlPXRoaXMuY2hhcnQucmVuZGVyZXIubGFiZWwoZC50ZXh0LGUtMyxlLTQsbnVsbCxudWxsLG51bGwsYS51c2VIVE1MLG51bGwsXCJsZWdlbmQtdGl0bGVcIikuYXR0cih7ekluZGV4OjF9KS5jc3MoZC5zdHlsZSkuYWRkKHRoaXMuZ3JvdXApKSxhPXRoaXMudGl0bGUuZ2V0QkJveCgpLFxuZz1hLmhlaWdodCx0aGlzLm9mZnNldFdpZHRoPWEud2lkdGgsdGhpcy5jb250ZW50R3JvdXAuYXR0cih7dHJhbnNsYXRlWTpnfSkpO3RoaXMudGl0bGVIZWlnaHQ9Z30sc2V0VGV4dDpmdW5jdGlvbihiKXt2YXIgZT10aGlzLm9wdGlvbnM7Yi5sZWdlbmRJdGVtLmF0dHIoe3RleHQ6ZS5sYWJlbEZvcm1hdD9hLmZvcm1hdChlLmxhYmVsRm9ybWF0LGIpOmUubGFiZWxGb3JtYXR0ZXIuY2FsbChiKX0pfSxyZW5kZXJJdGVtOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsZD1iLnJlbmRlcmVyLGc9dGhpcy5vcHRpb25zLGY9XCJob3Jpem9udGFsXCI9PT1nLmxheW91dCxrPXRoaXMuc3ltYm9sV2lkdGgsbD1nLnN5bWJvbFBhZGRpbmcsYz10aGlzLml0ZW1TdHlsZSxtPXRoaXMuaXRlbUhpZGRlblN0eWxlLHE9dGhpcy5wYWRkaW5nLEI9Zj91KGcuaXRlbURpc3RhbmNlLDIwKTowLHQ9IWcucnRsLHA9Zy53aWR0aCx6PWcuaXRlbU1hcmdpbkJvdHRvbXx8MCxJPXRoaXMuaXRlbU1hcmdpblRvcCxcbkw9YS5sZWdlbmRJdGVtLGg9IWEuc2VyaWVzLHc9IWgmJmEuc2VyaWVzLmRyYXdMZWdlbmRTeW1ib2w/YS5zZXJpZXM6YSxQPXcub3B0aW9ucyxIPXRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtJiZQJiZQLnNob3dDaGVja2JveCxQPWsrbCtCKyhIPzIwOjApLE89Zy51c2VIVE1MLEE9YS5vcHRpb25zLmNsYXNzTmFtZTtMfHwoYS5sZWdlbmRHcm91cD1kLmcoXCJsZWdlbmQtaXRlbVwiKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrdy50eXBlK1wiLXNlcmllcyBoaWdoY2hhcnRzLWNvbG9yLVwiK2EuY29sb3JJbmRleCsoQT9cIiBcIitBOlwiXCIpKyhoP1wiIGhpZ2hjaGFydHMtc2VyaWVzLVwiK2EuaW5kZXg6XCJcIikpLmF0dHIoe3pJbmRleDoxfSkuYWRkKHRoaXMuc2Nyb2xsR3JvdXApLGEubGVnZW5kSXRlbT1MPWQudGV4dChcIlwiLHQ/aytsOi1sLHRoaXMuYmFzZWxpbmV8fDAsTykuY3NzKHIoYS52aXNpYmxlP2M6bSkpLmF0dHIoe2FsaWduOnQ/XCJsZWZ0XCI6XCJyaWdodFwiLHpJbmRleDoyfSkuYWRkKGEubGVnZW5kR3JvdXApLFxudGhpcy5iYXNlbGluZXx8KGs9Yy5mb250U2l6ZSx0aGlzLmZvbnRNZXRyaWNzPWQuZm9udE1ldHJpY3MoayxMKSx0aGlzLmJhc2VsaW5lPXRoaXMuZm9udE1ldHJpY3MuZiszK0ksTC5hdHRyKFwieVwiLHRoaXMuYmFzZWxpbmUpKSx0aGlzLnN5bWJvbEhlaWdodD1nLnN5bWJvbEhlaWdodHx8dGhpcy5mb250TWV0cmljcy5mLHcuZHJhd0xlZ2VuZFN5bWJvbCh0aGlzLGEpLHRoaXMuc2V0SXRlbUV2ZW50cyYmdGhpcy5zZXRJdGVtRXZlbnRzKGEsTCxPKSxIJiZ0aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbShhKSk7dGhpcy5jb2xvcml6ZUl0ZW0oYSxhLnZpc2libGUpO2Mud2lkdGh8fEwuY3NzKHt3aWR0aDooZy5pdGVtV2lkdGh8fGcud2lkdGh8fGIuc3BhY2luZ0JveC53aWR0aCktUH0pO3RoaXMuc2V0VGV4dChhKTtkPUwuZ2V0QkJveCgpO2M9YS5jaGVja2JveE9mZnNldD1nLml0ZW1XaWR0aHx8YS5sZWdlbmRJdGVtV2lkdGh8fGQud2lkdGgrUDt0aGlzLml0ZW1IZWlnaHQ9ZD1NYXRoLnJvdW5kKGEubGVnZW5kSXRlbUhlaWdodHx8XG5kLmhlaWdodHx8dGhpcy5zeW1ib2xIZWlnaHQpO2YmJnRoaXMuaXRlbVgtcStjPihwfHxiLnNwYWNpbmdCb3gud2lkdGgtMipxLWcueCkmJih0aGlzLml0ZW1YPXEsdGhpcy5pdGVtWSs9SSt0aGlzLmxhc3RMaW5lSGVpZ2h0K3osdGhpcy5sYXN0TGluZUhlaWdodD0wKTt0aGlzLm1heEl0ZW1XaWR0aD1NYXRoLm1heCh0aGlzLm1heEl0ZW1XaWR0aCxjKTt0aGlzLmxhc3RJdGVtWT1JK3RoaXMuaXRlbVkrejt0aGlzLmxhc3RMaW5lSGVpZ2h0PU1hdGgubWF4KGQsdGhpcy5sYXN0TGluZUhlaWdodCk7YS5fbGVnZW5kSXRlbVBvcz1bdGhpcy5pdGVtWCx0aGlzLml0ZW1ZXTtmP3RoaXMuaXRlbVgrPWM6KHRoaXMuaXRlbVkrPUkrZCt6LHRoaXMubGFzdExpbmVIZWlnaHQ9ZCk7dGhpcy5vZmZzZXRXaWR0aD1wfHxNYXRoLm1heCgoZj90aGlzLml0ZW1YLXEtKGEuY2hlY2tib3g/MDpCKTpjKStxLHRoaXMub2Zmc2V0V2lkdGgpfSxnZXRBbGxJdGVtczpmdW5jdGlvbigpe3ZhciBhPVtdO20odGhpcy5jaGFydC5zZXJpZXMsXG5mdW5jdGlvbihiKXt2YXIgZT1iJiZiLm9wdGlvbnM7YiYmdShlLnNob3dJbkxlZ2VuZCxFKGUubGlua2VkVG8pPyExOnZvaWQgMCwhMCkmJihhPWEuY29uY2F0KGIubGVnZW5kSXRlbXN8fChcInBvaW50XCI9PT1lLmxlZ2VuZFR5cGU/Yi5kYXRhOmIpKSl9KTtyZXR1cm4gYX0sYWRqdXN0TWFyZ2luczpmdW5jdGlvbihhLGUpe3ZhciBiPXRoaXMuY2hhcnQsZD10aGlzLm9wdGlvbnMsZz1kLmFsaWduLmNoYXJBdCgwKStkLnZlcnRpY2FsQWxpZ24uY2hhckF0KDApK2QubGF5b3V0LmNoYXJBdCgwKTtkLmZsb2F0aW5nfHxtKFsvKGx0aHxjdHxydGgpLywvKHJ0dnxybXxyYnYpLywvKHJiaHxjYnxsYmgpLywvKGxidnxsbXxsdHYpL10sZnVuY3Rpb24oZixrKXtmLnRlc3QoZykmJiFFKGFba10pJiYoYltsW2tdXT1NYXRoLm1heChiW2xba11dLGIubGVnZW5kWyhrKzEpJTI/XCJsZWdlbmRIZWlnaHRcIjpcImxlZ2VuZFdpZHRoXCJdK1sxLC0xLC0xLDFdW2tdKmRbayUyP1wieFwiOlwieVwiXSt1KGQubWFyZ2luLFxuMTIpK2Vba10pKX0pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGU9YS5jaGFydCxkPWUucmVuZGVyZXIsZj1hLmdyb3VwLGssbCx0LGMsdT1hLmJveCxxPWEub3B0aW9ucyxCPWEucGFkZGluZzthLml0ZW1YPUI7YS5pdGVtWT1hLmluaXRpYWxJdGVtWTthLm9mZnNldFdpZHRoPTA7YS5sYXN0SXRlbVk9MDtmfHwoYS5ncm91cD1mPWQuZyhcImxlZ2VuZFwiKS5hdHRyKHt6SW5kZXg6N30pLmFkZCgpLGEuY29udGVudEdyb3VwPWQuZygpLmF0dHIoe3pJbmRleDoxfSkuYWRkKGYpLGEuc2Nyb2xsR3JvdXA9ZC5nKCkuYWRkKGEuY29udGVudEdyb3VwKSk7YS5yZW5kZXJUaXRsZSgpO2s9YS5nZXRBbGxJdGVtcygpO2coayxmdW5jdGlvbihhLGIpe3JldHVybihhLm9wdGlvbnMmJmEub3B0aW9ucy5sZWdlbmRJbmRleHx8MCktKGIub3B0aW9ucyYmYi5vcHRpb25zLmxlZ2VuZEluZGV4fHwwKX0pO3EucmV2ZXJzZWQmJmsucmV2ZXJzZSgpO2EuYWxsSXRlbXM9azthLmRpc3BsYXk9bD1cbiEhay5sZW5ndGg7YS5sYXN0TGluZUhlaWdodD0wO20oayxmdW5jdGlvbihiKXthLnJlbmRlckl0ZW0oYil9KTt0PShxLndpZHRofHxhLm9mZnNldFdpZHRoKStCO2M9YS5sYXN0SXRlbVkrYS5sYXN0TGluZUhlaWdodCthLnRpdGxlSGVpZ2h0O2M9YS5oYW5kbGVPdmVyZmxvdyhjKTtjKz1CO3V8fChhLmJveD11PWQucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1sZWdlbmQtYm94XCIpLmF0dHIoe3I6cS5ib3JkZXJSYWRpdXN9KS5hZGQoZiksdS5pc05ldz0hMCk7dS5hdHRyKHtzdHJva2U6cS5ib3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOnEuYm9yZGVyV2lkdGh8fDAsZmlsbDpxLmJhY2tncm91bmRDb2xvcnx8XCJub25lXCJ9KS5zaGFkb3cocS5zaGFkb3cpOzA8dCYmMDxjJiYodVt1LmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh1LmNyaXNwKHt4OjAseTowLHdpZHRoOnQsaGVpZ2h0OmN9LHUuc3Ryb2tlV2lkdGgoKSkpLHUuaXNOZXc9ITEpO3VbbD9cInNob3dcIjpcImhpZGVcIl0oKTthLmxlZ2VuZFdpZHRoPVxudDthLmxlZ2VuZEhlaWdodD1jO20oayxmdW5jdGlvbihiKXthLnBvc2l0aW9uSXRlbShiKX0pO2wmJmYuYWxpZ24ocihxLHt3aWR0aDp0LGhlaWdodDpjfSksITAsXCJzcGFjaW5nQm94XCIpO2UuaXNSZXNpemluZ3x8dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKX0saGFuZGxlT3ZlcmZsb3c6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxkPXRoaXMuY2hhcnQsZz1kLnJlbmRlcmVyLGY9dGhpcy5vcHRpb25zLGs9Zi55LGw9dGhpcy5wYWRkaW5nLGQ9ZC5zcGFjaW5nQm94LmhlaWdodCsoXCJ0b3BcIj09PWYudmVydGljYWxBbGlnbj8tazprKS1sLGs9Zi5tYXhIZWlnaHQsYyxyPXRoaXMuY2xpcFJlY3QscT1mLm5hdmlnYXRpb24sQj11KHEuYW5pbWF0aW9uLCEwKSx0PXEuYXJyb3dTaXplfHwxMixwPXRoaXMubmF2LHo9dGhpcy5wYWdlcyxJLEw9dGhpcy5hbGxJdGVtcyxoPWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYT9yLmF0dHIoe2hlaWdodDphfSk6ciYmKGIuY2xpcFJlY3Q9ci5kZXN0cm95KCksXG5iLmNvbnRlbnRHcm91cC5jbGlwKCkpO2IuY29udGVudEdyb3VwLmRpdiYmKGIuY29udGVudEdyb3VwLmRpdi5zdHlsZS5jbGlwPWE/XCJyZWN0KFwiK2wrXCJweCw5OTk5cHgsXCIrKGwrYSkrXCJweCwwKVwiOlwiYXV0b1wiKX07XCJob3Jpem9udGFsXCIhPT1mLmxheW91dHx8XCJtaWRkbGVcIj09PWYudmVydGljYWxBbGlnbnx8Zi5mbG9hdGluZ3x8KGQvPTIpO2smJihkPU1hdGgubWluKGQsaykpO3oubGVuZ3RoPTA7YT5kJiYhMSE9PXEuZW5hYmxlZD8odGhpcy5jbGlwSGVpZ2h0PWM9TWF0aC5tYXgoZC0yMC10aGlzLnRpdGxlSGVpZ2h0LWwsMCksdGhpcy5jdXJyZW50UGFnZT11KHRoaXMuY3VycmVudFBhZ2UsMSksdGhpcy5mdWxsSGVpZ2h0PWEsbShMLGZ1bmN0aW9uKGEsYil7dmFyIGU9YS5fbGVnZW5kSXRlbVBvc1sxXTthPU1hdGgucm91bmQoYS5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpO3ZhciBkPXoubGVuZ3RoO2lmKCFkfHxlLXpbZC0xXT5jJiYoSXx8ZSkhPT16W2QtMV0pei5wdXNoKEl8fFxuZSksZCsrO2I9PT1MLmxlbmd0aC0xJiZlK2EteltkLTFdPmMmJnoucHVzaChlKTtlIT09SSYmKEk9ZSl9KSxyfHwocj1iLmNsaXBSZWN0PWcuY2xpcFJlY3QoMCxsLDk5OTksMCksYi5jb250ZW50R3JvdXAuY2xpcChyKSksaChjKSxwfHwodGhpcy5uYXY9cD1nLmcoKS5hdHRyKHt6SW5kZXg6MX0pLmFkZCh0aGlzLmdyb3VwKSx0aGlzLnVwPWcuc3ltYm9sKFwidHJpYW5nbGVcIiwwLDAsdCx0KS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtiLnNjcm9sbCgtMSxCKX0pLmFkZChwKSx0aGlzLnBhZ2VyPWcudGV4dChcIlwiLDE1LDEwKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGVnZW5kLW5hdmlnYXRpb25cIikuY3NzKHEuc3R5bGUpLmFkZChwKSx0aGlzLmRvd249Zy5zeW1ib2woXCJ0cmlhbmdsZS1kb3duXCIsMCwwLHQsdCkub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Yi5zY3JvbGwoMSxCKX0pLmFkZChwKSksYi5zY3JvbGwoMCksYT1kKTpwJiYoaCgpLHRoaXMubmF2PXAuZGVzdHJveSgpLHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7dHJhbnNsYXRlWToxfSksXG50aGlzLmNsaXBIZWlnaHQ9MCk7cmV0dXJuIGF9LHNjcm9sbDpmdW5jdGlvbihhLGUpe3ZhciBiPXRoaXMucGFnZXMsZD1iLmxlbmd0aDthPXRoaXMuY3VycmVudFBhZ2UrYTt2YXIgZz10aGlzLmNsaXBIZWlnaHQsZj10aGlzLm9wdGlvbnMubmF2aWdhdGlvbixrPXRoaXMucGFnZXIsYz10aGlzLnBhZGRpbmc7YT5kJiYoYT1kKTswPGEmJih2b2lkIDAhPT1lJiZ0KGUsdGhpcy5jaGFydCksdGhpcy5uYXYuYXR0cih7dHJhbnNsYXRlWDpjLHRyYW5zbGF0ZVk6Zyt0aGlzLnBhZGRpbmcrNyt0aGlzLnRpdGxlSGVpZ2h0LHZpc2liaWxpdHk6XCJ2aXNpYmxlXCJ9KSx0aGlzLnVwLmF0dHIoe1wiY2xhc3NcIjoxPT09YT9cImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1pbmFjdGl2ZVwiOlwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWFjdGl2ZVwifSksay5hdHRyKHt0ZXh0OmErXCIvXCIrZH0pLHRoaXMuZG93bi5hdHRyKHt4OjE4K3RoaXMucGFnZXIuZ2V0QkJveCgpLndpZHRoLFwiY2xhc3NcIjphPT09ZD9cImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1pbmFjdGl2ZVwiOlxuXCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtYWN0aXZlXCJ9KSx0aGlzLnVwLmF0dHIoe2ZpbGw6MT09PWE/Zi5pbmFjdGl2ZUNvbG9yOmYuYWN0aXZlQ29sb3J9KS5jc3Moe2N1cnNvcjoxPT09YT9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn0pLHRoaXMuZG93bi5hdHRyKHtmaWxsOmE9PT1kP2YuaW5hY3RpdmVDb2xvcjpmLmFjdGl2ZUNvbG9yfSkuY3NzKHtjdXJzb3I6YT09PWQ/XCJkZWZhdWx0XCI6XCJwb2ludGVyXCJ9KSxlPS1iW2EtMV0rdGhpcy5pbml0aWFsSXRlbVksdGhpcy5zY3JvbGxHcm91cC5hbmltYXRlKHt0cmFuc2xhdGVZOmV9KSx0aGlzLmN1cnJlbnRQYWdlPWEsdGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoZSkpfX07YS5MZWdlbmRTeW1ib2xNaXhpbj17ZHJhd1JlY3RhbmdsZTpmdW5jdGlvbihhLGUpe3ZhciBiPWEuc3ltYm9sSGVpZ2h0LGQ9YS5vcHRpb25zLnNxdWFyZVN5bWJvbDtlLmxlZ2VuZFN5bWJvbD10aGlzLmNoYXJ0LnJlbmRlcmVyLnJlY3QoZD8oYS5zeW1ib2xXaWR0aC1iKS9cbjI6MCxhLmJhc2VsaW5lLWIrMSxkP2I6YS5zeW1ib2xXaWR0aCxiLHUoYS5vcHRpb25zLnN5bWJvbFJhZGl1cyxiLzIpKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnRcIikuYXR0cih7ekluZGV4OjN9KS5hZGQoZS5sZWdlbmRHcm91cCl9LGRyYXdMaW5lTWFya2VyOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucyxkPWIubWFya2VyLGc9YS5zeW1ib2xXaWR0aCxmPWEuc3ltYm9sSGVpZ2h0LGs9Zi8yLGw9dGhpcy5jaGFydC5yZW5kZXJlcixjPXRoaXMubGVnZW5kR3JvdXA7YT1hLmJhc2VsaW5lLU1hdGgucm91bmQoLjMqYS5mb250TWV0cmljcy5iKTt2YXIgbTttPXtcInN0cm9rZS13aWR0aFwiOmIubGluZVdpZHRofHwwfTtiLmRhc2hTdHlsZSYmKG0uZGFzaHN0eWxlPWIuZGFzaFN0eWxlKTt0aGlzLmxlZ2VuZExpbmU9bC5wYXRoKFtcIk1cIiwwLGEsXCJMXCIsZyxhXSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWdyYXBoXCIpLmF0dHIobSkuYWRkKGMpO2QmJiExIT09ZC5lbmFibGVkJiZcbihiPU1hdGgubWluKHUoZC5yYWRpdXMsayksayksMD09PXRoaXMuc3ltYm9sLmluZGV4T2YoXCJ1cmxcIikmJihkPXIoZCx7d2lkdGg6ZixoZWlnaHQ6Zn0pLGI9MCksdGhpcy5sZWdlbmRTeW1ib2w9ZD1sLnN5bWJvbCh0aGlzLnN5bWJvbCxnLzItYixhLWIsMipiLDIqYixkKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnRcIikuYWRkKGMpLGQuaXNNYXJrZXI9ITApfX07KC9UcmlkZW50XFwvN1xcLjAvLnRlc3QoZC5uYXZpZ2F0b3IudXNlckFnZW50KXx8ZikmJmsoYS5MZWdlbmQucHJvdG90eXBlLFwicG9zaXRpb25JdGVtXCIsZnVuY3Rpb24oYSxlKXt2YXIgYj10aGlzLGQ9ZnVuY3Rpb24oKXtlLl9sZWdlbmRJdGVtUG9zJiZhLmNhbGwoYixlKX07ZCgpO3NldFRpbWVvdXQoZCl9KX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1hLmFkZEV2ZW50LEE9YS5hbmltYXRlLEY9YS5hbmltT2JqZWN0LEU9YS5hdHRyLG09YS5kb2MsZj1hLkF4aXMsbD1hLmNyZWF0ZUVsZW1lbnQscj1hLmRlZmF1bHRPcHRpb25zLFxudT1hLmRpc2NhcmRFbGVtZW50LHQ9YS5jaGFydHMsZz1hLmNzcyxkPWEuZGVmaW5lZCxrPWEuZWFjaCxiPWEuZXh0ZW5kLGU9YS5maW5kLHY9YS5maXJlRXZlbnQseT1hLmdldFN0eWxlLG49YS5ncmVwLEQ9YS5pc051bWJlcixKPWEuaXNPYmplY3QsYz1hLmlzU3RyaW5nLEc9YS5MZWdlbmQscT1hLm1hcmdpbk5hbWVzLEI9YS5tZXJnZSxLPWEub2JqZWN0RWFjaCxwPWEuUG9pbnRlcix6PWEucGljayxJPWEucEludCxMPWEucmVtb3ZlRXZlbnQsaD1hLnNlcmllc1R5cGVzLHc9YS5zcGxhdCxQPWEuc3ZnLEg9YS5zeW5jVGltZW91dCxPPWEud2luLFE9YS5SZW5kZXJlcixSPWEuQ2hhcnQ9ZnVuY3Rpb24oKXt0aGlzLmdldEFyZ3MuYXBwbHkodGhpcyxhcmd1bWVudHMpfTthLmNoYXJ0PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IFIoYSxiLGMpfTtiKFIucHJvdG90eXBlLHtjYWxsYmFja3M6W10sZ2V0QXJnczpmdW5jdGlvbigpe3ZhciBhPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbmlmKGMoYVswXSl8fGFbMF0ubm9kZU5hbWUpdGhpcy5yZW5kZXJUbz1hLnNoaWZ0KCk7dGhpcy5pbml0KGFbMF0sYVsxXSl9LGluaXQ6ZnVuY3Rpb24oYixjKXt2YXIgZSxkLGg9Yi5zZXJpZXMscD1iLnBsb3RPcHRpb25zfHx7fTtiLnNlcmllcz1udWxsO2U9QihyLGIpO2ZvcihkIGluIGUucGxvdE9wdGlvbnMpZS5wbG90T3B0aW9uc1tkXS50b29sdGlwPXBbZF0mJkIocFtkXS50b29sdGlwKXx8dm9pZCAwO2UudG9vbHRpcC51c2VyT3B0aW9ucz1iLmNoYXJ0JiZiLmNoYXJ0LmZvckV4cG9ydCYmYi50b29sdGlwLnVzZXJPcHRpb25zfHxiLnRvb2x0aXA7ZS5zZXJpZXM9Yi5zZXJpZXM9aDt0aGlzLnVzZXJPcHRpb25zPWI7Yj1lLmNoYXJ0O2Q9Yi5ldmVudHM7dGhpcy5tYXJnaW49W107dGhpcy5zcGFjaW5nPVtdO3RoaXMuYm91bmRzPXtoOnt9LHY6e319O3RoaXMuY2FsbGJhY2s9Yzt0aGlzLmlzUmVzaXppbmc9MDt0aGlzLm9wdGlvbnM9ZTt0aGlzLmF4ZXM9W107dGhpcy5zZXJpZXM9XG5bXTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcz1iLnNob3dBeGVzO3ZhciBnPXRoaXM7Zy5pbmRleD10Lmxlbmd0aDt0LnB1c2goZyk7YS5jaGFydENvdW50Kys7ZCYmSyhkLGZ1bmN0aW9uKGEsYil7QyhnLGIsYSl9KTtnLnhBeGlzPVtdO2cueUF4aXM9W107Zy5wb2ludENvdW50PWcuY29sb3JDb3VudGVyPWcuc3ltYm9sQ291bnRlcj0wO2cuZmlyc3RSZW5kZXIoKX0saW5pdFNlcmllczpmdW5jdGlvbihiKXt2YXIgYz10aGlzLm9wdGlvbnMuY2hhcnQ7KGM9aFtiLnR5cGV8fGMudHlwZXx8Yy5kZWZhdWx0U2VyaWVzVHlwZV0pfHxhLmVycm9yKDE3LCEwKTtjPW5ldyBjO2MuaW5pdCh0aGlzLGIpO3JldHVybiBjfSxvcmRlclNlcmllczpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlcmllcztmb3IoYT1hfHwwO2E8Yi5sZW5ndGg7YSsrKWJbYV0mJihiW2FdLmluZGV4PWEsYlthXS5uYW1lPWJbYV0ubmFtZXx8XCJTZXJpZXMgXCIrKGJbYV0uaW5kZXgrMSkpfSxpc0luc2lkZVBsb3Q6ZnVuY3Rpb24oYSxcbmIsYyl7dmFyIGU9Yz9iOmE7YT1jP2E6YjtyZXR1cm4gMDw9ZSYmZTw9dGhpcy5wbG90V2lkdGgmJjA8PWEmJmE8PXRoaXMucGxvdEhlaWdodH0scmVkcmF3OmZ1bmN0aW9uKGMpe3ZhciBlPXRoaXMuYXhlcyxkPXRoaXMuc2VyaWVzLGg9dGhpcy5wb2ludGVyLHA9dGhpcy5sZWdlbmQsZz10aGlzLmlzRGlydHlMZWdlbmQsZixxLGw9dGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMsbj10aGlzLmlzRGlydHlCb3gseixtPXRoaXMucmVuZGVyZXIseD1tLmlzSGlkZGVuKCksdz1bXTt0aGlzLnNldFJlc3BvbnNpdmUmJnRoaXMuc2V0UmVzcG9uc2l2ZSghMSk7YS5zZXRBbmltYXRpb24oYyx0aGlzKTt4JiZ0aGlzLnRlbXBvcmFyeURpc3BsYXkoKTt0aGlzLmxheU91dFRpdGxlcygpO2ZvcihjPWQubGVuZ3RoO2MtLTspaWYoej1kW2NdLHoub3B0aW9ucy5zdGFja2luZyYmKGY9ITAsei5pc0RpcnR5KSl7cT0hMDticmVha31pZihxKWZvcihjPWQubGVuZ3RoO2MtLTspej1kW2NdLHoub3B0aW9ucy5zdGFja2luZyYmXG4oei5pc0RpcnR5PSEwKTtrKGQsZnVuY3Rpb24oYSl7YS5pc0RpcnR5JiZcInBvaW50XCI9PT1hLm9wdGlvbnMubGVnZW5kVHlwZSYmKGEudXBkYXRlVG90YWxzJiZhLnVwZGF0ZVRvdGFscygpLGc9ITApO2EuaXNEaXJ0eURhdGEmJnYoYSxcInVwZGF0ZWREYXRhXCIpfSk7ZyYmcC5vcHRpb25zLmVuYWJsZWQmJihwLnJlbmRlcigpLHRoaXMuaXNEaXJ0eUxlZ2VuZD0hMSk7ZiYmdGhpcy5nZXRTdGFja3MoKTtsJiZrKGUsZnVuY3Rpb24oYSl7YS51cGRhdGVOYW1lcygpO2Euc2V0U2NhbGUoKX0pO3RoaXMuZ2V0TWFyZ2lucygpO2wmJihrKGUsZnVuY3Rpb24oYSl7YS5pc0RpcnR5JiYobj0hMCl9KSxrKGUsZnVuY3Rpb24oYSl7dmFyIGM9YS5taW4rXCIsXCIrYS5tYXg7YS5leHRLZXkhPT1jJiYoYS5leHRLZXk9Yyx3LnB1c2goZnVuY3Rpb24oKXt2KGEsXCJhZnRlclNldEV4dHJlbWVzXCIsYihhLmV2ZW50QXJncyxhLmdldEV4dHJlbWVzKCkpKTtkZWxldGUgYS5ldmVudEFyZ3N9KSk7KG58fGYpJiZcbmEucmVkcmF3KCl9KSk7biYmdGhpcy5kcmF3Q2hhcnRCb3goKTt2KHRoaXMsXCJwcmVkcmF3XCIpO2soZCxmdW5jdGlvbihhKXsobnx8YS5pc0RpcnR5KSYmYS52aXNpYmxlJiZhLnJlZHJhdygpO2EuaXNEaXJ0eURhdGE9ITF9KTtoJiZoLnJlc2V0KCEwKTttLmRyYXcoKTt2KHRoaXMsXCJyZWRyYXdcIik7dih0aGlzLFwicmVuZGVyXCIpO3gmJnRoaXMudGVtcG9yYXJ5RGlzcGxheSghMCk7ayh3LGZ1bmN0aW9uKGEpe2EuY2FsbCgpfSl9LGdldDpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe3JldHVybiBiLmlkPT09YXx8Yi5vcHRpb25zJiZiLm9wdGlvbnMuaWQ9PT1hfXZhciBjLGQ9dGhpcy5zZXJpZXMsaDtjPWUodGhpcy5heGVzLGIpfHxlKHRoaXMuc2VyaWVzLGIpO2ZvcihoPTA7IWMmJmg8ZC5sZW5ndGg7aCsrKWM9ZShkW2hdLnBvaW50c3x8W10sYik7cmV0dXJuIGN9LGdldEF4ZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5vcHRpb25zLGM9Yi54QXhpcz13KGIueEF4aXN8fFxue30pLGI9Yi55QXhpcz13KGIueUF4aXN8fHt9KTtrKGMsZnVuY3Rpb24oYSxiKXthLmluZGV4PWI7YS5pc1g9ITB9KTtrKGIsZnVuY3Rpb24oYSxiKXthLmluZGV4PWJ9KTtjPWMuY29uY2F0KGIpO2soYyxmdW5jdGlvbihiKXtuZXcgZihhLGIpfSl9LGdldFNlbGVjdGVkUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9W107ayh0aGlzLnNlcmllcyxmdW5jdGlvbihiKXthPWEuY29uY2F0KG4oYi5kYXRhfHxbXSxmdW5jdGlvbihhKXtyZXR1cm4gYS5zZWxlY3RlZH0pKX0pO3JldHVybiBhfSxnZXRTZWxlY3RlZFNlcmllczpmdW5jdGlvbigpe3JldHVybiBuKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlbGVjdGVkfSl9LHNldFRpdGxlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZT10aGlzLGQ9ZS5vcHRpb25zLGg7aD1kLnRpdGxlPUIoe3N0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixmb250U2l6ZTpkLmlzU3RvY2s/XCIxNnB4XCI6XCIxOHB4XCJ9fSxkLnRpdGxlLGEpO2Q9ZC5zdWJ0aXRsZT1cbkIoe3N0eWxlOntjb2xvcjpcIiM2NjY2NjZcIn19LGQuc3VidGl0bGUsYik7ayhbW1widGl0bGVcIixhLGhdLFtcInN1YnRpdGxlXCIsYixkXV0sZnVuY3Rpb24oYSxiKXt2YXIgYz1hWzBdLGQ9ZVtjXSxoPWFbMV07YT1hWzJdO2QmJmgmJihlW2NdPWQ9ZC5kZXN0cm95KCkpO2EmJmEudGV4dCYmIWQmJihlW2NdPWUucmVuZGVyZXIudGV4dChhLnRleHQsMCwwLGEudXNlSFRNTCkuYXR0cih7YWxpZ246YS5hbGlnbixcImNsYXNzXCI6XCJoaWdoY2hhcnRzLVwiK2MsekluZGV4OmEuekluZGV4fHw0fSkuYWRkKCksZVtjXS51cGRhdGU9ZnVuY3Rpb24oYSl7ZS5zZXRUaXRsZSghYiYmYSxiJiZhKX0sZVtjXS5jc3MoYS5zdHlsZSkpfSk7ZS5sYXlPdXRUaXRsZXMoYyl9LGxheU91dFRpdGxlczpmdW5jdGlvbihhKXt2YXIgYz0wLGUsZD10aGlzLnJlbmRlcmVyLGg9dGhpcy5zcGFjaW5nQm94O2soW1widGl0bGVcIixcInN1YnRpdGxlXCJdLGZ1bmN0aW9uKGEpe3ZhciBlPXRoaXNbYV0scD10aGlzLm9wdGlvbnNbYV07XG5hPVwidGl0bGVcIj09PWE/LTM6cC52ZXJ0aWNhbEFsaWduPzA6YysyO3ZhciBnO2UmJihnPXAuc3R5bGUuZm9udFNpemUsZz1kLmZvbnRNZXRyaWNzKGcsZSkuYixlLmNzcyh7d2lkdGg6KHAud2lkdGh8fGgud2lkdGgrcC53aWR0aEFkanVzdCkrXCJweFwifSkuYWxpZ24oYih7eTphK2d9LHApLCExLFwic3BhY2luZ0JveFwiKSxwLmZsb2F0aW5nfHxwLnZlcnRpY2FsQWxpZ258fChjPU1hdGguY2VpbChjK2UuZ2V0QkJveChwLnVzZUhUTUwpLmhlaWdodCkpKX0sdGhpcyk7ZT10aGlzLnRpdGxlT2Zmc2V0IT09Yzt0aGlzLnRpdGxlT2Zmc2V0PWM7IXRoaXMuaXNEaXJ0eUJveCYmZSYmKHRoaXMuaXNEaXJ0eUJveD1lLHRoaXMuaGFzUmVuZGVyZWQmJnooYSwhMCkmJnRoaXMuaXNEaXJ0eUJveCYmdGhpcy5yZWRyYXcoKSl9LGdldENoYXJ0U2l6ZTpmdW5jdGlvbigpe3ZhciBiPXRoaXMub3B0aW9ucy5jaGFydCxjPWIud2lkdGgsYj1iLmhlaWdodCxlPXRoaXMucmVuZGVyVG87ZChjKXx8KHRoaXMuY29udGFpbmVyV2lkdGg9XG55KGUsXCJ3aWR0aFwiKSk7ZChiKXx8KHRoaXMuY29udGFpbmVySGVpZ2h0PXkoZSxcImhlaWdodFwiKSk7dGhpcy5jaGFydFdpZHRoPU1hdGgubWF4KDAsY3x8dGhpcy5jb250YWluZXJXaWR0aHx8NjAwKTt0aGlzLmNoYXJ0SGVpZ2h0PU1hdGgubWF4KDAsYS5yZWxhdGl2ZUxlbmd0aChiLHRoaXMuY2hhcnRXaWR0aCl8fHRoaXMuY29udGFpbmVySGVpZ2h0fHw0MDApfSx0ZW1wb3JhcnlEaXNwbGF5OmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMucmVuZGVyVG87aWYoYilmb3IoO2MmJmMuc3R5bGU7KWMuaGNPcmlnU3R5bGUmJihhLmNzcyhjLGMuaGNPcmlnU3R5bGUpLGRlbGV0ZSBjLmhjT3JpZ1N0eWxlKSxjLmhjT3JpZ0RldGFjaGVkJiYobS5ib2R5LnJlbW92ZUNoaWxkKGMpLGMuaGNPcmlnRGV0YWNoZWQ9ITEpLGM9Yy5wYXJlbnROb2RlO2Vsc2UgZm9yKDtjJiZjLnN0eWxlOyl7bS5ib2R5LmNvbnRhaW5zKGMpfHwoYy5oY09yaWdEZXRhY2hlZD0hMCxtLmJvZHkuYXBwZW5kQ2hpbGQoYykpO1xuaWYoXCJub25lXCI9PT15KGMsXCJkaXNwbGF5XCIsITEpfHxjLmhjT3JpY0RldGFjaGVkKWMuaGNPcmlnU3R5bGU9e2Rpc3BsYXk6Yy5zdHlsZS5kaXNwbGF5LGhlaWdodDpjLnN0eWxlLmhlaWdodCxvdmVyZmxvdzpjLnN0eWxlLm92ZXJmbG93fSxiPXtkaXNwbGF5OlwiYmxvY2tcIixvdmVyZmxvdzpcImhpZGRlblwifSxjIT09dGhpcy5yZW5kZXJUbyYmKGIuaGVpZ2h0PTApLGEuY3NzKGMsYiksYy5vZmZzZXRXaWR0aHx8Yy5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcImJsb2NrXCIsXCJpbXBvcnRhbnRcIik7Yz1jLnBhcmVudE5vZGU7aWYoYz09PW0uYm9keSlicmVha319LHNldENsYXNzTmFtZTpmdW5jdGlvbihhKXt0aGlzLmNvbnRhaW5lci5jbGFzc05hbWU9XCJoaWdoY2hhcnRzLWNvbnRhaW5lciBcIisoYXx8XCJcIil9LGdldENvbnRhaW5lcjpmdW5jdGlvbigpe3ZhciBlLGQ9dGhpcy5vcHRpb25zLGg9ZC5jaGFydCxwLGc7ZT10aGlzLnJlbmRlclRvO3ZhciBmPWEudW5pcXVlS2V5KCksaztlfHxcbih0aGlzLnJlbmRlclRvPWU9aC5yZW5kZXJUbyk7YyhlKSYmKHRoaXMucmVuZGVyVG89ZT1tLmdldEVsZW1lbnRCeUlkKGUpKTtlfHxhLmVycm9yKDEzLCEwKTtwPUkoRShlLFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpKTtEKHApJiZ0W3BdJiZ0W3BdLmhhc1JlbmRlcmVkJiZ0W3BdLmRlc3Ryb3koKTtFKGUsXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIix0aGlzLmluZGV4KTtlLmlubmVySFRNTD1cIlwiO2guc2tpcENsb25lfHxlLm9mZnNldFdpZHRofHx0aGlzLnRlbXBvcmFyeURpc3BsYXkoKTt0aGlzLmdldENoYXJ0U2l6ZSgpO3A9dGhpcy5jaGFydFdpZHRoO2c9dGhpcy5jaGFydEhlaWdodDtrPWIoe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixvdmVyZmxvdzpcImhpZGRlblwiLHdpZHRoOnArXCJweFwiLGhlaWdodDpnK1wicHhcIix0ZXh0QWxpZ246XCJsZWZ0XCIsbGluZUhlaWdodDpcIm5vcm1hbFwiLHpJbmRleDowLFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCI6XCJyZ2JhKDAsMCwwLDApXCJ9LGguc3R5bGUpO1xudGhpcy5jb250YWluZXI9ZT1sKFwiZGl2XCIse2lkOmZ9LGssZSk7dGhpcy5fY3Vyc29yPWUuc3R5bGUuY3Vyc29yO3RoaXMucmVuZGVyZXI9bmV3IChhW2gucmVuZGVyZXJdfHxRKShlLHAsZyxudWxsLGguZm9yRXhwb3J0LGQuZXhwb3J0aW5nJiZkLmV4cG9ydGluZy5hbGxvd0hUTUwpO3RoaXMuc2V0Q2xhc3NOYW1lKGguY2xhc3NOYW1lKTt0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGguc3R5bGUpO3RoaXMucmVuZGVyZXIuY2hhcnRJbmRleD10aGlzLmluZGV4fSxnZXRNYXJnaW5zOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3BhY2luZyxjPXRoaXMubWFyZ2luLGU9dGhpcy50aXRsZU9mZnNldDt0aGlzLnJlc2V0TWFyZ2lucygpO2UmJiFkKGNbMF0pJiYodGhpcy5wbG90VG9wPU1hdGgubWF4KHRoaXMucGxvdFRvcCxlK3RoaXMub3B0aW9ucy50aXRsZS5tYXJnaW4rYlswXSkpO3RoaXMubGVnZW5kLmRpc3BsYXkmJnRoaXMubGVnZW5kLmFkanVzdE1hcmdpbnMoYyxiKTt0aGlzLmV4dHJhTWFyZ2luJiZcbih0aGlzW3RoaXMuZXh0cmFNYXJnaW4udHlwZV09KHRoaXNbdGhpcy5leHRyYU1hcmdpbi50eXBlXXx8MCkrdGhpcy5leHRyYU1hcmdpbi52YWx1ZSk7dGhpcy5leHRyYVRvcE1hcmdpbiYmKHRoaXMucGxvdFRvcCs9dGhpcy5leHRyYVRvcE1hcmdpbik7YXx8dGhpcy5nZXRBeGlzTWFyZ2lucygpfSxnZXRBeGlzTWFyZ2luczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmF4aXNPZmZzZXQ9WzAsMCwwLDBdLGM9YS5tYXJnaW47YS5oYXNDYXJ0ZXNpYW5TZXJpZXMmJmsoYS5heGVzLGZ1bmN0aW9uKGEpe2EudmlzaWJsZSYmYS5nZXRPZmZzZXQoKX0pO2socSxmdW5jdGlvbihlLGgpe2QoY1toXSl8fChhW2VdKz1iW2hdKX0pO2Euc2V0Q2hhcnRTaXplKCl9LHJlZmxvdzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5vcHRpb25zLmNoYXJ0LGU9Yi5yZW5kZXJUbyxoPWQoYy53aWR0aCkmJmQoYy5oZWlnaHQpLHA9Yy53aWR0aHx8eShlLFwid2lkdGhcIiksYz1jLmhlaWdodHx8eShlLFwiaGVpZ2h0XCIpLFxuZT1hP2EudGFyZ2V0Ok87aWYoIWgmJiFiLmlzUHJpbnRpbmcmJnAmJmMmJihlPT09T3x8ZT09PW0pKXtpZihwIT09Yi5jb250YWluZXJXaWR0aHx8YyE9PWIuY29udGFpbmVySGVpZ2h0KWNsZWFyVGltZW91dChiLnJlZmxvd1RpbWVvdXQpLGIucmVmbG93VGltZW91dD1IKGZ1bmN0aW9uKCl7Yi5jb250YWluZXImJmIuc2V0U2l6ZSh2b2lkIDAsdm9pZCAwLCExKX0sYT8xMDA6MCk7Yi5jb250YWluZXJXaWR0aD1wO2IuY29udGFpbmVySGVpZ2h0PWN9fSxpbml0UmVmbG93OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiO2I9QyhPLFwicmVzaXplXCIsZnVuY3Rpb24oYil7YS5yZWZsb3coYil9KTtDKGEsXCJkZXN0cm95XCIsYil9LHNldFNpemU6ZnVuY3Rpb24oYixjLGUpe3ZhciBkPXRoaXMsaD1kLnJlbmRlcmVyO2QuaXNSZXNpemluZys9MTthLnNldEFuaW1hdGlvbihlLGQpO2Qub2xkQ2hhcnRIZWlnaHQ9ZC5jaGFydEhlaWdodDtkLm9sZENoYXJ0V2lkdGg9ZC5jaGFydFdpZHRoO3ZvaWQgMCE9PVxuYiYmKGQub3B0aW9ucy5jaGFydC53aWR0aD1iKTt2b2lkIDAhPT1jJiYoZC5vcHRpb25zLmNoYXJ0LmhlaWdodD1jKTtkLmdldENoYXJ0U2l6ZSgpO2I9aC5nbG9iYWxBbmltYXRpb247KGI/QTpnKShkLmNvbnRhaW5lcix7d2lkdGg6ZC5jaGFydFdpZHRoK1wicHhcIixoZWlnaHQ6ZC5jaGFydEhlaWdodCtcInB4XCJ9LGIpO2Quc2V0Q2hhcnRTaXplKCEwKTtoLnNldFNpemUoZC5jaGFydFdpZHRoLGQuY2hhcnRIZWlnaHQsZSk7ayhkLmF4ZXMsZnVuY3Rpb24oYSl7YS5pc0RpcnR5PSEwO2Euc2V0U2NhbGUoKX0pO2QuaXNEaXJ0eUxlZ2VuZD0hMDtkLmlzRGlydHlCb3g9ITA7ZC5sYXlPdXRUaXRsZXMoKTtkLmdldE1hcmdpbnMoKTtkLnJlZHJhdyhlKTtkLm9sZENoYXJ0SGVpZ2h0PW51bGw7dihkLFwicmVzaXplXCIpO0goZnVuY3Rpb24oKXtkJiZ2KGQsXCJlbmRSZXNpemVcIixudWxsLGZ1bmN0aW9uKCl7LS1kLmlzUmVzaXppbmd9KX0sRihiKS5kdXJhdGlvbil9LHNldENoYXJ0U2l6ZTpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2E9XG5mW2FdfHwwO3JldHVybiBNYXRoLm1heChtfHxhLGEpLzJ9dmFyIGM9dGhpcy5pbnZlcnRlZCxlPXRoaXMucmVuZGVyZXIsZD10aGlzLmNoYXJ0V2lkdGgsaD10aGlzLmNoYXJ0SGVpZ2h0LHA9dGhpcy5vcHRpb25zLmNoYXJ0LGc9dGhpcy5zcGFjaW5nLGY9dGhpcy5jbGlwT2Zmc2V0LHEsbixsLHosbTt0aGlzLnBsb3RMZWZ0PXE9TWF0aC5yb3VuZCh0aGlzLnBsb3RMZWZ0KTt0aGlzLnBsb3RUb3A9bj1NYXRoLnJvdW5kKHRoaXMucGxvdFRvcCk7dGhpcy5wbG90V2lkdGg9bD1NYXRoLm1heCgwLE1hdGgucm91bmQoZC1xLXRoaXMubWFyZ2luUmlnaHQpKTt0aGlzLnBsb3RIZWlnaHQ9ej1NYXRoLm1heCgwLE1hdGgucm91bmQoaC1uLXRoaXMubWFyZ2luQm90dG9tKSk7dGhpcy5wbG90U2l6ZVg9Yz96Omw7dGhpcy5wbG90U2l6ZVk9Yz9sOno7dGhpcy5wbG90Qm9yZGVyV2lkdGg9cC5wbG90Qm9yZGVyV2lkdGh8fDA7dGhpcy5zcGFjaW5nQm94PWUuc3BhY2luZ0JveD17eDpnWzNdLHk6Z1swXSxcbndpZHRoOmQtZ1szXS1nWzFdLGhlaWdodDpoLWdbMF0tZ1syXX07dGhpcy5wbG90Qm94PWUucGxvdEJveD17eDpxLHk6bix3aWR0aDpsLGhlaWdodDp6fTttPTIqTWF0aC5mbG9vcih0aGlzLnBsb3RCb3JkZXJXaWR0aC8yKTtjPU1hdGguY2VpbChiKDMpKTtlPU1hdGguY2VpbChiKDApKTt0aGlzLmNsaXBCb3g9e3g6Yyx5OmUsd2lkdGg6TWF0aC5mbG9vcih0aGlzLnBsb3RTaXplWC1iKDEpLWMpLGhlaWdodDpNYXRoLm1heCgwLE1hdGguZmxvb3IodGhpcy5wbG90U2l6ZVktYigyKS1lKSl9O2F8fGsodGhpcy5heGVzLGZ1bmN0aW9uKGEpe2Euc2V0QXhpc1NpemUoKTthLnNldEF4aXNUcmFuc2xhdGlvbigpfSl9LHJlc2V0TWFyZ2luczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMuY2hhcnQ7ayhbXCJtYXJnaW5cIixcInNwYWNpbmdcIl0sZnVuY3Rpb24oYyl7dmFyIGU9YltjXSxkPUooZSk/ZTpbZSxlLGUsZV07ayhbXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0sZnVuY3Rpb24oZSxcbmgpe2FbY11baF09eihiW2MrZV0sZFtoXSl9KX0pO2socSxmdW5jdGlvbihiLGMpe2FbYl09eihhLm1hcmdpbltjXSxhLnNwYWNpbmdbY10pfSk7YS5heGlzT2Zmc2V0PVswLDAsMCwwXTthLmNsaXBPZmZzZXQ9W119LGRyYXdDaGFydEJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5jaGFydCxiPXRoaXMucmVuZGVyZXIsYz10aGlzLmNoYXJ0V2lkdGgsZT10aGlzLmNoYXJ0SGVpZ2h0LGQ9dGhpcy5jaGFydEJhY2tncm91bmQsaD10aGlzLnBsb3RCYWNrZ3JvdW5kLHA9dGhpcy5wbG90Qm9yZGVyLGcsZj10aGlzLnBsb3RCR0ltYWdlLGs9YS5iYWNrZ3JvdW5kQ29sb3IscT1hLnBsb3RCYWNrZ3JvdW5kQ29sb3IsbD1hLnBsb3RCYWNrZ3JvdW5kSW1hZ2Usbix6PXRoaXMucGxvdExlZnQsbT10aGlzLnBsb3RUb3Asdz10aGlzLnBsb3RXaWR0aCxJPXRoaXMucGxvdEhlaWdodCx2PXRoaXMucGxvdEJveCxyPXRoaXMuY2xpcFJlY3QsQj10aGlzLmNsaXBCb3gseT1cImFuaW1hdGVcIjtcbmR8fCh0aGlzLmNoYXJ0QmFja2dyb3VuZD1kPWIucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1iYWNrZ3JvdW5kXCIpLmFkZCgpLHk9XCJhdHRyXCIpO2c9YS5ib3JkZXJXaWR0aHx8MDtuPWcrKGEuc2hhZG93Pzg6MCk7az17ZmlsbDprfHxcIm5vbmVcIn07aWYoZ3x8ZFtcInN0cm9rZS13aWR0aFwiXSlrLnN0cm9rZT1hLmJvcmRlckNvbG9yLGtbXCJzdHJva2Utd2lkdGhcIl09ZztkLmF0dHIoaykuc2hhZG93KGEuc2hhZG93KTtkW3ldKHt4Om4vMix5Om4vMix3aWR0aDpjLW4tZyUyLGhlaWdodDplLW4tZyUyLHI6YS5ib3JkZXJSYWRpdXN9KTt5PVwiYW5pbWF0ZVwiO2h8fCh5PVwiYXR0clwiLHRoaXMucGxvdEJhY2tncm91bmQ9aD1iLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1iYWNrZ3JvdW5kXCIpLmFkZCgpKTtoW3ldKHYpO2guYXR0cih7ZmlsbDpxfHxcIm5vbmVcIn0pLnNoYWRvdyhhLnBsb3RTaGFkb3cpO2wmJihmP2YuYW5pbWF0ZSh2KTp0aGlzLnBsb3RCR0ltYWdlPWIuaW1hZ2UobCxcbnosbSx3LEkpLmFkZCgpKTtyP3IuYW5pbWF0ZSh7d2lkdGg6Qi53aWR0aCxoZWlnaHQ6Qi5oZWlnaHR9KTp0aGlzLmNsaXBSZWN0PWIuY2xpcFJlY3QoQik7eT1cImFuaW1hdGVcIjtwfHwoeT1cImF0dHJcIix0aGlzLnBsb3RCb3JkZXI9cD1iLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1ib3JkZXJcIikuYXR0cih7ekluZGV4OjF9KS5hZGQoKSk7cC5hdHRyKHtzdHJva2U6YS5wbG90Qm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjphLnBsb3RCb3JkZXJXaWR0aHx8MCxmaWxsOlwibm9uZVwifSk7cFt5XShwLmNyaXNwKHt4OnoseTptLHdpZHRoOncsaGVpZ2h0Okl9LC1wLnN0cm9rZVdpZHRoKCkpKTt0aGlzLmlzRGlydHlCb3g9ITF9LHByb3BGcm9tU2VyaWVzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucy5jaGFydCxjLGU9YS5vcHRpb25zLnNlcmllcyxkLHA7ayhbXCJpbnZlcnRlZFwiLFwiYW5ndWxhclwiLFwicG9sYXJcIl0sZnVuY3Rpb24oZyl7Yz1oW2IudHlwZXx8Yi5kZWZhdWx0U2VyaWVzVHlwZV07XG5wPWJbZ118fGMmJmMucHJvdG90eXBlW2ddO2ZvcihkPWUmJmUubGVuZ3RoOyFwJiZkLS07KShjPWhbZVtkXS50eXBlXSkmJmMucHJvdG90eXBlW2ddJiYocD0hMCk7YVtnXT1wfSl9LGxpbmtTZXJpZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5zZXJpZXM7ayhiLGZ1bmN0aW9uKGEpe2EubGlua2VkU2VyaWVzLmxlbmd0aD0wfSk7ayhiLGZ1bmN0aW9uKGIpe3ZhciBlPWIub3B0aW9ucy5saW5rZWRUbztjKGUpJiYoZT1cIjpwcmV2aW91c1wiPT09ZT9hLnNlcmllc1tiLmluZGV4LTFdOmEuZ2V0KGUpKSYmZS5saW5rZWRQYXJlbnQhPT1iJiYoZS5saW5rZWRTZXJpZXMucHVzaChiKSxiLmxpbmtlZFBhcmVudD1lLGIudmlzaWJsZT16KGIub3B0aW9ucy52aXNpYmxlLGUub3B0aW9ucy52aXNpYmxlLGIudmlzaWJsZSkpfSl9LHJlbmRlclNlcmllczpmdW5jdGlvbigpe2sodGhpcy5zZXJpZXMsZnVuY3Rpb24oYSl7YS50cmFuc2xhdGUoKTthLnJlbmRlcigpfSl9LHJlbmRlckxhYmVsczpmdW5jdGlvbigpe3ZhciBhPVxudGhpcyxjPWEub3B0aW9ucy5sYWJlbHM7Yy5pdGVtcyYmayhjLml0ZW1zLGZ1bmN0aW9uKGUpe3ZhciBkPWIoYy5zdHlsZSxlLnN0eWxlKSxoPUkoZC5sZWZ0KSthLnBsb3RMZWZ0LHA9SShkLnRvcCkrYS5wbG90VG9wKzEyO2RlbGV0ZSBkLmxlZnQ7ZGVsZXRlIGQudG9wO2EucmVuZGVyZXIudGV4dChlLmh0bWwsaCxwKS5hdHRyKHt6SW5kZXg6Mn0pLmNzcyhkKS5hZGQoKX0pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF4ZXMsYj10aGlzLnJlbmRlcmVyLGM9dGhpcy5vcHRpb25zLGUsZCxoO3RoaXMuc2V0VGl0bGUoKTt0aGlzLmxlZ2VuZD1uZXcgRyh0aGlzLGMubGVnZW5kKTt0aGlzLmdldFN0YWNrcyYmdGhpcy5nZXRTdGFja3MoKTt0aGlzLmdldE1hcmdpbnMoITApO3RoaXMuc2V0Q2hhcnRTaXplKCk7Yz10aGlzLnBsb3RXaWR0aDtlPXRoaXMucGxvdEhlaWdodC09MjE7ayhhLGZ1bmN0aW9uKGEpe2Euc2V0U2NhbGUoKX0pO3RoaXMuZ2V0QXhpc01hcmdpbnMoKTtkPVxuMS4xPGMvdGhpcy5wbG90V2lkdGg7aD0xLjA1PGUvdGhpcy5wbG90SGVpZ2h0O2lmKGR8fGgpayhhLGZ1bmN0aW9uKGEpeyhhLmhvcml6JiZkfHwhYS5ob3JpeiYmaCkmJmEuc2V0VGlja0ludGVydmFsKCEwKX0pLHRoaXMuZ2V0TWFyZ2lucygpO3RoaXMuZHJhd0NoYXJ0Qm94KCk7dGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMmJmsoYSxmdW5jdGlvbihhKXthLnZpc2libGUmJmEucmVuZGVyKCl9KTt0aGlzLnNlcmllc0dyb3VwfHwodGhpcy5zZXJpZXNHcm91cD1iLmcoXCJzZXJpZXMtZ3JvdXBcIikuYXR0cih7ekluZGV4OjN9KS5hZGQoKSk7dGhpcy5yZW5kZXJTZXJpZXMoKTt0aGlzLnJlbmRlckxhYmVscygpO3RoaXMuYWRkQ3JlZGl0cygpO3RoaXMuc2V0UmVzcG9uc2l2ZSYmdGhpcy5zZXRSZXNwb25zaXZlKCk7dGhpcy5oYXNSZW5kZXJlZD0hMH0sYWRkQ3JlZGl0czpmdW5jdGlvbihhKXt2YXIgYj10aGlzO2E9QighMCx0aGlzLm9wdGlvbnMuY3JlZGl0cyxhKTthLmVuYWJsZWQmJiF0aGlzLmNyZWRpdHMmJlxuKHRoaXMuY3JlZGl0cz10aGlzLnJlbmRlcmVyLnRleHQoYS50ZXh0Kyh0aGlzLm1hcENyZWRpdHN8fFwiXCIpLDAsMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyZWRpdHNcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7YS5ocmVmJiYoTy5sb2NhdGlvbi5ocmVmPWEuaHJlZil9KS5hdHRyKHthbGlnbjphLnBvc2l0aW9uLmFsaWduLHpJbmRleDo4fSkuY3NzKGEuc3R5bGUpLmFkZCgpLmFsaWduKGEucG9zaXRpb24pLHRoaXMuY3JlZGl0cy51cGRhdGU9ZnVuY3Rpb24oYSl7Yi5jcmVkaXRzPWIuY3JlZGl0cy5kZXN0cm95KCk7Yi5hZGRDcmVkaXRzKGEpfSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi5heGVzLGU9Yi5zZXJpZXMsZD1iLmNvbnRhaW5lcixoLHA9ZCYmZC5wYXJlbnROb2RlO3YoYixcImRlc3Ryb3lcIik7Yi5yZW5kZXJlci5mb3JFeHBvcnQ/YS5lcmFzZSh0LGIpOnRbYi5pbmRleF09dm9pZCAwO2EuY2hhcnRDb3VudC0tO2IucmVuZGVyVG8ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpO1xuTChiKTtmb3IoaD1jLmxlbmd0aDtoLS07KWNbaF09Y1toXS5kZXN0cm95KCk7dGhpcy5zY3JvbGxlciYmdGhpcy5zY3JvbGxlci5kZXN0cm95JiZ0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtmb3IoaD1lLmxlbmd0aDtoLS07KWVbaF09ZVtoXS5kZXN0cm95KCk7ayhcInRpdGxlIHN1YnRpdGxlIGNoYXJ0QmFja2dyb3VuZCBwbG90QmFja2dyb3VuZCBwbG90QkdJbWFnZSBwbG90Qm9yZGVyIHNlcmllc0dyb3VwIGNsaXBSZWN0IGNyZWRpdHMgcG9pbnRlciByYW5nZVNlbGVjdG9yIGxlZ2VuZCByZXNldFpvb21CdXR0b24gdG9vbHRpcCByZW5kZXJlclwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhKXt2YXIgYz1iW2FdO2MmJmMuZGVzdHJveSYmKGJbYV09Yy5kZXN0cm95KCkpfSk7ZCYmKGQuaW5uZXJIVE1MPVwiXCIsTChkKSxwJiZ1KGQpKTtLKGIsZnVuY3Rpb24oYSxjKXtkZWxldGUgYltjXX0pfSxpc1JlYWR5VG9SZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBQfHxPIT1PLnRvcHx8XG5cImNvbXBsZXRlXCI9PT1tLnJlYWR5U3RhdGU/ITA6KG0uYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe20uZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixhLmZpcnN0UmVuZGVyKTtcImNvbXBsZXRlXCI9PT1tLnJlYWR5U3RhdGUmJmEuZmlyc3RSZW5kZXIoKX0pLCExKX0sZmlyc3RSZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zO2lmKGEuaXNSZWFkeVRvUmVuZGVyKCkpe2EuZ2V0Q29udGFpbmVyKCk7dihhLFwiaW5pdFwiKTthLnJlc2V0TWFyZ2lucygpO2Euc2V0Q2hhcnRTaXplKCk7YS5wcm9wRnJvbVNlcmllcygpO2EuZ2V0QXhlcygpO2soYi5zZXJpZXN8fFtdLGZ1bmN0aW9uKGIpe2EuaW5pdFNlcmllcyhiKX0pO2EubGlua1NlcmllcygpO3YoYSxcImJlZm9yZVJlbmRlclwiKTtwJiYoYS5wb2ludGVyPW5ldyBwKGEsYikpO2EucmVuZGVyKCk7aWYoIWEucmVuZGVyZXIuaW1nQ291bnQmJmEub25sb2FkKWEub25sb2FkKCk7XG5hLnRlbXBvcmFyeURpc3BsYXkoITApfX0sb25sb2FkOmZ1bmN0aW9uKCl7ayhbdGhpcy5jYWxsYmFja10uY29uY2F0KHRoaXMuY2FsbGJhY2tzKSxmdW5jdGlvbihhKXthJiZ2b2lkIDAhPT10aGlzLmluZGV4JiZhLmFwcGx5KHRoaXMsW3RoaXNdKX0sdGhpcyk7dih0aGlzLFwibG9hZFwiKTt2KHRoaXMsXCJyZW5kZXJcIik7ZCh0aGlzLmluZGV4KSYmITEhPT10aGlzLm9wdGlvbnMuY2hhcnQucmVmbG93JiZ0aGlzLmluaXRSZWZsb3coKTt0aGlzLm9ubG9hZD1udWxsfX0pfSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDLEE9YS5lYWNoLEY9YS5leHRlbmQsRT1hLmVyYXNlLG09YS5maXJlRXZlbnQsZj1hLmZvcm1hdCxsPWEuaXNBcnJheSxyPWEuaXNOdW1iZXIsdT1hLnBpY2ssdD1hLnJlbW92ZUV2ZW50O2EuUG9pbnQ9Qz1mdW5jdGlvbigpe307YS5Qb2ludC5wcm90b3R5cGU9e2luaXQ6ZnVuY3Rpb24oYSxkLGYpe3RoaXMuc2VyaWVzPWE7dGhpcy5jb2xvcj1hLmNvbG9yO3RoaXMuYXBwbHlPcHRpb25zKGQsXG5mKTthLm9wdGlvbnMuY29sb3JCeVBvaW50PyhkPWEub3B0aW9ucy5jb2xvcnN8fGEuY2hhcnQub3B0aW9ucy5jb2xvcnMsdGhpcy5jb2xvcj10aGlzLmNvbG9yfHxkW2EuY29sb3JDb3VudGVyXSxkPWQubGVuZ3RoLGY9YS5jb2xvckNvdW50ZXIsYS5jb2xvckNvdW50ZXIrKyxhLmNvbG9yQ291bnRlcj09PWQmJihhLmNvbG9yQ291bnRlcj0wKSk6Zj1hLmNvbG9ySW5kZXg7dGhpcy5jb2xvckluZGV4PXUodGhpcy5jb2xvckluZGV4LGYpO2EuY2hhcnQucG9pbnRDb3VudCsrO3JldHVybiB0aGlzfSxhcHBseU9wdGlvbnM6ZnVuY3Rpb24oYSxkKXt2YXIgZz10aGlzLnNlcmllcyxiPWcub3B0aW9ucy5wb2ludFZhbEtleXx8Zy5wb2ludFZhbEtleTthPUMucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHRoaXMsYSk7Rih0aGlzLGEpO3RoaXMub3B0aW9ucz10aGlzLm9wdGlvbnM/Rih0aGlzLm9wdGlvbnMsYSk6YTthLmdyb3VwJiZkZWxldGUgdGhpcy5ncm91cDtiJiYodGhpcy55PVxudGhpc1tiXSk7dGhpcy5pc051bGw9dSh0aGlzLmlzVmFsaWQmJiF0aGlzLmlzVmFsaWQoKSxudWxsPT09dGhpcy54fHwhcih0aGlzLnksITApKTt0aGlzLnNlbGVjdGVkJiYodGhpcy5zdGF0ZT1cInNlbGVjdFwiKTtcIm5hbWVcImluIHRoaXMmJnZvaWQgMD09PWQmJmcueEF4aXMmJmcueEF4aXMuaGFzTmFtZXMmJih0aGlzLng9Zy54QXhpcy5uYW1lVG9YKHRoaXMpKTt2b2lkIDA9PT10aGlzLngmJmcmJih0aGlzLng9dm9pZCAwPT09ZD9nLmF1dG9JbmNyZW1lbnQodGhpcyk6ZCk7cmV0dXJuIHRoaXN9LG9wdGlvbnNUb09iamVjdDpmdW5jdGlvbihhKXt2YXIgZD17fSxnPXRoaXMuc2VyaWVzLGI9Zy5vcHRpb25zLmtleXMsZT1ifHxnLnBvaW50QXJyYXlNYXB8fFtcInlcIl0sZj1lLmxlbmd0aCxtPTAsbj0wO2lmKHIoYSl8fG51bGw9PT1hKWRbZVswXV09YTtlbHNlIGlmKGwoYSkpZm9yKCFiJiZhLmxlbmd0aD5mJiYoZz10eXBlb2YgYVswXSxcInN0cmluZ1wiPT09Zz9kLm5hbWU9YVswXTpcIm51bWJlclwiPT09XG5nJiYoZC54PWFbMF0pLG0rKyk7bjxmOyliJiZ2b2lkIDA9PT1hW21dfHwoZFtlW25dXT1hW21dKSxtKyssbisrO2Vsc2VcIm9iamVjdFwiPT09dHlwZW9mIGEmJihkPWEsYS5kYXRhTGFiZWxzJiYoZy5faGFzUG9pbnRMYWJlbHM9ITApLGEubWFya2VyJiYoZy5faGFzUG9pbnRNYXJrZXJzPSEwKSk7cmV0dXJuIGR9LGdldENsYXNzTmFtZTpmdW5jdGlvbigpe3JldHVyblwiaGlnaGNoYXJ0cy1wb2ludFwiKyh0aGlzLnNlbGVjdGVkP1wiIGhpZ2hjaGFydHMtcG9pbnQtc2VsZWN0XCI6XCJcIikrKHRoaXMubmVnYXRpdmU/XCIgaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiOlwiXCIpKyh0aGlzLmlzTnVsbD9cIiBoaWdoY2hhcnRzLW51bGwtcG9pbnRcIjpcIlwiKSsodm9pZCAwIT09dGhpcy5jb2xvckluZGV4P1wiIGhpZ2hjaGFydHMtY29sb3ItXCIrdGhpcy5jb2xvckluZGV4OlwiXCIpKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lP1wiIFwiK3RoaXMub3B0aW9ucy5jbGFzc05hbWU6XCJcIikrKHRoaXMuem9uZSYmdGhpcy56b25lLmNsYXNzTmFtZT9cblwiIFwiK3RoaXMuem9uZS5jbGFzc05hbWUucmVwbGFjZShcImhpZ2hjaGFydHMtbmVnYXRpdmVcIixcIlwiKTpcIlwiKX0sZ2V0Wm9uZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuc2VyaWVzLGQ9YS56b25lcyxhPWEuem9uZUF4aXN8fFwieVwiLGY9MCxiO2ZvcihiPWRbZl07dGhpc1thXT49Yi52YWx1ZTspYj1kWysrZl07YiYmYi5jb2xvciYmIXRoaXMub3B0aW9ucy5jb2xvciYmKHRoaXMuY29sb3I9Yi5jb2xvcik7cmV0dXJuIGJ9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcy5jaGFydCxkPWEuaG92ZXJQb2ludHMsZjthLnBvaW50Q291bnQtLTtkJiYodGhpcy5zZXRTdGF0ZSgpLEUoZCx0aGlzKSxkLmxlbmd0aHx8KGEuaG92ZXJQb2ludHM9bnVsbCkpO2lmKHRoaXM9PT1hLmhvdmVyUG9pbnQpdGhpcy5vbk1vdXNlT3V0KCk7aWYodGhpcy5ncmFwaGljfHx0aGlzLmRhdGFMYWJlbCl0KHRoaXMpLHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7dGhpcy5sZWdlbmRJdGVtJiZhLmxlZ2VuZC5kZXN0cm95SXRlbSh0aGlzKTtcbmZvcihmIGluIHRoaXMpdGhpc1tmXT1udWxsfSxkZXN0cm95RWxlbWVudHM6ZnVuY3Rpb24oKXtmb3IodmFyIGE9W1wiZ3JhcGhpY1wiLFwiZGF0YUxhYmVsXCIsXCJkYXRhTGFiZWxVcHBlclwiLFwiY29ubmVjdG9yXCIsXCJzaGFkb3dHcm91cFwiXSxkLGY9NjtmLS07KWQ9YVtmXSx0aGlzW2RdJiYodGhpc1tkXT10aGlzW2RdLmRlc3Ryb3koKSl9LGdldExhYmVsQ29uZmlnOmZ1bmN0aW9uKCl7cmV0dXJue3g6dGhpcy5jYXRlZ29yeSx5OnRoaXMueSxjb2xvcjp0aGlzLmNvbG9yLGNvbG9ySW5kZXg6dGhpcy5jb2xvckluZGV4LGtleTp0aGlzLm5hbWV8fHRoaXMuY2F0ZWdvcnksc2VyaWVzOnRoaXMuc2VyaWVzLHBvaW50OnRoaXMscGVyY2VudGFnZTp0aGlzLnBlcmNlbnRhZ2UsdG90YWw6dGhpcy50b3RhbHx8dGhpcy5zdGFja1RvdGFsfX0sdG9vbHRpcEZvcm1hdHRlcjpmdW5jdGlvbihhKXt2YXIgZD10aGlzLnNlcmllcyxnPWQudG9vbHRpcE9wdGlvbnMsYj11KGcudmFsdWVEZWNpbWFscyxcIlwiKSxcbmU9Zy52YWx1ZVByZWZpeHx8XCJcIixsPWcudmFsdWVTdWZmaXh8fFwiXCI7QShkLnBvaW50QXJyYXlNYXB8fFtcInlcIl0sZnVuY3Rpb24oZCl7ZD1cIntwb2ludC5cIitkO2lmKGV8fGwpYT1hLnJlcGxhY2UoZCtcIn1cIixlK2QrXCJ9XCIrbCk7YT1hLnJlcGxhY2UoZCtcIn1cIixkK1wiOiwuXCIrYitcImZ9XCIpfSk7cmV0dXJuIGYoYSx7cG9pbnQ6dGhpcyxzZXJpZXM6dGhpcy5zZXJpZXN9KX0sZmlyZVBvaW50RXZlbnQ6ZnVuY3Rpb24oYSxkLGYpe3ZhciBiPXRoaXMsZT10aGlzLnNlcmllcy5vcHRpb25zOyhlLnBvaW50LmV2ZW50c1thXXx8Yi5vcHRpb25zJiZiLm9wdGlvbnMuZXZlbnRzJiZiLm9wdGlvbnMuZXZlbnRzW2FdKSYmdGhpcy5pbXBvcnRFdmVudHMoKTtcImNsaWNrXCI9PT1hJiZlLmFsbG93UG9pbnRTZWxlY3QmJihmPWZ1bmN0aW9uKGEpe2Iuc2VsZWN0JiZiLnNlbGVjdChudWxsLGEuY3RybEtleXx8YS5tZXRhS2V5fHxhLnNoaWZ0S2V5KX0pO20odGhpcyxhLGQsZil9LHZpc2libGU6ITB9fSkoTSk7XG4oZnVuY3Rpb24oYSl7dmFyIEM9YS5hZGRFdmVudCxBPWEuYW5pbU9iamVjdCxGPWEuYXJyYXlNYXgsRT1hLmFycmF5TWluLG09YS5jb3JyZWN0RmxvYXQsZj1hLkRhdGUsbD1hLmRlZmF1bHRPcHRpb25zLHI9YS5kZWZhdWx0UGxvdE9wdGlvbnMsdT1hLmRlZmluZWQsdD1hLmVhY2gsZz1hLmVyYXNlLGQ9YS5leHRlbmQsaz1hLmZpcmVFdmVudCxiPWEuZ3JlcCxlPWEuaXNBcnJheSx2PWEuaXNOdW1iZXIseT1hLmlzU3RyaW5nLG49YS5tZXJnZSxEPWEub2JqZWN0RWFjaCxKPWEucGljayxjPWEucmVtb3ZlRXZlbnQsRz1hLnNwbGF0LHE9YS5TVkdFbGVtZW50LEI9YS5zeW5jVGltZW91dCxLPWEud2luO2EuU2VyaWVzPWEuc2VyaWVzVHlwZShcImxpbmVcIixudWxsLHtsaW5lV2lkdGg6MixhbGxvd1BvaW50U2VsZWN0OiExLHNob3dDaGVja2JveDohMSxhbmltYXRpb246e2R1cmF0aW9uOjFFM30sZXZlbnRzOnt9LG1hcmtlcjp7bGluZVdpZHRoOjAsbGluZUNvbG9yOlwiI2ZmZmZmZlwiLHJhZGl1czo0LFxuc3RhdGVzOntob3Zlcjp7YW5pbWF0aW9uOntkdXJhdGlvbjo1MH0sZW5hYmxlZDohMCxyYWRpdXNQbHVzOjIsbGluZVdpZHRoUGx1czoxfSxzZWxlY3Q6e2ZpbGxDb2xvcjpcIiNjY2NjY2NcIixsaW5lQ29sb3I6XCIjMDAwMDAwXCIsbGluZVdpZHRoOjJ9fX0scG9pbnQ6e2V2ZW50czp7fX0sZGF0YUxhYmVsczp7YWxpZ246XCJjZW50ZXJcIixmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMueT9cIlwiOmEubnVtYmVyRm9ybWF0KHRoaXMueSwtMSl9LHN0eWxlOntmb250U2l6ZTpcIjExcHhcIixmb250V2VpZ2h0OlwiYm9sZFwiLGNvbG9yOlwiY29udHJhc3RcIix0ZXh0T3V0bGluZTpcIjFweCBjb250cmFzdFwifSx2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIseDowLHk6MCxwYWRkaW5nOjV9LGNyb3BUaHJlc2hvbGQ6MzAwLHBvaW50UmFuZ2U6MCxzb2Z0VGhyZXNob2xkOiEwLHN0YXRlczp7aG92ZXI6e2FuaW1hdGlvbjp7ZHVyYXRpb246NTB9LGxpbmVXaWR0aFBsdXM6MSxtYXJrZXI6e30sXG5oYWxvOntzaXplOjEwLG9wYWNpdHk6LjI1fX0sc2VsZWN0OnttYXJrZXI6e319fSxzdGlja3lUcmFja2luZzohMCx0dXJib1RocmVzaG9sZDoxRTMsZmluZE5lYXJlc3RQb2ludEJ5OlwieFwifSx7aXNDYXJ0ZXNpYW46ITAscG9pbnRDbGFzczphLlBvaW50LHNvcnRlZDohMCxyZXF1aXJlU29ydGluZzohMCxkaXJlY3RUb3VjaDohMSxheGlzVHlwZXM6W1wieEF4aXNcIixcInlBeGlzXCJdLGNvbG9yQ291bnRlcjowLHBhcmFsbGVsQXJyYXlzOltcInhcIixcInlcIl0sY29sbDpcInNlcmllc1wiLGluaXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGUsaD1hLnNlcmllcyxwO2MuY2hhcnQ9YTtjLm9wdGlvbnM9Yj1jLnNldE9wdGlvbnMoYik7Yy5saW5rZWRTZXJpZXM9W107Yy5iaW5kQXhlcygpO2QoYyx7bmFtZTpiLm5hbWUsc3RhdGU6XCJcIix2aXNpYmxlOiExIT09Yi52aXNpYmxlLHNlbGVjdGVkOiEwPT09Yi5zZWxlY3RlZH0pO2U9Yi5ldmVudHM7RChlLGZ1bmN0aW9uKGEsYil7QyhjLGIsYSl9KTtpZihlJiZcbmUuY2xpY2t8fGIucG9pbnQmJmIucG9pbnQuZXZlbnRzJiZiLnBvaW50LmV2ZW50cy5jbGlja3x8Yi5hbGxvd1BvaW50U2VsZWN0KWEucnVuVHJhY2tlckNsaWNrPSEwO2MuZ2V0Q29sb3IoKTtjLmdldFN5bWJvbCgpO3QoYy5wYXJhbGxlbEFycmF5cyxmdW5jdGlvbihhKXtjW2ErXCJEYXRhXCJdPVtdfSk7Yy5zZXREYXRhKGIuZGF0YSwhMSk7Yy5pc0NhcnRlc2lhbiYmKGEuaGFzQ2FydGVzaWFuU2VyaWVzPSEwKTtoLmxlbmd0aCYmKHA9aFtoLmxlbmd0aC0xXSk7Yy5faT1KKHAmJnAuX2ksLTEpKzE7YS5vcmRlclNlcmllcyh0aGlzLmluc2VydChoKSl9LGluc2VydDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMuaW5kZXgsYztpZih2KGIpKXtmb3IoYz1hLmxlbmd0aDtjLS07KWlmKGI+PUooYVtjXS5vcHRpb25zLmluZGV4LGFbY10uX2kpKXthLnNwbGljZShjKzEsMCx0aGlzKTticmVha30tMT09PWMmJmEudW5zaGlmdCh0aGlzKTtjKz0xfWVsc2UgYS5wdXNoKHRoaXMpO3JldHVybiBKKGMsXG5hLmxlbmd0aC0xKX0sYmluZEF4ZXM6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi5vcHRpb25zLGU9Yi5jaGFydCxkO3QoYi5heGlzVHlwZXN8fFtdLGZ1bmN0aW9uKGgpe3QoZVtoXSxmdW5jdGlvbihhKXtkPWEub3B0aW9ucztpZihjW2hdPT09ZC5pbmRleHx8dm9pZCAwIT09Y1toXSYmY1toXT09PWQuaWR8fHZvaWQgMD09PWNbaF0mJjA9PT1kLmluZGV4KWIuaW5zZXJ0KGEuc2VyaWVzKSxiW2hdPWEsYS5pc0RpcnR5PSEwfSk7YltoXXx8Yi5vcHRpb25hbEF4aXM9PT1ofHxhLmVycm9yKDE4LCEwKX0pfSx1cGRhdGVQYXJhbGxlbEFycmF5czpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc2VyaWVzLGU9YXJndW1lbnRzLGQ9dihiKT9mdW5jdGlvbihlKXt2YXIgZD1cInlcIj09PWUmJmMudG9ZRGF0YT9jLnRvWURhdGEoYSk6YVtlXTtjW2UrXCJEYXRhXCJdW2JdPWR9OmZ1bmN0aW9uKGEpe0FycmF5LnByb3RvdHlwZVtiXS5hcHBseShjW2ErXCJEYXRhXCJdLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsXG4yKSl9O3QoYy5wYXJhbGxlbEFycmF5cyxkKX0sYXV0b0luY3JlbWVudDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMueEluY3JlbWVudCxjLGU9YS5wb2ludEludGVydmFsVW5pdCxiPUooYixhLnBvaW50U3RhcnQsMCk7dGhpcy5wb2ludEludGVydmFsPWM9Sih0aGlzLnBvaW50SW50ZXJ2YWwsYS5wb2ludEludGVydmFsLDEpO2UmJihhPW5ldyBmKGIpLFwiZGF5XCI9PT1lP2E9K2FbZi5oY1NldERhdGVdKGFbZi5oY0dldERhdGVdKCkrYyk6XCJtb250aFwiPT09ZT9hPSthW2YuaGNTZXRNb250aF0oYVtmLmhjR2V0TW9udGhdKCkrYyk6XCJ5ZWFyXCI9PT1lJiYoYT0rYVtmLmhjU2V0RnVsbFllYXJdKGFbZi5oY0dldEZ1bGxZZWFyXSgpK2MpKSxjPWEtYik7dGhpcy54SW5jcmVtZW50PWIrYztyZXR1cm4gYn0sc2V0T3B0aW9uczpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9Yi5vcHRpb25zLGU9Yy5wbG90T3B0aW9ucyxkPShiLnVzZXJPcHRpb25zfHx7fSkucGxvdE9wdGlvbnN8fFxue30scD1lW3RoaXMudHlwZV07dGhpcy51c2VyT3B0aW9ucz1hO2I9bihwLGUuc2VyaWVzLGEpO3RoaXMudG9vbHRpcE9wdGlvbnM9bihsLnRvb2x0aXAsbC5wbG90T3B0aW9ucy5zZXJpZXMmJmwucGxvdE9wdGlvbnMuc2VyaWVzLnRvb2x0aXAsbC5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsYy50b29sdGlwLnVzZXJPcHRpb25zLGUuc2VyaWVzJiZlLnNlcmllcy50b29sdGlwLGVbdGhpcy50eXBlXS50b29sdGlwLGEudG9vbHRpcCk7dGhpcy5zdGlja3lUcmFja2luZz1KKGEuc3RpY2t5VHJhY2tpbmcsZFt0aGlzLnR5cGVdJiZkW3RoaXMudHlwZV0uc3RpY2t5VHJhY2tpbmcsZC5zZXJpZXMmJmQuc2VyaWVzLnN0aWNreVRyYWNraW5nLHRoaXMudG9vbHRpcE9wdGlvbnMuc2hhcmVkJiYhdGhpcy5ub1NoYXJlZFRvb2x0aXA/ITA6Yi5zdGlja3lUcmFja2luZyk7bnVsbD09PXAubWFya2VyJiZkZWxldGUgYi5tYXJrZXI7dGhpcy56b25lQXhpcz1iLnpvbmVBeGlzO2E9dGhpcy56b25lcz1cbihiLnpvbmVzfHxbXSkuc2xpY2UoKTshYi5uZWdhdGl2ZUNvbG9yJiYhYi5uZWdhdGl2ZUZpbGxDb2xvcnx8Yi56b25lc3x8YS5wdXNoKHt2YWx1ZTpiW3RoaXMuem9uZUF4aXMrXCJUaHJlc2hvbGRcIl18fGIudGhyZXNob2xkfHwwLGNsYXNzTmFtZTpcImhpZ2hjaGFydHMtbmVnYXRpdmVcIixjb2xvcjpiLm5lZ2F0aXZlQ29sb3IsZmlsbENvbG9yOmIubmVnYXRpdmVGaWxsQ29sb3J9KTthLmxlbmd0aCYmdShhW2EubGVuZ3RoLTFdLnZhbHVlKSYmYS5wdXNoKHtjb2xvcjp0aGlzLmNvbG9yLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcn0pO3JldHVybiBifSxnZXRDeWNsaWM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlLGQ9dGhpcy5jaGFydCxwPXRoaXMudXNlck9wdGlvbnMsZj1hK1wiSW5kZXhcIixnPWErXCJDb3VudGVyXCIsaz1jP2MubGVuZ3RoOkooZC5vcHRpb25zLmNoYXJ0W2ErXCJDb3VudFwiXSxkW2ErXCJDb3VudFwiXSk7Ynx8KGU9SihwW2ZdLHBbXCJfXCIrZl0pLHUoZSl8fChkLnNlcmllcy5sZW5ndGh8fFxuKGRbZ109MCkscFtcIl9cIitmXT1lPWRbZ10layxkW2ddKz0xKSxjJiYoYj1jW2VdKSk7dm9pZCAwIT09ZSYmKHRoaXNbZl09ZSk7dGhpc1thXT1ifSxnZXRDb2xvcjpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5jb2xvckJ5UG9pbnQ/dGhpcy5vcHRpb25zLmNvbG9yPW51bGw6dGhpcy5nZXRDeWNsaWMoXCJjb2xvclwiLHRoaXMub3B0aW9ucy5jb2xvcnx8clt0aGlzLnR5cGVdLmNvbG9yLHRoaXMuY2hhcnQub3B0aW9ucy5jb2xvcnMpfSxnZXRTeW1ib2w6ZnVuY3Rpb24oKXt0aGlzLmdldEN5Y2xpYyhcInN5bWJvbFwiLHRoaXMub3B0aW9ucy5tYXJrZXIuc3ltYm9sLHRoaXMuY2hhcnQub3B0aW9ucy5zeW1ib2xzKX0sZHJhd0xlZ2VuZFN5bWJvbDphLkxlZ2VuZFN5bWJvbE1peGluLmRyYXdMaW5lTWFya2VyLHNldERhdGE6ZnVuY3Rpb24oYixjLGQsZil7dmFyIGg9dGhpcyxwPWgucG9pbnRzLGc9cCYmcC5sZW5ndGh8fDAsayxxPWgub3B0aW9ucyxsPWguY2hhcnQsbj1udWxsLG09aC54QXhpcyxcbno9cS50dXJib1RocmVzaG9sZCxyPXRoaXMueERhdGEsQj10aGlzLnlEYXRhLEk9KGs9aC5wb2ludEFycmF5TWFwKSYmay5sZW5ndGg7Yj1ifHxbXTtrPWIubGVuZ3RoO2M9SihjLCEwKTtpZighMSE9PWYmJmsmJmc9PT1rJiYhaC5jcm9wcGVkJiYhaC5oYXNHcm91cGVkRGF0YSYmaC52aXNpYmxlKXQoYixmdW5jdGlvbihhLGIpe3BbYl0udXBkYXRlJiZhIT09cS5kYXRhW2JdJiZwW2JdLnVwZGF0ZShhLCExLG51bGwsITEpfSk7ZWxzZXtoLnhJbmNyZW1lbnQ9bnVsbDtoLmNvbG9yQ291bnRlcj0wO3QodGhpcy5wYXJhbGxlbEFycmF5cyxmdW5jdGlvbihhKXtoW2ErXCJEYXRhXCJdLmxlbmd0aD0wfSk7aWYoeiYmaz56KXtmb3IoZD0wO251bGw9PT1uJiZkPGs7KW49YltkXSxkKys7aWYodihuKSlmb3IoZD0wO2Q8aztkKyspcltkXT10aGlzLmF1dG9JbmNyZW1lbnQoKSxCW2RdPWJbZF07ZWxzZSBpZihlKG4pKWlmKEkpZm9yKGQ9MDtkPGs7ZCsrKW49YltkXSxyW2RdPW5bMF0sQltkXT1uLnNsaWNlKDEsXG5JKzEpO2Vsc2UgZm9yKGQ9MDtkPGs7ZCsrKW49YltkXSxyW2RdPW5bMF0sQltkXT1uWzFdO2Vsc2UgYS5lcnJvcigxMil9ZWxzZSBmb3IoZD0wO2Q8aztkKyspdm9pZCAwIT09YltkXSYmKG49e3NlcmllczpofSxoLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseShuLFtiW2RdXSksaC51cGRhdGVQYXJhbGxlbEFycmF5cyhuLGQpKTt5KEJbMF0pJiZhLmVycm9yKDE0LCEwKTtoLmRhdGE9W107aC5vcHRpb25zLmRhdGE9aC51c2VyT3B0aW9ucy5kYXRhPWI7Zm9yKGQ9ZztkLS07KXBbZF0mJnBbZF0uZGVzdHJveSYmcFtkXS5kZXN0cm95KCk7bSYmKG0ubWluUmFuZ2U9bS51c2VyTWluUmFuZ2UpO2guaXNEaXJ0eT1sLmlzRGlydHlCb3g9ITA7aC5pc0RpcnR5RGF0YT0hIXA7ZD0hMX1cInBvaW50XCI9PT1xLmxlZ2VuZFR5cGUmJih0aGlzLnByb2Nlc3NEYXRhKCksdGhpcy5nZW5lcmF0ZVBvaW50cygpKTtjJiZsLnJlZHJhdyhkKX0scHJvY2Vzc0RhdGE6ZnVuY3Rpb24oYil7dmFyIGM9XG50aGlzLnhEYXRhLGU9dGhpcy55RGF0YSxkPWMubGVuZ3RoLGg7aD0wO3ZhciBwLGYsZz10aGlzLnhBeGlzLGsscT10aGlzLm9wdGlvbnM7az1xLmNyb3BUaHJlc2hvbGQ7dmFyIG49dGhpcy5nZXRFeHRyZW1lc0Zyb21BbGx8fHEuZ2V0RXh0cmVtZXNGcm9tQWxsLGw9dGhpcy5pc0NhcnRlc2lhbixxPWcmJmcudmFsMmxpbixtPWcmJmcuaXNMb2csdixyO2lmKGwmJiF0aGlzLmlzRGlydHkmJiFnLmlzRGlydHkmJiF0aGlzLnlBeGlzLmlzRGlydHkmJiFiKXJldHVybiExO2cmJihiPWcuZ2V0RXh0cmVtZXMoKSx2PWIubWluLHI9Yi5tYXgpO2lmKGwmJnRoaXMuc29ydGVkJiYhbiYmKCFrfHxkPmt8fHRoaXMuZm9yY2VDcm9wKSlpZihjW2QtMV08dnx8Y1swXT5yKWM9W10sZT1bXTtlbHNlIGlmKGNbMF08dnx8Y1tkLTFdPnIpaD10aGlzLmNyb3BEYXRhKHRoaXMueERhdGEsdGhpcy55RGF0YSx2LHIpLGM9aC54RGF0YSxlPWgueURhdGEsaD1oLnN0YXJ0LHA9ITA7Zm9yKGs9Yy5sZW5ndGh8fFxuMTstLWs7KWQ9bT9xKGNba10pLXEoY1trLTFdKTpjW2tdLWNbay0xXSwwPGQmJih2b2lkIDA9PT1mfHxkPGYpP2Y9ZDowPmQmJnRoaXMucmVxdWlyZVNvcnRpbmcmJmEuZXJyb3IoMTUpO3RoaXMuY3JvcHBlZD1wO3RoaXMuY3JvcFN0YXJ0PWg7dGhpcy5wcm9jZXNzZWRYRGF0YT1jO3RoaXMucHJvY2Vzc2VkWURhdGE9ZTt0aGlzLmNsb3Nlc3RQb2ludFJhbmdlPWZ9LGNyb3BEYXRhOmZ1bmN0aW9uKGEsYixjLGUpe3ZhciBkPWEubGVuZ3RoLHA9MCxnPWQsZj1KKHRoaXMuY3JvcFNob3VsZGVyLDEpLGs7Zm9yKGs9MDtrPGQ7aysrKWlmKGFba10+PWMpe3A9TWF0aC5tYXgoMCxrLWYpO2JyZWFrfWZvcihjPWs7YzxkO2MrKylpZihhW2NdPmUpe2c9YytmO2JyZWFrfXJldHVybnt4RGF0YTphLnNsaWNlKHAsZykseURhdGE6Yi5zbGljZShwLGcpLHN0YXJ0OnAsZW5kOmd9fSxnZW5lcmF0ZVBvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPWEuZGF0YSxjPXRoaXMuZGF0YSxcbmUsZD10aGlzLnByb2Nlc3NlZFhEYXRhLGc9dGhpcy5wcm9jZXNzZWRZRGF0YSxmPXRoaXMucG9pbnRDbGFzcyxrPWQubGVuZ3RoLHE9dGhpcy5jcm9wU3RhcnR8fDAsbixsPXRoaXMuaGFzR3JvdXBlZERhdGEsYT1hLmtleXMsbSx2PVtdLHI7Y3x8bHx8KGM9W10sYy5sZW5ndGg9Yi5sZW5ndGgsYz10aGlzLmRhdGE9Yyk7YSYmbCYmKHRoaXMub3B0aW9ucy5rZXlzPSExKTtmb3Iocj0wO3I8aztyKyspbj1xK3IsbD8obT0obmV3IGYpLmluaXQodGhpcyxbZFtyXV0uY29uY2F0KEcoZ1tyXSkpKSxtLmRhdGFHcm91cD10aGlzLmdyb3VwTWFwW3JdKToobT1jW25dKXx8dm9pZCAwPT09YltuXXx8KGNbbl09bT0obmV3IGYpLmluaXQodGhpcyxiW25dLGRbcl0pKSxtJiYobS5pbmRleD1uLHZbcl09bSk7dGhpcy5vcHRpb25zLmtleXM9YTtpZihjJiYoayE9PShlPWMubGVuZ3RoKXx8bCkpZm9yKHI9MDtyPGU7cisrKXIhPT1xfHxsfHwocis9ayksY1tyXSYmKGNbcl0uZGVzdHJveUVsZW1lbnRzKCksXG5jW3JdLnBsb3RYPXZvaWQgMCk7dGhpcy5kYXRhPWM7dGhpcy5wb2ludHM9dn0sZ2V0RXh0cmVtZXM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy55QXhpcyxjPXRoaXMucHJvY2Vzc2VkWERhdGEsZCxoPVtdLHA9MDtkPXRoaXMueEF4aXMuZ2V0RXh0cmVtZXMoKTt2YXIgZz1kLm1pbixmPWQubWF4LGsscSxuLGw7YT1hfHx0aGlzLnN0YWNrZWRZRGF0YXx8dGhpcy5wcm9jZXNzZWRZRGF0YXx8W107ZD1hLmxlbmd0aDtmb3IobD0wO2w8ZDtsKyspaWYocT1jW2xdLG49YVtsXSxrPSh2KG4sITApfHxlKG4pKSYmKCFiLnBvc2l0aXZlVmFsdWVzT25seXx8bi5sZW5ndGh8fDA8bikscT10aGlzLmdldEV4dHJlbWVzRnJvbUFsbHx8dGhpcy5vcHRpb25zLmdldEV4dHJlbWVzRnJvbUFsbHx8dGhpcy5jcm9wcGVkfHwoY1tsXXx8cSk+PWcmJihjW2xdfHxxKTw9ZixrJiZxKWlmKGs9bi5sZW5ndGgpZm9yKDtrLS07KW51bGwhPT1uW2tdJiYoaFtwKytdPW5ba10pO2Vsc2UgaFtwKytdPW47dGhpcy5kYXRhTWluPVxuRShoKTt0aGlzLmRhdGFNYXg9RihoKX0sdHJhbnNsYXRlOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRYRGF0YXx8dGhpcy5wcm9jZXNzRGF0YSgpO3RoaXMuZ2VuZXJhdGVQb2ludHMoKTt2YXIgYT10aGlzLm9wdGlvbnMsYj1hLnN0YWNraW5nLGM9dGhpcy54QXhpcyxlPWMuY2F0ZWdvcmllcyxkPXRoaXMueUF4aXMsZz10aGlzLnBvaW50cyxmPWcubGVuZ3RoLGs9ISF0aGlzLm1vZGlmeVZhbHVlLHE9YS5wb2ludFBsYWNlbWVudCxuPVwiYmV0d2VlblwiPT09cXx8dihxKSxsPWEudGhyZXNob2xkLHI9YS5zdGFydEZyb21UaHJlc2hvbGQ/bDowLEIseSx0LEcsRD1OdW1iZXIuTUFYX1ZBTFVFO1wiYmV0d2VlblwiPT09cSYmKHE9LjUpO3YocSkmJihxKj1KKGEucG9pbnRSYW5nZXx8Yy5wb2ludFJhbmdlKSk7Zm9yKGE9MDthPGY7YSsrKXt2YXIgSz1nW2FdLEE9Sy54LEM9Sy55O3k9Sy5sb3c7dmFyIEU9YiYmZC5zdGFja3NbKHRoaXMubmVnU3RhY2tzJiZDPChyPzA6bCk/XCItXCI6XCJcIikrdGhpcy5zdGFja0tleV0sXG5GO2QucG9zaXRpdmVWYWx1ZXNPbmx5JiZudWxsIT09QyYmMD49QyYmKEsuaXNOdWxsPSEwKTtLLnBsb3RYPUI9bShNYXRoLm1pbihNYXRoLm1heCgtMUU1LGMudHJhbnNsYXRlKEEsMCwwLDAsMSxxLFwiZmxhZ3NcIj09PXRoaXMudHlwZSkpLDFFNSkpO2ImJnRoaXMudmlzaWJsZSYmIUsuaXNOdWxsJiZFJiZFW0FdJiYoRz10aGlzLmdldFN0YWNrSW5kaWNhdG9yKEcsQSx0aGlzLmluZGV4KSxGPUVbQV0sQz1GLnBvaW50c1tHLmtleV0seT1DWzBdLEM9Q1sxXSx5PT09ciYmRy5rZXk9PT1FW0FdLmJhc2UmJih5PUoobCxkLm1pbikpLGQucG9zaXRpdmVWYWx1ZXNPbmx5JiYwPj15JiYoeT1udWxsKSxLLnRvdGFsPUsuc3RhY2tUb3RhbD1GLnRvdGFsLEsucGVyY2VudGFnZT1GLnRvdGFsJiZLLnkvRi50b3RhbCoxMDAsSy5zdGFja1k9QyxGLnNldE9mZnNldCh0aGlzLnBvaW50WE9mZnNldHx8MCx0aGlzLmJhcld8fDApKTtLLnlCb3R0b209dSh5KT9kLnRyYW5zbGF0ZSh5LDAsMSwwLDEpOlxubnVsbDtrJiYoQz10aGlzLm1vZGlmeVZhbHVlKEMsSykpO0sucGxvdFk9eT1cIm51bWJlclwiPT09dHlwZW9mIEMmJkluZmluaXR5IT09Qz9NYXRoLm1pbihNYXRoLm1heCgtMUU1LGQudHJhbnNsYXRlKEMsMCwxLDAsMSkpLDFFNSk6dm9pZCAwO0suaXNJbnNpZGU9dm9pZCAwIT09eSYmMDw9eSYmeTw9ZC5sZW4mJjA8PUImJkI8PWMubGVuO0suY2xpZW50WD1uP20oYy50cmFuc2xhdGUoQSwwLDAsMCwxLHEpKTpCO0submVnYXRpdmU9Sy55PChsfHwwKTtLLmNhdGVnb3J5PWUmJnZvaWQgMCE9PWVbSy54XT9lW0sueF06Sy54O0suaXNOdWxsfHwodm9pZCAwIT09dCYmKEQ9TWF0aC5taW4oRCxNYXRoLmFicyhCLXQpKSksdD1CKTtLLnpvbmU9dGhpcy56b25lcy5sZW5ndGgmJksuZ2V0Wm9uZSgpfXRoaXMuY2xvc2VzdFBvaW50UmFuZ2VQeD1EfSxnZXRWYWxpZFBvaW50czpmdW5jdGlvbihhLGMpe3ZhciBlPXRoaXMuY2hhcnQ7cmV0dXJuIGIoYXx8dGhpcy5wb2ludHN8fFtdLGZ1bmN0aW9uKGEpe3JldHVybiBjJiZcbiFlLmlzSW5zaWRlUGxvdChhLnBsb3RYLGEucGxvdFksZS5pbnZlcnRlZCk/ITE6IWEuaXNOdWxsfSl9LHNldENsaXA6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMub3B0aW9ucyxlPWIucmVuZGVyZXIsZD1iLmludmVydGVkLHA9dGhpcy5jbGlwQm94LGc9cHx8Yi5jbGlwQm94LGY9dGhpcy5zaGFyZWRDbGlwS2V5fHxbXCJfc2hhcmVkQ2xpcFwiLGEmJmEuZHVyYXRpb24sYSYmYS5lYXNpbmcsZy5oZWlnaHQsYy54QXhpcyxjLnlBeGlzXS5qb2luKCksaz1iW2ZdLHE9YltmK1wibVwiXTtrfHwoYSYmKGcud2lkdGg9MCxiW2YrXCJtXCJdPXE9ZS5jbGlwUmVjdCgtOTksZD8tYi5wbG90TGVmdDotYi5wbG90VG9wLDk5LGQ/Yi5jaGFydFdpZHRoOmIuY2hhcnRIZWlnaHQpKSxiW2ZdPWs9ZS5jbGlwUmVjdChnKSxrLmNvdW50PXtsZW5ndGg6MH0pO2EmJiFrLmNvdW50W3RoaXMuaW5kZXhdJiYoay5jb3VudFt0aGlzLmluZGV4XT0hMCxrLmNvdW50Lmxlbmd0aCs9MSk7ITEhPT1jLmNsaXAmJlxuKHRoaXMuZ3JvdXAuY2xpcChhfHxwP2s6Yi5jbGlwUmVjdCksdGhpcy5tYXJrZXJHcm91cC5jbGlwKHEpLHRoaXMuc2hhcmVkQ2xpcEtleT1mKTthfHwoay5jb3VudFt0aGlzLmluZGV4XSYmKGRlbGV0ZSBrLmNvdW50W3RoaXMuaW5kZXhdLC0tay5jb3VudC5sZW5ndGgpLDA9PT1rLmNvdW50Lmxlbmd0aCYmZiYmYltmXSYmKHB8fChiW2ZdPWJbZl0uZGVzdHJveSgpKSxiW2YrXCJtXCJdJiYoYltmK1wibVwiXT1iW2YrXCJtXCJdLmRlc3Ryb3koKSkpKX0sYW5pbWF0ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9QSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSxlO2E/dGhpcy5zZXRDbGlwKGMpOihlPXRoaXMuc2hhcmVkQ2xpcEtleSwoYT1iW2VdKSYmYS5hbmltYXRlKHt3aWR0aDpiLnBsb3RTaXplWH0sYyksYltlK1wibVwiXSYmYltlK1wibVwiXS5hbmltYXRlKHt3aWR0aDpiLnBsb3RTaXplWCs5OX0sYyksdGhpcy5hbmltYXRlPW51bGwpfSxhZnRlckFuaW1hdGU6ZnVuY3Rpb24oKXt0aGlzLnNldENsaXAoKTtcbmsodGhpcyxcImFmdGVyQW5pbWF0ZVwiKTt0aGlzLmZpbmlzaGVkQW5pbWF0aW5nPSEwfSxkcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wb2ludHMsYj10aGlzLmNoYXJ0LGMsZSxkLGYsZz10aGlzLm9wdGlvbnMubWFya2VyLGsscSxuLGwsbT10aGlzW3RoaXMuc3BlY2lhbEdyb3VwXXx8dGhpcy5tYXJrZXJHcm91cCxyPUooZy5lbmFibGVkLHRoaXMueEF4aXMuaXNSYWRpYWw/ITA6bnVsbCx0aGlzLmNsb3Nlc3RQb2ludFJhbmdlUHg+PTIqZy5yYWRpdXMpO2lmKCExIT09Zy5lbmFibGVkfHx0aGlzLl9oYXNQb2ludE1hcmtlcnMpZm9yKGU9MDtlPGEubGVuZ3RoO2UrKylkPWFbZV0sYz1kLnBsb3RZLGY9ZC5ncmFwaGljLGs9ZC5tYXJrZXJ8fHt9LHE9ISFkLm1hcmtlcixuPXImJnZvaWQgMD09PWsuZW5hYmxlZHx8ay5lbmFibGVkLGw9ZC5pc0luc2lkZSxuJiZ2KGMpJiZudWxsIT09ZC55PyhjPUooay5zeW1ib2wsdGhpcy5zeW1ib2wpLGQuaGFzSW1hZ2U9MD09PWMuaW5kZXhPZihcInVybFwiKSxcbm49dGhpcy5tYXJrZXJBdHRyaWJzKGQsZC5zZWxlY3RlZCYmXCJzZWxlY3RcIiksZj9mW2w/XCJzaG93XCI6XCJoaWRlXCJdKCEwKS5hbmltYXRlKG4pOmwmJigwPG4ud2lkdGh8fGQuaGFzSW1hZ2UpJiYoZC5ncmFwaGljPWY9Yi5yZW5kZXJlci5zeW1ib2woYyxuLngsbi55LG4ud2lkdGgsbi5oZWlnaHQscT9rOmcpLmFkZChtKSksZiYmZi5hdHRyKHRoaXMucG9pbnRBdHRyaWJzKGQsZC5zZWxlY3RlZCYmXCJzZWxlY3RcIikpLGYmJmYuYWRkQ2xhc3MoZC5nZXRDbGFzc05hbWUoKSwhMCkpOmYmJihkLmdyYXBoaWM9Zi5kZXN0cm95KCkpfSxtYXJrZXJBdHRyaWJzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLm1hcmtlcixlPWEubWFya2VyfHx7fSxkPUooZS5yYWRpdXMsYy5yYWRpdXMpO2ImJihjPWMuc3RhdGVzW2JdLGI9ZS5zdGF0ZXMmJmUuc3RhdGVzW2JdLGQ9SihiJiZiLnJhZGl1cyxjJiZjLnJhZGl1cyxkKyhjJiZjLnJhZGl1c1BsdXN8fDApKSk7YS5oYXNJbWFnZSYmKGQ9XG4wKTthPXt4Ok1hdGguZmxvb3IoYS5wbG90WCktZCx5OmEucGxvdFktZH07ZCYmKGEud2lkdGg9YS5oZWlnaHQ9MipkKTtyZXR1cm4gYX0scG9pbnRBdHRyaWJzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLm1hcmtlcixlPWEmJmEub3B0aW9ucyxkPWUmJmUubWFya2VyfHx7fSxmPXRoaXMuY29sb3IsZz1lJiZlLmNvbG9yLHA9YSYmYS5jb2xvcixlPUooZC5saW5lV2lkdGgsYy5saW5lV2lkdGgpO2E9YSYmYS56b25lJiZhLnpvbmUuY29sb3I7Zj1nfHxhfHxwfHxmO2E9ZC5maWxsQ29sb3J8fGMuZmlsbENvbG9yfHxmO2Y9ZC5saW5lQ29sb3J8fGMubGluZUNvbG9yfHxmO2ImJihjPWMuc3RhdGVzW2JdLGI9ZC5zdGF0ZXMmJmQuc3RhdGVzW2JdfHx7fSxlPUooYi5saW5lV2lkdGgsYy5saW5lV2lkdGgsZStKKGIubGluZVdpZHRoUGx1cyxjLmxpbmVXaWR0aFBsdXMsMCkpLGE9Yi5maWxsQ29sb3J8fGMuZmlsbENvbG9yfHxhLGY9Yi5saW5lQ29sb3J8fGMubGluZUNvbG9yfHxcbmYpO3JldHVybntzdHJva2U6ZixcInN0cm9rZS13aWR0aFwiOmUsZmlsbDphfX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LGU9L0FwcGxlV2ViS2l0XFwvNTMzLy50ZXN0KEsubmF2aWdhdG9yLnVzZXJBZ2VudCksZCxoLGY9YS5kYXRhfHxbXSxuLGw7ayhhLFwiZGVzdHJveVwiKTtjKGEpO3QoYS5heGlzVHlwZXN8fFtdLGZ1bmN0aW9uKGIpeyhsPWFbYl0pJiZsLnNlcmllcyYmKGcobC5zZXJpZXMsYSksbC5pc0RpcnR5PWwuZm9yY2VSZWRyYXc9ITApfSk7YS5sZWdlbmRJdGVtJiZhLmNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShhKTtmb3IoaD1mLmxlbmd0aDtoLS07KShuPWZbaF0pJiZuLmRlc3Ryb3kmJm4uZGVzdHJveSgpO2EucG9pbnRzPW51bGw7Y2xlYXJUaW1lb3V0KGEuYW5pbWF0aW9uVGltZW91dCk7RChhLGZ1bmN0aW9uKGEsYil7YSBpbnN0YW5jZW9mIHEmJiFhLnN1cnZpdmUmJihkPWUmJlwiZ3JvdXBcIj09PWI/XCJoaWRlXCI6XCJkZXN0cm95XCIsYVtkXSgpKX0pO1xuYi5ob3ZlclNlcmllcz09PWEmJihiLmhvdmVyU2VyaWVzPW51bGwpO2coYi5zZXJpZXMsYSk7Yi5vcmRlclNlcmllcygpO0QoYSxmdW5jdGlvbihiLGMpe2RlbGV0ZSBhW2NdfSl9LGdldEdyYXBoUGF0aDpmdW5jdGlvbihhLGIsYyl7dmFyIGU9dGhpcyxkPWUub3B0aW9ucyxmPWQuc3RlcCxnLHA9W10saz1bXSxxO2E9YXx8ZS5wb2ludHM7KGc9YS5yZXZlcnNlZCkmJmEucmV2ZXJzZSgpOyhmPXtyaWdodDoxLGNlbnRlcjoyfVtmXXx8ZiYmMykmJmcmJihmPTQtZik7IWQuY29ubmVjdE51bGxzfHxifHxjfHwoYT10aGlzLmdldFZhbGlkUG9pbnRzKGEpKTt0KGEsZnVuY3Rpb24oaCxnKXt2YXIgbj1oLnBsb3RYLGw9aC5wbG90WSxtPWFbZy0xXTsoaC5sZWZ0Q2xpZmZ8fG0mJm0ucmlnaHRDbGlmZikmJiFjJiYocT0hMCk7aC5pc051bGwmJiF1KGIpJiYwPGc/cT0hZC5jb25uZWN0TnVsbHM6aC5pc051bGwmJiFiP3E9ITA6KDA9PT1nfHxxP2c9W1wiTVwiLGgucGxvdFgsaC5wbG90WV06ZS5nZXRQb2ludFNwbGluZT9cbmc9ZS5nZXRQb2ludFNwbGluZShhLGgsZyk6Zj8oZz0xPT09Zj9bXCJMXCIsbS5wbG90WCxsXToyPT09Zj9bXCJMXCIsKG0ucGxvdFgrbikvMixtLnBsb3RZLFwiTFwiLChtLnBsb3RYK24pLzIsbF06W1wiTFwiLG4sbS5wbG90WV0sZy5wdXNoKFwiTFwiLG4sbCkpOmc9W1wiTFwiLG4sbF0say5wdXNoKGgueCksZiYmay5wdXNoKGgueCkscC5wdXNoLmFwcGx5KHAsZykscT0hMSl9KTtwLnhNYXA9aztyZXR1cm4gZS5ncmFwaFBhdGg9cH0sZHJhd0dyYXBoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMub3B0aW9ucyxjPSh0aGlzLmdhcHBlZFBhdGh8fHRoaXMuZ2V0R3JhcGhQYXRoKS5jYWxsKHRoaXMpLGU9W1tcImdyYXBoXCIsXCJoaWdoY2hhcnRzLWdyYXBoXCIsYi5saW5lQ29sb3J8fHRoaXMuY29sb3IsYi5kYXNoU3R5bGVdXTt0KHRoaXMuem9uZXMsZnVuY3Rpb24oYyxkKXtlLnB1c2goW1wiem9uZS1ncmFwaC1cIitkLFwiaGlnaGNoYXJ0cy1ncmFwaCBoaWdoY2hhcnRzLXpvbmUtZ3JhcGgtXCIrZCtcIiBcIitcbihjLmNsYXNzTmFtZXx8XCJcIiksYy5jb2xvcnx8YS5jb2xvcixjLmRhc2hTdHlsZXx8Yi5kYXNoU3R5bGVdKX0pO3QoZSxmdW5jdGlvbihlLGQpe3ZhciBoPWVbMF0sZj1hW2hdO2Y/KGYuZW5kWD1jLnhNYXAsZi5hbmltYXRlKHtkOmN9KSk6Yy5sZW5ndGgmJihhW2hdPWEuY2hhcnQucmVuZGVyZXIucGF0aChjKS5hZGRDbGFzcyhlWzFdKS5hdHRyKHt6SW5kZXg6MX0pLmFkZChhLmdyb3VwKSxmPXtzdHJva2U6ZVsyXSxcInN0cm9rZS13aWR0aFwiOmIubGluZVdpZHRoLGZpbGw6YS5maWxsR3JhcGgmJmEuY29sb3J8fFwibm9uZVwifSxlWzNdP2YuZGFzaHN0eWxlPWVbM106XCJzcXVhcmVcIiE9PWIubGluZWNhcCYmKGZbXCJzdHJva2UtbGluZWNhcFwiXT1mW1wic3Ryb2tlLWxpbmVqb2luXCJdPVwicm91bmRcIiksZj1hW2hdLmF0dHIoZikuc2hhZG93KDI+ZCYmYi5zaGFkb3cpKTtmJiYoZi5zdGFydFg9Yy54TWFwLGYuaXNBcmVhPWMuaXNBcmVhKX0pfSxhcHBseVpvbmVzOmZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLGI9dGhpcy5jaGFydCxjPWIucmVuZGVyZXIsZT10aGlzLnpvbmVzLGQsZixnPXRoaXMuY2xpcHN8fFtdLGsscT10aGlzLmdyYXBoLG49dGhpcy5hcmVhLGw9TWF0aC5tYXgoYi5jaGFydFdpZHRoLGIuY2hhcnRIZWlnaHQpLG09dGhpc1sodGhpcy56b25lQXhpc3x8XCJ5XCIpK1wiQXhpc1wiXSxyLHYsQj1iLmludmVydGVkLHksdSxHLEQsSz0hMTtlLmxlbmd0aCYmKHF8fG4pJiZtJiZ2b2lkIDAhPT1tLm1pbiYmKHY9bS5yZXZlcnNlZCx5PW0uaG9yaXoscSYmcS5oaWRlKCksbiYmbi5oaWRlKCkscj1tLmdldEV4dHJlbWVzKCksdChlLGZ1bmN0aW9uKGUsaCl7ZD12P3k/Yi5wbG90V2lkdGg6MDp5PzA6bS50b1BpeGVscyhyLm1pbik7ZD1NYXRoLm1pbihNYXRoLm1heChKKGYsZCksMCksbCk7Zj1NYXRoLm1pbihNYXRoLm1heChNYXRoLnJvdW5kKG0udG9QaXhlbHMoSihlLnZhbHVlLHIubWF4KSwhMCkpLDApLGwpO0smJihkPWY9bS50b1BpeGVscyhyLm1heCkpO3U9TWF0aC5hYnMoZC1cbmYpO0c9TWF0aC5taW4oZCxmKTtEPU1hdGgubWF4KGQsZik7bS5pc1hBeGlzPyhrPXt4OkI/RDpHLHk6MCx3aWR0aDp1LGhlaWdodDpsfSx5fHwoay54PWIucGxvdEhlaWdodC1rLngpKTooaz17eDowLHk6Qj9EOkcsd2lkdGg6bCxoZWlnaHQ6dX0seSYmKGsueT1iLnBsb3RXaWR0aC1rLnkpKTtCJiZjLmlzVk1MJiYoaz1tLmlzWEF4aXM/e3g6MCx5OnY/RzpELGhlaWdodDprLndpZHRoLHdpZHRoOmIuY2hhcnRXaWR0aH06e3g6ay55LWIucGxvdExlZnQtYi5zcGFjaW5nQm94LngseTowLHdpZHRoOmsuaGVpZ2h0LGhlaWdodDpiLmNoYXJ0SGVpZ2h0fSk7Z1toXT9nW2hdLmFuaW1hdGUoayk6KGdbaF09Yy5jbGlwUmVjdChrKSxxJiZhW1wiem9uZS1ncmFwaC1cIitoXS5jbGlwKGdbaF0pLG4mJmFbXCJ6b25lLWFyZWEtXCIraF0uY2xpcChnW2hdKSk7Sz1lLnZhbHVlPnIubWF4fSksdGhpcy5jbGlwcz1nKX0saW52ZXJ0R3JvdXBzOmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXt0KFtcImdyb3VwXCIsXG5cIm1hcmtlckdyb3VwXCJdLGZ1bmN0aW9uKGIpe2NbYl0mJihlLnJlbmRlcmVyLmlzVk1MJiZjW2JdLmF0dHIoe3dpZHRoOmMueUF4aXMubGVuLGhlaWdodDpjLnhBeGlzLmxlbn0pLGNbYl0ud2lkdGg9Yy55QXhpcy5sZW4sY1tiXS5oZWlnaHQ9Yy54QXhpcy5sZW4sY1tiXS5pbnZlcnQoYSkpfSl9dmFyIGM9dGhpcyxlPWMuY2hhcnQsZDtjLnhBeGlzJiYoZD1DKGUsXCJyZXNpemVcIixiKSxDKGMsXCJkZXN0cm95XCIsZCksYihhKSxjLmludmVydEdyb3Vwcz1iKX0scGxvdEdyb3VwOmZ1bmN0aW9uKGEsYixjLGUsZCl7dmFyIGg9dGhpc1thXSxmPSFoO2YmJih0aGlzW2FdPWg9dGhpcy5jaGFydC5yZW5kZXJlci5nKCkuYXR0cih7ekluZGV4OmV8fC4xfSkuYWRkKGQpKTtoLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIitiK1wiIGhpZ2hjaGFydHMtc2VyaWVzLVwiK3RoaXMuaW5kZXgrXCIgaGlnaGNoYXJ0cy1cIit0aGlzLnR5cGUrXCItc2VyaWVzIGhpZ2hjaGFydHMtY29sb3ItXCIrdGhpcy5jb2xvckluZGV4K1xuXCIgXCIrKHRoaXMub3B0aW9ucy5jbGFzc05hbWV8fFwiXCIpLCEwKTtoLmF0dHIoe3Zpc2liaWxpdHk6Y30pW2Y/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHRoaXMuZ2V0UGxvdEJveCgpKTtyZXR1cm4gaH0sZ2V0UGxvdEJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj10aGlzLnhBeGlzLGM9dGhpcy55QXhpczthLmludmVydGVkJiYoYj1jLGM9dGhpcy54QXhpcyk7cmV0dXJue3RyYW5zbGF0ZVg6Yj9iLmxlZnQ6YS5wbG90TGVmdCx0cmFuc2xhdGVZOmM/Yy50b3A6YS5wbG90VG9wLHNjYWxlWDoxLHNjYWxlWToxfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsYyxlPWEub3B0aW9ucyxkPSEhYS5hbmltYXRlJiZiLnJlbmRlcmVyLmlzU1ZHJiZBKGUuYW5pbWF0aW9uKS5kdXJhdGlvbixmPWEudmlzaWJsZT9cImluaGVyaXRcIjpcImhpZGRlblwiLGc9ZS56SW5kZXgsaz1hLmhhc1JlbmRlcmVkLHE9Yi5zZXJpZXNHcm91cCxuPWIuaW52ZXJ0ZWQ7Yz1hLnBsb3RHcm91cChcImdyb3VwXCIsXG5cInNlcmllc1wiLGYsZyxxKTthLm1hcmtlckdyb3VwPWEucGxvdEdyb3VwKFwibWFya2VyR3JvdXBcIixcIm1hcmtlcnNcIixmLGcscSk7ZCYmYS5hbmltYXRlKCEwKTtjLmludmVydGVkPWEuaXNDYXJ0ZXNpYW4/bjohMTthLmRyYXdHcmFwaCYmKGEuZHJhd0dyYXBoKCksYS5hcHBseVpvbmVzKCkpO2EuZHJhd0RhdGFMYWJlbHMmJmEuZHJhd0RhdGFMYWJlbHMoKTthLnZpc2libGUmJmEuZHJhd1BvaW50cygpO2EuZHJhd1RyYWNrZXImJiExIT09YS5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcmJmEuZHJhd1RyYWNrZXIoKTthLmludmVydEdyb3VwcyhuKTshMT09PWUuY2xpcHx8YS5zaGFyZWRDbGlwS2V5fHxrfHxjLmNsaXAoYi5jbGlwUmVjdCk7ZCYmYS5hbmltYXRlKCk7a3x8KGEuYW5pbWF0aW9uVGltZW91dD1CKGZ1bmN0aW9uKCl7YS5hZnRlckFuaW1hdGUoKX0sZCkpO2EuaXNEaXJ0eT0hMTthLmhhc1JlbmRlcmVkPSEwfSxyZWRyYXc6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LFxuYj10aGlzLmlzRGlydHl8fHRoaXMuaXNEaXJ0eURhdGEsYz10aGlzLmdyb3VwLGU9dGhpcy54QXhpcyxkPXRoaXMueUF4aXM7YyYmKGEuaW52ZXJ0ZWQmJmMuYXR0cih7d2lkdGg6YS5wbG90V2lkdGgsaGVpZ2h0OmEucGxvdEhlaWdodH0pLGMuYW5pbWF0ZSh7dHJhbnNsYXRlWDpKKGUmJmUubGVmdCxhLnBsb3RMZWZ0KSx0cmFuc2xhdGVZOkooZCYmZC50b3AsYS5wbG90VG9wKX0pKTt0aGlzLnRyYW5zbGF0ZSgpO3RoaXMucmVuZGVyKCk7YiYmZGVsZXRlIHRoaXMua2RUcmVlfSxrZEF4aXNBcnJheTpbXCJjbGllbnRYXCIsXCJwbG90WVwiXSxzZWFyY2hQb2ludDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMueEF4aXMsZT10aGlzLnlBeGlzLGQ9dGhpcy5jaGFydC5pbnZlcnRlZDtyZXR1cm4gdGhpcy5zZWFyY2hLRFRyZWUoe2NsaWVudFg6ZD9jLmxlbi1hLmNoYXJ0WStjLnBvczphLmNoYXJ0WC1jLnBvcyxwbG90WTpkP2UubGVuLWEuY2hhcnRYK2UucG9zOmEuY2hhcnRZLWUucG9zfSxiKX0sXG5idWlsZEtEVHJlZTpmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYyxlLGQpe3ZhciBoLGY7aWYoZj1jJiZjLmxlbmd0aClyZXR1cm4gaD1iLmtkQXhpc0FycmF5W2UlZF0sYy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGFbaF0tYltoXX0pLGY9TWF0aC5mbG9vcihmLzIpLHtwb2ludDpjW2ZdLGxlZnQ6YShjLnNsaWNlKDAsZiksZSsxLGQpLHJpZ2h0OmEoYy5zbGljZShmKzEpLGUrMSxkKX19dGhpcy5idWlsZGluZ0tkVHJlZT0hMDt2YXIgYj10aGlzLGM9LTE8Yi5vcHRpb25zLmZpbmROZWFyZXN0UG9pbnRCeS5pbmRleE9mKFwieVwiKT8yOjE7ZGVsZXRlIGIua2RUcmVlO0IoZnVuY3Rpb24oKXtiLmtkVHJlZT1hKGIuZ2V0VmFsaWRQb2ludHMobnVsbCwhYi5kaXJlY3RUb3VjaCksYyxjKTtiLmJ1aWxkaW5nS2RUcmVlPSExfSxiLm9wdGlvbnMua2ROb3c/MDoxKX0sc2VhcmNoS0RUcmVlOmZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsaCxrKXt2YXIgcD1iLnBvaW50LHE9ZS5rZEF4aXNBcnJheVtoJVxua10sbixsLG09cDtsPXUoYVtkXSkmJnUocFtkXSk/TWF0aC5wb3coYVtkXS1wW2RdLDIpOm51bGw7bj11KGFbZl0pJiZ1KHBbZl0pP01hdGgucG93KGFbZl0tcFtmXSwyKTpudWxsO249KGx8fDApKyhufHwwKTtwLmRpc3Q9dShuKT9NYXRoLnNxcnQobik6TnVtYmVyLk1BWF9WQUxVRTtwLmRpc3RYPXUobCk/TWF0aC5zcXJ0KGwpOk51bWJlci5NQVhfVkFMVUU7cT1hW3FdLXBbcV07bj0wPnE/XCJsZWZ0XCI6XCJyaWdodFwiO2w9MD5xP1wicmlnaHRcIjpcImxlZnRcIjtiW25dJiYobj1jKGEsYltuXSxoKzEsayksbT1uW2ddPG1bZ10/bjpwKTtiW2xdJiZNYXRoLnNxcnQocSpxKTxtW2ddJiYoYT1jKGEsYltsXSxoKzEsayksbT1hW2ddPG1bZ10/YTptKTtyZXR1cm4gbX12YXIgZT10aGlzLGQ9dGhpcy5rZEF4aXNBcnJheVswXSxmPXRoaXMua2RBeGlzQXJyYXlbMV0sZz1iP1wiZGlzdFhcIjpcImRpc3RcIjtiPS0xPGUub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik/MjoxO3RoaXMua2RUcmVlfHxcbnRoaXMuYnVpbGRpbmdLZFRyZWV8fHRoaXMuYnVpbGRLRFRyZWUoKTtpZih0aGlzLmtkVHJlZSlyZXR1cm4gYyhhLHRoaXMua2RUcmVlLGIsYil9fSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5BeGlzLEE9YS5DaGFydCxGPWEuY29ycmVjdEZsb2F0LEU9YS5kZWZpbmVkLG09YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxmPWEuZWFjaCxsPWEuZm9ybWF0LHI9YS5vYmplY3RFYWNoLHU9YS5waWNrLHQ9YS5TZXJpZXM7YS5TdGFja0l0ZW09ZnVuY3Rpb24oYSxkLGYsYixlKXt2YXIgZz1hLmNoYXJ0LmludmVydGVkO3RoaXMuYXhpcz1hO3RoaXMuaXNOZWdhdGl2ZT1mO3RoaXMub3B0aW9ucz1kO3RoaXMueD1iO3RoaXMudG90YWw9bnVsbDt0aGlzLnBvaW50cz17fTt0aGlzLnN0YWNrPWU7dGhpcy5yaWdodENsaWZmPXRoaXMubGVmdENsaWZmPTA7dGhpcy5hbGlnbk9wdGlvbnM9e2FsaWduOmQuYWxpZ258fChnP2Y/XCJsZWZ0XCI6XCJyaWdodFwiOlwiY2VudGVyXCIpLHZlcnRpY2FsQWxpZ246ZC52ZXJ0aWNhbEFsaWdufHxcbihnP1wibWlkZGxlXCI6Zj9cImJvdHRvbVwiOlwidG9wXCIpLHk6dShkLnksZz80OmY/MTQ6LTYpLHg6dShkLngsZz9mPy02OjY6MCl9O3RoaXMudGV4dEFsaWduPWQudGV4dEFsaWdufHwoZz9mP1wicmlnaHRcIjpcImxlZnRcIjpcImNlbnRlclwiKX07YS5TdGFja0l0ZW0ucHJvdG90eXBlPXtkZXN0cm95OmZ1bmN0aW9uKCl7bSh0aGlzLHRoaXMuYXhpcyl9LHJlbmRlcjpmdW5jdGlvbihhKXt2YXIgZD10aGlzLm9wdGlvbnMsZj1kLmZvcm1hdCxmPWY/bChmLHRoaXMpOmQuZm9ybWF0dGVyLmNhbGwodGhpcyk7dGhpcy5sYWJlbD90aGlzLmxhYmVsLmF0dHIoe3RleHQ6Zix2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KTp0aGlzLmxhYmVsPXRoaXMuYXhpcy5jaGFydC5yZW5kZXJlci50ZXh0KGYsbnVsbCxudWxsLGQudXNlSFRNTCkuY3NzKGQuc3R5bGUpLmF0dHIoe2FsaWduOnRoaXMudGV4dEFsaWduLHJvdGF0aW9uOmQucm90YXRpb24sdmlzaWJpbGl0eTpcImhpZGRlblwifSkuYWRkKGEpfSxzZXRPZmZzZXQ6ZnVuY3Rpb24oYSxcbmQpe3ZhciBmPXRoaXMuYXhpcyxiPWYuY2hhcnQsZT1mLnRyYW5zbGF0ZShmLnVzZVBlcmNlbnRhZ2U/MTAwOnRoaXMudG90YWwsMCwwLDAsMSksZj1mLnRyYW5zbGF0ZSgwKSxmPU1hdGguYWJzKGUtZik7YT1iLnhBeGlzWzBdLnRyYW5zbGF0ZSh0aGlzLngpK2E7ZT10aGlzLmdldFN0YWNrQm94KGIsdGhpcyxhLGUsZCxmKTtpZihkPXRoaXMubGFiZWwpZC5hbGlnbih0aGlzLmFsaWduT3B0aW9ucyxudWxsLGUpLGU9ZC5hbGlnbkF0dHIsZFshMT09PXRoaXMub3B0aW9ucy5jcm9wfHxiLmlzSW5zaWRlUGxvdChlLngsZS55KT9cInNob3dcIjpcImhpZGVcIl0oITApfSxnZXRTdGFja0JveDpmdW5jdGlvbihhLGQsZixiLGUsbCl7dmFyIGc9ZC5heGlzLnJldmVyc2VkLGs9YS5pbnZlcnRlZDthPWEucGxvdEhlaWdodDtkPWQuaXNOZWdhdGl2ZSYmIWd8fCFkLmlzTmVnYXRpdmUmJmc7cmV0dXJue3g6az9kP2I6Yi1sOmYseTprP2EtZi1lOmQ/YS1iLWw6YS1iLHdpZHRoOms/bDplLGhlaWdodDprP1xuZTpsfX19O0EucHJvdG90eXBlLmdldFN0YWNrcz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7ZihhLnlBeGlzLGZ1bmN0aW9uKGEpe2Euc3RhY2tzJiZhLmhhc1Zpc2libGVTZXJpZXMmJihhLm9sZFN0YWNrcz1hLnN0YWNrcyl9KTtmKGEuc2VyaWVzLGZ1bmN0aW9uKGQpeyFkLm9wdGlvbnMuc3RhY2tpbmd8fCEwIT09ZC52aXNpYmxlJiYhMSE9PWEub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXN8fChkLnN0YWNrS2V5PWQudHlwZSt1KGQub3B0aW9ucy5zdGFjayxcIlwiKSl9KX07Qy5wcm90b3R5cGUuYnVpbGRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcyxkPXUodGhpcy5vcHRpb25zLnJldmVyc2VkU3RhY2tzLCEwKSxmPWEubGVuZ3RoLGI7aWYoIXRoaXMuaXNYQXhpcyl7dGhpcy51c2VQZXJjZW50YWdlPSExO2ZvcihiPWY7Yi0tOylhW2Q/YjpmLWItMV0uc2V0U3RhY2tlZFBvaW50cygpO2lmKHRoaXMudXNlUGVyY2VudGFnZSlmb3IoYj0wO2I8ZjtiKyspYVtiXS5zZXRQZXJjZW50U3RhY2tzKCl9fTtcbkMucHJvdG90eXBlLnJlbmRlclN0YWNrVG90YWxzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxkPWEucmVuZGVyZXIsZj10aGlzLnN0YWNrcyxiPXRoaXMuc3RhY2tUb3RhbEdyb3VwO2J8fCh0aGlzLnN0YWNrVG90YWxHcm91cD1iPWQuZyhcInN0YWNrLWxhYmVsc1wiKS5hdHRyKHt2aXNpYmlsaXR5OlwidmlzaWJsZVwiLHpJbmRleDo2fSkuYWRkKCkpO2IudHJhbnNsYXRlKGEucGxvdExlZnQsYS5wbG90VG9wKTtyKGYsZnVuY3Rpb24oYSl7cihhLGZ1bmN0aW9uKGEpe2EucmVuZGVyKGIpfSl9KX07Qy5wcm90b3R5cGUucmVzZXRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5zdGFja3M7YS5pc1hBeGlzfHxyKGQsZnVuY3Rpb24oZCl7cihkLGZ1bmN0aW9uKGIsZSl7Yi50b3VjaGVkPGEuc3RhY2tzVG91Y2hlZD8oYi5kZXN0cm95KCksZGVsZXRlIGRbZV0pOihiLnRvdGFsPW51bGwsYi5jdW09bnVsbCl9KX0pfTtDLnByb3RvdHlwZS5jbGVhblN0YWNrcz1mdW5jdGlvbigpe3ZhciBhO1xudGhpcy5pc1hBeGlzfHwodGhpcy5vbGRTdGFja3MmJihhPXRoaXMuc3RhY2tzPXRoaXMub2xkU3RhY2tzKSxyKGEsZnVuY3Rpb24oYSl7cihhLGZ1bmN0aW9uKGEpe2EuY3VtPWEudG90YWx9KX0pKX07dC5wcm90b3R5cGUuc2V0U3RhY2tlZFBvaW50cz1mdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5zdGFja2luZyYmKCEwPT09dGhpcy52aXNpYmxlfHwhMT09PXRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMpKXt2YXIgZj10aGlzLnByb2Nlc3NlZFhEYXRhLGQ9dGhpcy5wcm9jZXNzZWRZRGF0YSxrPVtdLGI9ZC5sZW5ndGgsZT10aGlzLm9wdGlvbnMsbD1lLnRocmVzaG9sZCxtPWUuc3RhcnRGcm9tVGhyZXNob2xkP2w6MCxuPWUuc3RhY2ssZT1lLnN0YWNraW5nLHI9dGhpcy5zdGFja0tleSx0PVwiLVwiK3IsYz10aGlzLm5lZ1N0YWNrcyxHPXRoaXMueUF4aXMscT1HLnN0YWNrcyxCPUcub2xkU3RhY2tzLEsscCx6LEksQSxoLHc7Ry5zdGFja3NUb3VjaGVkKz1cbjE7Zm9yKEE9MDtBPGI7QSsrKWg9ZltBXSx3PWRbQV0sSz10aGlzLmdldFN0YWNrSW5kaWNhdG9yKEssaCx0aGlzLmluZGV4KSxJPUsua2V5LHo9KHA9YyYmdzwobT8wOmwpKT90OnIscVt6XXx8KHFbel09e30pLHFbel1baF18fChCW3pdJiZCW3pdW2hdPyhxW3pdW2hdPUJbel1baF0scVt6XVtoXS50b3RhbD1udWxsKTpxW3pdW2hdPW5ldyBhLlN0YWNrSXRlbShHLEcub3B0aW9ucy5zdGFja0xhYmVscyxwLGgsbikpLHo9cVt6XVtoXSxudWxsIT09dyYmKHoucG9pbnRzW0ldPXoucG9pbnRzW3RoaXMuaW5kZXhdPVt1KHouY3VtLG0pXSxFKHouY3VtKXx8KHouYmFzZT1JKSx6LnRvdWNoZWQ9Ry5zdGFja3NUb3VjaGVkLDA8Sy5pbmRleCYmITE9PT10aGlzLnNpbmdsZVN0YWNrcyYmKHoucG9pbnRzW0ldWzBdPXoucG9pbnRzW3RoaXMuaW5kZXgrXCIsXCIraCtcIiwwXCJdWzBdKSksXCJwZXJjZW50XCI9PT1lPyhwPXA/cjp0LGMmJnFbcF0mJnFbcF1baF0/KHA9cVtwXVtoXSx6LnRvdGFsPXAudG90YWw9XG5NYXRoLm1heChwLnRvdGFsLHoudG90YWwpK01hdGguYWJzKHcpfHwwKTp6LnRvdGFsPUYoei50b3RhbCsoTWF0aC5hYnModyl8fDApKSk6ei50b3RhbD1GKHoudG90YWwrKHd8fDApKSx6LmN1bT11KHouY3VtLG0pKyh3fHwwKSxudWxsIT09dyYmKHoucG9pbnRzW0ldLnB1c2goei5jdW0pLGtbQV09ei5jdW0pO1wicGVyY2VudFwiPT09ZSYmKEcudXNlUGVyY2VudGFnZT0hMCk7dGhpcy5zdGFja2VkWURhdGE9aztHLm9sZFN0YWNrcz17fX19O3QucHJvdG90eXBlLnNldFBlcmNlbnRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5zdGFja0tleSxrPWEueUF4aXMuc3RhY2tzLGI9YS5wcm9jZXNzZWRYRGF0YSxlO2YoW2QsXCItXCIrZF0sZnVuY3Rpb24oZCl7Zm9yKHZhciBmPWIubGVuZ3RoLGcsbDtmLS07KWlmKGc9YltmXSxlPWEuZ2V0U3RhY2tJbmRpY2F0b3IoZSxnLGEuaW5kZXgsZCksZz0obD1rW2RdJiZrW2RdW2ddKSYmbC5wb2ludHNbZS5rZXldKWw9bC50b3RhbD8xMDAvXG5sLnRvdGFsOjAsZ1swXT1GKGdbMF0qbCksZ1sxXT1GKGdbMV0qbCksYS5zdGFja2VkWURhdGFbZl09Z1sxXX0pfTt0LnByb3RvdHlwZS5nZXRTdGFja0luZGljYXRvcj1mdW5jdGlvbihhLGQsZixiKXshRShhKXx8YS54IT09ZHx8YiYmYS5rZXkhPT1iP2E9e3g6ZCxpbmRleDowLGtleTpifTphLmluZGV4Kys7YS5rZXk9W2YsZCxhLmluZGV4XS5qb2luKCk7cmV0dXJuIGF9fSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDPWEuYWRkRXZlbnQsQT1hLmFuaW1hdGUsRj1hLkF4aXMsRT1hLmNyZWF0ZUVsZW1lbnQsbT1hLmNzcyxmPWEuZGVmaW5lZCxsPWEuZWFjaCxyPWEuZXJhc2UsdT1hLmV4dGVuZCx0PWEuZmlyZUV2ZW50LGc9YS5pbkFycmF5LGQ9YS5pc051bWJlcixrPWEuaXNPYmplY3QsYj1hLmlzQXJyYXksZT1hLm1lcmdlLHY9YS5vYmplY3RFYWNoLHk9YS5waWNrLG49YS5Qb2ludCxEPWEuU2VyaWVzLEo9YS5zZXJpZXNUeXBlcyxjPWEuc2V0QW5pbWF0aW9uLEc9YS5zcGxhdDt1KGEuQ2hhcnQucHJvdG90eXBlLFxue2FkZFNlcmllczpmdW5jdGlvbihhLGIsYyl7dmFyIGUsZD10aGlzO2EmJihiPXkoYiwhMCksdChkLFwiYWRkU2VyaWVzXCIse29wdGlvbnM6YX0sZnVuY3Rpb24oKXtlPWQuaW5pdFNlcmllcyhhKTtkLmlzRGlydHlMZWdlbmQ9ITA7ZC5saW5rU2VyaWVzKCk7YiYmZC5yZWRyYXcoYyl9KSk7cmV0dXJuIGV9LGFkZEF4aXM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGY9Yj9cInhBeGlzXCI6XCJ5QXhpc1wiLGc9dGhpcy5vcHRpb25zO2E9ZShhLHtpbmRleDp0aGlzW2ZdLmxlbmd0aCxpc1g6Yn0pO2I9bmV3IEYodGhpcyxhKTtnW2ZdPUcoZ1tmXXx8e30pO2dbZl0ucHVzaChhKTt5KGMsITApJiZ0aGlzLnJlZHJhdyhkKTtyZXR1cm4gYn0sc2hvd0xvYWRpbmc6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIub3B0aW9ucyxlPWIubG9hZGluZ0RpdixkPWMubG9hZGluZyxmPWZ1bmN0aW9uKCl7ZSYmbShlLHtsZWZ0OmIucGxvdExlZnQrXCJweFwiLHRvcDpiLnBsb3RUb3ArXCJweFwiLHdpZHRoOmIucGxvdFdpZHRoK1xuXCJweFwiLGhlaWdodDpiLnBsb3RIZWlnaHQrXCJweFwifSl9O2V8fChiLmxvYWRpbmdEaXY9ZT1FKFwiZGl2XCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtbG9hZGluZyBoaWdoY2hhcnRzLWxvYWRpbmctaGlkZGVuXCJ9LG51bGwsYi5jb250YWluZXIpLGIubG9hZGluZ1NwYW49RShcInNwYW5cIix7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1sb2FkaW5nLWlubmVyXCJ9LG51bGwsZSksQyhiLFwicmVkcmF3XCIsZikpO2UuY2xhc3NOYW1lPVwiaGlnaGNoYXJ0cy1sb2FkaW5nXCI7Yi5sb2FkaW5nU3Bhbi5pbm5lckhUTUw9YXx8Yy5sYW5nLmxvYWRpbmc7bShlLHUoZC5zdHlsZSx7ekluZGV4OjEwfSkpO20oYi5sb2FkaW5nU3BhbixkLmxhYmVsU3R5bGUpO2IubG9hZGluZ1Nob3dufHwobShlLHtvcGFjaXR5OjAsZGlzcGxheTpcIlwifSksQShlLHtvcGFjaXR5OmQuc3R5bGUub3BhY2l0eXx8LjV9LHtkdXJhdGlvbjpkLnNob3dEdXJhdGlvbnx8MH0pKTtiLmxvYWRpbmdTaG93bj0hMDtmKCl9LGhpZGVMb2FkaW5nOmZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLm9wdGlvbnMsYj10aGlzLmxvYWRpbmdEaXY7YiYmKGIuY2xhc3NOYW1lPVwiaGlnaGNoYXJ0cy1sb2FkaW5nIGhpZ2hjaGFydHMtbG9hZGluZy1oaWRkZW5cIixBKGIse29wYWNpdHk6MH0se2R1cmF0aW9uOmEubG9hZGluZy5oaWRlRHVyYXRpb258fDEwMCxjb21wbGV0ZTpmdW5jdGlvbigpe20oYix7ZGlzcGxheTpcIm5vbmVcIn0pfX0pKTt0aGlzLmxvYWRpbmdTaG93bj0hMX0scHJvcHNSZXF1aXJlRGlydHlCb3g6XCJiYWNrZ3JvdW5kQ29sb3IgYm9yZGVyQ29sb3IgYm9yZGVyV2lkdGggbWFyZ2luIG1hcmdpblRvcCBtYXJnaW5SaWdodCBtYXJnaW5Cb3R0b20gbWFyZ2luTGVmdCBzcGFjaW5nIHNwYWNpbmdUb3Agc3BhY2luZ1JpZ2h0IHNwYWNpbmdCb3R0b20gc3BhY2luZ0xlZnQgYm9yZGVyUmFkaXVzIHBsb3RCYWNrZ3JvdW5kQ29sb3IgcGxvdEJhY2tncm91bmRJbWFnZSBwbG90Qm9yZGVyQ29sb3IgcGxvdEJvcmRlcldpZHRoIHBsb3RTaGFkb3cgc2hhZG93XCIuc3BsaXQoXCIgXCIpLFxucHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzOlwiY2hhcnQuaW52ZXJ0ZWQgY2hhcnQucG9sYXIgY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzIGNoYXJ0LnR5cGUgY29sb3JzIHBsb3RPcHRpb25zIHRvb2x0aXBcIi5zcGxpdChcIiBcIiksdXBkYXRlOmZ1bmN0aW9uKGEsYixjKXt2YXIgaz10aGlzLG49e2NyZWRpdHM6XCJhZGRDcmVkaXRzXCIsdGl0bGU6XCJzZXRUaXRsZVwiLHN1YnRpdGxlOlwic2V0U3VidGl0bGVcIn0scT1hLmNoYXJ0LG0saCxyPVtdO2lmKHEpe2UoITAsay5vcHRpb25zLmNoYXJ0LHEpO1wiY2xhc3NOYW1lXCJpbiBxJiZrLnNldENsYXNzTmFtZShxLmNsYXNzTmFtZSk7aWYoXCJpbnZlcnRlZFwiaW4gcXx8XCJwb2xhclwiaW4gcSlrLnByb3BGcm9tU2VyaWVzKCksbT0hMDtcImFsaWduVGlja3NcImluIHEmJihtPSEwKTt2KHEsZnVuY3Rpb24oYSxiKXstMSE9PWcoXCJjaGFydC5cIitiLGsucHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzKSYmKGg9ITApOy0xIT09ZyhiLGsucHJvcHNSZXF1aXJlRGlydHlCb3gpJiZcbihrLmlzRGlydHlCb3g9ITApfSk7XCJzdHlsZVwiaW4gcSYmay5yZW5kZXJlci5zZXRTdHlsZShxLnN0eWxlKX1hLmNvbG9ycyYmKHRoaXMub3B0aW9ucy5jb2xvcnM9YS5jb2xvcnMpO2EucGxvdE9wdGlvbnMmJmUoITAsdGhpcy5vcHRpb25zLnBsb3RPcHRpb25zLGEucGxvdE9wdGlvbnMpO3YoYSxmdW5jdGlvbihhLGIpe2lmKGtbYl0mJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBrW2JdLnVwZGF0ZSlrW2JdLnVwZGF0ZShhLCExKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBrW25bYl1dKWtbbltiXV0oYSk7XCJjaGFydFwiIT09YiYmLTEhPT1nKGIsay5wcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXMpJiYoaD0hMCl9KTtsKFwieEF4aXMgeUF4aXMgekF4aXMgc2VyaWVzIGNvbG9yQXhpcyBwYW5lXCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGIpe2FbYl0mJihsKEcoYVtiXSksZnVuY3Rpb24oYSxlKXsoZT1mKGEuaWQpJiZrLmdldChhLmlkKXx8a1tiXVtlXSkmJmUuY29sbD09PWImJihlLnVwZGF0ZShhLFxuITEpLGMmJihlLnRvdWNoZWQ9ITApKTtpZighZSYmYylpZihcInNlcmllc1wiPT09YilrLmFkZFNlcmllcyhhLCExKS50b3VjaGVkPSEwO2Vsc2UgaWYoXCJ4QXhpc1wiPT09Ynx8XCJ5QXhpc1wiPT09YilrLmFkZEF4aXMoYSxcInhBeGlzXCI9PT1iLCExKS50b3VjaGVkPSEwfSksYyYmbChrW2JdLGZ1bmN0aW9uKGEpe2EudG91Y2hlZD9kZWxldGUgYS50b3VjaGVkOnIucHVzaChhKX0pKX0pO2wocixmdW5jdGlvbihhKXthLnJlbW92ZSghMSl9KTttJiZsKGsuYXhlcyxmdW5jdGlvbihhKXthLnVwZGF0ZSh7fSwhMSl9KTtoJiZsKGsuc2VyaWVzLGZ1bmN0aW9uKGEpe2EudXBkYXRlKHt9LCExKX0pO2EubG9hZGluZyYmZSghMCxrLm9wdGlvbnMubG9hZGluZyxhLmxvYWRpbmcpO209cSYmcS53aWR0aDtxPXEmJnEuaGVpZ2h0O2QobSkmJm0hPT1rLmNoYXJ0V2lkdGh8fGQocSkmJnEhPT1rLmNoYXJ0SGVpZ2h0P2suc2V0U2l6ZShtLHEpOnkoYiwhMCkmJmsucmVkcmF3KCl9LHNldFN1YnRpdGxlOmZ1bmN0aW9uKGEpe3RoaXMuc2V0VGl0bGUodm9pZCAwLFxuYSl9fSk7dShuLnByb3RvdHlwZSx7dXBkYXRlOmZ1bmN0aW9uKGEsYixjLGUpe2Z1bmN0aW9uIGQoKXtmLmFwcGx5T3B0aW9ucyhhKTtudWxsPT09Zi55JiZoJiYoZi5ncmFwaGljPWguZGVzdHJveSgpKTtrKGEsITApJiYoaCYmaC5lbGVtZW50JiZhJiZhLm1hcmtlciYmdm9pZCAwIT09YS5tYXJrZXIuc3ltYm9sJiYoZi5ncmFwaGljPWguZGVzdHJveSgpKSxhJiZhLmRhdGFMYWJlbHMmJmYuZGF0YUxhYmVsJiYoZi5kYXRhTGFiZWw9Zi5kYXRhTGFiZWwuZGVzdHJveSgpKSk7cD1mLmluZGV4O2cudXBkYXRlUGFyYWxsZWxBcnJheXMoZixwKTtxLmRhdGFbcF09ayhxLmRhdGFbcF0sITApfHxrKGEsITApP2Yub3B0aW9uczphO2cuaXNEaXJ0eT1nLmlzRGlydHlEYXRhPSEwOyFnLmZpeGVkQm94JiZnLmhhc0NhcnRlc2lhblNlcmllcyYmKGwuaXNEaXJ0eUJveD0hMCk7XCJwb2ludFwiPT09cS5sZWdlbmRUeXBlJiYobC5pc0RpcnR5TGVnZW5kPSEwKTtiJiZsLnJlZHJhdyhjKX12YXIgZj1cbnRoaXMsZz1mLnNlcmllcyxoPWYuZ3JhcGhpYyxwLGw9Zy5jaGFydCxxPWcub3B0aW9ucztiPXkoYiwhMCk7ITE9PT1lP2QoKTpmLmZpcmVQb2ludEV2ZW50KFwidXBkYXRlXCIse29wdGlvbnM6YX0sZCl9LHJlbW92ZTpmdW5jdGlvbihhLGIpe3RoaXMuc2VyaWVzLnJlbW92ZVBvaW50KGcodGhpcyx0aGlzLnNlcmllcy5kYXRhKSxhLGIpfX0pO3UoRC5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKGEsYixjLGUpe3ZhciBkPXRoaXMub3B0aW9ucyxmPXRoaXMuZGF0YSxnPXRoaXMuY2hhcnQsaD10aGlzLnhBeGlzLGg9aCYmaC5oYXNOYW1lcyYmaC5uYW1lcyxrPWQuZGF0YSxwLGwscT10aGlzLnhEYXRhLG4sbTtiPXkoYiwhMCk7cD17c2VyaWVzOnRoaXN9O3RoaXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KHAsW2FdKTttPXAueDtuPXEubGVuZ3RoO2lmKHRoaXMucmVxdWlyZVNvcnRpbmcmJm08cVtuLTFdKWZvcihsPSEwO24mJnFbbi0xXT5tOyluLS07XG50aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHAsXCJzcGxpY2VcIixuLDAsMCk7dGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwLG4pO2gmJnAubmFtZSYmKGhbbV09cC5uYW1lKTtrLnNwbGljZShuLDAsYSk7bCYmKHRoaXMuZGF0YS5zcGxpY2UobiwwLG51bGwpLHRoaXMucHJvY2Vzc0RhdGEoKSk7XCJwb2ludFwiPT09ZC5sZWdlbmRUeXBlJiZ0aGlzLmdlbmVyYXRlUG9pbnRzKCk7YyYmKGZbMF0mJmZbMF0ucmVtb3ZlP2ZbMF0ucmVtb3ZlKCExKTooZi5zaGlmdCgpLHRoaXMudXBkYXRlUGFyYWxsZWxBcnJheXMocCxcInNoaWZ0XCIpLGsuc2hpZnQoKSkpO3RoaXMuaXNEaXJ0eURhdGE9dGhpcy5pc0RpcnR5PSEwO2ImJmcucmVkcmF3KGUpfSxyZW1vdmVQb2ludDpmdW5jdGlvbihhLGIsZSl7dmFyIGQ9dGhpcyxmPWQuZGF0YSxnPWZbYV0saz1kLnBvaW50cyxoPWQuY2hhcnQsbD1mdW5jdGlvbigpe2smJmsubGVuZ3RoPT09Zi5sZW5ndGgmJmsuc3BsaWNlKGEsMSk7Zi5zcGxpY2UoYSwxKTtcbmQub3B0aW9ucy5kYXRhLnNwbGljZShhLDEpO2QudXBkYXRlUGFyYWxsZWxBcnJheXMoZ3x8e3NlcmllczpkfSxcInNwbGljZVwiLGEsMSk7ZyYmZy5kZXN0cm95KCk7ZC5pc0RpcnR5PSEwO2QuaXNEaXJ0eURhdGE9ITA7YiYmaC5yZWRyYXcoKX07YyhlLGgpO2I9eShiLCEwKTtnP2cuZmlyZVBvaW50RXZlbnQoXCJyZW1vdmVcIixudWxsLGwpOmwoKX0scmVtb3ZlOmZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBlKCl7ZC5kZXN0cm95KCk7Zi5pc0RpcnR5TGVnZW5kPWYuaXNEaXJ0eUJveD0hMDtmLmxpbmtTZXJpZXMoKTt5KGEsITApJiZmLnJlZHJhdyhiKX12YXIgZD10aGlzLGY9ZC5jaGFydDshMSE9PWM/dChkLFwicmVtb3ZlXCIsbnVsbCxlKTplKCl9LHVwZGF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLmNoYXJ0LGY9Yy51c2VyT3B0aW9ucyxnPWMub2xkVHlwZXx8Yy50eXBlLGs9YS50eXBlfHxmLnR5cGV8fGQub3B0aW9ucy5jaGFydC50eXBlLGg9SltnXS5wcm90b3R5cGUsbixcbnE9W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIixcIm5hdmlnYXRvclNlcmllc1wiLFwiYmFzZVNlcmllc1wiXSxtPWMuZmluaXNoZWRBbmltYXRpbmcmJnthbmltYXRpb246ITF9O2lmKE9iamVjdC5rZXlzJiZcImRhdGFcIj09PU9iamVjdC5rZXlzKGEpLnRvU3RyaW5nKCkpcmV0dXJuIHRoaXMuc2V0RGF0YShhLmRhdGEsYik7aWYoayYmayE9PWd8fHZvaWQgMCE9PWEuekluZGV4KXEubGVuZ3RoPTA7bChxLGZ1bmN0aW9uKGEpe3FbYV09Y1thXTtkZWxldGUgY1thXX0pO2E9ZShmLG0se2luZGV4OmMuaW5kZXgscG9pbnRTdGFydDpjLnhEYXRhWzBdfSx7ZGF0YTpjLm9wdGlvbnMuZGF0YX0sYSk7Yy5yZW1vdmUoITEsbnVsbCwhMSk7Zm9yKG4gaW4gaCljW25dPXZvaWQgMDt1KGMsSltrfHxnXS5wcm90b3R5cGUpO2wocSxmdW5jdGlvbihhKXtjW2FdPXFbYV19KTtjLmluaXQoZCxhKTtjLm9sZFR5cGU9ZztkLmxpbmtTZXJpZXMoKTt5KGIsITApJiZkLnJlZHJhdyghMSl9fSk7XG51KEYucHJvdG90eXBlLHt1cGRhdGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNoYXJ0O2E9Yy5vcHRpb25zW3RoaXMuY29sbF1bdGhpcy5vcHRpb25zLmluZGV4XT1lKHRoaXMudXNlck9wdGlvbnMsYSk7dGhpcy5kZXN0cm95KCEwKTt0aGlzLmluaXQoYyx1KGEse2V2ZW50czp2b2lkIDB9KSk7Yy5pc0RpcnR5Qm94PSEwO3koYiwhMCkmJmMucmVkcmF3KCl9LHJlbW92ZTpmdW5jdGlvbihhKXtmb3IodmFyIGM9dGhpcy5jaGFydCxlPXRoaXMuY29sbCxkPXRoaXMuc2VyaWVzLGY9ZC5sZW5ndGg7Zi0tOylkW2ZdJiZkW2ZdLnJlbW92ZSghMSk7cihjLmF4ZXMsdGhpcyk7cihjW2VdLHRoaXMpO2IoYy5vcHRpb25zW2VdKT9jLm9wdGlvbnNbZV0uc3BsaWNlKHRoaXMub3B0aW9ucy5pbmRleCwxKTpkZWxldGUgYy5vcHRpb25zW2VdO2woY1tlXSxmdW5jdGlvbihhLGIpe2Eub3B0aW9ucy5pbmRleD1ifSk7dGhpcy5kZXN0cm95KCk7Yy5pc0RpcnR5Qm94PSEwO3koYSwhMCkmJmMucmVkcmF3KCl9LFxuc2V0VGl0bGU6ZnVuY3Rpb24oYSxiKXt0aGlzLnVwZGF0ZSh7dGl0bGU6YX0sYil9LHNldENhdGVnb3JpZXM6ZnVuY3Rpb24oYSxiKXt0aGlzLnVwZGF0ZSh7Y2F0ZWdvcmllczphfSxiKX19KX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1hLmNvbG9yLEE9YS5lYWNoLEY9YS5tYXAsRT1hLnBpY2ssbT1hLlNlcmllcyxmPWEuc2VyaWVzVHlwZTtmKFwiYXJlYVwiLFwibGluZVwiLHtzb2Z0VGhyZXNob2xkOiExLHRocmVzaG9sZDowfSx7c2luZ2xlU3RhY2tzOiExLGdldFN0YWNrUG9pbnRzOmZ1bmN0aW9uKGYpe3ZhciBsPVtdLG09W10sdD10aGlzLnhBeGlzLGc9dGhpcy55QXhpcyxkPWcuc3RhY2tzW3RoaXMuc3RhY2tLZXldLGs9e30sYj10aGlzLmluZGV4LGU9Zy5zZXJpZXMsdj1lLmxlbmd0aCx5LG49RShnLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsITApPzE6LTEsRDtmPWZ8fHRoaXMucG9pbnRzO2lmKHRoaXMub3B0aW9ucy5zdGFja2luZyl7Zm9yKEQ9MDtEPGYubGVuZ3RoO0QrKylrW2ZbRF0ueF09XG5mW0RdO2Eub2JqZWN0RWFjaChkLGZ1bmN0aW9uKGEsYil7bnVsbCE9PWEudG90YWwmJm0ucHVzaChiKX0pO20uc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9KTt5PUYoZSxmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpc2libGV9KTtBKG0sZnVuY3Rpb24oYSxjKXt2YXIgZT0wLGYscjtpZihrW2FdJiYha1thXS5pc051bGwpbC5wdXNoKGtbYV0pLEEoWy0xLDFdLGZ1bmN0aW9uKGUpe3ZhciBnPTE9PT1lP1wicmlnaHROdWxsXCI6XCJsZWZ0TnVsbFwiLGw9MCxxPWRbbVtjK2VdXTtpZihxKWZvcihEPWI7MDw9RCYmRDx2OylmPXEucG9pbnRzW0RdLGZ8fChEPT09Yj9rW2FdW2ddPSEwOnlbRF0mJihyPWRbYV0ucG9pbnRzW0RdKSYmKGwtPXJbMV0tclswXSkpLEQrPW47a1thXVsxPT09ZT9cInJpZ2h0Q2xpZmZcIjpcImxlZnRDbGlmZlwiXT1sfSk7ZWxzZXtmb3IoRD1iOzA8PUQmJkQ8djspe2lmKGY9ZFthXS5wb2ludHNbRF0pe2U9ZlsxXTticmVha31EKz1ufWU9Zy50cmFuc2xhdGUoZSwwLFxuMSwwLDEpO2wucHVzaCh7aXNOdWxsOiEwLHBsb3RYOnQudHJhbnNsYXRlKGEsMCwwLDAsMSkseDphLHBsb3RZOmUseUJvdHRvbTplfSl9fSl9cmV0dXJuIGx9LGdldEdyYXBoUGF0aDpmdW5jdGlvbihhKXt2YXIgZj1tLnByb3RvdHlwZS5nZXRHcmFwaFBhdGgsbD10aGlzLm9wdGlvbnMsdD1sLnN0YWNraW5nLGc9dGhpcy55QXhpcyxkLGssYj1bXSxlPVtdLHY9dGhpcy5pbmRleCx5LG49Zy5zdGFja3NbdGhpcy5zdGFja0tleV0sRD1sLnRocmVzaG9sZCxBPWcuZ2V0VGhyZXNob2xkKGwudGhyZXNob2xkKSxjLGw9bC5jb25uZWN0TnVsbHN8fFwicGVyY2VudFwiPT09dCxHPWZ1bmN0aW9uKGMsZCxmKXt2YXIgaz1hW2NdO2M9dCYmbltrLnhdLnBvaW50c1t2XTt2YXIgbD1rW2YrXCJOdWxsXCJdfHwwO2Y9a1tmK1wiQ2xpZmZcIl18fDA7dmFyIHEsbSxrPSEwO2Z8fGw/KHE9KGw/Y1swXTpjWzFdKStmLG09Y1swXStmLGs9ISFsKTohdCYmYVtkXSYmYVtkXS5pc051bGwmJihxPW09RCk7dm9pZCAwIT09XG5xJiYoZS5wdXNoKHtwbG90WDp5LHBsb3RZOm51bGw9PT1xP0E6Zy5nZXRUaHJlc2hvbGQocSksaXNOdWxsOmssaXNDbGlmZjohMH0pLGIucHVzaCh7cGxvdFg6eSxwbG90WTpudWxsPT09bT9BOmcuZ2V0VGhyZXNob2xkKG0pLGRvQ3VydmU6ITF9KSl9O2E9YXx8dGhpcy5wb2ludHM7dCYmKGE9dGhpcy5nZXRTdGFja1BvaW50cyhhKSk7Zm9yKGQ9MDtkPGEubGVuZ3RoO2QrKylpZihrPWFbZF0uaXNOdWxsLHk9RShhW2RdLnJlY3RQbG90WCxhW2RdLnBsb3RYKSxjPUUoYVtkXS55Qm90dG9tLEEpLCFrfHxsKWx8fEcoZCxkLTEsXCJsZWZ0XCIpLGsmJiF0JiZsfHwoZS5wdXNoKGFbZF0pLGIucHVzaCh7eDpkLHBsb3RYOnkscGxvdFk6Y30pKSxsfHxHKGQsZCsxLFwicmlnaHRcIik7ZD1mLmNhbGwodGhpcyxlLCEwLCEwKTtiLnJldmVyc2VkPSEwO2s9Zi5jYWxsKHRoaXMsYiwhMCwhMCk7ay5sZW5ndGgmJihrWzBdPVwiTFwiKTtrPWQuY29uY2F0KGspO2Y9Zi5jYWxsKHRoaXMsZSwhMSxsKTtrLnhNYXA9XG5kLnhNYXA7dGhpcy5hcmVhUGF0aD1rO3JldHVybiBmfSxkcmF3R3JhcGg6ZnVuY3Rpb24oKXt0aGlzLmFyZWFQYXRoPVtdO20ucHJvdG90eXBlLmRyYXdHcmFwaC5hcHBseSh0aGlzKTt2YXIgYT10aGlzLGY9dGhpcy5hcmVhUGF0aCx1PXRoaXMub3B0aW9ucyx0PVtbXCJhcmVhXCIsXCJoaWdoY2hhcnRzLWFyZWFcIix0aGlzLmNvbG9yLHUuZmlsbENvbG9yXV07QSh0aGlzLnpvbmVzLGZ1bmN0aW9uKGYsZCl7dC5wdXNoKFtcInpvbmUtYXJlYS1cIitkLFwiaGlnaGNoYXJ0cy1hcmVhIGhpZ2hjaGFydHMtem9uZS1hcmVhLVwiK2QrXCIgXCIrZi5jbGFzc05hbWUsZi5jb2xvcnx8YS5jb2xvcixmLmZpbGxDb2xvcnx8dS5maWxsQ29sb3JdKX0pO0EodCxmdW5jdGlvbihnKXt2YXIgZD1nWzBdLGs9YVtkXTtrPyhrLmVuZFg9Zi54TWFwLGsuYW5pbWF0ZSh7ZDpmfSkpOihrPWFbZF09YS5jaGFydC5yZW5kZXJlci5wYXRoKGYpLmFkZENsYXNzKGdbMV0pLmF0dHIoe2ZpbGw6RShnWzNdLEMoZ1syXSkuc2V0T3BhY2l0eShFKHUuZmlsbE9wYWNpdHksXG4uNzUpKS5nZXQoKSksekluZGV4OjB9KS5hZGQoYS5ncm91cCksay5pc0FyZWE9ITApO2suc3RhcnRYPWYueE1hcDtrLnNoaWZ0VW5pdD11LnN0ZXA/MjoxfSl9LGRyYXdMZWdlbmRTeW1ib2w6YS5MZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlfSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5waWNrO2E9YS5zZXJpZXNUeXBlO2EoXCJzcGxpbmVcIixcImxpbmVcIix7fSx7Z2V0UG9pbnRTcGxpbmU6ZnVuY3Rpb24oYSxGLEUpe3ZhciBtPUYucGxvdFgsZj1GLnBsb3RZLGw9YVtFLTFdO0U9YVtFKzFdO3ZhciByLHUsdCxnO2lmKGwmJiFsLmlzTnVsbCYmITEhPT1sLmRvQ3VydmUmJiFGLmlzQ2xpZmYmJkUmJiFFLmlzTnVsbCYmITEhPT1FLmRvQ3VydmUmJiFGLmlzQ2xpZmYpe2E9bC5wbG90WTt0PUUucGxvdFg7RT1FLnBsb3RZO3ZhciBkPTA7cj0oMS41Km0rbC5wbG90WCkvMi41O3U9KDEuNSpmK2EpLzIuNTt0PSgxLjUqbSt0KS8yLjU7Zz0oMS41KmYrRSkvMi41O3QhPT1yJiYoZD1cbihnLXUpKih0LW0pLyh0LXIpK2YtZyk7dSs9ZDtnKz1kO3U+YSYmdT5mPyh1PU1hdGgubWF4KGEsZiksZz0yKmYtdSk6dTxhJiZ1PGYmJih1PU1hdGgubWluKGEsZiksZz0yKmYtdSk7Zz5FJiZnPmY/KGc9TWF0aC5tYXgoRSxmKSx1PTIqZi1nKTpnPEUmJmc8ZiYmKGc9TWF0aC5taW4oRSxmKSx1PTIqZi1nKTtGLnJpZ2h0Q29udFg9dDtGLnJpZ2h0Q29udFk9Z31GPVtcIkNcIixDKGwucmlnaHRDb250WCxsLnBsb3RYKSxDKGwucmlnaHRDb250WSxsLnBsb3RZKSxDKHIsbSksQyh1LGYpLG0sZl07bC5yaWdodENvbnRYPWwucmlnaHRDb250WT1udWxsO3JldHVybiBGfX0pfSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDPWEuc2VyaWVzVHlwZXMuYXJlYS5wcm90b3R5cGUsQT1hLnNlcmllc1R5cGU7QShcImFyZWFzcGxpbmVcIixcInNwbGluZVwiLGEuZGVmYXVsdFBsb3RPcHRpb25zLmFyZWEse2dldFN0YWNrUG9pbnRzOkMuZ2V0U3RhY2tQb2ludHMsZ2V0R3JhcGhQYXRoOkMuZ2V0R3JhcGhQYXRoLFxuZHJhd0dyYXBoOkMuZHJhd0dyYXBoLGRyYXdMZWdlbmRTeW1ib2w6YS5MZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlfSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5hbmltT2JqZWN0LEE9YS5jb2xvcixGPWEuZWFjaCxFPWEuZXh0ZW5kLG09YS5pc051bWJlcixmPWEubWVyZ2UsbD1hLnBpY2sscj1hLlNlcmllcyx1PWEuc2VyaWVzVHlwZSx0PWEuc3ZnO3UoXCJjb2x1bW5cIixcImxpbmVcIix7Ym9yZGVyUmFkaXVzOjAsY3Jpc3A6ITAsZ3JvdXBQYWRkaW5nOi4yLG1hcmtlcjpudWxsLHBvaW50UGFkZGluZzouMSxtaW5Qb2ludExlbmd0aDowLGNyb3BUaHJlc2hvbGQ6NTAscG9pbnRSYW5nZTpudWxsLHN0YXRlczp7aG92ZXI6e2hhbG86ITEsYnJpZ2h0bmVzczouMSxzaGFkb3c6ITF9LHNlbGVjdDp7Y29sb3I6XCIjY2NjY2NjXCIsYm9yZGVyQ29sb3I6XCIjMDAwMDAwXCIsc2hhZG93OiExfX0sZGF0YUxhYmVsczp7YWxpZ246bnVsbCx2ZXJ0aWNhbEFsaWduOm51bGwseTpudWxsfSxcbnNvZnRUaHJlc2hvbGQ6ITEsc3RhcnRGcm9tVGhyZXNob2xkOiEwLHN0aWNreVRyYWNraW5nOiExLHRvb2x0aXA6e2Rpc3RhbmNlOjZ9LHRocmVzaG9sZDowLGJvcmRlckNvbG9yOlwiI2ZmZmZmZlwifSx7Y3JvcFNob3VsZGVyOjAsZGlyZWN0VG91Y2g6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdLG5lZ1N0YWNrczohMCxpbml0OmZ1bmN0aW9uKCl7ci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcyxkPWEuY2hhcnQ7ZC5oYXNSZW5kZXJlZCYmRihkLnNlcmllcyxmdW5jdGlvbihkKXtkLnR5cGU9PT1hLnR5cGUmJihkLmlzRGlydHk9ITApfSl9LGdldENvbHVtbk1ldHJpY3M6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5vcHRpb25zLGY9YS54QXhpcyxiPWEueUF4aXMsZT1mLnJldmVyc2VkLG0scj17fSxuPTA7ITE9PT1kLmdyb3VwaW5nP249MTpGKGEuY2hhcnQuc2VyaWVzLGZ1bmN0aW9uKGMpe3ZhciBlPWMub3B0aW9ucyxcbmQ9Yy55QXhpcyxmO2MudHlwZSE9PWEudHlwZXx8IWMudmlzaWJsZSYmYS5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllc3x8Yi5sZW4hPT1kLmxlbnx8Yi5wb3MhPT1kLnBvc3x8KGUuc3RhY2tpbmc/KG09Yy5zdGFja0tleSx2b2lkIDA9PT1yW21dJiYoclttXT1uKyspLGY9clttXSk6ITEhPT1lLmdyb3VwaW5nJiYoZj1uKyspLGMuY29sdW1uSW5kZXg9Zil9KTt2YXIgdD1NYXRoLm1pbihNYXRoLmFicyhmLnRyYW5zQSkqKGYub3JkaW5hbFNsb3BlfHxkLnBvaW50UmFuZ2V8fGYuY2xvc2VzdFBvaW50UmFuZ2V8fGYudGlja0ludGVydmFsfHwxKSxmLmxlbiksdT10KmQuZ3JvdXBQYWRkaW5nLGM9KHQtMip1KS8obnx8MSksZD1NYXRoLm1pbihkLm1heFBvaW50V2lkdGh8fGYubGVuLGwoZC5wb2ludFdpZHRoLGMqKDEtMipkLnBvaW50UGFkZGluZykpKTthLmNvbHVtbk1ldHJpY3M9e3dpZHRoOmQsb2Zmc2V0OihjLWQpLzIrKHUrKChhLmNvbHVtbkluZGV4fHwwKStcbihlPzE6MCkpKmMtdC8yKSooZT8tMToxKX07cmV0dXJuIGEuY29sdW1uTWV0cmljc30sY3Jpc3BDb2w6ZnVuY3Rpb24oYSxkLGYsYil7dmFyIGU9dGhpcy5jaGFydCxnPXRoaXMuYm9yZGVyV2lkdGgsaz0tKGclMj8uNTowKSxnPWclMj8uNToxO2UuaW52ZXJ0ZWQmJmUucmVuZGVyZXIuaXNWTUwmJihnKz0xKTt0aGlzLm9wdGlvbnMuY3Jpc3AmJihmPU1hdGgucm91bmQoYStmKStrLGE9TWF0aC5yb3VuZChhKStrLGYtPWEpO2I9TWF0aC5yb3VuZChkK2IpK2c7az0uNT49TWF0aC5hYnMoZCkmJi41PGI7ZD1NYXRoLnJvdW5kKGQpK2c7Yi09ZDtrJiZiJiYoLS1kLGIrPTEpO3JldHVybnt4OmEseTpkLHdpZHRoOmYsaGVpZ2h0OmJ9fSx0cmFuc2xhdGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5jaGFydCxmPWEub3B0aW9ucyxiPWEuZGVuc2U9Mj5hLmNsb3Nlc3RQb2ludFJhbmdlKmEueEF4aXMudHJhbnNBLGI9YS5ib3JkZXJXaWR0aD1sKGYuYm9yZGVyV2lkdGgsYj8wOjEpLGU9YS55QXhpcyxcbm09YS50cmFuc2xhdGVkVGhyZXNob2xkPWUuZ2V0VGhyZXNob2xkKGYudGhyZXNob2xkKSx0PWwoZi5taW5Qb2ludExlbmd0aCw1KSxuPWEuZ2V0Q29sdW1uTWV0cmljcygpLHU9bi53aWR0aCxBPWEuYmFyVz1NYXRoLm1heCh1LDErMipiKSxjPWEucG9pbnRYT2Zmc2V0PW4ub2Zmc2V0O2QuaW52ZXJ0ZWQmJihtLT0uNSk7Zi5wb2ludFBhZGRpbmcmJihBPU1hdGguY2VpbChBKSk7ci5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KGEpO0YoYS5wb2ludHMsZnVuY3Rpb24oYil7dmFyIGY9bChiLnlCb3R0b20sbSksZz05OTkrTWF0aC5hYnMoZiksZz1NYXRoLm1pbihNYXRoLm1heCgtZyxiLnBsb3RZKSxlLmxlbitnKSxrPWIucGxvdFgrYyxuPUEscj1NYXRoLm1pbihnLGYpLHYseT1NYXRoLm1heChnLGYpLXI7TWF0aC5hYnMoeSk8dCYmdCYmKHk9dCx2PSFlLnJldmVyc2VkJiYhYi5uZWdhdGl2ZXx8ZS5yZXZlcnNlZCYmYi5uZWdhdGl2ZSxyPU1hdGguYWJzKHItbSk+dD9mLXQ6bS0odj9cbnQ6MCkpO2IuYmFyWD1rO2IucG9pbnRXaWR0aD11O2IudG9vbHRpcFBvcz1kLmludmVydGVkP1tlLmxlbitlLnBvcy1kLnBsb3RMZWZ0LWcsYS54QXhpcy5sZW4tay1uLzIseV06W2srbi8yLGcrZS5wb3MtZC5wbG90VG9wLHldO2Iuc2hhcGVUeXBlPVwicmVjdFwiO2Iuc2hhcGVBcmdzPWEuY3Jpc3BDb2wuYXBwbHkoYSxiLmlzTnVsbD9bayxtLG4sMF06W2sscixuLHldKX0pfSxnZXRTeW1ib2w6YS5ub29wLGRyYXdMZWdlbmRTeW1ib2w6YS5MZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLGRyYXdHcmFwaDpmdW5jdGlvbigpe3RoaXMuZ3JvdXBbdGhpcy5kZW5zZT9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShcImhpZ2hjaGFydHMtZGVuc2UtZGF0YVwiKX0scG9pbnRBdHRyaWJzOmZ1bmN0aW9uKGEsZCl7dmFyIGc9dGhpcy5vcHRpb25zLGIsZT10aGlzLnBvaW50QXR0clRvT3B0aW9uc3x8e307Yj1lLnN0cm9rZXx8XCJib3JkZXJDb2xvclwiO3ZhciBsPWVbXCJzdHJva2Utd2lkdGhcIl18fFxuXCJib3JkZXJXaWR0aFwiLG09YSYmYS5jb2xvcnx8dGhpcy5jb2xvcixuPWFbYl18fGdbYl18fHRoaXMuY29sb3J8fG0scj1hW2xdfHxnW2xdfHx0aGlzW2xdfHwwLGU9Zy5kYXNoU3R5bGU7YSYmdGhpcy56b25lcy5sZW5ndGgmJihtPWEuZ2V0Wm9uZSgpLG09YS5vcHRpb25zLmNvbG9yfHxtJiZtLmNvbG9yfHx0aGlzLmNvbG9yKTtkJiYoYT1mKGcuc3RhdGVzW2RdLGEub3B0aW9ucy5zdGF0ZXMmJmEub3B0aW9ucy5zdGF0ZXNbZF18fHt9KSxkPWEuYnJpZ2h0bmVzcyxtPWEuY29sb3J8fHZvaWQgMCE9PWQmJkEobSkuYnJpZ2h0ZW4oYS5icmlnaHRuZXNzKS5nZXQoKXx8bSxuPWFbYl18fG4scj1hW2xdfHxyLGU9YS5kYXNoU3R5bGV8fGUpO2I9e2ZpbGw6bSxzdHJva2U6bixcInN0cm9rZS13aWR0aFwiOnJ9O2UmJihiLmRhc2hzdHlsZT1lKTtyZXR1cm4gYn0sZHJhd1BvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZD10aGlzLmNoYXJ0LGs9YS5vcHRpb25zLGI9ZC5yZW5kZXJlcixlPVxuay5hbmltYXRpb25MaW1pdHx8MjUwLGw7RihhLnBvaW50cyxmdW5jdGlvbihnKXt2YXIgbj1nLmdyYXBoaWM7aWYobShnLnBsb3RZKSYmbnVsbCE9PWcueSl7bD1nLnNoYXBlQXJncztpZihuKW5bZC5wb2ludENvdW50PGU/XCJhbmltYXRlXCI6XCJhdHRyXCJdKGYobCkpO2Vsc2UgZy5ncmFwaGljPW49YltnLnNoYXBlVHlwZV0obCkuYWRkKGcuZ3JvdXB8fGEuZ3JvdXApO2suYm9yZGVyUmFkaXVzJiZuLmF0dHIoe3I6ay5ib3JkZXJSYWRpdXN9KTtuLmF0dHIoYS5wb2ludEF0dHJpYnMoZyxnLnNlbGVjdGVkJiZcInNlbGVjdFwiKSkuc2hhZG93KGsuc2hhZG93LG51bGwsay5zdGFja2luZyYmIWsuYm9yZGVyUmFkaXVzKTtuLmFkZENsYXNzKGcuZ2V0Q2xhc3NOYW1lKCksITApfWVsc2UgbiYmKGcuZ3JhcGhpYz1uLmRlc3Ryb3koKSl9KX0sYW5pbWF0ZTpmdW5jdGlvbihhKXt2YXIgZD10aGlzLGY9dGhpcy55QXhpcyxiPWQub3B0aW9ucyxlPXRoaXMuY2hhcnQuaW52ZXJ0ZWQsZz17fTt0JiYoYT9cbihnLnNjYWxlWT0uMDAxLGE9TWF0aC5taW4oZi5wb3MrZi5sZW4sTWF0aC5tYXgoZi5wb3MsZi50b1BpeGVscyhiLnRocmVzaG9sZCkpKSxlP2cudHJhbnNsYXRlWD1hLWYubGVuOmcudHJhbnNsYXRlWT1hLGQuZ3JvdXAuYXR0cihnKSk6KGdbZT9cInRyYW5zbGF0ZVhcIjpcInRyYW5zbGF0ZVlcIl09Zi5wb3MsZC5ncm91cC5hbmltYXRlKGcsRShDKGQub3B0aW9ucy5hbmltYXRpb24pLHtzdGVwOmZ1bmN0aW9uKGEsYil7ZC5ncm91cC5hdHRyKHtzY2FsZVk6TWF0aC5tYXgoLjAwMSxiLnBvcyl9KX19KSksZC5hbmltYXRlPW51bGwpKX0scmVtb3ZlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxkPWEuY2hhcnQ7ZC5oYXNSZW5kZXJlZCYmRihkLnNlcmllcyxmdW5jdGlvbihkKXtkLnR5cGU9PT1hLnR5cGUmJihkLmlzRGlydHk9ITApfSk7ci5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KGEsYXJndW1lbnRzKX19KX0pKE0pOyhmdW5jdGlvbihhKXthPWEuc2VyaWVzVHlwZTthKFwiYmFyXCIsXCJjb2x1bW5cIixcbm51bGwse2ludmVydGVkOiEwfSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5TZXJpZXM7YT1hLnNlcmllc1R5cGU7YShcInNjYXR0ZXJcIixcImxpbmVcIix7bGluZVdpZHRoOjAsZmluZE5lYXJlc3RQb2ludEJ5OlwieHlcIixtYXJrZXI6e2VuYWJsZWQ6ITB9LHRvb2x0aXA6e2hlYWRlckZvcm1hdDonXFx4M2NzcGFuIHN0eWxlXFx4M2RcImNvbG9yOntwb2ludC5jb2xvcn1cIlxceDNlXFx1MjVjZlxceDNjL3NwYW5cXHgzZSBcXHgzY3NwYW4gc3R5bGVcXHgzZFwiZm9udC1zaXplOiAwLjg1ZW1cIlxceDNlIHtzZXJpZXMubmFtZX1cXHgzYy9zcGFuXFx4M2VcXHgzY2JyL1xceDNlJyxwb2ludEZvcm1hdDpcIng6IFxceDNjYlxceDNle3BvaW50Lnh9XFx4M2MvYlxceDNlXFx4M2Nici9cXHgzZXk6IFxceDNjYlxceDNle3BvaW50Lnl9XFx4M2MvYlxceDNlXFx4M2Nici9cXHgzZVwifX0se3NvcnRlZDohMSxyZXF1aXJlU29ydGluZzohMSxub1NoYXJlZFRvb2x0aXA6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwibWFya2VyR3JvdXBcIixcImRhdGFMYWJlbHNHcm91cFwiXSxcbnRha2VPcmRpbmFsUG9zaXRpb246ITEsZHJhd0dyYXBoOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmxpbmVXaWR0aCYmQy5wcm90b3R5cGUuZHJhd0dyYXBoLmNhbGwodGhpcyl9fSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5waWNrLEE9YS5yZWxhdGl2ZUxlbmd0aDthLkNlbnRlcmVkU2VyaWVzTWl4aW49e2dldENlbnRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxFPXRoaXMuY2hhcnQsbT0yKihhLnNsaWNlZE9mZnNldHx8MCksZj1FLnBsb3RXaWR0aC0yKm0sRT1FLnBsb3RIZWlnaHQtMiptLGw9YS5jZW50ZXIsbD1bQyhsWzBdLFwiNTAlXCIpLEMobFsxXSxcIjUwJVwiKSxhLnNpemV8fFwiMTAwJVwiLGEuaW5uZXJTaXplfHwwXSxyPU1hdGgubWluKGYsRSksdSx0O2Zvcih1PTA7ND51OysrdSl0PWxbdV0sYT0yPnV8fDI9PT11JiYvJSQvLnRlc3QodCksbFt1XT1BKHQsW2YsRSxyLGxbMl1dW3VdKSsoYT9tOjApO2xbM10+bFsyXSYmKGxbM109bFsyXSk7cmV0dXJuIGx9fX0pKE0pO1xuKGZ1bmN0aW9uKGEpe3ZhciBDPWEuYWRkRXZlbnQsQT1hLmRlZmluZWQsRj1hLmVhY2gsRT1hLmV4dGVuZCxtPWEuaW5BcnJheSxmPWEubm9vcCxsPWEucGljayxyPWEuUG9pbnQsdT1hLlNlcmllcyx0PWEuc2VyaWVzVHlwZSxnPWEuc2V0QW5pbWF0aW9uO3QoXCJwaWVcIixcImxpbmVcIix7Y2VudGVyOltudWxsLG51bGxdLGNsaXA6ITEsY29sb3JCeVBvaW50OiEwLGRhdGFMYWJlbHM6e2Rpc3RhbmNlOjMwLGVuYWJsZWQ6ITAsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnQuaXNOdWxsP3ZvaWQgMDp0aGlzLnBvaW50Lm5hbWV9LHg6MH0saWdub3JlSGlkZGVuUG9pbnQ6ITAsbGVnZW5kVHlwZTpcInBvaW50XCIsbWFya2VyOm51bGwsc2l6ZTpudWxsLHNob3dJbkxlZ2VuZDohMSxzbGljZWRPZmZzZXQ6MTAsc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7Zm9sbG93UG9pbnRlcjohMH0sYm9yZGVyQ29sb3I6XCIjZmZmZmZmXCIsYm9yZGVyV2lkdGg6MSxzdGF0ZXM6e2hvdmVyOnticmlnaHRuZXNzOi4xLFxuc2hhZG93OiExfX19LHtpc0NhcnRlc2lhbjohMSxyZXF1aXJlU29ydGluZzohMSxkaXJlY3RUb3VjaDohMCxub1NoYXJlZFRvb2x0aXA6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdLGF4aXNUeXBlczpbXSxwb2ludEF0dHJpYnM6YS5zZXJpZXNUeXBlcy5jb2x1bW4ucHJvdG90eXBlLnBvaW50QXR0cmlicyxhbmltYXRlOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMsYj1kLnBvaW50cyxlPWQuc3RhcnRBbmdsZVJhZDthfHwoRihiLGZ1bmN0aW9uKGEpe3ZhciBiPWEuZ3JhcGhpYyxmPWEuc2hhcGVBcmdzO2ImJihiLmF0dHIoe3I6YS5zdGFydFJ8fGQuY2VudGVyWzNdLzIsc3RhcnQ6ZSxlbmQ6ZX0pLGIuYW5pbWF0ZSh7cjpmLnIsc3RhcnQ6Zi5zdGFydCxlbmQ6Zi5lbmR9LGQub3B0aW9ucy5hbmltYXRpb24pKX0pLGQuYW5pbWF0ZT1udWxsKX0sdXBkYXRlVG90YWxzOmZ1bmN0aW9uKCl7dmFyIGEsZj0wLGI9dGhpcy5wb2ludHMsZT1iLmxlbmd0aCxnLFxubD10aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7Zm9yKGE9MDthPGU7YSsrKWc9YlthXSxmKz1sJiYhZy52aXNpYmxlPzA6Zy5pc051bGw/MDpnLnk7dGhpcy50b3RhbD1mO2ZvcihhPTA7YTxlO2ErKylnPWJbYV0sZy5wZXJjZW50YWdlPTA8ZiYmKGcudmlzaWJsZXx8IWwpP2cueS9mKjEwMDowLGcudG90YWw9Zn0sZ2VuZXJhdGVQb2ludHM6ZnVuY3Rpb24oKXt1LnByb3RvdHlwZS5nZW5lcmF0ZVBvaW50cy5jYWxsKHRoaXMpO3RoaXMudXBkYXRlVG90YWxzKCl9LHRyYW5zbGF0ZTpmdW5jdGlvbihhKXt0aGlzLmdlbmVyYXRlUG9pbnRzKCk7dmFyIGQ9MCxiPXRoaXMub3B0aW9ucyxlPWIuc2xpY2VkT2Zmc2V0LGY9ZSsoYi5ib3JkZXJXaWR0aHx8MCksZyxuLG0scj1iLnN0YXJ0QW5nbGV8fDAsYz10aGlzLnN0YXJ0QW5nbGVSYWQ9TWF0aC5QSS8xODAqKHItOTApLHI9KHRoaXMuZW5kQW5nbGVSYWQ9TWF0aC5QSS8xODAqKGwoYi5lbmRBbmdsZSxyKzM2MCktOTApKS1jLHQ9XG50aGlzLnBvaW50cyxxLEI9Yi5kYXRhTGFiZWxzLmRpc3RhbmNlLGI9Yi5pZ25vcmVIaWRkZW5Qb2ludCx1LHA9dC5sZW5ndGgsejthfHwodGhpcy5jZW50ZXI9YT10aGlzLmdldENlbnRlcigpKTt0aGlzLmdldFg9ZnVuY3Rpb24oYixjLGUpe209TWF0aC5hc2luKE1hdGgubWluKChiLWFbMV0pLyhhWzJdLzIrZS5sYWJlbERpc3RhbmNlKSwxKSk7cmV0dXJuIGFbMF0rKGM/LTE6MSkqTWF0aC5jb3MobSkqKGFbMl0vMitlLmxhYmVsRGlzdGFuY2UpfTtmb3IodT0wO3U8cDt1Kyspe3o9dFt1XTt6LmxhYmVsRGlzdGFuY2U9bCh6Lm9wdGlvbnMuZGF0YUxhYmVscyYmei5vcHRpb25zLmRhdGFMYWJlbHMuZGlzdGFuY2UsQik7dGhpcy5tYXhMYWJlbERpc3RhbmNlPU1hdGgubWF4KHRoaXMubWF4TGFiZWxEaXN0YW5jZXx8MCx6LmxhYmVsRGlzdGFuY2UpO2c9YytkKnI7aWYoIWJ8fHoudmlzaWJsZSlkKz16LnBlcmNlbnRhZ2UvMTAwO249YytkKnI7ei5zaGFwZVR5cGU9XCJhcmNcIjt6LnNoYXBlQXJncz1cbnt4OmFbMF0seTphWzFdLHI6YVsyXS8yLGlubmVyUjphWzNdLzIsc3RhcnQ6TWF0aC5yb3VuZCgxRTMqZykvMUUzLGVuZDpNYXRoLnJvdW5kKDFFMypuKS8xRTN9O209KG4rZykvMjttPjEuNSpNYXRoLlBJP20tPTIqTWF0aC5QSTptPC1NYXRoLlBJLzImJihtKz0yKk1hdGguUEkpO3ouc2xpY2VkVHJhbnNsYXRpb249e3RyYW5zbGF0ZVg6TWF0aC5yb3VuZChNYXRoLmNvcyhtKSplKSx0cmFuc2xhdGVZOk1hdGgucm91bmQoTWF0aC5zaW4obSkqZSl9O249TWF0aC5jb3MobSkqYVsyXS8yO3E9TWF0aC5zaW4obSkqYVsyXS8yO3oudG9vbHRpcFBvcz1bYVswXSsuNypuLGFbMV0rLjcqcV07ei5oYWxmPW08LU1hdGguUEkvMnx8bT5NYXRoLlBJLzI/MTowO3ouYW5nbGU9bTtnPU1hdGgubWluKGYsei5sYWJlbERpc3RhbmNlLzUpO3oubGFiZWxQb3M9W2FbMF0rbitNYXRoLmNvcyhtKSp6LmxhYmVsRGlzdGFuY2UsYVsxXStxK01hdGguc2luKG0pKnoubGFiZWxEaXN0YW5jZSxhWzBdK24rTWF0aC5jb3MobSkqXG5nLGFbMV0rcStNYXRoLnNpbihtKSpnLGFbMF0rbixhWzFdK3EsMD56LmxhYmVsRGlzdGFuY2U/XCJjZW50ZXJcIjp6LmhhbGY/XCJyaWdodFwiOlwibGVmdFwiLG1dfX0sZHJhd0dyYXBoOm51bGwsZHJhd1BvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZj1hLmNoYXJ0LnJlbmRlcmVyLGIsZSxnLGwsbj1hLm9wdGlvbnMuc2hhZG93O24mJiFhLnNoYWRvd0dyb3VwJiYoYS5zaGFkb3dHcm91cD1mLmcoXCJzaGFkb3dcIikuYWRkKGEuZ3JvdXApKTtGKGEucG9pbnRzLGZ1bmN0aW9uKGQpe2lmKCFkLmlzTnVsbCl7ZT1kLmdyYXBoaWM7bD1kLnNoYXBlQXJncztiPWQuZ2V0VHJhbnNsYXRlKCk7dmFyIGs9ZC5zaGFkb3dHcm91cDtuJiYhayYmKGs9ZC5zaGFkb3dHcm91cD1mLmcoXCJzaGFkb3dcIikuYWRkKGEuc2hhZG93R3JvdXApKTtrJiZrLmF0dHIoYik7Zz1hLnBvaW50QXR0cmlicyhkLGQuc2VsZWN0ZWQmJlwic2VsZWN0XCIpO2U/ZS5zZXRSYWRpYWxSZWZlcmVuY2UoYS5jZW50ZXIpLmF0dHIoZykuYW5pbWF0ZShFKGwsXG5iKSk6KGQuZ3JhcGhpYz1lPWZbZC5zaGFwZVR5cGVdKGwpLnNldFJhZGlhbFJlZmVyZW5jZShhLmNlbnRlcikuYXR0cihiKS5hZGQoYS5ncm91cCksZC52aXNpYmxlfHxlLmF0dHIoe3Zpc2liaWxpdHk6XCJoaWRkZW5cIn0pLGUuYXR0cihnKS5hdHRyKHtcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIn0pLnNoYWRvdyhuLGspKTtlLmFkZENsYXNzKGQuZ2V0Q2xhc3NOYW1lKCkpfX0pfSxzZWFyY2hQb2ludDpmLHNvcnRCeUFuZ2xlOmZ1bmN0aW9uKGEsZil7YS5zb3J0KGZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZvaWQgMCE9PWEuYW5nbGUmJihlLmFuZ2xlLWEuYW5nbGUpKmZ9KX0sZHJhd0xlZ2VuZFN5bWJvbDphLkxlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGUsZ2V0Q2VudGVyOmEuQ2VudGVyZWRTZXJpZXNNaXhpbi5nZXRDZW50ZXIsZ2V0U3ltYm9sOmZ9LHtpbml0OmZ1bmN0aW9uKCl7ci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcyxmO2EubmFtZT1cbmwoYS5uYW1lLFwiU2xpY2VcIik7Zj1mdW5jdGlvbihiKXthLnNsaWNlKFwic2VsZWN0XCI9PT1iLnR5cGUpfTtDKGEsXCJzZWxlY3RcIixmKTtDKGEsXCJ1bnNlbGVjdFwiLGYpO3JldHVybiBhfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIGEuaXNOdW1iZXIodGhpcy55LCEwKSYmMDw9dGhpcy55fSxzZXRWaXNpYmxlOmZ1bmN0aW9uKGEsZil7dmFyIGI9dGhpcyxlPWIuc2VyaWVzLGQ9ZS5jaGFydCxnPWUub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtmPWwoZixnKTthIT09Yi52aXNpYmxlJiYoYi52aXNpYmxlPWIub3B0aW9ucy52aXNpYmxlPWE9dm9pZCAwPT09YT8hYi52aXNpYmxlOmEsZS5vcHRpb25zLmRhdGFbbShiLGUuZGF0YSldPWIub3B0aW9ucyxGKFtcImdyYXBoaWNcIixcImRhdGFMYWJlbFwiLFwiY29ubmVjdG9yXCIsXCJzaGFkb3dHcm91cFwiXSxmdW5jdGlvbihlKXtpZihiW2VdKWJbZV1bYT9cInNob3dcIjpcImhpZGVcIl0oITApfSksYi5sZWdlbmRJdGVtJiZkLmxlZ2VuZC5jb2xvcml6ZUl0ZW0oYixcbmEpLGF8fFwiaG92ZXJcIiE9PWIuc3RhdGV8fGIuc2V0U3RhdGUoXCJcIiksZyYmKGUuaXNEaXJ0eT0hMCksZiYmZC5yZWRyYXcoKSl9LHNsaWNlOmZ1bmN0aW9uKGEsZixiKXt2YXIgZT10aGlzLnNlcmllcztnKGIsZS5jaGFydCk7bChmLCEwKTt0aGlzLnNsaWNlZD10aGlzLm9wdGlvbnMuc2xpY2VkPUEoYSk/YTohdGhpcy5zbGljZWQ7ZS5vcHRpb25zLmRhdGFbbSh0aGlzLGUuZGF0YSldPXRoaXMub3B0aW9uczt0aGlzLmdyYXBoaWMuYW5pbWF0ZSh0aGlzLmdldFRyYW5zbGF0ZSgpKTt0aGlzLnNoYWRvd0dyb3VwJiZ0aGlzLnNoYWRvd0dyb3VwLmFuaW1hdGUodGhpcy5nZXRUcmFuc2xhdGUoKSl9LGdldFRyYW5zbGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWNlZD90aGlzLnNsaWNlZFRyYW5zbGF0aW9uOnt0cmFuc2xhdGVYOjAsdHJhbnNsYXRlWTowfX0saGFsb1BhdGg6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5zaGFwZUFyZ3M7cmV0dXJuIHRoaXMuc2xpY2VkfHwhdGhpcy52aXNpYmxlP1xuW106dGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5hcmMoZC54LGQueSxkLnIrYSxkLnIrYSx7aW5uZXJSOnRoaXMuc2hhcGVBcmdzLnIsc3RhcnQ6ZC5zdGFydCxlbmQ6ZC5lbmR9KX19KX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1hLmFkZEV2ZW50LEE9YS5hcnJheU1heCxGPWEuZGVmaW5lZCxFPWEuZWFjaCxtPWEuZXh0ZW5kLGY9YS5mb3JtYXQsbD1hLm1hcCxyPWEubWVyZ2UsdT1hLm5vb3AsdD1hLnBpY2ssZz1hLnJlbGF0aXZlTGVuZ3RoLGQ9YS5TZXJpZXMsaz1hLnNlcmllc1R5cGVzLGI9YS5zdGFibGVTb3J0O2EuZGlzdHJpYnV0ZT1mdW5jdGlvbihhLGQpe2Z1bmN0aW9uIGUoYSxiKXtyZXR1cm4gYS50YXJnZXQtYi50YXJnZXR9dmFyIGYsZz0hMCxrPWEsYz1bXSxtO209MDtmb3IoZj1hLmxlbmd0aDtmLS07KW0rPWFbZl0uc2l6ZTtpZihtPmQpe2IoYSxmdW5jdGlvbihhLGIpe3JldHVybihiLnJhbmt8fDApLShhLnJhbmt8fDApfSk7Zm9yKG09Zj0wO208PVxuZDspbSs9YVtmXS5zaXplLGYrKztjPWEuc3BsaWNlKGYtMSxhLmxlbmd0aCl9YihhLGUpO2ZvcihhPWwoYSxmdW5jdGlvbihhKXtyZXR1cm57c2l6ZTphLnNpemUsdGFyZ2V0czpbYS50YXJnZXRdfX0pO2c7KXtmb3IoZj1hLmxlbmd0aDtmLS07KWc9YVtmXSxtPShNYXRoLm1pbi5hcHBseSgwLGcudGFyZ2V0cykrTWF0aC5tYXguYXBwbHkoMCxnLnRhcmdldHMpKS8yLGcucG9zPU1hdGgubWluKE1hdGgubWF4KDAsbS1nLnNpemUvMiksZC1nLnNpemUpO2Y9YS5sZW5ndGg7Zm9yKGc9ITE7Zi0tOykwPGYmJmFbZi0xXS5wb3MrYVtmLTFdLnNpemU+YVtmXS5wb3MmJihhW2YtMV0uc2l6ZSs9YVtmXS5zaXplLGFbZi0xXS50YXJnZXRzPWFbZi0xXS50YXJnZXRzLmNvbmNhdChhW2ZdLnRhcmdldHMpLGFbZi0xXS5wb3MrYVtmLTFdLnNpemU+ZCYmKGFbZi0xXS5wb3M9ZC1hW2YtMV0uc2l6ZSksYS5zcGxpY2UoZiwxKSxnPSEwKX1mPTA7RShhLGZ1bmN0aW9uKGEpe3ZhciBiPTA7RShhLnRhcmdldHMsXG5mdW5jdGlvbigpe2tbZl0ucG9zPWEucG9zK2I7Yis9a1tmXS5zaXplO2YrK30pfSk7ay5wdXNoLmFwcGx5KGssYyk7YihrLGUpfTtkLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscz1mdW5jdGlvbigpe3ZhciBiPXRoaXMsZD1iLm9wdGlvbnMsZz1kLmRhdGFMYWJlbHMsaz1iLnBvaW50cyxsLG0sYz1iLmhhc1JlbmRlcmVkfHwwLHUscSxCPXQoZy5kZWZlciwhIWQuYW5pbWF0aW9uKSxBPWIuY2hhcnQucmVuZGVyZXI7aWYoZy5lbmFibGVkfHxiLl9oYXNQb2ludExhYmVscyliLmRsUHJvY2Vzc09wdGlvbnMmJmIuZGxQcm9jZXNzT3B0aW9ucyhnKSxxPWIucGxvdEdyb3VwKFwiZGF0YUxhYmVsc0dyb3VwXCIsXCJkYXRhLWxhYmVsc1wiLEImJiFjP1wiaGlkZGVuXCI6XCJ2aXNpYmxlXCIsZy56SW5kZXh8fDYpLEImJihxLmF0dHIoe29wYWNpdHk6K2N9KSxjfHxDKGIsXCJhZnRlckFuaW1hdGVcIixmdW5jdGlvbigpe2IudmlzaWJsZSYmcS5zaG93KCEwKTtxW2QuYW5pbWF0aW9uP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7b3BhY2l0eToxfSxcbntkdXJhdGlvbjoyMDB9KX0pKSxtPWcsRShrLGZ1bmN0aW9uKGMpe3ZhciBlLGs9Yy5kYXRhTGFiZWwsbixoLHA9Yy5jb25uZWN0b3Isdj0hayxCO2w9Yy5kbE9wdGlvbnN8fGMub3B0aW9ucyYmYy5vcHRpb25zLmRhdGFMYWJlbHM7aWYoZT10KGwmJmwuZW5hYmxlZCxtLmVuYWJsZWQpJiZudWxsIT09Yy55KWc9cihtLGwpLG49Yy5nZXRMYWJlbENvbmZpZygpLHU9Zy5mb3JtYXQ/ZihnLmZvcm1hdCxuKTpnLmZvcm1hdHRlci5jYWxsKG4sZyksQj1nLnN0eWxlLG49Zy5yb3RhdGlvbixCLmNvbG9yPXQoZy5jb2xvcixCLmNvbG9yLGIuY29sb3IsXCIjMDAwMDAwXCIpLFwiY29udHJhc3RcIj09PUIuY29sb3ImJihjLmNvbnRyYXN0Q29sb3I9QS5nZXRDb250cmFzdChjLmNvbG9yfHxiLmNvbG9yKSxCLmNvbG9yPWcuaW5zaWRlfHwwPnQoYy5sYWJlbERpc3RhbmNlLGcuZGlzdGFuY2UpfHxkLnN0YWNraW5nP2MuY29udHJhc3RDb2xvcjpcIiMwMDAwMDBcIiksZC5jdXJzb3ImJihCLmN1cnNvcj1kLmN1cnNvciksXG5oPXtmaWxsOmcuYmFja2dyb3VuZENvbG9yLHN0cm9rZTpnLmJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6Zy5ib3JkZXJXaWR0aCxyOmcuYm9yZGVyUmFkaXVzfHwwLHJvdGF0aW9uOm4scGFkZGluZzpnLnBhZGRpbmcsekluZGV4OjF9LGEub2JqZWN0RWFjaChoLGZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YSYmZGVsZXRlIGhbYl19KTsha3x8ZSYmRih1KT9lJiZGKHUpJiYoaz9oLnRleHQ9dTooaz1jLmRhdGFMYWJlbD1BW24/XCJ0ZXh0XCI6XCJsYWJlbFwiXSh1LDAsLTk5OTksZy5zaGFwZSxudWxsLG51bGwsZy51c2VIVE1MLG51bGwsXCJkYXRhLWxhYmVsXCIpLGsuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29sb3ItXCIrYy5jb2xvckluZGV4K1wiIFwiKyhnLmNsYXNzTmFtZXx8XCJcIikrKGcudXNlSFRNTD9cImhpZ2hjaGFydHMtdHJhY2tlclwiOlwiXCIpKSksay5hdHRyKGgpLGsuY3NzKEIpLnNoYWRvdyhnLnNoYWRvdyksay5hZGRlZHx8ay5hZGQocSksYi5hbGlnbkRhdGFMYWJlbChjLFxuayxnLG51bGwsdikpOihjLmRhdGFMYWJlbD1rPWsuZGVzdHJveSgpLHAmJihjLmNvbm5lY3Rvcj1wLmRlc3Ryb3koKSkpfSl9O2QucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsPWZ1bmN0aW9uKGEsYixkLGYsZyl7dmFyIGU9dGhpcy5jaGFydCxjPWUuaW52ZXJ0ZWQsaz10KGEucGxvdFgsLTk5OTkpLGw9dChhLnBsb3RZLC05OTk5KSxuPWIuZ2V0QkJveCgpLHIscD1kLnJvdGF0aW9uLHY9ZC5hbGlnbix1PXRoaXMudmlzaWJsZSYmKGEuc2VyaWVzLmZvcmNlREx8fGUuaXNJbnNpZGVQbG90KGssTWF0aC5yb3VuZChsKSxjKXx8ZiYmZS5pc0luc2lkZVBsb3QoayxjP2YueCsxOmYueStmLmhlaWdodC0xLGMpKSx5PVwianVzdGlmeVwiPT09dChkLm92ZXJmbG93LFwianVzdGlmeVwiKTtpZih1JiYocj1kLnN0eWxlLmZvbnRTaXplLHI9ZS5yZW5kZXJlci5mb250TWV0cmljcyhyLGIpLmIsZj1tKHt4OmM/dGhpcy55QXhpcy5sZW4tbDprLHk6TWF0aC5yb3VuZChjP3RoaXMueEF4aXMubGVuLWs6bCksXG53aWR0aDowLGhlaWdodDowfSxmKSxtKGQse3dpZHRoOm4ud2lkdGgsaGVpZ2h0Om4uaGVpZ2h0fSkscD8oeT0hMSxrPWUucmVuZGVyZXIucm90Q29ycihyLHApLGs9e3g6Zi54K2QueCtmLndpZHRoLzIray54LHk6Zi55K2QueSt7dG9wOjAsbWlkZGxlOi41LGJvdHRvbToxfVtkLnZlcnRpY2FsQWxpZ25dKmYuaGVpZ2h0fSxiW2c/XCJhdHRyXCI6XCJhbmltYXRlXCJdKGspLmF0dHIoe2FsaWduOnZ9KSxsPShwKzcyMCklMzYwLGw9MTgwPGwmJjM2MD5sLFwibGVmdFwiPT09dj9rLnktPWw/bi5oZWlnaHQ6MDpcImNlbnRlclwiPT09dj8oay54LT1uLndpZHRoLzIsay55LT1uLmhlaWdodC8yKTpcInJpZ2h0XCI9PT12JiYoay54LT1uLndpZHRoLGsueS09bD8wOm4uaGVpZ2h0KSk6KGIuYWxpZ24oZCxudWxsLGYpLGs9Yi5hbGlnbkF0dHIpLHk/YS5pc0xhYmVsSnVzdGlmaWVkPXRoaXMuanVzdGlmeURhdGFMYWJlbChiLGQsayxuLGYsZyk6dChkLmNyb3AsITApJiYodT1lLmlzSW5zaWRlUGxvdChrLngsXG5rLnkpJiZlLmlzSW5zaWRlUGxvdChrLngrbi53aWR0aCxrLnkrbi5oZWlnaHQpKSxkLnNoYXBlJiYhcCkpYltnP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7YW5jaG9yWDpjP2UucGxvdFdpZHRoLWEucGxvdFk6YS5wbG90WCxhbmNob3JZOmM/ZS5wbG90SGVpZ2h0LWEucGxvdFg6YS5wbG90WX0pO3V8fChiLmF0dHIoe3k6LTk5OTl9KSxiLnBsYWNlZD0hMSl9O2QucHJvdG90eXBlLmp1c3RpZnlEYXRhTGFiZWw9ZnVuY3Rpb24oYSxiLGQsZixnLGspe3ZhciBjPXRoaXMuY2hhcnQsZT1iLmFsaWduLGw9Yi52ZXJ0aWNhbEFsaWduLG0sbixwPWEuYm94PzA6YS5wYWRkaW5nfHwwO209ZC54K3A7MD5tJiYoXCJyaWdodFwiPT09ZT9iLmFsaWduPVwibGVmdFwiOmIueD0tbSxuPSEwKTttPWQueCtmLndpZHRoLXA7bT5jLnBsb3RXaWR0aCYmKFwibGVmdFwiPT09ZT9iLmFsaWduPVwicmlnaHRcIjpiLng9Yy5wbG90V2lkdGgtbSxuPSEwKTttPWQueStwOzA+bSYmKFwiYm90dG9tXCI9PT1sP2IudmVydGljYWxBbGlnbj1cblwidG9wXCI6Yi55PS1tLG49ITApO209ZC55K2YuaGVpZ2h0LXA7bT5jLnBsb3RIZWlnaHQmJihcInRvcFwiPT09bD9iLnZlcnRpY2FsQWxpZ249XCJib3R0b21cIjpiLnk9Yy5wbG90SGVpZ2h0LW0sbj0hMCk7biYmKGEucGxhY2VkPSFrLGEuYWxpZ24oYixudWxsLGcpKTtyZXR1cm4gbn07ay5waWUmJihrLnBpZS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGY9Yi5kYXRhLGcsaz1iLmNoYXJ0LGw9Yi5vcHRpb25zLmRhdGFMYWJlbHMsbT10KGwuY29ubmVjdG9yUGFkZGluZywxMCksYz10KGwuY29ubmVjdG9yV2lkdGgsMSkscj1rLnBsb3RXaWR0aCxxPWsucGxvdEhlaWdodCx1LEM9Yi5jZW50ZXIscD1DWzJdLzIsej1DWzFdLEksTCxoLHcsTT1bW10sW11dLEgsTyxRLFIseD1bMCwwLDAsMF07Yi52aXNpYmxlJiYobC5lbmFibGVkfHxiLl9oYXNQb2ludExhYmVscykmJihFKGYsZnVuY3Rpb24oYSl7YS5kYXRhTGFiZWwmJmEudmlzaWJsZSYmYS5kYXRhTGFiZWwuc2hvcnRlbmVkJiZcbihhLmRhdGFMYWJlbC5hdHRyKHt3aWR0aDpcImF1dG9cIn0pLmNzcyh7d2lkdGg6XCJhdXRvXCIsdGV4dE92ZXJmbG93OlwiY2xpcFwifSksYS5kYXRhTGFiZWwuc2hvcnRlbmVkPSExKX0pLGQucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzLmFwcGx5KGIpLEUoZixmdW5jdGlvbihhKXthLmRhdGFMYWJlbCYmYS52aXNpYmxlJiYoTVthLmhhbGZdLnB1c2goYSksYS5kYXRhTGFiZWwuX3Bvcz1udWxsKX0pLEUoTSxmdW5jdGlvbihjLGQpe3ZhciBlLGYsbj1jLmxlbmd0aCx2PVtdLHU7aWYobilmb3IoYi5zb3J0QnlBbmdsZShjLGQtLjUpLDA8Yi5tYXhMYWJlbERpc3RhbmNlJiYoZT1NYXRoLm1heCgwLHotcC1iLm1heExhYmVsRGlzdGFuY2UpLGY9TWF0aC5taW4oeitwK2IubWF4TGFiZWxEaXN0YW5jZSxrLnBsb3RIZWlnaHQpLEUoYyxmdW5jdGlvbihhKXswPGEubGFiZWxEaXN0YW5jZSYmYS5kYXRhTGFiZWwmJihhLnRvcD1NYXRoLm1heCgwLHotcC1hLmxhYmVsRGlzdGFuY2UpLGEuYm90dG9tPVxuTWF0aC5taW4oeitwK2EubGFiZWxEaXN0YW5jZSxrLnBsb3RIZWlnaHQpLHU9YS5kYXRhTGFiZWwuZ2V0QkJveCgpLmhlaWdodHx8MjEsYS5wb3NpdGlvbnNJbmRleD12LnB1c2goe3RhcmdldDphLmxhYmVsUG9zWzFdLWEudG9wK3UvMixzaXplOnUscmFuazphLnl9KS0xKX0pLGEuZGlzdHJpYnV0ZSh2LGYrdS1lKSksUj0wO1I8bjtSKyspZz1jW1JdLGY9Zy5wb3NpdGlvbnNJbmRleCxoPWcubGFiZWxQb3MsST1nLmRhdGFMYWJlbCxRPSExPT09Zy52aXNpYmxlP1wiaGlkZGVuXCI6XCJpbmhlcml0XCIsZT1oWzFdLHYmJkYodltmXSk/dm9pZCAwPT09dltmXS5wb3M/UT1cImhpZGRlblwiOih3PXZbZl0uc2l6ZSxPPWcudG9wK3ZbZl0ucG9zKTpPPWUsZGVsZXRlIGcucG9zaXRpb25JbmRleCxIPWwuanVzdGlmeT9DWzBdKyhkPy0xOjEpKihwK2cubGFiZWxEaXN0YW5jZSk6Yi5nZXRYKE88Zy50b3ArMnx8Tz5nLmJvdHRvbS0yP2U6TyxkLGcpLEkuX2F0dHI9e3Zpc2liaWxpdHk6USxhbGlnbjpoWzZdfSxcbkkuX3Bvcz17eDpIK2wueCsoe2xlZnQ6bSxyaWdodDotbX1baFs2XV18fDApLHk6TytsLnktMTB9LGgueD1ILGgueT1PLHQobC5jcm9wLCEwKSYmKEw9SS5nZXRCQm94KCkud2lkdGgsZT1udWxsLEgtTDxtPyhlPU1hdGgucm91bmQoTC1IK20pLHhbM109TWF0aC5tYXgoZSx4WzNdKSk6SCtMPnItbSYmKGU9TWF0aC5yb3VuZChIK0wtcittKSx4WzFdPU1hdGgubWF4KGUseFsxXSkpLDA+Ty13LzI/eFswXT1NYXRoLm1heChNYXRoLnJvdW5kKC1PK3cvMikseFswXSk6Tyt3LzI+cSYmKHhbMl09TWF0aC5tYXgoTWF0aC5yb3VuZChPK3cvMi1xKSx4WzJdKSksSS5zaWRlT3ZlcmZsb3c9ZSl9KSwwPT09QSh4KXx8dGhpcy52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyh4KSkmJih0aGlzLnBsYWNlRGF0YUxhYmVscygpLGMmJkUodGhpcy5wb2ludHMsZnVuY3Rpb24oYSl7dmFyIGU7dT1hLmNvbm5lY3RvcjtpZigoST1hLmRhdGFMYWJlbCkmJkkuX3BvcyYmYS52aXNpYmxlJiYwPGEubGFiZWxEaXN0YW5jZSl7UT1cbkkuX2F0dHIudmlzaWJpbGl0eTtpZihlPSF1KWEuY29ubmVjdG9yPXU9ay5yZW5kZXJlci5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29ubmVjdG9yIGhpZ2hjaGFydHMtY29sb3ItXCIrYS5jb2xvckluZGV4KS5hZGQoYi5kYXRhTGFiZWxzR3JvdXApLHUuYXR0cih7XCJzdHJva2Utd2lkdGhcIjpjLHN0cm9rZTpsLmNvbm5lY3RvckNvbG9yfHxhLmNvbG9yfHxcIiM2NjY2NjZcIn0pO3VbZT9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2Q6Yi5jb25uZWN0b3JQYXRoKGEubGFiZWxQb3MpfSk7dS5hdHRyKFwidmlzaWJpbGl0eVwiLFEpfWVsc2UgdSYmKGEuY29ubmVjdG9yPXUuZGVzdHJveSgpKX0pKX0say5waWUucHJvdG90eXBlLmNvbm5lY3RvclBhdGg9ZnVuY3Rpb24oYSl7dmFyIGI9YS54LGQ9YS55O3JldHVybiB0KHRoaXMub3B0aW9ucy5kYXRhTGFiZWxzLnNvZnRDb25uZWN0b3IsITApP1tcIk1cIixiKyhcImxlZnRcIj09PWFbNl0/NTotNSksZCxcIkNcIixiLGQsMiphWzJdLWFbNF0sXG4yKmFbM10tYVs1XSxhWzJdLGFbM10sXCJMXCIsYVs0XSxhWzVdXTpbXCJNXCIsYisoXCJsZWZ0XCI9PT1hWzZdPzU6LTUpLGQsXCJMXCIsYVsyXSxhWzNdLFwiTFwiLGFbNF0sYVs1XV19LGsucGllLnByb3RvdHlwZS5wbGFjZURhdGFMYWJlbHM9ZnVuY3Rpb24oKXtFKHRoaXMucG9pbnRzLGZ1bmN0aW9uKGEpe3ZhciBiPWEuZGF0YUxhYmVsO2ImJmEudmlzaWJsZSYmKChhPWIuX3Bvcyk/KGIuc2lkZU92ZXJmbG93JiYoYi5fYXR0ci53aWR0aD1iLmdldEJCb3goKS53aWR0aC1iLnNpZGVPdmVyZmxvdyxiLmNzcyh7d2lkdGg6Yi5fYXR0ci53aWR0aCtcInB4XCIsdGV4dE92ZXJmbG93OlwiZWxsaXBzaXNcIn0pLGIuc2hvcnRlbmVkPSEwKSxiLmF0dHIoYi5fYXR0ciksYltiLm1vdmVkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShhKSxiLm1vdmVkPSEwKTpiJiZiLmF0dHIoe3k6LTk5OTl9KSl9LHRoaXMpfSxrLnBpZS5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWw9dSxrLnBpZS5wcm90b3R5cGUudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3c9XG5mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNlbnRlcixkPXRoaXMub3B0aW9ucyxlPWQuY2VudGVyLGY9ZC5taW5TaXplfHw4MCxrLGM9bnVsbCE9PWQuc2l6ZTtjfHwobnVsbCE9PWVbMF0/az1NYXRoLm1heChiWzJdLU1hdGgubWF4KGFbMV0sYVszXSksZik6KGs9TWF0aC5tYXgoYlsyXS1hWzFdLWFbM10sZiksYlswXSs9KGFbM10tYVsxXSkvMiksbnVsbCE9PWVbMV0/az1NYXRoLm1heChNYXRoLm1pbihrLGJbMl0tTWF0aC5tYXgoYVswXSxhWzJdKSksZik6KGs9TWF0aC5tYXgoTWF0aC5taW4oayxiWzJdLWFbMF0tYVsyXSksZiksYlsxXSs9KGFbMF0tYVsyXSkvMiksazxiWzJdPyhiWzJdPWssYlszXT1NYXRoLm1pbihnKGQuaW5uZXJTaXplfHwwLGspLGspLHRoaXMudHJhbnNsYXRlKGIpLHRoaXMuZHJhd0RhdGFMYWJlbHMmJnRoaXMuZHJhd0RhdGFMYWJlbHMoKSk6Yz0hMCk7cmV0dXJuIGN9KTtrLmNvbHVtbiYmKGsuY29sdW1uLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD1mdW5jdGlvbihhLFxuYixmLGcsayl7dmFyIGU9dGhpcy5jaGFydC5pbnZlcnRlZCxjPWEuc2VyaWVzLGw9YS5kbEJveHx8YS5zaGFwZUFyZ3MsbT10KGEuYmVsb3csYS5wbG90WT50KHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCxjLnlBeGlzLmxlbikpLG49dChmLmluc2lkZSwhIXRoaXMub3B0aW9ucy5zdGFja2luZyk7bCYmKGc9cihsKSwwPmcueSYmKGcuaGVpZ2h0Kz1nLnksZy55PTApLGw9Zy55K2cuaGVpZ2h0LWMueUF4aXMubGVuLDA8bCYmKGcuaGVpZ2h0LT1sKSxlJiYoZz17eDpjLnlBeGlzLmxlbi1nLnktZy5oZWlnaHQseTpjLnhBeGlzLmxlbi1nLngtZy53aWR0aCx3aWR0aDpnLmhlaWdodCxoZWlnaHQ6Zy53aWR0aH0pLG58fChlPyhnLngrPW0/MDpnLndpZHRoLGcud2lkdGg9MCk6KGcueSs9bT9nLmhlaWdodDowLGcuaGVpZ2h0PTApKSk7Zi5hbGlnbj10KGYuYWxpZ24sIWV8fG4/XCJjZW50ZXJcIjptP1wicmlnaHRcIjpcImxlZnRcIik7Zi52ZXJ0aWNhbEFsaWduPXQoZi52ZXJ0aWNhbEFsaWduLGV8fFxubj9cIm1pZGRsZVwiOm0/XCJ0b3BcIjpcImJvdHRvbVwiKTtkLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsYSxiLGYsZyxrKTthLmlzTGFiZWxKdXN0aWZpZWQmJmEuY29udHJhc3RDb2xvciYmYS5kYXRhTGFiZWwuY3NzKHtjb2xvcjphLmNvbnRyYXN0Q29sb3J9KX0pfSkoTSk7KGZ1bmN0aW9uKGEpe3ZhciBDPWEuQ2hhcnQsQT1hLmVhY2gsRj1hLm9iamVjdEVhY2gsRT1hLnBpY2ssbT1hLmFkZEV2ZW50O0MucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGYoKXt2YXIgZj1bXTtBKGEueUF4aXN8fFtdLGZ1bmN0aW9uKGEpe2Eub3B0aW9ucy5zdGFja0xhYmVscyYmIWEub3B0aW9ucy5zdGFja0xhYmVscy5hbGxvd092ZXJsYXAmJkYoYS5zdGFja3MsZnVuY3Rpb24oYSl7RihhLGZ1bmN0aW9uKGEpe2YucHVzaChhLmxhYmVsKX0pfSl9KTtBKGEuc2VyaWVzfHxbXSxmdW5jdGlvbihhKXt2YXIgbD1hLm9wdGlvbnMuZGF0YUxhYmVscyxnPWEuZGF0YUxhYmVsQ29sbGVjdGlvbnN8fFxuW1wiZGF0YUxhYmVsXCJdOyhsLmVuYWJsZWR8fGEuX2hhc1BvaW50TGFiZWxzKSYmIWwuYWxsb3dPdmVybGFwJiZhLnZpc2libGUmJkEoZyxmdW5jdGlvbihkKXtBKGEucG9pbnRzLGZ1bmN0aW9uKGEpe2FbZF0mJihhW2RdLmxhYmVscmFuaz1FKGEubGFiZWxyYW5rLGEuc2hhcGVBcmdzJiZhLnNoYXBlQXJncy5oZWlnaHQpLGYucHVzaChhW2RdKSl9KX0pfSk7YS5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMoZil9ZigpO20oYSxcInJlZHJhd1wiLGYpfSk7Qy5wcm90b3R5cGUuaGlkZU92ZXJsYXBwaW5nTGFiZWxzPWZ1bmN0aW9uKGEpe3ZhciBmPWEubGVuZ3RoLG0sdSx0LGcsZCxrLGIsZSx2LHk9ZnVuY3Rpb24oYSxiLGQsYyxlLGYsZyxrKXtyZXR1cm4hKGU+YStkfHxlK2c8YXx8Zj5iK2N8fGYrazxiKX07Zm9yKHU9MDt1PGY7dSsrKWlmKG09YVt1XSltLm9sZE9wYWNpdHk9bS5vcGFjaXR5LG0ubmV3T3BhY2l0eT0xLG0ud2lkdGh8fCh0PW0uZ2V0QkJveCgpLG0ud2lkdGg9dC53aWR0aCxtLmhlaWdodD1cbnQuaGVpZ2h0KTthLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4oYi5sYWJlbHJhbmt8fDApLShhLmxhYmVscmFua3x8MCl9KTtmb3IodT0wO3U8Zjt1KyspZm9yKHQ9YVt1XSxtPXUrMTttPGY7KyttKWlmKGc9YVttXSx0JiZnJiZ0IT09ZyYmdC5wbGFjZWQmJmcucGxhY2VkJiYwIT09dC5uZXdPcGFjaXR5JiYwIT09Zy5uZXdPcGFjaXR5JiYoZD10LmFsaWduQXR0cixrPWcuYWxpZ25BdHRyLGI9dC5wYXJlbnRHcm91cCxlPWcucGFyZW50R3JvdXAsdj0yKih0LmJveD8wOnQucGFkZGluZ3x8MCksZD15KGQueCtiLnRyYW5zbGF0ZVgsZC55K2IudHJhbnNsYXRlWSx0LndpZHRoLXYsdC5oZWlnaHQtdixrLngrZS50cmFuc2xhdGVYLGsueStlLnRyYW5zbGF0ZVksZy53aWR0aC12LGcuaGVpZ2h0LXYpKSkodC5sYWJlbHJhbms8Zy5sYWJlbHJhbms/dDpnKS5uZXdPcGFjaXR5PTA7QShhLGZ1bmN0aW9uKGEpe3ZhciBiLGQ7YSYmKGQ9YS5uZXdPcGFjaXR5LGEub2xkT3BhY2l0eSE9PWQmJlxuYS5wbGFjZWQmJihkP2Euc2hvdyghMCk6Yj1mdW5jdGlvbigpe2EuaGlkZSgpfSxhLmFsaWduQXR0ci5vcGFjaXR5PWQsYVthLmlzT2xkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShhLmFsaWduQXR0cixudWxsLGIpKSxhLmlzT2xkPSEwKX0pfX0pKE0pOyhmdW5jdGlvbihhKXt2YXIgQz1hLmFkZEV2ZW50LEE9YS5DaGFydCxGPWEuY3JlYXRlRWxlbWVudCxFPWEuY3NzLG09YS5kZWZhdWx0T3B0aW9ucyxmPWEuZGVmYXVsdFBsb3RPcHRpb25zLGw9YS5lYWNoLHI9YS5leHRlbmQsdT1hLmZpcmVFdmVudCx0PWEuaGFzVG91Y2gsZz1hLmluQXJyYXksZD1hLmlzT2JqZWN0LGs9YS5MZWdlbmQsYj1hLm1lcmdlLGU9YS5waWNrLHY9YS5Qb2ludCx5PWEuU2VyaWVzLG49YS5zZXJpZXNUeXBlcyxEPWEuc3ZnLEo7Sj1hLlRyYWNrZXJNaXhpbj17ZHJhd1RyYWNrZXJQb2ludDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LnBvaW50ZXIsZD1mdW5jdGlvbihhKXt2YXIgYz1iLmdldFBvaW50RnJvbUV2ZW50KGEpO1xudm9pZCAwIT09YyYmKGIuaXNEaXJlY3RUb3VjaD0hMCxjLm9uTW91c2VPdmVyKGEpKX07bChhLnBvaW50cyxmdW5jdGlvbihhKXthLmdyYXBoaWMmJihhLmdyYXBoaWMuZWxlbWVudC5wb2ludD1hKTthLmRhdGFMYWJlbCYmKGEuZGF0YUxhYmVsLmRpdj9hLmRhdGFMYWJlbC5kaXYucG9pbnQ9YTphLmRhdGFMYWJlbC5lbGVtZW50LnBvaW50PWEpfSk7YS5faGFzVHJhY2tpbmd8fChsKGEudHJhY2tlckdyb3VwcyxmdW5jdGlvbihjKXtpZihhW2NdKXthW2NdLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIsZCkub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGEpe2Iub25UcmFja2VyTW91c2VPdXQoYSl9KTtpZih0KWFbY10ub24oXCJ0b3VjaHN0YXJ0XCIsZCk7YS5vcHRpb25zLmN1cnNvciYmYVtjXS5jc3MoRSkuY3NzKHtjdXJzb3I6YS5vcHRpb25zLmN1cnNvcn0pfX0pLGEuX2hhc1RyYWNraW5nPSEwKX0sZHJhd1RyYWNrZXJHcmFwaDpmdW5jdGlvbigpe3ZhciBhPVxudGhpcyxiPWEub3B0aW9ucyxkPWIudHJhY2tCeUFyZWEsZT1bXS5jb25jYXQoZD9hLmFyZWFQYXRoOmEuZ3JhcGhQYXRoKSxmPWUubGVuZ3RoLGc9YS5jaGFydCxrPWcucG9pbnRlcixtPWcucmVuZGVyZXIsbj1nLm9wdGlvbnMudG9vbHRpcC5zbmFwLGg9YS50cmFja2VyLHIsdT1mdW5jdGlvbigpe2lmKGcuaG92ZXJTZXJpZXMhPT1hKWEub25Nb3VzZU92ZXIoKX0sdj1cInJnYmEoMTkyLDE5MiwxOTIsXCIrKEQ/LjAwMDE6LjAwMikrXCIpXCI7aWYoZiYmIWQpZm9yKHI9ZisxO3ItLTspXCJNXCI9PT1lW3JdJiZlLnNwbGljZShyKzEsMCxlW3IrMV0tbixlW3IrMl0sXCJMXCIpLChyJiZcIk1cIj09PWVbcl18fHI9PT1mKSYmZS5zcGxpY2UociwwLFwiTFwiLGVbci0yXStuLGVbci0xXSk7aD9oLmF0dHIoe2Q6ZX0pOmEuZ3JhcGgmJihhLnRyYWNrZXI9bS5wYXRoKGUpLmF0dHIoe1wic3Ryb2tlLWxpbmVqb2luXCI6XCJyb3VuZFwiLHZpc2liaWxpdHk6YS52aXNpYmxlP1widmlzaWJsZVwiOlwiaGlkZGVuXCIsc3Ryb2tlOnYsXG5maWxsOmQ/djpcIm5vbmVcIixcInN0cm9rZS13aWR0aFwiOmEuZ3JhcGguc3Ryb2tlV2lkdGgoKSsoZD8wOjIqbiksekluZGV4OjJ9KS5hZGQoYS5ncm91cCksbChbYS50cmFja2VyLGEubWFya2VyR3JvdXBdLGZ1bmN0aW9uKGEpe2EuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikub24oXCJtb3VzZW92ZXJcIix1KS5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oYSl7ay5vblRyYWNrZXJNb3VzZU91dChhKX0pO2IuY3Vyc29yJiZhLmNzcyh7Y3Vyc29yOmIuY3Vyc29yfSk7aWYodClhLm9uKFwidG91Y2hzdGFydFwiLHUpfSkpfX07bi5jb2x1bW4mJihuLmNvbHVtbi5wcm90b3R5cGUuZHJhd1RyYWNrZXI9Si5kcmF3VHJhY2tlclBvaW50KTtuLnBpZSYmKG4ucGllLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1KLmRyYXdUcmFja2VyUG9pbnQpO24uc2NhdHRlciYmKG4uc2NhdHRlci5wcm90b3R5cGUuZHJhd1RyYWNrZXI9Si5kcmF3VHJhY2tlclBvaW50KTtyKGsucHJvdG90eXBlLHtzZXRJdGVtRXZlbnRzOmZ1bmN0aW9uKGEsXG5kLGUpe3ZhciBjPXRoaXMsZj1jLmNoYXJ0LnJlbmRlcmVyLmJveFdyYXBwZXIsZz1cImhpZ2hjaGFydHMtbGVnZW5kLVwiKyhhLnNlcmllcz9cInBvaW50XCI6XCJzZXJpZXNcIikrXCItYWN0aXZlXCI7KGU/ZDphLmxlZ2VuZEdyb3VwKS5vbihcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKCl7YS5zZXRTdGF0ZShcImhvdmVyXCIpO2YuYWRkQ2xhc3MoZyk7ZC5jc3MoYy5vcHRpb25zLml0ZW1Ib3ZlclN0eWxlKX0pLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbigpe2QuY3NzKGIoYS52aXNpYmxlP2MuaXRlbVN0eWxlOmMuaXRlbUhpZGRlblN0eWxlKSk7Zi5yZW1vdmVDbGFzcyhnKTthLnNldFN0YXRlKCl9KS5vbihcImNsaWNrXCIsZnVuY3Rpb24oYil7dmFyIGM9ZnVuY3Rpb24oKXthLnNldFZpc2libGUmJmEuc2V0VmlzaWJsZSgpfTtiPXticm93c2VyRXZlbnQ6Yn07YS5maXJlUG9pbnRFdmVudD9hLmZpcmVQb2ludEV2ZW50KFwibGVnZW5kSXRlbUNsaWNrXCIsYixjKTp1KGEsXCJsZWdlbmRJdGVtQ2xpY2tcIixiLGMpfSl9LFxuY3JlYXRlQ2hlY2tib3hGb3JJdGVtOmZ1bmN0aW9uKGEpe2EuY2hlY2tib3g9RihcImlucHV0XCIse3R5cGU6XCJjaGVja2JveFwiLGNoZWNrZWQ6YS5zZWxlY3RlZCxkZWZhdWx0Q2hlY2tlZDphLnNlbGVjdGVkfSx0aGlzLm9wdGlvbnMuaXRlbUNoZWNrYm94U3R5bGUsdGhpcy5jaGFydC5jb250YWluZXIpO0MoYS5jaGVja2JveCxcImNsaWNrXCIsZnVuY3Rpb24oYil7dShhLnNlcmllc3x8YSxcImNoZWNrYm94Q2xpY2tcIix7Y2hlY2tlZDpiLnRhcmdldC5jaGVja2VkLGl0ZW06YX0sZnVuY3Rpb24oKXthLnNlbGVjdCgpfSl9KX19KTttLmxlZ2VuZC5pdGVtU3R5bGUuY3Vyc29yPVwicG9pbnRlclwiO3IoQS5wcm90b3R5cGUse3Nob3dSZXNldFpvb206ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9bS5sYW5nLGQ9YS5vcHRpb25zLmNoYXJ0LnJlc2V0Wm9vbUJ1dHRvbixlPWQudGhlbWUsZj1lLnN0YXRlcyxnPVwiY2hhcnRcIj09PWQucmVsYXRpdmVUbz9udWxsOlwicGxvdEJveFwiO3RoaXMucmVzZXRab29tQnV0dG9uPVxuYS5yZW5kZXJlci5idXR0b24oYi5yZXNldFpvb20sbnVsbCxudWxsLGZ1bmN0aW9uKCl7YS56b29tT3V0KCl9LGUsZiYmZi5ob3ZlcikuYXR0cih7YWxpZ246ZC5wb3NpdGlvbi5hbGlnbix0aXRsZTpiLnJlc2V0Wm9vbVRpdGxlfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXJlc2V0LXpvb21cIikuYWRkKCkuYWxpZ24oZC5wb3NpdGlvbiwhMSxnKX0sem9vbU91dDpmdW5jdGlvbigpe3ZhciBhPXRoaXM7dShhLFwic2VsZWN0aW9uXCIse3Jlc2V0U2VsZWN0aW9uOiEwfSxmdW5jdGlvbigpe2Euem9vbSgpfSl9LHpvb206ZnVuY3Rpb24oYSl7dmFyIGIsYz10aGlzLnBvaW50ZXIsZj0hMSxnOyFhfHxhLnJlc2V0U2VsZWN0aW9uPyhsKHRoaXMuYXhlcyxmdW5jdGlvbihhKXtiPWEuem9vbSgpfSksYy5pbml0aWF0ZWQ9ITEpOmwoYS54QXhpcy5jb25jYXQoYS55QXhpcyksZnVuY3Rpb24oYSl7dmFyIGQ9YS5heGlzO2NbZC5pc1hBeGlzP1wiem9vbVhcIjpcInpvb21ZXCJdJiYoYj1kLnpvb20oYS5taW4sXG5hLm1heCksZC5kaXNwbGF5QnRuJiYoZj0hMCkpfSk7Zz10aGlzLnJlc2V0Wm9vbUJ1dHRvbjtmJiYhZz90aGlzLnNob3dSZXNldFpvb20oKTohZiYmZChnKSYmKHRoaXMucmVzZXRab29tQnV0dG9uPWcuZGVzdHJveSgpKTtiJiZ0aGlzLnJlZHJhdyhlKHRoaXMub3B0aW9ucy5jaGFydC5hbmltYXRpb24sYSYmYS5hbmltYXRpb24sMTAwPnRoaXMucG9pbnRDb3VudCkpfSxwYW46ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5ob3ZlclBvaW50cyxlO2QmJmwoZCxmdW5jdGlvbihhKXthLnNldFN0YXRlKCl9KTtsKFwieHlcIj09PWI/WzEsMF06WzFdLGZ1bmN0aW9uKGIpe2I9Y1tiP1wieEF4aXNcIjpcInlBeGlzXCJdWzBdO3ZhciBkPWIuaG9yaXosZj1hW2Q/XCJjaGFydFhcIjpcImNoYXJ0WVwiXSxkPWQ/XCJtb3VzZURvd25YXCI6XCJtb3VzZURvd25ZXCIsZz1jW2RdLGg9KGIucG9pbnRSYW5nZXx8MCkvMixrPWIuZ2V0RXh0cmVtZXMoKSxsPWIudG9WYWx1ZShnLWYsITApK2gsaD1iLnRvVmFsdWUoZytcbmIubGVuLWYsITApLWgsbT1oPGwsZz1tP2g6bCxsPW0/bDpoLGg9TWF0aC5taW4oay5kYXRhTWluLGIudG9WYWx1ZShiLnRvUGl4ZWxzKGsubWluKS1iLm1pblBpeGVsUGFkZGluZykpLG09TWF0aC5tYXgoay5kYXRhTWF4LGIudG9WYWx1ZShiLnRvUGl4ZWxzKGsubWF4KStiLm1pblBpeGVsUGFkZGluZykpLG47bj1oLWc7MDxuJiYobCs9bixnPWgpO249bC1tOzA8biYmKGw9bSxnLT1uKTtiLnNlcmllcy5sZW5ndGgmJmchPT1rLm1pbiYmbCE9PWsubWF4JiYoYi5zZXRFeHRyZW1lcyhnLGwsITEsITEse3RyaWdnZXI6XCJwYW5cIn0pLGU9ITApO2NbZF09Zn0pO2UmJmMucmVkcmF3KCExKTtFKGMuY29udGFpbmVyLHtjdXJzb3I6XCJtb3ZlXCJ9KX19KTtyKHYucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5zZXJpZXMsZj1kLmNoYXJ0O2E9ZShhLCFjLnNlbGVjdGVkKTtjLmZpcmVQb2ludEV2ZW50KGE/XCJzZWxlY3RcIjpcInVuc2VsZWN0XCIse2FjY3VtdWxhdGU6Yn0sXG5mdW5jdGlvbigpe2Muc2VsZWN0ZWQ9Yy5vcHRpb25zLnNlbGVjdGVkPWE7ZC5vcHRpb25zLmRhdGFbZyhjLGQuZGF0YSldPWMub3B0aW9ucztjLnNldFN0YXRlKGEmJlwic2VsZWN0XCIpO2J8fGwoZi5nZXRTZWxlY3RlZFBvaW50cygpLGZ1bmN0aW9uKGEpe2Euc2VsZWN0ZWQmJmEhPT1jJiYoYS5zZWxlY3RlZD1hLm9wdGlvbnMuc2VsZWN0ZWQ9ITEsZC5vcHRpb25zLmRhdGFbZyhhLGQuZGF0YSldPWEub3B0aW9ucyxhLnNldFN0YXRlKFwiXCIpLGEuZmlyZVBvaW50RXZlbnQoXCJ1bnNlbGVjdFwiKSl9KX0pfSxvbk1vdXNlT3ZlcjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlcmllcy5jaGFydCxjPWIucG9pbnRlcjthPWE/Yy5ub3JtYWxpemUoYSk6Yy5nZXRDaGFydENvb3JkaW5hdGVzRnJvbVBvaW50KHRoaXMsYi5pbnZlcnRlZCk7Yy5ydW5Qb2ludEFjdGlvbnMoYSx0aGlzKX0sb25Nb3VzZU91dDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuc2VyaWVzLmNoYXJ0O3RoaXMuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTtcbmwoYS5ob3ZlclBvaW50c3x8W10sZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZSgpfSk7YS5ob3ZlclBvaW50cz1hLmhvdmVyUG9pbnQ9bnVsbH0saW1wb3J0RXZlbnRzOmZ1bmN0aW9uKCl7aWYoIXRoaXMuaGFzSW1wb3J0ZWRFdmVudHMpe3ZhciBjPXRoaXMsZD1iKGMuc2VyaWVzLm9wdGlvbnMucG9pbnQsYy5vcHRpb25zKS5ldmVudHM7Yy5ldmVudHM9ZDthLm9iamVjdEVhY2goZCxmdW5jdGlvbihhLGIpe0MoYyxiLGEpfSk7dGhpcy5oYXNJbXBvcnRlZEV2ZW50cz0hMH19LHNldFN0YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9TWF0aC5mbG9vcih0aGlzLnBsb3RYKSxkPXRoaXMucGxvdFksZz10aGlzLnNlcmllcyxrPWcub3B0aW9ucy5zdGF0ZXNbYV18fHt9LGw9ZltnLnR5cGVdLm1hcmtlciYmZy5vcHRpb25zLm1hcmtlcixtPWwmJiExPT09bC5lbmFibGVkLG49bCYmbC5zdGF0ZXMmJmwuc3RhdGVzW2FdfHx7fSxoPSExPT09bi5lbmFibGVkLHQ9Zy5zdGF0ZU1hcmtlckdyYXBoaWMsdT1cbnRoaXMubWFya2VyfHx7fSx2PWcuY2hhcnQseT1nLmhhbG8sQSxDPWwmJmcubWFya2VyQXR0cmliczthPWF8fFwiXCI7aWYoIShhPT09dGhpcy5zdGF0ZSYmIWJ8fHRoaXMuc2VsZWN0ZWQmJlwic2VsZWN0XCIhPT1hfHwhMT09PWsuZW5hYmxlZHx8YSYmKGh8fG0mJiExPT09bi5lbmFibGVkKXx8YSYmdS5zdGF0ZXMmJnUuc3RhdGVzW2FdJiYhMT09PXUuc3RhdGVzW2FdLmVuYWJsZWQpKXtDJiYoQT1nLm1hcmtlckF0dHJpYnModGhpcyxhKSk7aWYodGhpcy5ncmFwaGljKXRoaXMuc3RhdGUmJnRoaXMuZ3JhcGhpYy5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnQtXCIrdGhpcy5zdGF0ZSksYSYmdGhpcy5ncmFwaGljLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1cIithKSx0aGlzLmdyYXBoaWMuYW5pbWF0ZShnLnBvaW50QXR0cmlicyh0aGlzLGEpLGUodi5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbixrLmFuaW1hdGlvbikpLEEmJnRoaXMuZ3JhcGhpYy5hbmltYXRlKEEsZSh2Lm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLFxubi5hbmltYXRpb24sbC5hbmltYXRpb24pKSx0JiZ0LmhpZGUoKTtlbHNle2lmKGEmJm4pe2w9dS5zeW1ib2x8fGcuc3ltYm9sO3QmJnQuY3VycmVudFN5bWJvbCE9PWwmJih0PXQuZGVzdHJveSgpKTtpZih0KXRbYj9cImFuaW1hdGVcIjpcImF0dHJcIl0oe3g6QS54LHk6QS55fSk7ZWxzZSBsJiYoZy5zdGF0ZU1hcmtlckdyYXBoaWM9dD12LnJlbmRlcmVyLnN5bWJvbChsLEEueCxBLnksQS53aWR0aCxBLmhlaWdodCkuYWRkKGcubWFya2VyR3JvdXApLHQuY3VycmVudFN5bWJvbD1sKTt0JiZ0LmF0dHIoZy5wb2ludEF0dHJpYnModGhpcyxhKSl9dCYmKHRbYSYmdi5pc0luc2lkZVBsb3QoYyxkLHYuaW52ZXJ0ZWQpP1wic2hvd1wiOlwiaGlkZVwiXSgpLHQuZWxlbWVudC5wb2ludD10aGlzKX0oYz1rLmhhbG8pJiZjLnNpemU/KHl8fChnLmhhbG89eT12LnJlbmRlcmVyLnBhdGgoKS5hZGQoKHRoaXMuZ3JhcGhpY3x8dCkucGFyZW50R3JvdXApKSx5W2I/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHtkOnRoaXMuaGFsb1BhdGgoYy5zaXplKX0pLFxueS5hdHRyKHtcImNsYXNzXCI6XCJoaWdoY2hhcnRzLWhhbG8gaGlnaGNoYXJ0cy1jb2xvci1cIitlKHRoaXMuY29sb3JJbmRleCxnLmNvbG9ySW5kZXgpfSkseS5wb2ludD10aGlzLHkuYXR0cihyKHtmaWxsOnRoaXMuY29sb3J8fGcuY29sb3IsXCJmaWxsLW9wYWNpdHlcIjpjLm9wYWNpdHksekluZGV4Oi0xfSxjLmF0dHJpYnV0ZXMpKSk6eSYmeS5wb2ludCYmeS5wb2ludC5oYWxvUGF0aCYmeS5hbmltYXRlKHtkOnkucG9pbnQuaGFsb1BhdGgoMCl9KTt0aGlzLnN0YXRlPWF9fSxoYWxvUGF0aDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5jaXJjbGUoTWF0aC5mbG9vcih0aGlzLnBsb3RYKS1hLHRoaXMucGxvdFktYSwyKmEsMiphKX19KTtyKHkucHJvdG90eXBlLHtvbk1vdXNlT3ZlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj1hLmhvdmVyU2VyaWVzO2lmKGImJmIhPT10aGlzKWIub25Nb3VzZU91dCgpO3RoaXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyJiZcbnUodGhpcyxcIm1vdXNlT3ZlclwiKTt0aGlzLnNldFN0YXRlKFwiaG92ZXJcIik7YS5ob3ZlclNlcmllcz10aGlzfSxvbk1vdXNlT3V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy5jaGFydCxkPWIudG9vbHRpcCxlPWIuaG92ZXJQb2ludDtiLmhvdmVyU2VyaWVzPW51bGw7aWYoZSllLm9uTW91c2VPdXQoKTt0aGlzJiZhLmV2ZW50cy5tb3VzZU91dCYmdSh0aGlzLFwibW91c2VPdXRcIik7IWR8fHRoaXMuc3RpY2t5VHJhY2tpbmd8fGQuc2hhcmVkJiYhdGhpcy5ub1NoYXJlZFRvb2x0aXB8fGQuaGlkZSgpO3RoaXMuc2V0U3RhdGUoKX0sc2V0U3RhdGU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIub3B0aW9ucyxkPWIuZ3JhcGgsZj1jLnN0YXRlcyxnPWMubGluZVdpZHRoLGM9MDthPWF8fFwiXCI7aWYoYi5zdGF0ZSE9PWEmJihsKFtiLmdyb3VwLGIubWFya2VyR3JvdXAsYi5kYXRhTGFiZWxzR3JvdXBdLGZ1bmN0aW9uKGMpe2MmJihiLnN0YXRlJiZjLnJlbW92ZUNsYXNzKFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIrXG5iLnN0YXRlKSxhJiZjLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIrYSkpfSksYi5zdGF0ZT1hLCFmW2FdfHwhMSE9PWZbYV0uZW5hYmxlZCkmJihhJiYoZz1mW2FdLmxpbmVXaWR0aHx8ZysoZlthXS5saW5lV2lkdGhQbHVzfHwwKSksZCYmIWQuZGFzaHN0eWxlKSlmb3IoZz17XCJzdHJva2Utd2lkdGhcIjpnfSxkLmFuaW1hdGUoZyxlKGIuY2hhcnQub3B0aW9ucy5jaGFydC5hbmltYXRpb24sZlthXSYmZlthXS5hbmltYXRpb24pKTtiW1wiem9uZS1ncmFwaC1cIitjXTspYltcInpvbmUtZ3JhcGgtXCIrY10uYXR0cihnKSxjKz0xfSxzZXRWaXNpYmxlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWMuY2hhcnQsZT1jLmxlZ2VuZEl0ZW0sZixnPWQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMsaz1jLnZpc2libGU7Zj0oYy52aXNpYmxlPWE9Yy5vcHRpb25zLnZpc2libGU9Yy51c2VyT3B0aW9ucy52aXNpYmxlPXZvaWQgMD09PWE/IWs6YSk/XCJzaG93XCI6XCJoaWRlXCI7bChbXCJncm91cFwiLFxuXCJkYXRhTGFiZWxzR3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJ0cmFja2VyXCIsXCJ0dFwiXSxmdW5jdGlvbihhKXtpZihjW2FdKWNbYV1bZl0oKX0pO2lmKGQuaG92ZXJTZXJpZXM9PT1jfHwoZC5ob3ZlclBvaW50JiZkLmhvdmVyUG9pbnQuc2VyaWVzKT09PWMpYy5vbk1vdXNlT3V0KCk7ZSYmZC5sZWdlbmQuY29sb3JpemVJdGVtKGMsYSk7Yy5pc0RpcnR5PSEwO2Mub3B0aW9ucy5zdGFja2luZyYmbChkLnNlcmllcyxmdW5jdGlvbihhKXthLm9wdGlvbnMuc3RhY2tpbmcmJmEudmlzaWJsZSYmKGEuaXNEaXJ0eT0hMCl9KTtsKGMubGlua2VkU2VyaWVzLGZ1bmN0aW9uKGIpe2Iuc2V0VmlzaWJsZShhLCExKX0pO2cmJihkLmlzRGlydHlCb3g9ITApOyExIT09YiYmZC5yZWRyYXcoKTt1KGMsZil9LHNob3c6ZnVuY3Rpb24oKXt0aGlzLnNldFZpc2libGUoITApfSxoaWRlOmZ1bmN0aW9uKCl7dGhpcy5zZXRWaXNpYmxlKCExKX0sc2VsZWN0OmZ1bmN0aW9uKGEpe3RoaXMuc2VsZWN0ZWQ9YT12b2lkIDA9PT1cbmE/IXRoaXMuc2VsZWN0ZWQ6YTt0aGlzLmNoZWNrYm94JiYodGhpcy5jaGVja2JveC5jaGVja2VkPWEpO3UodGhpcyxhP1wic2VsZWN0XCI6XCJ1bnNlbGVjdFwiKX0sZHJhd1RyYWNrZXI6Si5kcmF3VHJhY2tlckdyYXBofSl9KShNKTsoZnVuY3Rpb24oYSl7dmFyIEM9YS5DaGFydCxBPWEuZWFjaCxGPWEuaW5BcnJheSxFPWEuaXNBcnJheSxtPWEuaXNPYmplY3QsZj1hLnBpY2ssbD1hLnNwbGF0O0MucHJvdG90eXBlLnNldFJlc3BvbnNpdmU9ZnVuY3Rpb24oZil7dmFyIGw9dGhpcy5vcHRpb25zLnJlc3BvbnNpdmUsbT1bXSxnPXRoaXMuY3VycmVudFJlc3BvbnNpdmU7bCYmbC5ydWxlcyYmQShsLnJ1bGVzLGZ1bmN0aW9uKGQpe3ZvaWQgMD09PWQuX2lkJiYoZC5faWQ9YS51bmlxdWVLZXkoKSk7dGhpcy5tYXRjaFJlc3BvbnNpdmVSdWxlKGQsbSxmKX0sdGhpcyk7dmFyIGQ9YS5tZXJnZS5hcHBseSgwLGEubWFwKG0sZnVuY3Rpb24oZCl7cmV0dXJuIGEuZmluZChsLnJ1bGVzLGZ1bmN0aW9uKGEpe3JldHVybiBhLl9pZD09PVxuZH0pLmNoYXJ0T3B0aW9uc30pKSxtPW0udG9TdHJpbmcoKXx8dm9pZCAwO20hPT0oZyYmZy5ydWxlSWRzKSYmKGcmJnRoaXMudXBkYXRlKGcudW5kb09wdGlvbnMsZiksbT8odGhpcy5jdXJyZW50UmVzcG9uc2l2ZT17cnVsZUlkczptLG1lcmdlZE9wdGlvbnM6ZCx1bmRvT3B0aW9uczp0aGlzLmN1cnJlbnRPcHRpb25zKGQpfSx0aGlzLnVwZGF0ZShkLGYpKTp0aGlzLmN1cnJlbnRSZXNwb25zaXZlPXZvaWQgMCl9O0MucHJvdG90eXBlLm1hdGNoUmVzcG9uc2l2ZVJ1bGU9ZnVuY3Rpb24oYSxsKXt2YXIgbT1hLmNvbmRpdGlvbjsobS5jYWxsYmFja3x8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFydFdpZHRoPD1mKG0ubWF4V2lkdGgsTnVtYmVyLk1BWF9WQUxVRSkmJnRoaXMuY2hhcnRIZWlnaHQ8PWYobS5tYXhIZWlnaHQsTnVtYmVyLk1BWF9WQUxVRSkmJnRoaXMuY2hhcnRXaWR0aD49ZihtLm1pbldpZHRoLDApJiZ0aGlzLmNoYXJ0SGVpZ2h0Pj1mKG0ubWluSGVpZ2h0LDApfSkuY2FsbCh0aGlzKSYmXG5sLnB1c2goYS5faWQpfTtDLnByb3RvdHlwZS5jdXJyZW50T3B0aW9ucz1mdW5jdGlvbihmKXtmdW5jdGlvbiByKGYsZCxrLGIpe3ZhciBlO2Eub2JqZWN0RWFjaChmLGZ1bmN0aW9uKGEsZyl7aWYoIWImJi0xPEYoZyxbXCJzZXJpZXNcIixcInhBeGlzXCIsXCJ5QXhpc1wiXSkpZm9yKGZbZ109bChmW2ddKSxrW2ddPVtdLGU9MDtlPGZbZ10ubGVuZ3RoO2UrKylkW2ddW2VdJiYoa1tnXVtlXT17fSxyKGFbZV0sZFtnXVtlXSxrW2ddW2VdLGIrMSkpO2Vsc2UgbShhKT8oa1tnXT1FKGEpP1tdOnt9LHIoYSxkW2ddfHx7fSxrW2ddLGIrMSkpOmtbZ109ZFtnXXx8bnVsbH0pfXZhciB0PXt9O3IoZix0aGlzLm9wdGlvbnMsdCwwKTtyZXR1cm4gdH19KShNKTtyZXR1cm4gTX0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGNoYXJ0cy9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9oaWdoY2hhcnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40\n");

/***/ })
/******/ ]);